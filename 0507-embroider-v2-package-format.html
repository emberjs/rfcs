<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>0507-embroider-v2-package-format</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0001-transform-attribute-meta-parameter.html">0001-transform-attribute-meta-parameter</a></li><li class="chapter-item expanded "><a href="0003-block-params.html">0003-block-params</a></li><li class="chapter-item expanded "><a href="0003-cli-ember-doctor.html">0003-cli-ember-doctor</a></li><li class="chapter-item expanded "><a href="0010-engines.html">0010-engines</a></li><li class="chapter-item expanded "><a href="0011-improved-cp-syntax.html">0011-improved-cp-syntax</a></li><li class="chapter-item expanded "><a href="0012-help-json-output.html">0012-help-json-output</a></li><li class="chapter-item expanded "><a href="0015-the-road-to-ember-2-0.html">0015-the-road-to-ember-2-0</a></li><li class="chapter-item expanded "><a href="0020-sri-default.html">0020-sri-default</a></li><li class="chapter-item expanded "><a href="0023-command-line-completion.html">0023-command-line-completion</a></li><li class="chapter-item expanded "><a href="0024-bound-attributes.html">0024-bound-attributes</a></li><li class="chapter-item expanded "><a href="0028-app-import-output-file.html">0028-app-import-output-file</a></li><li class="chapter-item expanded "><a href="0029-addon-black-and-whitelist-for-apps.html">0029-addon-black-and-whitelist-for-apps</a></li><li class="chapter-item expanded "><a href="0045-internet-explorer.html">0045-internet-explorer</a></li><li class="chapter-item expanded "><a href="0046-cli-improved-release-process.html">0046-cli-improved-release-process</a></li><li class="chapter-item expanded "><a href="0046-registry-reform.html">0046-registry-reform</a></li><li class="chapter-item expanded "><a href="0050-cli-production-code-stripping.html">0050-cli-production-code-stripping</a></li><li class="chapter-item expanded "><a href="0050-improved-actions.html">0050-improved-actions</a></li><li class="chapter-item expanded "><a href="0053-helpers.html">0053-helpers</a></li><li class="chapter-item expanded "><a href="0055-anonymous-amd.html">0055-anonymous-amd</a></li><li class="chapter-item expanded "><a href="0056-improved-release-cycle.html">0056-improved-release-cycle</a></li><li class="chapter-item expanded "><a href="0057-ember-data-reference-unification.html">0057-ember-data-reference-unification</a></li><li class="chapter-item expanded "><a href="0058-helper-listing.html">0058-helper-listing</a></li><li class="chapter-item expanded "><a href="0061-ember-data-background-fetch.html">0061-ember-data-background-fetch</a></li><li class="chapter-item expanded "><a href="0064-contextual-component-lookup.html">0064-contextual-component-lookup</a></li><li class="chapter-item expanded "><a href="0065-deprecation-warning-handlers.html">0065-deprecation-warning-handlers</a></li><li class="chapter-item expanded "><a href="0080-serve-file-api.html">0080-serve-file-api</a></li><li class="chapter-item expanded "><a href="0086-firefox-in-ci.html">0086-firefox-in-ci</a></li><li class="chapter-item expanded "><a href="0090-addon-tree-caching.html">0090-addon-tree-caching</a></li><li class="chapter-item expanded "><a href="0091-cli-addon-instrumentation-experimental-hooks.html">0091-cli-addon-instrumentation-experimental-hooks</a></li><li class="chapter-item expanded "><a href="0091-weakmap.html">0091-weakmap</a></li><li class="chapter-item expanded "><a href="0092-blueprint-remove-old-files.html">0092-blueprint-remove-old-files</a></li><li class="chapter-item expanded "><a href="0095-cli-standardise-targets.html">0095-cli-standardise-targets</a></li><li class="chapter-item expanded "><a href="0095-router-service.html">0095-router-service</a></li><li class="chapter-item expanded "><a href="0096-enable-yarn-usage.html">0096-enable-yarn-usage</a></li><li class="chapter-item expanded "><a href="0101-ember-data-friendly-errors.html">0101-ember-data-friendly-errors</a></li><li class="chapter-item expanded "><a href="0105-addons-optionalDependencies.html">0105-addons-optionalDependencies</a></li><li class="chapter-item expanded "><a href="0108-add-custom-transform.html">0108-add-custom-transform</a></li><li class="chapter-item expanded "><a href="0110-packaging.html">0110-packaging</a></li><li class="chapter-item expanded "><a href="0114-add-template-lint-addon.html">0114-add-template-lint-addon</a></li><li class="chapter-item expanded "><a href="0116-qunit-dom.html">0116-qunit-dom</a></li><li class="chapter-item expanded "><a href="0120-cli-guides.html">0120-cli-guides</a></li><li class="chapter-item expanded "><a href="0120-route-serializers.html">0120-route-serializers</a></li><li class="chapter-item expanded "><a href="0121-remove-ember-cli-eslint.html">0121-remove-ember-cli-eslint</a></li><li class="chapter-item expanded "><a href="0136-contains-to-includes.html">0136-contains-to-includes</a></li><li class="chapter-item expanded "><a href="0139-isHtmlSafe.html">0139-isHtmlSafe</a></li><li class="chapter-item expanded "><a href="0143-module-unification.html">0143-module-unification</a></li><li class="chapter-item expanded "><a href="0150-factory-for.html">0150-factory-for</a></li><li class="chapter-item expanded "><a href="0176-javascript-module-api.html">0176-javascript-module-api</a></li><li class="chapter-item expanded "><a href="0178-deprecate-ember-k.html">0178-deprecate-ember-k</a></li><li class="chapter-item expanded "><a href="0181-deprecate-ember-data-initializers.html">0181-deprecate-ember-data-initializers</a></li><li class="chapter-item expanded "><a href="0186-track-unique-history-location-state.html">0186-track-unique-history-location-state</a></li><li class="chapter-item expanded "><a href="0191-deprecate-component-lifecycle-hook-args.html">0191-deprecate-component-lifecycle-hook-args</a></li><li class="chapter-item expanded "><a href="0194-deprecate-custom-event-manager.html">0194-deprecate-custom-event-manager</a></li><li class="chapter-item expanded "><a href="0213-custom-components.html">0213-custom-components</a></li><li class="chapter-item expanded "><a href="0225-ember-engines-mount-params.html">0225-ember-engines-mount-params</a></li><li class="chapter-item expanded "><a href="0226-named-blocks.html">0226-named-blocks</a></li><li class="chapter-item expanded "><a href="0229-deprecate-testing-restricted-resolver.html">0229-deprecate-testing-restricted-resolver</a></li><li class="chapter-item expanded "><a href="0232-simplify-qunit-testing-api.html">0232-simplify-qunit-testing-api</a></li><li class="chapter-item expanded "><a href="0236-deprecation-ember-string.html">0236-deprecation-ember-string</a></li><li class="chapter-item expanded "><a href="0237-deprecation-ember-map.html">0237-deprecation-ember-map</a></li><li class="chapter-item expanded "><a href="0240-es-classes.html">0240-es-classes</a></li><li class="chapter-item expanded "><a href="0252-browser-support-changes.html">0252-browser-support-changes</a></li><li class="chapter-item expanded "><a href="0268-acceptance-testing-refactor.html">0268-acceptance-testing-refactor</a></li><li class="chapter-item expanded "><a href="0272-deprecation-native-function-prototype-extensions.html">0272-deprecation-native-function-prototype-extensions</a></li><li class="chapter-item expanded "><a href="0276-named-args.html">0276-named-args</a></li><li class="chapter-item expanded "><a href="0278-template-only-components.html">0278-template-only-components</a></li><li class="chapter-item expanded "><a href="0280-remove-application-wrapper.html">0280-remove-application-wrapper</a></li><li class="chapter-item expanded "><a href="0281-es5-getters.html">0281-es5-getters</a></li><li class="chapter-item expanded "><a href="0286-block-let-template-helper.html">0286-block-let-template-helper</a></li><li class="chapter-item expanded "><a href="0287-promote-in-element-to-public-api.html">0287-promote-in-element-to-public-api</a></li><li class="chapter-item expanded "><a href="0293-record-data.html">0293-record-data</a></li><li class="chapter-item expanded "><a href="0294-optional-jquery.html">0294-optional-jquery</a></li><li class="chapter-item expanded "><a href="0297-deprecate-ember-logger.html">0297-deprecate-ember-logger</a></li><li class="chapter-item expanded "><a href="0300-rfc-process-update.html">0300-rfc-process-update</a></li><li class="chapter-item expanded "><a href="0308-deprecate-property-lookup-fallback.html">0308-deprecate-property-lookup-fallback</a></li><li class="chapter-item expanded "><a href="0311-angle-bracket-invocation.html">0311-angle-bracket-invocation</a></li><li class="chapter-item expanded "><a href="0318-array-helper.html">0318-array-helper</a></li><li class="chapter-item expanded "><a href="0322-deprecate-copy-copyable.html">0322-deprecate-copy-copyable</a></li><li class="chapter-item expanded "><a href="0324-deprecate-component-isvisible.html">0324-deprecate-component-isvisible</a></li><li class="chapter-item expanded "><a href="0326-ember-data-filter-deprecation.html">0326-ember-data-filter-deprecation</a></li><li class="chapter-item expanded "><a href="0329-deprecated-ember-evented-in-ember-data.html">0329-deprecated-ember-evented-in-ember-data</a></li><li class="chapter-item expanded "><a href="0331-deprecate-globals-resolver.html">0331-deprecate-globals-resolver</a></li><li class="chapter-item expanded "><a href="0332-ember-data-record-links-and-meta.html">0332-ember-data-record-links-and-meta</a></li><li class="chapter-item expanded "><a href="0335-deprecate-send-action.html">0335-deprecate-send-action</a></li><li class="chapter-item expanded "><a href="0337-native-class-constructor-update.html">0337-native-class-constructor-update</a></li><li class="chapter-item expanded "><a href="0340-deprecate-ember-merge.html">0340-deprecate-ember-merge</a></li><li class="chapter-item expanded "><a href="0345-discord.html">0345-discord</a></li><li class="chapter-item expanded "><a href="0364-roadmap-2018.html">0364-roadmap-2018</a></li><li class="chapter-item expanded "><a href="0369-deprecate-computed-clobberability.html">0369-deprecate-computed-clobberability</a></li><li class="chapter-item expanded "><a href="0370-deprecate-computed-volatile.html">0370-deprecate-computed-volatile</a></li><li class="chapter-item expanded "><a href="0372-ember-data-model-factory-for.html">0372-ember-data-model-factory-for</a></li><li class="chapter-item expanded "><a href="0373-Element-Modifier-Managers.html">0373-Element-Modifier-Managers</a></li><li class="chapter-item expanded "><a href="0375-deprecate-computed-property-modifier.html">0375-deprecate-computed-property-modifier</a></li><li class="chapter-item expanded "><a href="0386-remove-jquery.html">0386-remove-jquery</a></li><li class="chapter-item expanded "><a href="0389-dynamic-tag-names.html">0389-dynamic-tag-names</a></li><li class="chapter-item expanded "><a href="0391-router-helpers.html">0391-router-helpers</a></li><li class="chapter-item expanded "><a href="0392-deprecate-component-manager-string-lookup.html">0392-deprecate-component-manager-string-lookup</a></li><li class="chapter-item expanded "><a href="0395-ember-data-packages.html">0395-ember-data-packages</a></li><li class="chapter-item expanded "><a href="0398-RouteInfo-Metadata.html">0398-RouteInfo-Metadata</a></li><li class="chapter-item expanded "><a href="0403-ember-data-identifiers.html">0403-ember-data-identifiers</a></li><li class="chapter-item expanded "><a href="0408-decorators.html">0408-decorators</a></li><li class="chapter-item expanded "><a href="0410-tracked-properties.html">0410-tracked-properties</a></li><li class="chapter-item expanded "><a href="0415-render-element-modifiers.html">0415-render-element-modifiers</a></li><li class="chapter-item expanded "><a href="0416-glimmer-components.html">0416-glimmer-components</a></li><li class="chapter-item expanded "><a href="0418-deprecate-route-render-methods.html">0418-deprecate-route-render-methods</a></li><li class="chapter-item expanded "><a href="0421-deprecate-application-controller-props.html">0421-deprecate-application-controller-props</a></li><li class="chapter-item expanded "><a href="0425-website-redesign.html">0425-website-redesign</a></li><li class="chapter-item expanded "><a href="0431-guides-restructure.html">0431-guides-restructure</a></li><li class="chapter-item expanded "><a href="0432-contextual-helpers.html">0432-contextual-helpers</a></li><li class="chapter-item expanded "><a href="0435-modifier-splattributes.html">0435-modifier-splattributes</a></li><li class="chapter-item expanded "><a href="0440-decorator-support.html">0440-decorator-support</a></li><li class="chapter-item expanded "><a href="0445-deprecate-with.html">0445-deprecate-with</a></li><li class="chapter-item expanded "><a href="0446-contribution-guides.html">0446-contribution-guides</a></li><li class="chapter-item expanded "><a href="0449-deprecate-partials.html">0449-deprecate-partials</a></li><li class="chapter-item expanded "><a href="0451-injection-parameter-normalization.html">0451-injection-parameter-normalization</a></li><li class="chapter-item expanded "><a href="0452-ember-data-medium-term-plan.html">0452-ember-data-medium-term-plan</a></li><li class="chapter-item expanded "><a href="0457-nested-lookups.html">0457-nested-lookups</a></li><li class="chapter-item expanded "><a href="0459-angle-bracket-built-in-components.html">0459-angle-bracket-built-in-components</a></li><li class="chapter-item expanded "><a href="0460-yieldable-named-blocks.html">0460-yieldable-named-blocks</a></li><li class="chapter-item expanded "><a href="0461-ember-data-singleton-record-data.html">0461-ember-data-singleton-record-data</a></li><li class="chapter-item expanded "><a href="0463-record-data-state.html">0463-record-data-state</a></li><li class="chapter-item expanded "><a href="0465-record-data-errors.html">0465-record-data-errors</a></li><li class="chapter-item expanded "><a href="0466-request-state-service.html">0466-request-state-service</a></li><li class="chapter-item expanded "><a href="0468-classic-decorator.html">0468-classic-decorator</a></li><li class="chapter-item expanded "><a href="0470-fn-helper.html">0470-fn-helper</a></li><li class="chapter-item expanded "><a href="0471-on-modifier.html">0471-on-modifier</a></li><li class="chapter-item expanded "><a href="0477-blueprints-update.html">0477-blueprints-update</a></li><li class="chapter-item expanded "><a href="0478-tracked-properties-updates.html">0478-tracked-properties-updates</a></li><li class="chapter-item expanded "><a href="0481-component-templates-co-location.html">0481-component-templates-co-location</a></li><li class="chapter-item expanded "><a href="0486-deprecate-mouseenter.html">0486-deprecate-mouseenter</a></li><li class="chapter-item expanded "><a href="0487-custom-model-classes.html">0487-custom-model-classes</a></li><li class="chapter-item expanded "><a href="0491-deprecate-disconnect-outlet.html">0491-deprecate-disconnect-outlet</a></li><li class="chapter-item expanded "><a href="0494-async-observers.html">0494-async-observers</a></li><li class="chapter-item expanded "><a href="0496-handlebars-strict-mode.html">0496-handlebars-strict-mode</a></li><li class="chapter-item expanded "><a href="0507-embroider-v2-package-format.html" class="active">0507-embroider-v2-package-format</a></li><li class="chapter-item expanded "><a href="0519-2019-2020-roadmap.html">0519-2019-2020-roadmap</a></li><li class="chapter-item expanded "><a href="0521-find-by-identifier.html">0521-find-by-identifier</a></li><li class="chapter-item expanded "><a href="0522-default-serializers-and-adapters.html">0522-default-serializers-and-adapters</a></li><li class="chapter-item expanded "><a href="0523-model-argument-for-route-templates.html">0523-model-argument-for-route-templates</a></li><li class="chapter-item expanded "><a href="0554-deprecate-getwithdefault.html">0554-deprecate-getwithdefault</a></li><li class="chapter-item expanded "><a href="0558-edition-detection.html">0558-edition-detection</a></li><li class="chapter-item expanded "><a href="0560-add-equality-operators.html">0560-add-equality-operators</a></li><li class="chapter-item expanded "><a href="0561-add-numeric-comparison-operators.html">0561-add-numeric-comparison-operators</a></li><li class="chapter-item expanded "><a href="0562-add-logical-operators.html">0562-add-logical-operators</a></li><li class="chapter-item expanded "><a href="0566-memo-decorator.html">0566-memo-decorator</a></li><li class="chapter-item expanded "><a href="0580-destroyables.html">0580-destroyables</a></li><li class="chapter-item expanded "><a href="0581-new-test-waiters.html">0581-new-test-waiters</a></li><li class="chapter-item expanded "><a href="0585-improved-ember-registry-apis.html">0585-improved-ember-registry-apis</a></li><li class="chapter-item expanded "><a href="0615-autotracking-memoization.html">0615-autotracking-memoization</a></li><li class="chapter-item expanded "><a href="0617-rfc-stages.html">0617-rfc-stages</a></li><li class="chapter-item expanded "><a href="0625-helper-managers.html">0625-helper-managers</a></li><li class="chapter-item expanded "><a href="0626-invoke-helper.html">0626-invoke-helper</a></li><li class="chapter-item expanded "><a href="0628-prettier.html">0628-prettier</a></li><li class="chapter-item expanded "><a href="0631-refresh-method-for-router-service.html">0631-refresh-method-for-router-service</a></li><li class="chapter-item expanded "><a href="0635-ember-new-lang.html">0635-ember-new-lang</a></li><li class="chapter-item expanded "><a href="0637-customizable-test-setups.html">0637-customizable-test-setups</a></li><li class="chapter-item expanded "><a href="0638-interactive-app-creation.html">0638-interactive-app-creation</a></li><li class="chapter-item expanded "><a href="0639-replace-blacklist-whitelist.html">0639-replace-blacklist-whitelist</a></li><li class="chapter-item expanded "><a href="0645-add-ember-page-title-addon.html">0645-add-ember-page-title-addon</a></li><li class="chapter-item expanded "><a href="0649-deprecation-staging.html">0649-deprecation-staging</a></li><li class="chapter-item expanded "><a href="0659-unique-id-helper.html">0659-unique-id-helper</a></li><li class="chapter-item expanded "><a href="0669-tracked-storage-primitive.html">0669-tracked-storage-primitive</a></li><li class="chapter-item expanded "><a href="0671-modernize-built-in-components-1.html">0671-modernize-built-in-components-1</a></li><li class="chapter-item expanded "><a href="0673-deprecate-tryinvoke.html">0673-deprecate-tryinvoke</a></li><li class="chapter-item expanded "><a href="0674-deprecate-transition-methods-of-controller-and-route.html">0674-deprecate-transition-methods-of-controller-and-route</a></li><li class="chapter-item expanded "><a href="0680-implicit-injection-deprecation.html">0680-implicit-injection-deprecation</a></li><li class="chapter-item expanded "><a href="0685-new-browser-support-policy.html">0685-new-browser-support-policy</a></li><li class="chapter-item expanded "><a href="0686-deprecate-old-manager-capabilities-versions.html">0686-deprecate-old-manager-capabilities-versions</a></li><li class="chapter-item expanded "><a href="0689-deprecate-has-block.html">0689-deprecate-has-block</a></li><li class="chapter-item expanded "><a href="0690-deprecate-attrs-in-templates.html">0690-deprecate-attrs-in-templates</a></li><li class="chapter-item expanded "><a href="0691-deprecate-class-binding-and-class-name-bindings.html">0691-deprecate-class-binding-and-class-name-bindings</a></li><li class="chapter-item expanded "><a href="0692-deprecate-array-observers.html">0692-deprecate-array-observers</a></li><li class="chapter-item expanded "><a href="0698-deprecate-link-to-positional-arguments.html">0698-deprecate-link-to-positional-arguments</a></li><li class="chapter-item expanded "><a href="0702-eslint-plugin-qunit.html">0702-eslint-plugin-qunit</a></li><li class="chapter-item expanded "><a href="0704-deprecate-octane-optional-features.html">0704-deprecate-octane-optional-features</a></li><li class="chapter-item expanded "><a href="0705-deprecate-jquery-optional-feature.html">0705-deprecate-jquery-optional-feature</a></li><li class="chapter-item expanded "><a href="0706-deprecate-ember-global.html">0706-deprecate-ember-global</a></li><li class="chapter-item expanded "><a href="0707-modernize-built-in-components-2.html">0707-modernize-built-in-components-2</a></li><li class="chapter-item expanded "><a href="0711-deprecate-auto-location.html">0711-deprecate-auto-location</a></li><li class="chapter-item expanded "><a href="0724-road-to-typescript.html">0724-road-to-typescript</a></li><li class="chapter-item expanded "><a href="0730-semver-for-ts.html">0730-semver-for-ts</a></li><li class="chapter-item expanded "><a href="0738-ember-data-deprecate-model-reopen.html">0738-ember-data-deprecate-model-reopen</a></li><li class="chapter-item expanded "><a href="0739-ember-data-deprecate-non-strict-relationships.html">0739-ember-data-deprecate-non-strict-relationships</a></li><li class="chapter-item expanded "><a href="0742-ember-data-deprecate-helper-functions.html">0742-ember-data-deprecate-helper-functions</a></li><li class="chapter-item expanded "><a href="0748-glimmer-component-signature.html">0748-glimmer-component-signature</a></li><li class="chapter-item expanded "><a href="0750-deprecate-ember-assign.html">0750-deprecate-ember-assign</a></li><li class="chapter-item expanded "><a href="0752-inject-service.html">0752-inject-service</a></li><li class="chapter-item expanded "><a href="0756-helper-default-manager.html">0756-helper-default-manager</a></li><li class="chapter-item expanded "><a href="0772-deprecate-bower-support.html">0772-deprecate-bower-support</a></li><li class="chapter-item expanded "><a href="0776-typescript-blueprints.html">0776-typescript-blueprints</a></li><li class="chapter-item expanded "><a href="0779-first-class-component-templates.html">0779-first-class-component-templates</a></li><li class="chapter-item expanded "><a href="0785-remove-set-get-in-tests.html">0785-remove-set-get-in-tests</a></li><li class="chapter-item expanded "><a href="0786-ember-cookbook.html">0786-ember-cookbook</a></li><li class="chapter-item expanded "><a href="0794-ember-data-schema-definition-service-simplify.html">0794-ember-data-schema-definition-service-simplify</a></li><li class="chapter-item expanded "><a href="0795-ember-data-return-promise-save.html">0795-ember-data-return-promise-save</a></li><li class="chapter-item expanded "><a href="0796-ember-data-deprecate-rsvp.html">0796-ember-data-deprecate-rsvp</a></li><li class="chapter-item expanded "><a href="0800-ts-adoption-plan.html">0800-ts-adoption-plan</a></li><li class="chapter-item expanded "><a href="0801-deprecate-blacklist-and-whitelist-build-options.html">0801-deprecate-blacklist-and-whitelist-build-options</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<p>Start Date: 2019-06-21
Relevant Team(s): Ember CLI, Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/507</p>
<hr />
<h1 id="v2-addon-format-embroider-compatibility"><a class="header" href="#v2-addon-format-embroider-compatibility">v2 Addon Format (Embroider Compatibility)</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This RFC defines a new package format that is designed to make Ember packages (meaning both apps and addons) statically analyzable and more compatible with the rest of the NPM &amp; Javascript ecosystem. This RFC is the first step in stabilizing <a href="https://github.com/embroider-build/embroider">Embroider</a> as our next-generation build system.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>One of the good things about Ember is that apps and addons have a powerful set of build-time capabilities that allow lots of shared code with zero-to-no manual integration steps for the typical user. We have been doing “zero config” since before it was a cool buzzword (it was just called “convention over configuration”). And we’ve been broadly successful at maintaining very wide backward- and forward-compatibility for a large body of highly-rated community-maintained addons.</p>
<p>But one of the challenging things about Ember is that our ecosystem’s build-time capabilities are more implementation-defined than spec-defined, and the implementation has accumulated capabilities organically while only rarely phasing out older patterns. I believe the lack of a clear, foundational, build-time public API specification is the fundamental underlying issue that efforts like the various packaging / packager RFCs have tried to work around.</p>
<p>The benefits to users for this RFC (and Embroider in general) are:</p>
<ul>
<li>faster builds and faster NPM installs</li>
<li>“zero-config import from NPM — both static and dynamic” as a first-class feature that works for both third-party libraries and Ember addons</li>
<li>support for arbitrary code splitting</li>
<li>tree-shaking of unused modules, components, helpers, etc from the app and all addons</li>
<li>a layered build system with clearly documented APIs between the layers, so it's easier to experiment and contribute</li>
<li>a build system that can take advantage of current and future investments by the wider Javascript ecosystem into code bundling &amp; optimization.</li>
</ul>
<h2 id="key-ideas"><a class="header" href="#key-ideas">Key Ideas</a></h2>
<h3 id="fully-embrace-es-modules"><a class="header" href="#fully-embrace-es-modules">Fully Embrace ES Modules</a></h3>
<p>Ember was one of the earliest adopters of ECMAScript modules, and Ember core team members were directly involved in helping move that features through TC39. Ember’s early experiences with modules influenced the spec itself. <em>Yet we have lagged in truly embracing modules.</em></p>
<p>For example, how do Ember apps express that they depend on a third-party library? The <a href="https://ember-cli.com/user-guide/#javascript-assets">app.import</a> API. This should be ECMA standard <code>import</code>.</p>
<p>Another way to state the problem is that apps and addons all <em>push</em> whatever code they want into the final built app. Whereas ES modules can <em>pull</em> each other into the build as needed.</p>
<h3 id="play-nice-with-npm-conventions"><a class="header" href="#play-nice-with-npm-conventions">Play nice with NPM Conventions</a></h3>
<p>The ECMA module spec by itself doesn’t try to define a module resolution algorithm. But the overwhelmingly most popular convention is the <a href="https://nodejs.org/api/all.html#modules_all_together">node_modules resolution algorithm</a>.</p>
<p>Ember addons do respect node_module resolution for build-time code, but they do not respect it for runtime code. This is an unhelpful distinction.</p>
<h3 id="verbose-static-javascript-as-a-compiler-target"><a class="header" href="#verbose-static-javascript-as-a-compiler-target">Verbose, Static Javascript as a Compiler Target</a></h3>
<p>Ember’s strong conventions mean that many kinds of dependencies can be inferred (including <em>statically</em> inferred) without requiring the developer to laboriously manage them. This is a good thing and I believe the current fad in the wider Javascript ecosystem for making developers hand-write verbose static imports for everything confuses the benefits of having static analysis (which is good) with the benefits of hand-managing those static imports (which is unnecessary cognitive load when you have clear conventions and a compiler).</p>
<p>This design is about compiling today’s idiomatic Ember code into more “vanilla” patterns that leverage ES modules, node_modules resolution, and spec-compliant static and dynamic <code>import</code> to express the structure of an Ember application in a much more “vanilla Javascript” way.</p>
<p>This compile step lets us separate the authoring format (which isn’t changing in any significant way in this RFC) from the packaging format (which can be more verbose and static than we would want in an authoring format).</p>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h1>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p><strong>package</strong>: every addon and app is a <strong>package</strong>. Every &quot;NPM package&quot; is a <strong>package</strong>, but not every <strong>package</strong> is an &quot;NPM package&quot; because we also include in-repo packages. The most important fact about a package is that it’s often the boundary around code that comes from a particular author, team, or organization, so coordination across packages is a more sensitive design problem than coordination within apps.</p>
<p><strong>app</strong>: a package used at the root of a project.</p>
<p><strong>addon</strong>: a package not used at the root of a project. Will be an <strong>allowed dependency</strong> of either an <strong>app</strong> or an <strong>addon</strong>.</p>
<p><strong>allowed dependency</strong>: For <strong>addons</strong>, the <strong>allowed dependencies</strong> are the <strong>packages</strong> listed in <code>dependencies</code> and <code>peerDependencies</code> in <code>package.json</code> plus any in-repo addons. For <strong>apps</strong>, the <strong>allowed dependencies</strong> are the <code>dependencies</code>, <code>peerDependencies</code>, and <code>devDependencies</code> in <code>package.json</code> plus any in-repo addons.</p>
<p><strong>Ember package metadata</strong>: the <code>ember</code> section inside <code>package.json</code>. This already exists in v1 (it's used to set <code>edition</code>), we’re going to extend it.</p>
<p><strong>v2 package</strong>: a package with <code>package.json</code> like:</p>
<pre><code>&quot;keywords&quot;: [ &quot;ember-addon&quot; ],
&quot;ember&quot;: {
  &quot;version&quot;: 2
}
</code></pre>
<p><strong>v1 package</strong>: a package with <code>package.json</code> like:</p>
<pre><code>&quot;keywords&quot;: [ &quot;ember-addon&quot; ]
</code></pre>
<p>and no <code>version</code> key (or version key less than 2) in <strong>Ember package metadata</strong>.</p>
<p><strong>non-Ember package</strong>: a package without <code>keywords: [&quot;ember-addon&quot;]</code></p>
<h2 id="scope-of-this-rfc"><a class="header" href="#scope-of-this-rfc">Scope of this RFC</a></h2>
<p>This RFC is intended as the base level spec for v2 Ember packages. <strong>It does not attempt to cover everything a v1 package can do today</strong>. For example, no provision is made in this RFC for:</p>
<ul>
<li>providing dev middleware</li>
<li>providing commands and blueprints</li>
<li>preprocessing your parent package's code</li>
<li>modifying your parent package's babel config</li>
<li>injecting content into index.html (contentFor)</li>
</ul>
<p>It is understood that all of these are legitimate things for Ember addons to do. Defining these capabilities within v2 packages will be done in followup RFCs. It is simply too much scope to cover in one RFC.</p>
<p>Because we're hyper-focused on backward- and forward-compatibility, there is no harm in progressively converting some addons to v2 (which provides immediate benefits in terms of build performance and reduced fragility under Embroider) while others need to stay as v1 until we offer the features they need.</p>
<p>This RFC is carefully decoupled from other new Ember features (like <a href="https://github.com/emberjs/rfcs/pull/496">strict mode</a> ), but it is understood that the spec created by this RFC will become a living standard that needs to both influence and be influenced by the rest of Ember's design.</p>
<h2 id="package-public-api-overview"><a class="header" href="#package-public-api-overview">Package Public API Overview</a></h2>
<p>The format we are about to describe <em>is a publication format</em>. Not necessarily an authoring format. By separating the two, we make it easier to evolve the authoring format without breaking ecosystem-wide compatibility. The publication format is deliberately more explicit and less dynamic that what we may want for an authoring format.</p>
<p>First, here’s the list of things a v2 package can provide. More detail on each of these will follow:</p>
<ul>
<li><strong>Own Javascript</strong>: javascript and templates under the package’s own namespace (the v1 equivalent is <code>/addon/**/*.{js,hbs}/</code>)</li>
<li><strong>App Javascript</strong>: javascript and templates that must be merged with the consuming app’s namespace (the v1 equivalent is <code>/app/**/*.{js,hbs}</code>). Other RFCs are working to move Ember away from needing this feature, but we are not gated on any of those and fully support <strong>App Javascript</strong>.</li>
<li><strong>Fastboot Javascript</strong>: just like <strong>App Javascript</strong>, but only applies when running in Fastboot.</li>
<li><strong>CSS</strong>: available for <code>@import</code> by other CSS files (both in the same package and across packages) and by ECMA <code>import</code> directives in Javascript modules (both in the same package and across packages).</li>
<li><strong>Implicit Dependencies</strong>: scripts, modules, and stylesheets that should be implicitly included in the app or the app's tests whenever this addon is active. This is a backward-compatibility feature.</li>
<li><strong>Renaming Rules</strong>: allow a package to declare that some of its modules should be available at different import paths than their real, resolvable path. This is a backward-compatibility feature that new addons should not use.</li>
<li><strong>Externals</strong>: allows a package to declare that it imports some things that are not <strong>allowed dependencies</strong>. Instead of being resolved at build time, <strong>externals</strong> are deferred until runtime and get handled by the traditional <code>loader.js</code> <code>require()</code>.</li>
<li><strong>Assets</strong>: any files that must be available in the final built application directory such that they have public URLs (typical examples are images and fonts).</li>
<li><strong>Build Hooks</strong>: code that runs within Node at application build time. The v1 equivalent is an addon's <code>index.js</code> file.</li>
</ul>
<h2 id="own-javascript"><a class="header" href="#own-javascript">Own Javascript</a></h2>
<p>The public <code>main</code> (as defined in <code>package.json</code>) of a v2 package points to its <strong>Own Javascript</strong>. The code is formatted as ES modules that follow the <strong>Ember Language Standard</strong> (which is defined later in this RFC). Addon authors can still author in whatever dialect they want, but they must transpile to Ember Language Standard before publishing to NPM.</p>
<p>Templates are in hbs format. No custom AST transforms are supported. Addon authors can still use custom AST transforms, but those transforms must have already been applied and re-emitted into hbs source text before publication to NPM. This means that only AST transforms whose output are serializable into hbs source text are permitted.</p>
<p>Unlike v1 addons, there is no <code>/app</code> or <code>/addon</code> directory that is magically removed from the runtime paths to the modules. All resolution follows the prevailing Node rules.</p>
<p>The benefit of this design is that it makes our packages understandable by a broader set of tooling. Editors and build tools can follow <code>import</code> statements across packages and end up in the right place.</p>
<p>In v1 packages, <code>main</code> usually points to a build-time configuration file. That file is moving and will be described in the <strong>Build Hooks</strong> section below.</p>
<h3 id="own-javascript-imports"><a class="header" href="#own-javascript-imports">Own Javascript: Imports</a></h3>
<p>Modules in <strong>Own Javascript</strong> are allowed to use ECMA static <code>import</code> and dynamic <code>import()</code> to resolve any <strong>allowed dependency</strong>, causing it to be included in the build whenever the importing module is included. This replaces <code>app.import</code>. Resolution follows prevailing Node rules. (This usually means the node_modules algorithm, but it could also mean Yarn PnP. The difference shouldn't matter if you are correctly declaring all your <strong>allowed dependencies</strong>.)</p>
<p>Notice that a package’s <strong>allowed dependencies</strong> do not include the package itself. This is consistent with how Node resolution works. To import files from within your own package you must use relative paths. This is different from how run-time AMD module resolution has historically worked in Ember Apps. (<code>@embroider/compat</code> implements automatic adjustment for this case when compiling from v1 to v2).</p>
<h3 id="own-javascript-co-located-component-templates"><a class="header" href="#own-javascript-co-located-component-templates">Own Javascript: Co-located Component Templates</a></h3>
<p>Modules in <strong>Own Javascript</strong> get no <em>automatic</em> component template co-location. They should use Ember's <code>setComponentTemplate</code> explicitly. They can access their compiled templates either by importing them or by inlining them via the <code>hbs</code> macro provided by ember-cli-htmlbars.</p>
<p>We're assuming that template co-location will be handled by the build step <em>before</em> an addon is published to NPM in V2 format.</p>
<p>Similarly, template-only components must be explicitly present as Javascript modules that invoke Ember's <code>templateOnlyComponent()</code> and <code>setComponentTemplate</code>.</p>
<h3 id="own-javascript-transpilation-of-imported-modules"><a class="header" href="#own-javascript-transpilation-of-imported-modules">Own Javascript: Transpilation of imported modules</a></h3>
<p>Any module you import, whether from an Ember package or a non-Ember package, gets transpiled by default such that it will support the app's set of browser targets. This ensures that the app's <code>config/targets.js</code> will always be respected and you won't accidentally break your older supported browsers by importing a dependency that uses newer ECMA features.</p>
<p>Today in practice this means everything you import will go through babel-preset-env, and babel-preset-env will use the same configuration that it uses in the app.</p>
<p>There is an explicit per-package opt-out for cases where you're <em>sure</em> that transpilation is not needed and not desirable. (See <strong>Build Hooks</strong> for details on the <code>skipBabel</code> option.)</p>
<h3 id="own-javascript-supported-module-formats-for-non-ember-packages"><a class="header" href="#own-javascript-supported-module-formats-for-non-ember-packages">Own Javascript: Supported module formats for non-Ember packages</a></h3>
<p>As already stated, V2 Ember packages must contain only ES modules. However, non-Ember packages in your <strong>allowed dependencies</strong> are allowed to contain ES modules <em>or</em> CommonJS modules. This provides the best compatibility with general-purpose NPM utilities.</p>
<h3 id="own-javascript-macros"><a class="header" href="#own-javascript-macros">Own Javascript: Macros</a></h3>
<p>The V2 format deliberately eliminates many sources of app-build-time dynamism from addons. Instead, we provide an equivalently-powerful macro system and consider it an always-supported language extension (the macros are always available to every V2 package, ambiently, and we promise to give them their faithful build-time semantics).</p>
<p>See <strong>Macro System</strong> for the full details.</p>
<h2 id="app-javascript"><a class="header" href="#app-javascript">App Javascript</a></h2>
<p>To provide <strong>App Javascript</strong>, a package includes the <code>app-js</code> key in <strong>Ember package metadata</strong>. For example, to duplicate the behavior of v1 packages, you could say:</p>
<pre><code>&quot;ember&quot;: {
  &quot;version&quot;: 2,
  &quot;app-js&quot;: &quot;./app&quot;
}
</code></pre>
<p>Like the <strong>Own Javascript</strong>, the code must be authored as ES modules in <strong>Ember Language Standard</strong>. ECMA static and dynamic imports from any <strong>allowed dependency</strong> are supported. Even though the app javascript will be addressable within the <em>app's</em> module namespace, your own imports still resolve relative to your addon.</p>
<p>By making <code>app-js</code> an explicit key in <strong>Ember package metadata</strong>, our publication format is more durable (you can rearrange the conventional directory structure in the future without breaking the format) and more performant (less filesystem traversal is required to decide whether the package is using the <strong>App Javascript</strong> feature.</p>
<h2 id="fastboot-javascript"><a class="header" href="#fastboot-javascript">Fastboot Javascript</a></h2>
<p>To provide <strong>Fastboot Javascript</strong>, a package includes the <code>fastboot-js</code> key in <strong>Ember package metadata</strong>. This works almost identically to <strong>App Javascript</strong>, except it means the given directory will only be merged into the app's namespace when running in Fastboot (server-side rendering) mode. This key is a backward compatibility feature that allows addons with a <code>fastboot</code> directory to express their needs.</p>
<p>New v2 packages don't need to use <code>fastboot-js</code> because they can use the macro system to branch between browser and server implementations.</p>
<h2 id="css"><a class="header" href="#css">CSS</a></h2>
<p>To provide <strong>CSS</strong>, a package can include any number of CSS files. These files can <code>@import</code> each other via relative paths, which will result in build-time inclusion (as already works in v1 packages).</p>
<p>If any of the <strong>Own Javascript</strong> or <strong>App Javascript</strong> modules depend on the presence of a CSS file in the same package, it should say so explicitly via an ECMA relative import, like:</p>
<pre><code>import '../css/some-component.css';
</code></pre>
<p>This is interpreted as a build-time directive that ensures that before the Javascript module is evaluated, the CSS file's contents will be present in the DOM. ECMA import of CSS files must always include the explicit <code>.css</code> extension.</p>
<blockquote>
<p>Q: Does this interfere with the ability to do CSS-in-JS style for people who like that?</p>
</blockquote>
<blockquote>
<p>A: No, because that would be a preprocessing step before publication. It’s a choice of authoring format, just like TypeScript or SCSS. CSS-in-JS people would compile all their things to ES modules before we deal with it.</p>
</blockquote>
<p>It is also possible for other packages (including the consuming application) to depend on a CSS file in any of its <strong>allowed dependencies</strong>, from either Javascript or CSS. From Javascript it looks like:</p>
<pre><code>// This will resolve the `your-addon` package and find
// './some-component.css' relative to the package root.
// The .css file extension is mandatory
import 'your-addon/some-component.css';
</code></pre>
<p>And from CSS it looks like:</p>
<pre><code>@import 'your-addon/some-component';
</code></pre>
<p>What about SCSS <em>et al</em>? You’re still free to use them as your authoring format, and they should be transpiled to CSS in your publication format. If you want to offer the original SCSS to consuming packages, you’re free to include it in the publication format too. Since we’re making all packages resolvable via normal node rules, it’s now dramatically easier to implement a preprocessor that supports inter-package dependencies. (The same logic applies to TypeScript.)</p>
<h2 id="implicit-dependencies"><a class="header" href="#implicit-dependencies">Implicit Dependencies</a></h2>
<p>Within <strong>Ember package metadata</strong> we support several flavors of implicit dependencies:</p>
<ul>
<li>implicit-modules</li>
<li>implicit-scripts</li>
<li>implicit-styles</li>
<li>implicit-test-modules</li>
<li>implicit-test-scripts</li>
<li>implicit-test-styles</li>
</ul>
<p>Each one is a list of package-relative paths to files within the package.</p>
<p>Whenever your package is active, all of its implicit dependencies will be included in the build. The <code>-test-</code> variants will be included only in test suites, and the non-<code>-test-</code> variants are always included.</p>
<p><code>implicit-modules</code> and <code>implicit-test-modules</code> mean that the app should be built as if someone has explicitly typed ECMA import statements for each of the listed modules.</p>
<p><code>implicit-scripts</code> and <code>implicit-test-scripts</code> are for Javascript in a script context. Script context is different from module context (as defined by the ECMA spec). This is how an addon can push things into the equivalent of the traditional <code>vendor.js</code>, which is in script context.</p>
<p><code>implicit-styles</code> and <code>implicit-test-styles</code> are for stylesheets. This is how an addon can push things into the equivalent of the traditional vendor.css.</p>
<p>While <strong>Implicit Dependencies</strong> are a fully-supported part of the v2 spec, v2 packages are encouraged to use direct ECMA <code>import</code> or CSS <code>@import</code> instead, whenever possible. A direct <code>import</code> provides finer-grained dependency information: we know exactly <em>which</em> module inside your package actually depends on the thing, rather than needing to assume that your entire package depends on it.</p>
<p>For example, if one of your components depends on a third-party library, you should <code>import</code> that library directly from your component. Then the library will only be included if somebody uses that particular component. Whereas if you use <code>implicit-scripts</code>, the library will always be included, even if nobody uses the component that needs the library.</p>
<h2 id="renaming-rules"><a class="header" href="#renaming-rules">Renaming Rules</a></h2>
<p>V1 Addons have multiple ways (at least five that I've found so far!) of emitting modules that escape the addon's own package namespace. Examples:</p>
<ul>
<li><code>ember-lodash</code> remaps all of its modules to the package name <code>lodash</code></li>
<li><code>@ember/test-helpers</code> provides some modules under its true name, but also some modules under <code>ember-test-helpers</code>.</li>
</ul>
<p>In order for Embroider compile these packages to valid V2 packages, we give V2 packages the ability to express renaming rules using the following properties in <strong>Ember package metadata</strong>:</p>
<ul>
<li>
<p><code>renamed-packages</code>: a map from the package name a user would type to the real package name that provides it. Example:</p>
<pre><code class="language-js">{
  &quot;renamed-packages&quot;: {
    &quot;lodash&quot;: &quot;ember-lodash&quot;
  }
}
</code></pre>
</li>
<li>
<p><code>renamed-modules</code>: a map from modules that a user may try to import to the real paths where those modules live:</p>
<pre><code class="language-js"> &quot;renamed-modules&quot;: {
  &quot;ember-test-helpers/index.js&quot;: &quot;@ember/test-helpers/ember-test-helpers/index.js&quot;
 }
</code></pre>
<p>When Embroider compiles a V1 package like <code>@ember/test-helpers</code> it ensures that the modules that would have &quot;escaped&quot; the package end up <em>inside</em> the package, so that this kind of renaming works.</p>
<p>The renaming rules allow these addons to adopt V2 format without breaking their public API. New addons <em>should not</em> use renaming rules because it's confusing when the imports people type don't align with their real dependencies.</p>
</li>
</ul>
<h2 id="externals"><a class="header" href="#externals">Externals</a></h2>
<p>The <code>externals</code> property in <strong>Ember package metadata</strong> allows a V2 addon to declare specific imported modules that should not be resolved at build time. Instead they will be resolved at runtime using the traditional <code>loader.js</code> <code>require()</code>.</p>
<p>When Embroider compiles V1 packages to V2 it does automatic externals detection.</p>
<p>When publishing a native V2 package, any externals need to be listed explicitly in <strong>Ember package metadata</strong>.</p>
<p>An example of when you may need <code>externals</code> is when you need to consume a script (not a module) that contains arbitrary <code>define()</code> statements. The modules defined by those statements aren't resolvable, in general, at build time. So attempts to import them will generate build errors. By listing them in externals, you can defer them until runtime where they will work.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>To provide <strong>Assets</strong>, a package includes the <code>public-assets</code> key in <strong>Ember package metadata</strong>. It's a mapping from local paths to app-relative URLs that should be available in the final app. For example:</p>
<pre><code>&quot;name&quot;: &quot;my-addon&quot;,
&quot;ember&quot;: {
  &quot;version&quot;: 2,
  &quot;public-assets&quot;: {
    &quot;./public/image.png&quot;: &quot;/my-addon/image.png&quot;
  }
}
</code></pre>
<p>with:</p>
<pre><code>my-addon
└── public
    └── image.png
</code></pre>
<p>will result in final build output:</p>
<pre><code>dist
└── my-addon
    └── image.png
</code></pre>
<p>Notice that we’re <em>not</em> choosing to include assets via explicit ECMA <code>import</code>. The reason is that fine-grained inclusion of asset files is not critical to runtime performance. Any assets that your app doesn’t actually need, it should never fetch. Assets are always things with their own URLs.</p>
<p>If two V2 packages try to emit assets with the same public URL, that's a build error.</p>
<blockquote>
<p>Q: Should we just automatically namespace them instead?
A: That was considered, but it makes backward compatibility harder, and public URLs are not always free to choose/change.</p>
</blockquote>
<h2 id="build-hooks"><a class="header" href="#build-hooks">Build Hooks</a></h2>
<p>In today’s v1 addon packages, the <code>index.js</code> file is the main entrypoint that allows an addon to integrate itself with the overall ember-cli build pipeline. The same idea carries forward to v2, with some changes.</p>
<p>It is no longer the <code>main</code> entrypoint of the package (see <strong>Own Javascript</strong>). Instead, it’s located via the <code>build</code> key in <strong>Ember package metadata</strong>, which should point at a Javascript file. <code>build</code> is optional — if you don’t have anything to say, you don’t need the file.</p>
<p>It is now an ECMA module, not a CJS file. The default export is a class that implements your build hooks (there is no required base class).</p>
<p>Here is a list of build hooks, each of which will have its own section below.</p>
<ul>
<li>configure</li>
<li>configureDependencies</li>
<li>skipBabel</li>
</ul>
<p>I will describe the hooks using TypeScript signatures for precision. This does not imply anything about us actually using TypeScript to implement them. Each package has two type variables:</p>
<ul>
<li><code>PackageOptions</code> is the interface for what options you accept from packages that depend on you. It's your package's build-time public API.</li>
<li><code>OwnConfig</code> is the interface for the configuration that you want to send to your own code, which your code can access via the <code>getOwnConfig</code> macro. This is how you influence your runtime code from the build hooks.</li>
</ul>
<h3 id="build-hook-configure"><a class="header" href="#build-hook-configure">Build Hook: configure</a></h3>
<pre><code class="language-ts">interface ConfigurationRequest&lt;PackageOptions&gt; = {
  options: PackageOptions,
  fromPackageName: string,
  fromPackageRoot: string,
};
configure&lt;PackageOptions, OwnConfig&gt;(
  requests: ConfigurationRequest&lt;PackageOptions&gt;[]
): OwnConfig
</code></pre>
<p>The configure hook receives an array of configuration requests. Each request contain the <code>PackageOptions</code> that a package that depends on this addon has sent to this addon. It also includes the <code>fromPackageName</code> and <code>fromPackageRoot</code> (the full path on disk to the requesting package) so that any configuration errors can blame the proper source.</p>
<p><code>configure</code> deals with an array because multiple packages may depend on a single copy of our package. But our package can only be configured in one way (for example, we are either going to include some extra code or strip it out via the macro system, but we can't do both).</p>
<p>Addons are encouraged to merge configuration requests intelligently to try to satisfy all requesters. If it's impossible to do so, you can throw an error that explains the problem.</p>
<p>The <code>OwnConfig</code> return value must be JSON-serializable. It becomes available to your <strong>Own Javascript</strong> via the <code>getOwnConfig</code> macro, so that it can influence what code is conditionally compiled out of the build.</p>
<h3 id="build-hook-configuredependencies"><a class="header" href="#build-hook-configuredependencies">Build Hook: configureDependencies</a></h3>
<pre><code class="language-ts">configureDependencies(): {
  [dependencyName: string]: PackageOptionsForDependency | &quot;disabled&quot;
}
</code></pre>
<p>The <code>configureDependencies</code> hook is how you send configuration down to your own dependencies. For each package in your <strong>allowed dependencies</strong> you may return either the <code>PackageOptions</code> expected by that package, or the string <code>&quot;disabled&quot;</code>.</p>
<p>Any dependencies that you don't mention are considered active, but don't receive any configuration from you.</p>
<p>Any dependency for which you provide <code>PackageOptions</code> is active, and will receive those <code>PackageOptions</code> in its own <code>configure</code> hook.</p>
<p>If you set a package to <code>&quot;disabled&quot;</code>, it will not become active <em>because of your addon</em>. It may still become active if another package depends on it and leave it active.</p>
<p>When and only when a package is active:</p>
<ul>
<li>all standard Ember module types (<code>your-package/components/*.js</code>, <code>your-package/services/*.js</code>, etc) from its <strong>Own Javascript</strong> <em>that cannot be statically ruled out as unnecessary</em> are included in the build as if some application code has <code>import</code>ed them. (What counts as “cannot be statically ruled out” is free to change as apps adopt increasingly static practices. This doesn’t break any already published packages, it just makes builds that consume them more efficient.)</li>
<li>all of the package's <strong>Implicit Dependencies</strong> are included in the build.</li>
<li>all <strong>App Javascript</strong> is included in the build.</li>
<li>all <strong>Assets</strong> are included in the build.</li>
<li>the package's <strong>Active Dependencies</strong> become active recursively.</li>
</ul>
<p>Whether or not a package is active:</p>
<ul>
<li>directly-imported <strong>Own Javascript</strong> and <strong>CSS</strong> are available to any other package as described in those sections. The rationale for allowing <code>import</code> of non-active packages is that (1) we follow node module resolution and node module resolution doesn’t care about our notion of “active”, and (2) <code>import</code> is an explicit request to use the module in question. It’s not surprising that it would work, it would be more surprising if it didn’t.</li>
</ul>
<p>The <code>configureDependencies</code> hook is the <em>only</em> way to disable child packages. The package hooks are implemented as a class with no base class. There is no <code>super</code> to manipulate to interfere with your children’s hooks.</p>
<h3 id="build-hook-skipbabel"><a class="header" href="#build-hook-skipbabel">Build Hook: skipBabel</a></h3>
<pre><code class="language-ts">skipBabel(): { package: string, semverRange?: string }[]
</code></pre>
<p>By default, all imported dependencies (and their recursive imported dependencies) go through the app's babel config. This ensures browser compatibility safety. However, we provide <code>skipBabel</code> as an opt-out to work around transpilation problems in cases where the developer has verified that transpilation of a given package isn't needed.</p>
<p><code>skipBabel</code> returns a list of package names and optionally semver ranges. If no range is included, it defaults to <code>*</code>. This is a place where you're allowed to mentioned packages that are <em>not</em> in your <strong>allowed dependencies</strong> because it may be necessary to talk about deeper dependencies within them. The <code>skipBabel</code> settings for all active addons are combined and if any addon skips babel for a given package &amp; version, that causes the package to not be transpiled.</p>
<p>The semver range is useful to disambiguate if there are multiple versions of the same package involved in the app, and in cases where a developer has manually verified that transpilation isn't needed, it's good practice to use the semver range so that <code>skipBabel</code> doesn't accidentally apply to a future version of the package that may indeed need transpilation.</p>
<h2 id="what-about-test-support"><a class="header" href="#what-about-test-support">What about Test Support?</a></h2>
<p>v1 packages can provide <code>treeForTestSupport</code>, <code>treeForAddonTestSupport</code>, and <code>app.import</code> with <code>type=&quot;test&quot;</code>. All of these features are dropped.</p>
<p>To provide test-support code, make a separate module within your package and tell people to <code>import</code> it from their tests. As long as it is only imported from tests, it will not be present in non-test bundles. (Things get simpler when you respect the module dependency graph.)</p>
<h2 id="macro-system"><a class="header" href="#macro-system">Macro System</a></h2>
<p>v1 packages can run arbitrary Node code that completely alters their runtime code. This makes them impossible to analyze. v2 packages are not allowed to do this. There are no &quot;treeFor*&quot; hooks. Instead, they can influence their runtime code only through the macro system.</p>
<p>It helps to think about the macro system as an extension to Javascript itself that we allow in v2 packages. Because the macros are allowed to appear in any published V2 package, and because the macros are <em>not</em> a dependency that each package can control (you don't get to bring your own separate macro system version with you), it's important that we design a small core that we can support for the long-term. We probably can't make breaking changes to the macro system, we can only introduce new macros.</p>
<p>(I'm proposing the macros live under <code>@ember/macros</code>. The current implementation of them lives in <code>@embroider/macros</code>.)</p>
<p>The Javascript macros are:</p>
<ul>
<li>importSync</li>
<li>getOwnConfig</li>
<li>getConfig</li>
<li>macroCondition</li>
<li>each</li>
<li>moduleExists</li>
<li>dependencySatisfies</li>
<li>failBuild</li>
</ul>
<p>The Handlebars macros are:</p>
<ul>
<li>macroGetOwnConfig</li>
<li>macroGetConfig</li>
<li>macroCondition</li>
<li>macroDependencySatisfies</li>
<li>macroMaybeAttrs</li>
<li>macroFailBuild</li>
</ul>
<p>The difference in naming is because the JS macros get explicitly imported from <code>@ember/macros</code>, whereas the Handlebars macros do not, so they need an appropriate namespace prefix. (If we land template imports, I'm fine with adjusting this RFC to make the names align.)</p>
<h3 id="javascript-macro-importsync"><a class="header" href="#javascript-macro-importsync">JavaScript Macro: importSync</a></h3>
<pre><code class="language-js">import { importSync } from &quot;@ember/macros&quot;;
importSync(&quot;some-dependency&quot;).default;
</code></pre>
<p><code>importSync</code> exists to do a thing that standard Javascript does not do: synchronous dynamic import. Ember historically needs synchronous dynamic import (it's what our runtime AMD <code>require</code> does). Until some future date at which Ember has migrated away from synchronous module resolution we need <code>importSync</code>.</p>
<p><code>importSync</code> is defined as behaving exactly like the standards-compliant <code>import()</code> except instead of returning <code>Promise&lt;Module&gt;</code> it returns <code>Module</code>.</p>
<p>In this RFC we don't state explicitly what <code>importSync</code> compiles to. It compiles to whatever the Javascript bundler we're using supports in order to achieve synchronous dynamic import. For example, if we're internally using Webpack we can compile <code>importSync(&quot;something&quot;)</code> to <code>require(&quot;something&quot;)</code>, because Webpack supports CommonJS <code>require</code> anywhere.</p>
<h3 id="javascript-macro-getownconfig"><a class="header" href="#javascript-macro-getownconfig">JavaScript Macro: getOwnConfig</a></h3>
<pre><code class="language-js">// this example:
import { getOwnConfig } from &quot;@ember/macros&quot;;
const shouldEnableCoolFeature = getOwnConfig().coolFeature;
// might compile to:
const shouldEnableCoolFeature = true;
// assuming your ownConfig is `{ coolFeature: true }`.
</code></pre>
<p><code>getOwnConfig()</code> behaves like a function that returns your <code>OwnConfig</code>, as determined by the return value of your <code>configure</code> <strong>Build Hook</strong>. You're allowed to chain property access and optional property access (including array indices) off of <code>getOwnConfig()</code>. Since the <code>OwnConfig</code> is required to be JSON-serializable, any subset of it can be accessed this way, and we inline that value directly into the code.</p>
<p>You can choose to inline the whole OwnConfig if you want to:</p>
<pre><code class="language-js">// this example:
import { getOwnConfig } from &quot;@ember/macros&quot;;
const myConfig = getOwnConfig();
// might compile to:
const myConfig = { coolFeature: true };
// assuming your ownConfig is `{ coolFeature: true }`.
</code></pre>
<p>Since <code>getOwnConfig</code> accesses the output of your <code>configure</code> build-hook, you have a place to run arbitrary build-time code and inject the results into runtime Javascript.</p>
<h3 id="javascript-macro-getconfig"><a class="header" href="#javascript-macro-getconfig">Javascript Macro: getConfig</a></h3>
<p><code>getConfig</code> can access the <code>OwnConfig</code> of your dependencies.</p>
<pre><code class="language-js">import { getConfig } from &quot;@ember/macros&quot;;
const testSelectorsConfig = getConfig(&quot;ember-test-selector&quot;);
</code></pre>
<p>It supports property chaining the same as <code>getOwnConfig</code>.</p>
<p>This is a low-level power tool. It's mostly useful as a compile target for custom Babel plugins. For example, <code>ember-test-selectors</code> has a custom Babel plugin that <em>sometimes</em> strips test properties out of your components. But if a V2 package is using ember-test-selectors, it needs to run the custom transform <em>before publishing</em>. At that point, it's too soon to decide whether to strip them.</p>
<p>Instead of actually doing the stripping, the ember-test-selector plugin would compile the user's code into code that uses <code>macroCondition</code> and <code>getConfig('ember-test-selectors')</code>. In this way, we get the powerful custom behavior, but only the standard core macros are needed at the time when the app itself is building.</p>
<h3 id="javascript-macro-macrocondition"><a class="header" href="#javascript-macro-macrocondition">JavaScript Macro: macroCondition</a></h3>
<p><code>macroCondition</code> acts like a function that takes a boolean value and returns that same boolean value. But whenever <code>macroCondition</code> appears directly inside the predicate of an <code>if</code> statement or as the predicate of a ternary expression, it tells the macro system to do branch elimination based on the predicate. Here is an example that combines three of the macros we've seen so far:</p>
<pre><code class="language-js">// This example:
import { macroCondition, getOwnConfig, importSync } from &quot;@ember/macros&quot;;

let implementation;

if (macroCondition(getOwnConfig().useNewVersion)) {
  implementation = importSync(&quot;./new-component&quot;);
} else {
  implementation = importSync(&quot;./old-component&quot;);
}

export default implementation;

// ==============
// Could compile down to this if OwnConfig contains { useNewVersion: true }
let implementation;
implementation = importSync(&quot;./new-component&quot;);
export default implementation;

// ===============
// Or compile down to this if OwnConfig contains { useNewVersion: false }
let implementation;
implementation = importSync(&quot;./old-component&quot;);
export default implementation;
</code></pre>
<p>It is a build error if <code>macroCondition</code> cannot statically determine the truth status of its argument. It's a build error if <code>macroCondition</code> appears anywhere other than as the predicate of an if statement or ternary expression.</p>
<p><code>macroCondition</code> supports boolean logic, like <code>macroCondition(getOwnConfig().a &amp;&amp; getOwnConfig().b)</code>.</p>
<p>Here is an example of <code>macroCondition</code> in a ternary expression:</p>
<pre><code class="language-js">// this example:
const flavor = macroCondition(getOwnConfig().prefersChocolate)
  ? &quot;chocolate&quot;
  : &quot;vanilla&quot;;
// could compile down to:
const flavor = &quot;chocolate&quot;;
</code></pre>
<p><code>macroCondition</code> is the foundation that lets us choose which code to include in the build. You can choose to inline two different implementations within the branches of an <code>if</code> statement, or you can keep them in entirely separate modules and import only the correct one via <code>importSync</code>.</p>
<p>It would also be possible (in the future, when top-level await stabilizes) to use <a href="https://github.com/tc39/proposal-top-level-await">top-level await</a> to replace usage of our <code>importSync</code> macro with standards-compliant <code>import()</code>:</p>
<pre><code class="language-js">if (macroConditional(getOwnConfig().x)) {
  await import(&quot;x&quot;);
} else {
  await import(&quot;y&quot;);
}
</code></pre>
<p>Q: Why not allow <code>if (getOwnConfig().thing)</code> instead of <code>if (macroCondition(getOwnConfig().thing))</code>?</p>
<p>A: Because we don't want to leave any confusion over whether branch elimination will be done. Boolean expressions that include a macro like <code>getOwnConfig</code> alongside other runtime-only values are perfectly legal. But those expressions would not allow branch elimination. The ambiguity means you might accidentally defeat branch elimination without noticing. <code>macroCondition</code> is intended to signal -- both to the reader and to the compiler -- that this place absolutely <em>must</em> do branch elimination. It's an error if we can't eliminate one branch or the other.</p>
<h3 id="javascript-macro-each"><a class="header" href="#javascript-macro-each">JavaScript macro: each</a></h3>
<p><code>each</code> allows you to unroll a loop based on an array value provided by another macro. It behaves like the identity function (returning its argument unchanged), but it provides the special guarantee that if you use it as the argument of a <code>for ... of</code> loop, the loop will be unrolled:</p>
<pre><code class="language-js">// This example:
import { getOwnConfig, each, importSync } from &quot;@ember/macros&quot;;
let plugins = [];
for (let plugin of each(getOwnConfig().registeredPlugins)) {
  plugins.push(importSync(plugin).default);
}

// could compile to this, given OwnConfig
// containing { registeredPlugins: ['@bigco/bar-chart', '@bigco/line-chart']}

let plugins = [];
plugins.push(importSync(&quot;@bigco/bar-chart&quot;).default);
plugins.push(importSync(&quot;@bigco/line-chart&quot;).default);
</code></pre>
<p>It is a static error if the argument to <code>each</code> does not evaluate to a statically known array.</p>
<h3 id="javascript-macro-moduleexists"><a class="header" href="#javascript-macro-moduleexists">JavaScript Macro: moduleExists</a></h3>
<p>Allow you to test if an <code>import</code> (or <code>import()</code> or <code>importSync()</code>, since they all accept an argument with identical semantics) would succeed. Always compiles to a boolean literal.</p>
<pre><code class="language-js">import { moduleExists, macroCondition, importSync } from &quot;@ember/macros&quot;;
if (macroCondition(moduleExists(&quot;ember-data&quot;))) {
  const DS = importSync(&quot;ember-data&quot;).default;
  DS.Adapter.extend({
    //
  });
}
</code></pre>
<p>Remember that you're always only allowed to <code>import</code> from your own <strong>allowed dependencies</strong>. So if an addon wants to optionally use another package only if that package is present, that package must be listed as an <strong>Optional Peer Dependency</strong>.</p>
<p><code>moduleExists</code> differs in one respect from all the other macros: there is no reliable build-time polyfill for it in non-Embroider builds. So when you use it in a non-Embroider build, you get a runtime implementation instead (equivalent to today's <code>require.has()</code>. If you need build-time branch elimination, try to use <code>dependencySatisfies</code> instead, which works correctly in both Embroider and non-Embroider builds.</p>
<h3 id="javascript-macro-dependencysatisfies"><a class="header" href="#javascript-macro-dependencysatisfies">JavaScript Macro: dependencySatisfies</a></h3>
<p>Allows you to test if the given <strong>allowed dependency</strong> satisfies the given semver range. Always compiles to a boolean literal.</p>
<pre><code class="language-js">import { dependencySatisfies, macroCondition } from &quot;@ember/macros&quot;;
if (macroCondition(dependencySatisfies(&quot;ember-data&quot;, &quot;^3.0.0&quot;))) {
  // include code here for ember-data 3.0 compat
}
</code></pre>
<p>The package version will be <code>semver.coerce</code>d first, such that non-standard versions like &quot;3.9.0-beta.0&quot; will appropriately satisfy constraints like &quot;&gt; 3.8&quot;.</p>
<h3 id="javascript-macro-failbuild"><a class="header" href="#javascript-macro-failbuild">Javascript Macro: failBuild</a></h3>
<p>Allow you to cause a build failure with a custom error message. If <code>failBuild</code> isn't eliminated by <code>macroCondition</code>'s branch elimination, the build will fail.</p>
<pre><code class="language-js">import { dependencySatisfies, macroCondition, failBuild } from &quot;@ember/macros&quot;;
if (macroCondition(dependencySatisfies(&quot;ember-data&quot;, &quot;^3.0.0&quot;))) {
  // include code here for ember-data 3.0 compat
} else {
  failBuild(`We don't support ember-data versions other than ^3.0.0`);
}
</code></pre>
<h3 id="handlebars-macro-macrogetownconfig"><a class="header" href="#handlebars-macro-macrogetownconfig">Handlebars Macro: macroGetOwnConfig</a></h3>
<p><code>macroGetOwnConfig</code> is very similar to the <code>getOwnConfig</code> JS macro, but it works as a Handlebars helper. Given this <code>OwnConfig</code>:</p>
<pre><code class="language-json">{
  &quot;items&quot;: [{ &quot;score&quot;: 42 }]
}
</code></pre>
<p>Then:</p>
<pre><code class="language-hbs">&lt;SomeComponent @score={{macroGetOwnConfig &quot;items&quot; 0 &quot;score&quot; }} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @score={{42}} /&gt;
</code></pre>
<p>If you don't pass any arguments, you can get the whole thing (although this makes your template bigger, so use arguments when you can):</p>
<pre><code class="language-hbs">&lt;SomeComponent @config={{macroGetOwnConfig}} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @config={{hash items=(array (hash score=42))}} /&gt;
</code></pre>
<h3 id="handlebars-macro-macrogetconfig"><a class="header" href="#handlebars-macro-macrogetconfig">Handlebars Macro: macroGetConfig</a></h3>
<p>The equivalent of the <code>getConfig</code> JS macro as a Handlebars helper. Given a dependency <code>ember-score</code> exposes this config:</p>
<pre><code class="language-json">{
  &quot;items&quot;: [{ &quot;score&quot;: 42 }]
}
</code></pre>
<p>Then:</p>
<pre><code class="language-hbs">&lt;SomeComponent @score={{macroGetConfig &quot;ember-score&quot; &quot;items&quot; 0 &quot;score&quot; }} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @score={{42}} /&gt;
</code></pre>
<h3 id="handlebars-macro-macrocondition"><a class="header" href="#handlebars-macro-macrocondition">Handlebars Macro: macroCondition</a></h3>
<p>Used as a helper within a block <code>{{#if}}</code> or inline <code>{{if}}</code>. Just like the JS <code>macroCondition</code>, it ensures that branch elimination will happen.</p>
<pre><code class="language-hbs">  {{#if (macroCondition (macroGetOwnConfig &quot;shouldUseThing&quot;)) }}
    &lt;Thing /&gt;
  {{else}}
    &lt;OtherThing /&gt;
  {{/if}}

  {{! ⬆️compiles to ⬇️ }}
  &lt;Thing /&gt;
</code></pre>
<h3 id="handlebars-macro-macrodependencysatisfies"><a class="header" href="#handlebars-macro-macrodependencysatisfies">Handlebars Macro: macroDependencySatisfies</a></h3>
<p>Acts like a helper that returns a boolean. Like the <code>dependencySatisfies</code> JS macro, it can only resolve things that are <strong>allowed dependencies</strong>, so the same need for peer dependencies and/or <strong>Optional Peer Dependencies</strong> applies.</p>
<pre><code class="language-hbs">&lt;SomeComponent @canAnimate={{macroDependencySatisfies &quot;liquid-fire&quot; &quot;*&quot;}} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @canAnimate={{true}} /&gt;
</code></pre>
<h3 id="handlebars-macro-macromaybeattrs"><a class="header" href="#handlebars-macro-macromaybeattrs">Handlebars Macro: macroMaybeAttrs</a></h3>
<p>There is one place where <code>{{#if}}</code> doesn't work: within &quot;element space&quot;. If you want to <em>sometimes</em> set an attribute, but sometimes not, this doesn't work:</p>
<pre><code class="language-hbs">&lt;div {{#if this.testing}} data-test-target={{@id}} {{/if}} /&gt;
</code></pre>
<p><code>macroMaybeAttrs</code> exists to conditionally compile away attributes and arguments out of element space:</p>
<pre><code class="language-hbs">&lt;div {{macroMaybeAttrs (macroGetConfig &quot;ember-test-selectors&quot; &quot;enabled&quot;) data-test-target=@id }} /&gt;
</code></pre>
<p>It can be placed on both HTML elements and angle bracket component invocations.</p>
<h3 id="handlebars-macro-macrofailbuild"><a class="header" href="#handlebars-macro-macrofailbuild">Handlebars Macro: macroFailBuild</a></h3>
<p>Like the JS <code>failBuild</code> macro.</p>
<pre><code class="language-hbs">{{#if (macroCondition (macroDependencySatisfies &quot;some-peer-dep&quot; &quot;^3.0.0&quot;)) }}
  &lt;UseTheThing /&gt;
{{else}}
  {{macroFailBuild &quot;You tried to use &lt;MyFancyComponent/&gt; but it requires some-peer-dep ^3.0.0&quot;}}
{{/if}}
</code></pre>
<h3 id="macros-overall-design"><a class="header" href="#macros-overall-design">Macros: Overall Design</a></h3>
<p>All the macros are intended to be valid syntax. They shouldn't break parsing or linting.</p>
<p>While we guarantee that branch elimination will run in production builds, we <em>don't</em> guarantee that in development. The macros are designed so that in development they may have <em>runtime</em> implementations. This is powerful because it lets us produce a single build that works in multiple contexts. For example:</p>
<ul>
<li>
<p>it solves the longstanding problem that when you run your tests by visiting <code>localhost:4200/tests</code> the tests see the <code>development</code> environment, not the <code>test</code> environment. To get the test environment you can't use <code>ember serve</code>, you must use <code>ember test</code>. This has remained unfixed because it's expensive to do the whole build twice for the two environments.</p>
<p>We can solve this problem by producing a <em>single</em> build containing <em>both</em> environments, guarded by the macro system. The macros can evaluate at runtime, allowing each environment to get the right thing. In production builds, test-only or dev-only branches will still be eliminated.</p>
</li>
<li>
<p>it makes Fastboot builds simpler because we can guard the fastboot-only and browser-only code with the macro system. In development, we can run a single build that leaves both branches in and evaluates the macros at runtime.</p>
</li>
</ul>
<p>The macros package (<code>@ember/macros</code> as proposed, <code>@embroider/macros</code> as implemented) will work in both regular ember-cli and in Embroider. And it will work in both V1 and V2 packages.</p>
<h2 id="peer-dependencies"><a class="header" href="#peer-dependencies">Peer Dependencies</a></h2>
<p>V2 packages can only resolve their <strong>allowed dependencies</strong>. This is fundamental rule that we can't break if we want the broadest compatibility with NPM and future compatibility with other strict systems such as <a href="https://github.com/yarnpkg/rfcs/pull/101">Yarn PnP</a>. Node often allows you to resolve things that are not <strong>allowed dependencies</strong> due to hoisting optimizations. But this is not safe or guaranteed, so we forbid relying on it.</p>
<p>This means that many things addons will try to access from their surrounding environment will need to be listed as <code>peerDependencies</code>. For example, addons that want to import <code>ember-data</code> should list <code>ember-data</code> as a <code>peerDependency</code>, so the app can control the <code>ember-data</code> version and the addon is guaranteed to resolve the same copy.</p>
<p>This also applies recursively -- if your addon wants to use an addon that needs <code>ember-data</code>, your addon should also list <code>ember-data</code> as a <code>peerDependency</code>. The clearest documented description of how recursive peerDependencies should work is in the <a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-plug-an-play.md#c-formal-plugnplay-guarantees">Yarn PnP Formal Guarantees</a>.</p>
<p><code>ember-source</code> provides many &quot;virtual&quot; packages like <code>@ember/component</code>. If they were real packages, they would be <code>peerDependencies</code>, but having non-real packages in package.json is likely to result in errors. Pedantically, they can be listed in <strong>externals</strong> instead. In practice, they are a well-known set that we can always handle correctly automatically, so it's not very important whether an addon includes them in <strong>externals</strong>.</p>
<h3 id="optional-peer-dependencies"><a class="header" href="#optional-peer-dependencies">Optional Peer Dependencies</a></h3>
<p>Some addons optionally use another addon if it happens to be available in the app. In order to resolve such a dependency, we really need <strong>Optional Peer Dependencies</strong>.</p>
<p>NPM doesn't have a concept of optional peer dependencies. It has &quot;optional dependencies&quot;, but they are something different and pretty useless.</p>
<p>Yarn did an <a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-optional-peer-dependencies.md">RFC for optional peer dependency support</a>. It is basically compatible with NPM, with the only caveat being that if you use NPM you may see a spurious warning at install time. As non-actionable peerDependency warnings are rife throughout the NPM ecosystem this doesn't seem like a big deal.</p>
<p>V2 Packages are allowed to use optional peer dependencies as described in the Yarn RFC.</p>
<p>Our own tooling, like ember-cli-dependency-checker, we can make sure the warnings respect the Yarn standard.</p>
<h2 id="apps-as-v2-packages"><a class="header" href="#apps-as-v2-packages">Apps as V2 Packages</a></h2>
<p>This RFC is focused heavily on addons, because that is the area that is most critical to standardize. Publishing addons to NPM in V2 format has major benefits:</p>
<ul>
<li>build performance: there is much less work to do at app build time, and many <code>dependencies</code> of addons can become <code>devDependencies</code> of addons, resulting in smaller <code>node_modules</code> and faster <code>npm install</code>.</li>
<li>tool integration: VSCode, Typescript, SCSS, etc will all understand your code better when the dependencies are in V2 format. Things like &quot;jump-to-definition&quot; will work.</li>
<li>Embroider stability: <code>@embroider/compat</code> needs to use heuristics and some addon-specific rules to compile V1 addons into V2. This is necessarily more fragile than having addons published natively in V2. The first step in stabilizing Embroider for mainstream adoption is standardizing on this new addon format.</li>
</ul>
<p>In contrast, apps are not published to NPM. So where would they use V2 publication format?</p>
<p>During the build process for an app, it will first build from its authoring format <em>to the standard v2 package format</em>. At that point, the whole project is just a collection of standard v2 packages with well-defined semantics, and we can confidently treat that stage in the build pipeline as supported public API.</p>
<p>The benefit of this approach is that we can separately evolve authoring formats and last-stage packaging tools, while keeping a stable interface between them. The stable interface is designed to leverage general-purpose ECMA-spec-compliant features wherever practical, which makes it a rich target. For more detail on Embroider's three-stage build pipeline see <a href="https://github.com/embroider-build/embroider/blob/f5181d0d7eab146fd0dfcafdff552ee4fc129f2a/README.md#embroider-a-modern-build-system-for-emberjs-apps">the README</a>.</p>
<p>v2-formatted apps do differ in a few ways from v2-formatted addon, as described in the following sections.</p>
<h3 id="features-that-apps-may-not-use"><a class="header" href="#features-that-apps-may-not-use">Features that Apps May Not Use</a></h3>
<p>Several features in the v2 addon format are designed to be consumed <em>by the app</em>. These features aren’t appropriate in an app, because that is the end of the line — a v2-formatted app should be understandable by general-purpose Javascript tooling and have very little <em>implicit</em> Ember-specific build semantics left.</p>
<p>Features that apps may not use include:</p>
<ul>
<li>the <code>implicit-*</code> keys in <strong>Ember package metadata</strong>.</li>
<li>the <code>app-js</code> key in <strong>Ember package metadata</strong></li>
<li>the <code>build</code> key in <strong>Ember package metadata</strong>. We should consider updating the <em>authoring</em> format so that apps can use a build file with the standard package hooks, because that makes a lot of sense. But it’s not appropriate in the v2 format (which is a <em>publication</em> format), and this change can be a separate RFC, and it will be an easier RFC after landing this one.</li>
<li>automatic inclusion of resolvable types (components, services, etc) from the <strong>Own Javascript</strong> of all <strong>Active Dependencies</strong> and the app itself.</li>
<li>the <code>public-assets</code> key in <strong>Ember package metadata</strong>.</li>
</ul>
<p>All these features can appear in v2 <em>addons</em>, and the <em>app</em> ensures each one is represented by standards-compliant Javascript within the app’s own code. To illustrate with some examples, the V2 format for an app (as already implemented in Embroider) includes:</p>
<ul>
<li><code>&lt;script&gt;</code> tag(s) in index.html and tests/index.html that ensure <code>implicit-scripts</code> and <code>implicit-test-scripts</code> of all active addons are already accounted for.</li>
<li><code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> tag(s) in index.html and tests/index.html that ensure <code>implicit-styles</code> and <code>implicit-test-styles</code> are accounted for.</li>
<li>actual Javascript <code>import</code> statements within the app's code that ensure <code>implicit-modules</code> and <code>implicit-test-modules</code> are accounted for</li>
<li>actual Javascript <code>import</code> statements and AMD <code>define</code> calls that handle automatic inclusion of resolvable types that cannot be statically ruled out.</li>
</ul>
<h2 id="features-that-only-apps-may-use"><a class="header" href="#features-that-only-apps-may-use">Features that only Apps may use</a></h2>
<p>There are also a few V2 package features only supported in apps. These are mostly of interest only to people working within ember-cli and/or embroider to implement new packaging tools. Each of these is a property in <strong>Ember package metadata</strong>:</p>
<ul>
<li>
<p><code>rootURL</code>: has the same meaning as <code>rootURL</code> in <code>config/environment.js</code> in a standard Ember app.</p>
</li>
<li>
<p><code>assets</code>: a list of relative paths to files. The intent of <code>assets</code> is that it declares that each file in the list must result in a valid URL in the final app.</p>
<p>The most important assets are HTML files. All <code>contentFor</code> has already been applied to them. (Remember, we’re talking about the publication format that can be handed to the final stage packager, not necessarily the authoring format.) It is the job of the final stage packager to examine each asset HTML file and decide how to package up all its included assets in a correct and optimal way, emitting a final result HTML file that is rewritten to include the packaged assets.</p>
<p>Note that packagers must respect the HTML semantics of <code>&lt;script type=&quot;module&quot;&gt;</code> vs <code>&lt;script&gt;</code> vs <code>&lt;script async&gt;</code>. For example: don’t go looking for <code>import</code> in <code>&lt;script&gt;</code>, it’s only correct in <code>&lt;script type=&quot;module&quot;&gt;</code></p>
<p>File types other than HTML are allowed to appear in <code>&quot;assets&quot;</code>. The intent is the same (it means these files must end up in the final build such that they’re addressable by URLs). For example, a Javascript file in <code>&quot;assets&quot;</code> implies that you want that JS file to be addressable in the final app (and we will treat it as a script, not a module, because this is for foreign JS that isn’t going through the typical build system. If you actually want a separate JS file as output of your build, use <code>import()</code> instead). This is a catch-all that allows things like your <code>/public</code> folder full of arbitrary files to pass through the final stage packager.</p>
<p>A conventional app will have an <code>&quot;assets&quot;</code> list that include <code>index.html</code>, <code>tests/index.html</code>, and all the files that were copied from <code>/public</code>.</p>
</li>
<li>
<p><code>template-compiler.filename</code>: the relative path to a module that is capable of compiling all the templates. The module exports :</p>
<ul>
<li><code>compile: (moduleName: string, templateContents: string) =&gt; string</code> that converts templates into JS modules.</li>
</ul>
</li>
<li>
<p><code>template-compiler.isParallelSafe</code>: true if the template compiler can be used in other node processes</p>
</li>
<li>
<p><code>babel.filename</code>: the relative path to a module that exports the app's babel config.</p>
</li>
<li>
<p><code>babel.isParallelSafe</code>: true if the <code>babel</code> settings can be used in a new node process.</p>
</li>
<li>
<p><code>babel.majorVersion</code>: the version of babel the app's settings were written for. Only 6 and 7 are supported at this time.</p>
</li>
</ul>
<p>Unlike addons, an app’s <strong>Own Javascript</strong> is not limited to only ES latest features. It’s allowed to use any features that work with the config in <code>babel.filename</code>. This is an optimization — we <em>could</em> logically require apps to follow the same rule as addons and compile down to ES latest before handing off to a final packager. But the final packager is going to run babel anyway, so we allow apps to do all their transpilation in that final single pass.</p>
<h2 id="ember-language-standard"><a class="header" href="#ember-language-standard">Ember Language Standard</a></h2>
<p>This RFC introduces the idea of <code>Ember Language Standard</code> as a way to be explicit about exactly what Javascript dialect we support in shared packages, and exactly what extensions to Javascript are required to understand the complete semantics of Ember apps.</p>
<p>As of this writing, Ember language standard contains the following subset of ECMAScript:</p>
<ul>
<li>all of ECMAScript 2019
<ul>
<li>with the caveat that if you use un-transpile-able features (like <code>Proxy</code>) that aren't supported in all browsers that Ember supports, your package won't support those browsers</li>
</ul>
</li>
<li><a href="https://github.com/tc39/proposal-decorators">decorators proposal</a> currently in TC39 stage 2.</li>
<li><a href="https://github.com/tc39/proposal-optional-chaining">Optional Chaining</a> and <a href="https://github.com/tc39/proposal-nullish-coalescing">Nullish Coalescing</a>, which are stage 4 (completed) proposals slated for inclusion in es2020.</li>
<li>A subset of <a href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a>, a stage 4 (completed) proposal slated for inclusion in es2020, as detailed below.</li>
</ul>
<p>We also incorporate the following extensions to Javascript. Our intent here is that this is the minimal set of things that aren't really expressible, even in principle, using Javascript itself:</p>
<ul>
<li>
<p>handlebars templates may be imported as if they were ES modules. You get back an ES module with a default export containing an opaque value representing the compiled template. The only public-API for <em>consuming</em> the opaque value you get back is to pass it to Ember's <code>setComponentTemplate()</code> or set it as the <code>layout</code> property on an <code>Ember.Component</code>. The <code>.hbs</code> extension has lower priority than <code>.js</code>, so <code>import './foo'</code> will favor <code>./foo.js</code> over <code>./foo.hbs</code>.</p>
</li>
<li>
<p>CSS files may be imported as if they were ES modules. The <code>.css</code> extension is mandatory, unlike <code>.js</code> and <code>.hbs</code> it is never automatically inferred. We define <em>no exported value</em>. The meaning is: if you import a CSS file, the CSS file is guaranteed to be in the DOM before your module evaluates.</p>
<p>The reason we define no exported value is that it's not clear we want to commit to one long-term standard. By not giving CSS a value in JS, we reserve the right to do so in the future if a web standard emerges. Users who want imported CSS to return a value are free to compile their CSS to actual JS modules <em>before</em> publishing their package.</p>
</li>
<li>
<p>JSON files may be imported as if they were ES modules. This is supported in Node and it's enabled by default in popular Javascript bundlers like Webpack, so it's common to encounter code on NPM that expects it to work. We interpret JSON as an ECMA module whose <code>default</code> export is the JSON object.</p>
</li>
</ul>
<h3 id="supported-subset-of-dynamic-import-syntax"><a class="header" href="#supported-subset-of-dynamic-import-syntax">Supported subset of dynamic import syntax</a></h3>
<p><a href="https://github.com/tc39/proposal-dynamic-import">Dynamic import</a> aka <code>import()</code> is supported. However, we choose to support only a subset of possible syntax inside <code>import()</code>. Since we're choosing a strict subset, we can safely expand it later as needed.</p>
<p>First we'll illustrate by examples:</p>
<pre><code class="language-js">// ALLOWED: string literal
import(&quot;./some-module&quot;)

// ALLOWED: template string with a static prefix containing
// a relative path
import(`./locale/${currentLocale}/messages`);

// ALLOWED: template string with a static prefix containing
// a complete package name
import(`some-package/${feature}`);

// ALLOWED: template string with a static prefix that clearly
// contains an absolute URL.
import(`https://example.com/components/${choice}`);

// FORBIDDEN: any syntax that is not a string literal or template string
import(arbitraryExpression());

// FORBIDDEN: template string that does not uniquely identify a package
import(`@ember/${which}`);
</code></pre>
<p>To be more precise, the only supported syntax inside <code>import()</code> is:</p>
<ul>
<li>a string-literal</li>
<li>or a template string that begins with a static prefix which falls into one of these allowed cases:
<ul>
<li>the static prefix matches <code>/(\w+:)?\/\//</code>
<ul>
<li>this detects absolute URLs, both ones with protocols (starting with <code>http://</code>) and ones that are protocol-relative (starting with <code>//</code>).</li>
<li>in this case, Embroider will leave your <code>import()</code> alone so you can access the browser's implementation of <code>import()</code>. You are responsible for the contents of the URL, it is beyond the scope of the Embroider build.</li>
</ul>
</li>
<li>the static prefix starts with <code>@</code> and contains at least two <code>/</code>
<ul>
<li>this detects a namespaced NPM package name. If the package can't be resolved or it contains zero files that match your pattern, we emit a static build error.</li>
</ul>
</li>
<li>the static prefix does not start with <code>@</code> and contains at least one <code>/</code>
<ul>
<li>this covers patterns that start with a non-namespaced NPM package names or a relative path. If the pattern matches zero files, we emit a static build error.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Any other syntax is a static build error.</p>
<p>The rationale for this chosen subset is that we want it to be possible to introduced <em>controlled</em>, <em>intentional</em> dynamism, without accidentally blowing holes in the static analysis of whole programs. For example, if we simply allowed any non-statically-resolvable module specifier to silently become a runtime <code>import()</code>, it would mask many bugs that would otherwise be caught statically at build time. You can opt-in to fully-dynamic runtime <code>import()</code>, but you need to say so in a way that is statically legible so we can distinguish it from accidents.</p>
<h2 id="compatibility-strategy"><a class="header" href="#compatibility-strategy">Compatibility Strategy</a></h2>
<p>The <code>@embroider/compat</code> package exists to compile V1 packages to V2. This allows <code>@embroider/core</code> to always assume V2 packages as input, so we don't need to wait until every addon is natively available in V2 before we start getting the benefits of Embroider. However, there is still an incentive to convert as many addons as possible to V2, because they build faster and they will be more stable (the v1-to-v2 compilation isn't flawless, we need heuristics and package-specific rules to deal with some dynamic addon behaviors).</p>
<p>It also needs to be possible for an addon published as V2 to work in existing apps on existing ember-cli versions. This is enabled by:</p>
<ul>
<li><code>ember-auto-import</code>, which serves as a high-fidelity polyfill for importing directly from NPM. V2 addons natively support importing from NPM, but they should depend on <code>ember-auto-import</code> so those imports will have the same meaning when used in classic ember-cli.</li>
<li><code>@ember/macros</code>, which shall provide correct semantics regardless of whether the package using them is published as V1 or V2 and regardless of whether the build is being done by classic ember-cli or Embroider. Native V2 packages under Embroider can alway use macros, without an explicit dependency on <code>@ember/macros</code>, but they should include the dependency so that macros will work in classic ember-cli.</li>
<li>ember-cli already supports a <code>main</code> property in under <code>ember-addon</code> and has supported it for many versions. This allows an addon to put its classic <code>index.js</code> file in a place other than the package's true <code>main</code>. This means that V2 addons can have their runtime <code>index.js</code> as <code>main</code>, and should point <code>ember-addon.main</code> to a <code>classic.js</code> file. The <code>classic.js</code> file should <code>require</code> and <code>export</code> a compatibility shim library that we will provide. The compatibility shim will have the classic methods like <code>treeForAddon</code>, <code>treeForPublic</code> that take the V2-formatted features and present them in a way that classic ember-cli will understand. Since V2 packages are much more static than V1 packages, this shim is expected to not be very complicated.</li>
</ul>
<h1 id="how-we-teach-this"><a class="header" href="#how-we-teach-this">How we Teach This</a></h1>
<p>This RFC should have no direct impact on what app authors need to learn. They keep using addons the same way they always have. Future RFCs that take Embroider mainstream <em>will</em> have impact, but that can be discussed then.</p>
<p>The impact on addon authors is more significant. This design is fully backward compatible, and the intention is that all existing addons continue to work (some with worse compatibility hacks than others in the v1-to-v2 compiler). But there will be a demand for addons published in v2 format, since it is expected to result in faster build times. My prediction is that people who are motivated to get their own app build times down will send a lot of PRs to the addons they’re using.</p>
<p>In many cases, converting addons to v2 makes them simpler. For example, today many addons use custom broccoli code to wrap third-party libraries in a fastboot guard that prevents the libraries from trying to load in Node (where they presumably don’t work). In v2, they can drop all that custom build-time code in favor of a macro-guarded <code>importSync</code>.</p>
<p>This design does <em>not</em> advocate loudly deprecating any v1 addon features. Doing that all at once would be unnecessarily disruptive. I would rather rely on the carrot of faster builds and Embroider stability than the stick of deprecation warnings. We can choose to deprecate v1 features in stages at a later time.</p>
<p>We should release an officially-supported package (tentatively named <code>@embroider/addon</code>) that provides tooling for addon authors who want to publish a V2 package that is backward compatible in non-embroider apps. This package's documentation is a natural starting point for teaching developers what to do.</p>
<h1 id="alternative-designs"><a class="header" href="#alternative-designs">Alternative Designs</a></h1>
<p>Embroider effectively supersedes both the <a href="https://github.com/ember-cli/rfcs/blob/master/active/0051-packaging.md">Packager RFC</a> and the <a href="https://github.com/ember-cli/rfcs/pull/118">Prebuilt Addons RFC</a>. So both of those are alternatives to this one.</p>
<p>Packager creates an escape hatch from the existing ember-cli build that is supposed to provide a foundation for many of the same features enabled by this design. The intention was correct, but in my opinion it tries to decompose the build along the wrong abstraction boundaries. It follows the existing pattern within ember-cli of decomposing the build by feature (all app javascript, all addon javascript, all templates, etc) rather than by package (everything from the app, everything from ember-data, everything from ember-power-select, etc), which puts it into direct conflict with the Prebuilt Addons RFC.</p>
<p>The API that packager provides is also incomplete compared with this design. For example, to take the packager output and build it using Webpack, Rollup, or Parcel still requires a significant amount of custom code. Whereas taking a collection of v2 formatted Ember packages and building them with any of those tools requires very little Ember-specific code.</p>
<p>The prebuilt addons RFC addresses build performance by doing the same kind of work-moving as this design. Addons can do much of their building up front, thus saving time when apps are building. But it only achieves a speedup when apps happen to be using the same build options that addons authors happened to publish. This design takes a different approach that preserves complete freedom for app authors to postprocess all addon Javascript, including dead-code-elimination based on the addon features their app is using. The prebuilt addons RFC also doesn’t attempt to specify the contents of the prebuilt trees — it just accepts the current implementation-defined contents. This is problematic because shared builds artifacts are long-lived, so it’s worth trying to align them with very general, spec-compliant semantics.</p>
<h1 id="supporting-references"><a class="header" href="#supporting-references">Supporting References</a></h1>
<ul>
<li>
<p>There is a <a href="https://github.com/embroider-build/embroider/blob/master/SPEC.md">SPEC draft</a> in the Embroider repo that predates this one, but covers a broader scope. Where this document contradicts SPEC.md, this document takes precedence and SPEC.md needs to be updated. But SPEC.md covers a broader scope, including the disposition of the other build hooks that will be handled in future RFCs.</p>
</li>
<li>
<p>The definitive list of <strong>Ember package metadata</strong> fields is declared in <a href="https://github.com/embroider-build/embroider/blob/master/packages/core/src/metadata.ts">AppMeta and AddonMeta interfaces</a>. Each one is documented in an <a href="https://github.com/embroider-build/embroider/blob/master/SPEC.md#appendix-list-of-ember-package-metadata-fields">Appendix in SPEC.md</a>.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="0496-handlebars-strict-mode.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="0519-2019-2020-roadmap.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="0496-handlebars-strict-mode.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="0519-2019-2020-roadmap.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
