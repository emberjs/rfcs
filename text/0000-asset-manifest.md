- Start Date: 2016-07-17
- RFC PR: [emberjs/rfcs#153](https://github.com/emberjs/rfcs/pull/153)
- Ember Issue: (leave this empty)

# Summary

The Asset Manifest is a JSON specification to describe assets and bundles of assets that can be loaded into an Ember application asynchronously at runtime.

This is a corollary to a forthcoming Asset Loader service which will handle the asynchronous loading of application assets.

# Motivation

The primary motivation for defining an Ember Asset Manifest specification is to enable [lazy-loading of Engines](https://github.com/emberjs/rfcs/blob/master/text/0010-engines.md#lazy-loading-manifests). Beyond that it can also be used for any piece-wise loading strategy of assets into an Ember application at runtime.

## Goals

- Define an interface for specifying where to load an asset needed for an application at runtime.
- Allow asset URIs to be fingerprinted for caching reasons.
- Allow compositional loading of assets for future application segmentation.
- Ensure flexibility for consumers.

## Secondary / Related Goals

- Keep the API of the forthcoming Asset Loader service simple.
- Enable the prevention of duplicate requests for assets.

# Detailed Design

The default Asset Manifest generated by Ember-CLI will be a new file: `asset-manifest.json`. Creating a standalone file, as opposed to an inline config or sub-section of another file, allows easy manipulation via additional build plugins (such as `broccoli-asset-rev`) and gives flexibility in how the contents are used. This file will by default, though optionally, be inserted into an application's `index.html`, similarly to how `config/environment` is done today.

At the core of the manifest is the idea of a "bundle" which is simply a collection of assets intended to be loaded together. Each bundle is associated with a "name" that represents the field it is under in the `bundles` property of the manifest. Even though `bundles` will be the only top-level field of the manifest in the first iteration, having the additional object layer will allow us to expand the manifest to include additional information in the future.

Bundles enable easy loading of lazy Engines at runtime, since Engine names can and should be used as bundle names. Therefore, regardless of aliasing, we should always load an Engine's assets according to its package name and not its mounted path.

Using bundle names will make it easier to avoid duplicate loading of sets ofassets and ensures we can support multiple inclusion of the same bundle without duplicating load. Additionally, referencing bundles via a name rather than route path decouples asset loading from the routing behavior.

Each bundle will have two primary fields: `assets` and `dependencies`.

`assets` is an array of asset objects, which specify a `uri` and `type` for an asset to be loaded. The asset objects are to be sorted according to load order as determined via the generator of the manifest. This is important for assets such as `vendor.js` which need to be loaded before other assets like `app.js`.

Since load order should be static, this should be determined at build time so that the runtime behavior can be a simple iteration over the provided array. It will be up to the implementation of the Asset Loader service to guarantee load actually occurs in order.

The `asset` interface could be expanded in the future to include additional metadata if needed, such as if two assets can be downloaded in parallel.

It should be noted that the generated `asset-manifest.json` will default to not including static assets in the `public` directory of Ember-CLI applications. Those assets are usually loaded on-demand and are not necessary to load with runtime assets, such as scripts and styles.

`dependencies` is an array of names of additional bundles whose resources also need to be loaded in order for the bundle to work. While this probably won't be leveraged in the initial Lazy-Loading Engine work, it provides the ability to have more fine-grained control of asset loading in the future while retaining existing benefits.

The Asset Loader should load dependencies prior to loading the assets of the given bundle.

Given this design, the Asset Loader API should then be based around the idea of "bundles" and "assets" which should keep the API simple (e.g., `loadBundle`, `loadAsset`, etc.).

## Overrides & Customization

As mentioned above, the generated `asset-manifest.json` can be customized via additional build plugins. There are no limitations on what can be done in that regard, though the generated output should follow the interfaces described here.

It should also be possible to provide more than one Asset Manifest to allow runtime extensibility of the manifest. However, this exact behavior will be per the API of the Asset Loader Service.

## Asset & Bundle Interfaces

The above design can be expressed through a couple interfaces as follows:

```ts
type BundleName = string;

interface Asset {
  type: String,
  uri: String
}

interface Bundle {
  assets: Array<Asset>,
  dependencies?: Array<BundleName>
}

interface AssetManifest {
  bundles: Map<BundleName, Bundle>
}
```

Note: `Map` in the above can be implemented as a standard JS object.

## Asset URIs

Asset URIs will be constructed similarly to the asset URIs you find in your `index.html` as most assets will be inserted into the DOM in a similar fashion as those that are available upon page load.

The format of the asset URIs will be determined by the build process. They will, for example, take into account the `rootURL` of the host application. Additionally, tools such as `broccoli-asset-rev` will be assessed to ensure they have proper ability to modify the generated URIs for fingerprinting or other modifications, such as CDN prefix insertion.

The following examples of URIs should not be taken as a set standard.

## Example

```json
// asset-manifest.json
{
  "bundles": {
    "blog": {
      "assets": [
        {
          "uri": "/assets/blog/vendor-gqjszdtdmxhjuvcu.js",
          "type": "js"
        },
        {
          "uri": "/assets/blog/engine-n92evcv0clnc1hi7.js",
          "type": "js"
        },
        {
          "uri": "/assets/blog/vendor-pdkli3mxhsfqn695.css",
          "type": "css"
        },
        {
          "uri": "/assets/blog/engine-7mykz5k5v1ljnw3f.css",
          "type": "css"
        }
      ],
      "dependencies": [
        "shared-components"
      ]
    },

    "shared-components": {
      "assets": [
        {
          "uri": "/assets/shared-components/vendor-xw6m3aj4u4eyfxt1.js",
          "type": "js"
        },
        {
          "uri": "/assets/shared-components/vendor-ivxyhmmkis3wobht.css",
          "type": "css"
        }
      ]
    }
  }
}
```

# How We Teach This

The Asset Manifest should be generated at build time by Ember-CLI and consumed automatically by the Asset Loader service during runtime. Due to this, it is likely that many developers will never need to interact with the asset manifest directly.

However, the core concepts of defining assets and bundles and how they are loaded should be introduced and taught alongside Engines as they are the first and primary use case for this construct. This should only affect advanced users that are exploring the possibility of using lazily loaded Engines.

# Drawbacks

- Adds an additional element to consider in an Ember Application's build and runtime for advanced use cases
- Complex manifests can result in additional file weight, due to extra nesting

# Alternatives

## [Multiple Meta Modules](https://github.com/ember-cli/ember-cli/pull/5582https://github.com/ember-cli/ember-cli/pull/5582)

An alternative to the above approach is to allow each bundle to be loaded as part of the config module from each engine, a separate "meta module" if you will.  These modules would then need to be assembled by a config loader.

In this approach the primary app manifest could look like:

```json
{
  "configs": [
    "blog",
    "chat"
  ],

  "bundles": {
    "shared-components": {
      "assets": [
        {
          "uri": "/assets/shared-components/vendor-xw6m3aj4u4eyfxt1.js",
          "type": "js"
        },
        {
          "uri": "/assets/shared-components/vendor-ivxyhmmkis3wobht.css",
          "type": "css"
        }
      ]
    }
  }
}
```

The `configs` field will represent additional configs that need to be integrated into the primary config. These will be looked up according to the standard convention of `<name>/asset-manifest`.

Each config will still have the possibility of a `bundles` field for those bundles that are not associated with a config. This is primarily for a future state where we might enable piecewise loading of assets.

The primary benefit to this approach is that the asset information for each Engine will be associated with its actual modules.

The drawback to this approach, however, is additional runtime overhead in parsing the multiple configs and increased complexity for both build and runtime systems.

# Unresolved Questions

- Single Vs. Multiple Configs
