<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0001-transform-attribute-meta-parameter.html">0001-transform-attribute-meta-parameter</a></li><li class="chapter-item expanded "><a href="0003-block-params.html">0003-block-params</a></li><li class="chapter-item expanded "><a href="0003-cli-ember-doctor.html">0003-cli-ember-doctor</a></li><li class="chapter-item expanded "><a href="0010-engines.html">0010-engines</a></li><li class="chapter-item expanded "><a href="0011-improved-cp-syntax.html">0011-improved-cp-syntax</a></li><li class="chapter-item expanded "><a href="0012-help-json-output.html">0012-help-json-output</a></li><li class="chapter-item expanded "><a href="0015-the-road-to-ember-2-0.html">0015-the-road-to-ember-2-0</a></li><li class="chapter-item expanded "><a href="0020-sri-default.html">0020-sri-default</a></li><li class="chapter-item expanded "><a href="0023-command-line-completion.html">0023-command-line-completion</a></li><li class="chapter-item expanded "><a href="0024-bound-attributes.html">0024-bound-attributes</a></li><li class="chapter-item expanded "><a href="0028-app-import-output-file.html">0028-app-import-output-file</a></li><li class="chapter-item expanded "><a href="0029-addon-black-and-whitelist-for-apps.html">0029-addon-black-and-whitelist-for-apps</a></li><li class="chapter-item expanded "><a href="0045-internet-explorer.html">0045-internet-explorer</a></li><li class="chapter-item expanded "><a href="0046-cli-improved-release-process.html">0046-cli-improved-release-process</a></li><li class="chapter-item expanded "><a href="0046-registry-reform.html">0046-registry-reform</a></li><li class="chapter-item expanded "><a href="0050-cli-production-code-stripping.html">0050-cli-production-code-stripping</a></li><li class="chapter-item expanded "><a href="0050-improved-actions.html">0050-improved-actions</a></li><li class="chapter-item expanded "><a href="0053-helpers.html">0053-helpers</a></li><li class="chapter-item expanded "><a href="0055-anonymous-amd.html">0055-anonymous-amd</a></li><li class="chapter-item expanded "><a href="0056-improved-release-cycle.html">0056-improved-release-cycle</a></li><li class="chapter-item expanded "><a href="0057-ember-data-reference-unification.html">0057-ember-data-reference-unification</a></li><li class="chapter-item expanded "><a href="0058-helper-listing.html">0058-helper-listing</a></li><li class="chapter-item expanded "><a href="0061-ember-data-background-fetch.html">0061-ember-data-background-fetch</a></li><li class="chapter-item expanded "><a href="0064-contextual-component-lookup.html">0064-contextual-component-lookup</a></li><li class="chapter-item expanded "><a href="0065-deprecation-warning-handlers.html">0065-deprecation-warning-handlers</a></li><li class="chapter-item expanded "><a href="0080-serve-file-api.html">0080-serve-file-api</a></li><li class="chapter-item expanded "><a href="0086-firefox-in-ci.html">0086-firefox-in-ci</a></li><li class="chapter-item expanded "><a href="0090-addon-tree-caching.html">0090-addon-tree-caching</a></li><li class="chapter-item expanded "><a href="0091-cli-addon-instrumentation-experimental-hooks.html">0091-cli-addon-instrumentation-experimental-hooks</a></li><li class="chapter-item expanded "><a href="0091-weakmap.html">0091-weakmap</a></li><li class="chapter-item expanded "><a href="0092-blueprint-remove-old-files.html">0092-blueprint-remove-old-files</a></li><li class="chapter-item expanded "><a href="0095-cli-standardise-targets.html">0095-cli-standardise-targets</a></li><li class="chapter-item expanded "><a href="0095-router-service.html">0095-router-service</a></li><li class="chapter-item expanded "><a href="0096-enable-yarn-usage.html">0096-enable-yarn-usage</a></li><li class="chapter-item expanded "><a href="0101-ember-data-friendly-errors.html">0101-ember-data-friendly-errors</a></li><li class="chapter-item expanded "><a href="0105-addons-optionalDependencies.html">0105-addons-optionalDependencies</a></li><li class="chapter-item expanded "><a href="0108-add-custom-transform.html">0108-add-custom-transform</a></li><li class="chapter-item expanded "><a href="0110-packaging.html">0110-packaging</a></li><li class="chapter-item expanded "><a href="0114-add-template-lint-addon.html">0114-add-template-lint-addon</a></li><li class="chapter-item expanded "><a href="0116-qunit-dom.html">0116-qunit-dom</a></li><li class="chapter-item expanded "><a href="0120-cli-guides.html">0120-cli-guides</a></li><li class="chapter-item expanded "><a href="0120-route-serializers.html">0120-route-serializers</a></li><li class="chapter-item expanded "><a href="0121-remove-ember-cli-eslint.html">0121-remove-ember-cli-eslint</a></li><li class="chapter-item expanded "><a href="0136-contains-to-includes.html">0136-contains-to-includes</a></li><li class="chapter-item expanded "><a href="0139-isHtmlSafe.html">0139-isHtmlSafe</a></li><li class="chapter-item expanded "><a href="0143-module-unification.html">0143-module-unification</a></li><li class="chapter-item expanded "><a href="0150-factory-for.html">0150-factory-for</a></li><li class="chapter-item expanded "><a href="0176-javascript-module-api.html">0176-javascript-module-api</a></li><li class="chapter-item expanded "><a href="0178-deprecate-ember-k.html">0178-deprecate-ember-k</a></li><li class="chapter-item expanded "><a href="0181-deprecate-ember-data-initializers.html">0181-deprecate-ember-data-initializers</a></li><li class="chapter-item expanded "><a href="0186-track-unique-history-location-state.html">0186-track-unique-history-location-state</a></li><li class="chapter-item expanded "><a href="0191-deprecate-component-lifecycle-hook-args.html">0191-deprecate-component-lifecycle-hook-args</a></li><li class="chapter-item expanded "><a href="0194-deprecate-custom-event-manager.html">0194-deprecate-custom-event-manager</a></li><li class="chapter-item expanded "><a href="0213-custom-components.html">0213-custom-components</a></li><li class="chapter-item expanded "><a href="0225-ember-engines-mount-params.html">0225-ember-engines-mount-params</a></li><li class="chapter-item expanded "><a href="0226-named-blocks.html">0226-named-blocks</a></li><li class="chapter-item expanded "><a href="0229-deprecate-testing-restricted-resolver.html">0229-deprecate-testing-restricted-resolver</a></li><li class="chapter-item expanded "><a href="0232-simplify-qunit-testing-api.html">0232-simplify-qunit-testing-api</a></li><li class="chapter-item expanded "><a href="0236-deprecation-ember-string.html">0236-deprecation-ember-string</a></li><li class="chapter-item expanded "><a href="0237-deprecation-ember-map.html">0237-deprecation-ember-map</a></li><li class="chapter-item expanded "><a href="0240-es-classes.html">0240-es-classes</a></li><li class="chapter-item expanded "><a href="0252-browser-support-changes.html">0252-browser-support-changes</a></li><li class="chapter-item expanded "><a href="0268-acceptance-testing-refactor.html">0268-acceptance-testing-refactor</a></li><li class="chapter-item expanded "><a href="0272-deprecation-native-function-prototype-extensions.html">0272-deprecation-native-function-prototype-extensions</a></li><li class="chapter-item expanded "><a href="0276-named-args.html">0276-named-args</a></li><li class="chapter-item expanded "><a href="0278-template-only-components.html">0278-template-only-components</a></li><li class="chapter-item expanded "><a href="0280-remove-application-wrapper.html">0280-remove-application-wrapper</a></li><li class="chapter-item expanded "><a href="0281-es5-getters.html">0281-es5-getters</a></li><li class="chapter-item expanded "><a href="0286-block-let-template-helper.html">0286-block-let-template-helper</a></li><li class="chapter-item expanded "><a href="0287-promote-in-element-to-public-api.html">0287-promote-in-element-to-public-api</a></li><li class="chapter-item expanded "><a href="0293-record-data.html">0293-record-data</a></li><li class="chapter-item expanded "><a href="0294-optional-jquery.html">0294-optional-jquery</a></li><li class="chapter-item expanded "><a href="0297-deprecate-ember-logger.html">0297-deprecate-ember-logger</a></li><li class="chapter-item expanded "><a href="0300-rfc-process-update.html">0300-rfc-process-update</a></li><li class="chapter-item expanded "><a href="0308-deprecate-property-lookup-fallback.html">0308-deprecate-property-lookup-fallback</a></li><li class="chapter-item expanded "><a href="0311-angle-bracket-invocation.html">0311-angle-bracket-invocation</a></li><li class="chapter-item expanded "><a href="0318-array-helper.html">0318-array-helper</a></li><li class="chapter-item expanded "><a href="0322-deprecate-copy-copyable.html">0322-deprecate-copy-copyable</a></li><li class="chapter-item expanded "><a href="0324-deprecate-component-isvisible.html">0324-deprecate-component-isvisible</a></li><li class="chapter-item expanded "><a href="0326-ember-data-filter-deprecation.html">0326-ember-data-filter-deprecation</a></li><li class="chapter-item expanded "><a href="0329-deprecated-ember-evented-in-ember-data.html">0329-deprecated-ember-evented-in-ember-data</a></li><li class="chapter-item expanded "><a href="0331-deprecate-globals-resolver.html">0331-deprecate-globals-resolver</a></li><li class="chapter-item expanded "><a href="0332-ember-data-record-links-and-meta.html">0332-ember-data-record-links-and-meta</a></li><li class="chapter-item expanded "><a href="0335-deprecate-send-action.html">0335-deprecate-send-action</a></li><li class="chapter-item expanded "><a href="0337-native-class-constructor-update.html">0337-native-class-constructor-update</a></li><li class="chapter-item expanded "><a href="0340-deprecate-ember-merge.html">0340-deprecate-ember-merge</a></li><li class="chapter-item expanded "><a href="0345-discord.html">0345-discord</a></li><li class="chapter-item expanded "><a href="0364-roadmap-2018.html">0364-roadmap-2018</a></li><li class="chapter-item expanded "><a href="0369-deprecate-computed-clobberability.html">0369-deprecate-computed-clobberability</a></li><li class="chapter-item expanded "><a href="0370-deprecate-computed-volatile.html">0370-deprecate-computed-volatile</a></li><li class="chapter-item expanded "><a href="0372-ember-data-model-factory-for.html">0372-ember-data-model-factory-for</a></li><li class="chapter-item expanded "><a href="0373-Element-Modifier-Managers.html">0373-Element-Modifier-Managers</a></li><li class="chapter-item expanded "><a href="0375-deprecate-computed-property-modifier.html">0375-deprecate-computed-property-modifier</a></li><li class="chapter-item expanded "><a href="0386-remove-jquery.html">0386-remove-jquery</a></li><li class="chapter-item expanded "><a href="0389-dynamic-tag-names.html">0389-dynamic-tag-names</a></li><li class="chapter-item expanded "><a href="0391-router-helpers.html">0391-router-helpers</a></li><li class="chapter-item expanded "><a href="0392-deprecate-component-manager-string-lookup.html">0392-deprecate-component-manager-string-lookup</a></li><li class="chapter-item expanded "><a href="0395-ember-data-packages.html">0395-ember-data-packages</a></li><li class="chapter-item expanded "><a href="0398-RouteInfo-Metadata.html">0398-RouteInfo-Metadata</a></li><li class="chapter-item expanded "><a href="0403-ember-data-identifiers.html">0403-ember-data-identifiers</a></li><li class="chapter-item expanded "><a href="0408-decorators.html">0408-decorators</a></li><li class="chapter-item expanded "><a href="0410-tracked-properties.html">0410-tracked-properties</a></li><li class="chapter-item expanded "><a href="0415-render-element-modifiers.html">0415-render-element-modifiers</a></li><li class="chapter-item expanded "><a href="0416-glimmer-components.html">0416-glimmer-components</a></li><li class="chapter-item expanded "><a href="0418-deprecate-route-render-methods.html">0418-deprecate-route-render-methods</a></li><li class="chapter-item expanded "><a href="0421-deprecate-application-controller-props.html">0421-deprecate-application-controller-props</a></li><li class="chapter-item expanded "><a href="0425-website-redesign.html">0425-website-redesign</a></li><li class="chapter-item expanded "><a href="0431-guides-restructure.html">0431-guides-restructure</a></li><li class="chapter-item expanded "><a href="0432-contextual-helpers.html">0432-contextual-helpers</a></li><li class="chapter-item expanded "><a href="0435-modifier-splattributes.html">0435-modifier-splattributes</a></li><li class="chapter-item expanded "><a href="0440-decorator-support.html">0440-decorator-support</a></li><li class="chapter-item expanded "><a href="0445-deprecate-with.html">0445-deprecate-with</a></li><li class="chapter-item expanded "><a href="0446-contribution-guides.html">0446-contribution-guides</a></li><li class="chapter-item expanded "><a href="0449-deprecate-partials.html">0449-deprecate-partials</a></li><li class="chapter-item expanded "><a href="0451-injection-parameter-normalization.html">0451-injection-parameter-normalization</a></li><li class="chapter-item expanded "><a href="0452-ember-data-medium-term-plan.html">0452-ember-data-medium-term-plan</a></li><li class="chapter-item expanded "><a href="0457-nested-lookups.html">0457-nested-lookups</a></li><li class="chapter-item expanded "><a href="0459-angle-bracket-built-in-components.html">0459-angle-bracket-built-in-components</a></li><li class="chapter-item expanded "><a href="0460-yieldable-named-blocks.html">0460-yieldable-named-blocks</a></li><li class="chapter-item expanded "><a href="0461-ember-data-singleton-record-data.html">0461-ember-data-singleton-record-data</a></li><li class="chapter-item expanded "><a href="0463-record-data-state.html">0463-record-data-state</a></li><li class="chapter-item expanded "><a href="0465-record-data-errors.html">0465-record-data-errors</a></li><li class="chapter-item expanded "><a href="0466-request-state-service.html">0466-request-state-service</a></li><li class="chapter-item expanded "><a href="0468-classic-decorator.html">0468-classic-decorator</a></li><li class="chapter-item expanded "><a href="0470-fn-helper.html">0470-fn-helper</a></li><li class="chapter-item expanded "><a href="0471-on-modifier.html">0471-on-modifier</a></li><li class="chapter-item expanded "><a href="0477-blueprints-update.html">0477-blueprints-update</a></li><li class="chapter-item expanded "><a href="0478-tracked-properties-updates.html">0478-tracked-properties-updates</a></li><li class="chapter-item expanded "><a href="0481-component-templates-co-location.html">0481-component-templates-co-location</a></li><li class="chapter-item expanded "><a href="0486-deprecate-mouseenter.html">0486-deprecate-mouseenter</a></li><li class="chapter-item expanded "><a href="0487-custom-model-classes.html">0487-custom-model-classes</a></li><li class="chapter-item expanded "><a href="0491-deprecate-disconnect-outlet.html">0491-deprecate-disconnect-outlet</a></li><li class="chapter-item expanded "><a href="0494-async-observers.html">0494-async-observers</a></li><li class="chapter-item expanded "><a href="0496-handlebars-strict-mode.html">0496-handlebars-strict-mode</a></li><li class="chapter-item expanded "><a href="0507-embroider-v2-package-format.html">0507-embroider-v2-package-format</a></li><li class="chapter-item expanded "><a href="0519-2019-2020-roadmap.html">0519-2019-2020-roadmap</a></li><li class="chapter-item expanded "><a href="0521-find-by-identifier.html">0521-find-by-identifier</a></li><li class="chapter-item expanded "><a href="0522-default-serializers-and-adapters.html">0522-default-serializers-and-adapters</a></li><li class="chapter-item expanded "><a href="0523-model-argument-for-route-templates.html">0523-model-argument-for-route-templates</a></li><li class="chapter-item expanded "><a href="0554-deprecate-getwithdefault.html">0554-deprecate-getwithdefault</a></li><li class="chapter-item expanded "><a href="0558-edition-detection.html">0558-edition-detection</a></li><li class="chapter-item expanded "><a href="0560-add-equality-operators.html">0560-add-equality-operators</a></li><li class="chapter-item expanded "><a href="0561-add-numeric-comparison-operators.html">0561-add-numeric-comparison-operators</a></li><li class="chapter-item expanded "><a href="0562-add-logical-operators.html">0562-add-logical-operators</a></li><li class="chapter-item expanded "><a href="0566-memo-decorator.html">0566-memo-decorator</a></li><li class="chapter-item expanded "><a href="0580-destroyables.html">0580-destroyables</a></li><li class="chapter-item expanded "><a href="0581-new-test-waiters.html">0581-new-test-waiters</a></li><li class="chapter-item expanded "><a href="0585-improved-ember-registry-apis.html">0585-improved-ember-registry-apis</a></li><li class="chapter-item expanded "><a href="0615-autotracking-memoization.html">0615-autotracking-memoization</a></li><li class="chapter-item expanded "><a href="0617-rfc-stages.html">0617-rfc-stages</a></li><li class="chapter-item expanded "><a href="0625-helper-managers.html">0625-helper-managers</a></li><li class="chapter-item expanded "><a href="0626-invoke-helper.html">0626-invoke-helper</a></li><li class="chapter-item expanded "><a href="0628-prettier.html">0628-prettier</a></li><li class="chapter-item expanded "><a href="0631-refresh-method-for-router-service.html">0631-refresh-method-for-router-service</a></li><li class="chapter-item expanded "><a href="0635-ember-new-lang.html">0635-ember-new-lang</a></li><li class="chapter-item expanded "><a href="0637-customizable-test-setups.html">0637-customizable-test-setups</a></li><li class="chapter-item expanded "><a href="0638-interactive-app-creation.html">0638-interactive-app-creation</a></li><li class="chapter-item expanded "><a href="0639-replace-blacklist-whitelist.html">0639-replace-blacklist-whitelist</a></li><li class="chapter-item expanded "><a href="0645-add-ember-page-title-addon.html">0645-add-ember-page-title-addon</a></li><li class="chapter-item expanded "><a href="0649-deprecation-staging.html">0649-deprecation-staging</a></li><li class="chapter-item expanded "><a href="0659-unique-id-helper.html">0659-unique-id-helper</a></li><li class="chapter-item expanded "><a href="0669-tracked-storage-primitive.html">0669-tracked-storage-primitive</a></li><li class="chapter-item expanded "><a href="0671-modernize-built-in-components-1.html">0671-modernize-built-in-components-1</a></li><li class="chapter-item expanded "><a href="0673-deprecate-tryinvoke.html">0673-deprecate-tryinvoke</a></li><li class="chapter-item expanded "><a href="0674-deprecate-transition-methods-of-controller-and-route.html">0674-deprecate-transition-methods-of-controller-and-route</a></li><li class="chapter-item expanded "><a href="0680-implicit-injection-deprecation.html">0680-implicit-injection-deprecation</a></li><li class="chapter-item expanded "><a href="0685-new-browser-support-policy.html">0685-new-browser-support-policy</a></li><li class="chapter-item expanded "><a href="0686-deprecate-old-manager-capabilities-versions.html">0686-deprecate-old-manager-capabilities-versions</a></li><li class="chapter-item expanded "><a href="0689-deprecate-has-block.html">0689-deprecate-has-block</a></li><li class="chapter-item expanded "><a href="0690-deprecate-attrs-in-templates.html">0690-deprecate-attrs-in-templates</a></li><li class="chapter-item expanded "><a href="0691-deprecate-class-binding-and-class-name-bindings.html">0691-deprecate-class-binding-and-class-name-bindings</a></li><li class="chapter-item expanded "><a href="0692-deprecate-array-observers.html">0692-deprecate-array-observers</a></li><li class="chapter-item expanded "><a href="0698-deprecate-link-to-positional-arguments.html">0698-deprecate-link-to-positional-arguments</a></li><li class="chapter-item expanded "><a href="0702-eslint-plugin-qunit.html">0702-eslint-plugin-qunit</a></li><li class="chapter-item expanded "><a href="0704-deprecate-octane-optional-features.html">0704-deprecate-octane-optional-features</a></li><li class="chapter-item expanded "><a href="0705-deprecate-jquery-optional-feature.html">0705-deprecate-jquery-optional-feature</a></li><li class="chapter-item expanded "><a href="0706-deprecate-ember-global.html">0706-deprecate-ember-global</a></li><li class="chapter-item expanded "><a href="0707-modernize-built-in-components-2.html">0707-modernize-built-in-components-2</a></li><li class="chapter-item expanded "><a href="0711-deprecate-auto-location.html">0711-deprecate-auto-location</a></li><li class="chapter-item expanded "><a href="0724-road-to-typescript.html">0724-road-to-typescript</a></li><li class="chapter-item expanded "><a href="0730-semver-for-ts.html">0730-semver-for-ts</a></li><li class="chapter-item expanded "><a href="0738-ember-data-deprecate-model-reopen.html">0738-ember-data-deprecate-model-reopen</a></li><li class="chapter-item expanded "><a href="0739-ember-data-deprecate-non-strict-relationships.html">0739-ember-data-deprecate-non-strict-relationships</a></li><li class="chapter-item expanded "><a href="0742-ember-data-deprecate-helper-functions.html">0742-ember-data-deprecate-helper-functions</a></li><li class="chapter-item expanded "><a href="0748-glimmer-component-signature.html">0748-glimmer-component-signature</a></li><li class="chapter-item expanded "><a href="0750-deprecate-ember-assign.html">0750-deprecate-ember-assign</a></li><li class="chapter-item expanded "><a href="0752-inject-service.html">0752-inject-service</a></li><li class="chapter-item expanded "><a href="0756-helper-default-manager.html">0756-helper-default-manager</a></li><li class="chapter-item expanded "><a href="0772-deprecate-bower-support.html">0772-deprecate-bower-support</a></li><li class="chapter-item expanded "><a href="0776-typescript-blueprints.html">0776-typescript-blueprints</a></li><li class="chapter-item expanded "><a href="0779-first-class-component-templates.html">0779-first-class-component-templates</a></li><li class="chapter-item expanded "><a href="0785-remove-set-get-in-tests.html">0785-remove-set-get-in-tests</a></li><li class="chapter-item expanded "><a href="0786-ember-cookbook.html">0786-ember-cookbook</a></li><li class="chapter-item expanded "><a href="0794-ember-data-schema-definition-service-simplify.html">0794-ember-data-schema-definition-service-simplify</a></li><li class="chapter-item expanded "><a href="0795-ember-data-return-promise-save.html">0795-ember-data-return-promise-save</a></li><li class="chapter-item expanded "><a href="0796-ember-data-deprecate-rsvp.html">0796-ember-data-deprecate-rsvp</a></li><li class="chapter-item expanded "><a href="0800-ts-adoption-plan.html">0800-ts-adoption-plan</a></li><li class="chapter-item expanded "><a href="0801-deprecate-blacklist-and-whitelist-build-options.html">0801-deprecate-blacklist-and-whitelist-build-options</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ember-rfcs"><a class="header" href="#ember-rfcs">Ember RFCs</a></h1>
<p>Many changes, including bug fixes and documentation improvements can be
implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put
through a bit of a design process and produce a consensus among the Ember
core teams.</p>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a
consistent and controlled path for new features to enter the framework.</p>
<p><a href="https://github.com/emberjs/rfcs/pulls">Active RFC List</a></p>
<p><a href="https://emberjs.github.io/rfcs/">Approved RFC List</a></p>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot;
changes to Ember, Ember Data, Ember CLI, their documentation, or any other
projects under the purview of the <a href="https://emberjs.com/team/">Ember core teams</a>.
What constitutes a &quot;substantial&quot; change is evolving based on community norms,
but may include the following:</p>
<ul>
<li>A new feature that creates new API surface area, and would
require a <a href="http://emberjs.com/guides/contributing/adding-new-features/">feature flag</a> if introduced.</li>
<li>The removal of features that already shipped as part of the release
channel.</li>
<li>The introduction of new idiomatic usage or conventions, even if they
do not include code changes to Ember itself.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing or refactoring</li>
<li>Addition or removal of warnings</li>
<li>Additions that strictly improve objective, numerical quality
criteria (speedup, better browser support)</li>
<li>Additions only likely to be <em>noticed by</em> other implementors-of-Ember,
invisible to users-of-Ember.</li>
</ul>
<p>If you submit a pull request to implement a new feature without going
through the RFC process, it may be closed with a polite request to
submit an RFC first.</p>
<h2 id="gathering-feedback-before-submitting"><a class="header" href="#gathering-feedback-before-submitting">Gathering feedback before submitting</a></h2>
<p>It's often helpful to get feedback on your concept before diving into the
level of API design detail required for an RFC. <strong>You may open an
issue on this repo to start a high-level discussion</strong>, with the goal of
eventually formulating an RFC pull request with the specific implementation
design. We also highly recommend sharing drafts of RFCs in <code>#dev-rfc</code> on 
the <a href="https://discord.gg/emberjs">Ember Discord</a> for early feedback.</p>
<h2 id="the-process"><a class="header" href="#the-process">The process</a></h2>
<p>In short, to get a major feature added to Ember, one must first get the
RFC merged into the RFC repo as a markdown file. At that point the RFC
is 'active' and may be implemented with the goal of eventual inclusion
into Ember.</p>
<ul>
<li>Fork the RFC repo http://github.com/emberjs/rfcs</li>
<li>Copy the appropriate template. For most RFCs, this is <code>0000-template.md</code>, 
for deprecation RFCs it is <code>deprecation-template.md</code>.
Copy the template file to <code>text/0000-my-feature.md</code>, where
'my-feature' is descriptive. Don't assign an RFC number yet.</li>
<li>Fill in the RFC. Put care into the details: <strong>RFCs that do not
present convincing motivation, demonstrate understanding of the
impact of the design, or are disingenuous about the drawbacks or
alternatives tend to be poorly-received</strong>.</li>
<li>Fill in the relevant core teams. Use the table below to map from projects to 
teams.</li>
<li>Submit a pull request. As a pull request the RFC will receive design
feedback from the larger community, and the author should be prepared
to revise it in response.</li>
<li>Find a champion on the relevant core team. The champion is responsible for 
shepherding the RFC through the RFC process and representing it in core team 
meetings.</li>
<li>Update the pull request to add the number of the PR to the filename and 
add a link to the PR in the header of the RFC.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support
are much more likely to make progress than those that don't receive any
comments.</li>
<li>Eventually, the [core teams] will decide whether the RFC is a candidate
for inclusion in Ember.</li>
<li>RFCs that are candidates for inclusion in Ember will enter a &quot;final comment
period&quot; lasting 7 days. The beginning of this period will be signaled with a
comment and tag on the RFC's pull request. Furthermore,
<a href="https://twitter.com/emberjs">Ember's official Twitter account</a> will post a
tweet about the RFC to attract the community's attention.</li>
<li>An RFC can be modified based upon feedback from the [core teams] and community.
Significant modifications may trigger a new final comment period.</li>
<li>An RFC may be rejected by the [core teams] after public discussion has settled
and comments have been made summarizing the rationale for rejection. The RFC 
will enter a &quot;final comment period to close&quot; lasting 7 days. At the end of the 
&quot;FCP to close&quot; period, the PR will be closed.</li>
<li>An RFC may also be closed by the core teams if it is superseded by a merged
RFC. In this case, a link to the new RFC should be added in a comment.</li>
<li>An RFC author may withdraw their own RFC by closing it themselves.</li>
<li>An RFC may be accepted at the close of its final comment period. A <a href="http://emberjs.com/team/">core team</a>
member will merge the RFC's associated pull request, at which point the RFC will
become 'active'.</li>
</ul>
<h3 id="relevant-teams"><a class="header" href="#relevant-teams">Relevant Teams</a></h3>
<p>The RFC template requires indicating the relevant core teams. The following table 
offers a reference of teams responsible for each project. Please reach out for 
further guidance. </p>
<table><thead><tr><th>Core Team</th><th>Project/Topics</th></tr></thead><tbody>
<tr><td>Ember.js</td><td>Ember.js</td></tr>
<tr><td>Ember Data</td><td>Ember Data</td></tr>
<tr><td>Ember CLI</td><td>Ember CLI</td></tr>
<tr><td>Learning</td><td>Documentation, Website, learning experiences</td></tr>
<tr><td>TypeScript</td><td>TypeScript integration and design</td></tr>
<tr><td>Steering</td><td>Governance</td></tr>
</tbody></table>
<h3 id="finding-a-champion"><a class="header" href="#finding-a-champion">Finding a champion</a></h3>
<p>The RFC Process requires finding a champion from the relevant core teams. The 
champion is responsible for representing the RFC in team meetings, and for 
shepherding its progress. <a href="introduction.html#champion-responsibilities">Read more about the Champion's job</a></p>
<ul>
<li>
<p><em>Find one via Discord.</em> 
The <code>dev-rfc</code> channel on the <a href="https://discord.gg/emberjs">Ember Discord</a> is 
reserved for the discussion of RFCs. We highly recommend circulating early drafts of 
your RFC in this channel to both receive early feedback and to find a champion.</p>
</li>
<li>
<p><em>Ask for a champion via an issue, or in the RFC itself.</em>
We monitor the RFC repository. We will circulate requests for champions, but highly 
recommend discussing the RFC in Discord.</p>
</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes active the relevant teams will plan the feature and create 
issues in the relevant repositories.
Becoming 'active' is not a rubber stamp, and in particular still does not mean 
the feature will ultimately be merged; it does mean that the core team has agreed 
to it in principle and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is
'active' implies nothing about what priority is assigned to its
implementation, nor whether anybody is currently working on it.</p>
<p>Modifications to active RFC's can be done in followup PR's. We strive
to write each RFC in a manner that it will reflect the final design of
the feature; but the nature of the process means that we cannot expect
every merged RFC to actually reflect what the end result will be at
the time of the next major release; therefore we try to keep each RFC
document somewhat in sync with the feature as planned,
tracking such changes via followup pull requests to the document.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>The author of an RFC is not obligated to implement it. Of course, the
RFC author (like any other developer) is welcome to post an
implementation for review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an 'active'
RFC, but cannot determine if someone else is already working on it,
feel free to ask (e.g. by leaving a comment on the associated issue).</p>
<h2 id="for-core-team-members"><a class="header" href="#for-core-team-members">For Core Team Members</a></h2>
<h3 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h3>
<p>Each core team is responsible for reviewing open RFCs. The team must ensure 
that if an RFC is relevant to their team's responsibilities the team is 
correctly specified in the 'Relevant Team(s)' section of the RFC front-matter.
The team must also ensure that each RFC addresses any consequences, changes, or
work required in the team's area of responsibility.</p>
<p>As it is with the wider community, the RFC process is the time for 
teams and team members to push back on, encourage, refine, or otherwise comment 
on proposals.</p>
<h3 id="referencing-rfcs"><a class="header" href="#referencing-rfcs">Referencing RFCs</a></h3>
<ul>
<li>When mentioning RFCs that have been merged, link to the merged version, 
not to the pull-request.</li>
</ul>
<h3 id="champion-responsibilities"><a class="header" href="#champion-responsibilities">Champion Responsibilities</a></h3>
<ul>
<li>Achieving consensus from the team(s) to move the RFC through the stages of 
the RFC process.</li>
<li>Ensuring the RFC follows the RFC process.</li>
<li>Shepherding the planning and implementation of the RFC. Before the RFC is 
accepted, the champion may remove themselves. The champion may find a replacement 
champion at any time.</li>
</ul>
<h3 id="helpful-checklists-for-champions"><a class="header" href="#helpful-checklists-for-champions">Helpful checklists for Champions</a></h3>
<h4 id="becoming-champion-of-an-rfc"><a class="header" href="#becoming-champion-of-an-rfc">Becoming champion of an RFC</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
Assign the RFC to yourself</li>
</ul>
<h4 id="moving-to-fcp-to-merge"><a class="header" href="#moving-to-fcp-to-merge">Moving to FCP to Merge</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
Achieve consensus to move to &quot;FCP to Merge&quot; from relevant core teams</li>
<li><input disabled="" type="checkbox"/>
Comment in the RFC to address any outstanding issues and to proclaim the 
start of the FCP period</li>
<li><input disabled="" type="checkbox"/>
Tweet from <code>@emberjs</code> about the FCP </li>
<li><input disabled="" type="checkbox"/>
Ensure the RFC has had the filename and header updated with the PR number </li>
</ul>
<h4 id="move-to-fcp-to-close"><a class="header" href="#move-to-fcp-to-close">Move to FCP to Close</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
Achieve consensus to move to &quot;FCP to Close&quot; from relevant core teams</li>
<li><input disabled="" type="checkbox"/>
Comment in the RFC to explain the decision</li>
</ul>
<h4 id="closing-an-rfc"><a class="header" href="#closing-an-rfc">Closing an RFC</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
Comment about the end of the FCP period with no new info</li>
<li><input disabled="" type="checkbox"/>
Close the PR</li>
</ul>
<h4 id="merging-an-rfc"><a class="header" href="#merging-an-rfc">Merging an RFC</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
Achieve consensus to merge from relevant core teams</li>
<li><input disabled="" type="checkbox"/>
Ensure the RFC has had the filename and header updated with the PR number </li>
<li><input disabled="" type="checkbox"/>
Create a tracking card for the RFC implementation at {projects}</li>
<li><input disabled="" type="checkbox"/>
Update the RFC header with a link to the tracking</li>
<li><input disabled="" type="checkbox"/>
Merge</li>
<li><input disabled="" type="checkbox"/>
Update the RFC PR with a link to the merged RFC (The <code>Rendered</code> links often
go stale when the branch or fork is deleted)</li>
<li><input disabled="" type="checkbox"/>
Ensure relevant teams plan out what is necessary to implement</li>
<li><input disabled="" type="checkbox"/>
Put relevant issues on the tracking</li>
</ul>
<p><em>Ember's RFC process owes its inspiration to the <a href="https://github.com/rust-lang/rfcs">Rust RFC process</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-08-14
RFC PR: https://github.com/emberjs/rfcs/pull/1
Ember Issue: https://github.com/emberjs/data/pull/4086</p>
<hr />
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>For Ember Data. Pass through attribute meta data, which includes <code>parentType</code>, <code>options</code>, <code>name</code>, etc.,
to the transform associated with that attribute. This will allow provide the following function signiture updates to <code>DS.Transform</code>: </p>
<ul>
<li><code>transform.serialize(deserialized, attributeMeta)</code></li>
<li><code>transform.deserialize(serialized, attributeMeta)</code></li>
</ul>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>The main use case is to be able to configure the transform
on a per-model basis making more DRY code. So the transform can be aware of type and options on <code>DS.attr</code> can
be useful to configure the transform for DRY use.</p>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h1>
<h2 id="implementing"><a class="header" href="#implementing">Implementing</a></h2>
<p>The change will most likely start in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/system/model/attributes.js#L193"><code>eachTransformedAttribute</code></a>, which gets the attributes for that instance via <code>get(this, 'attributes')</code>. In the <code>forEach</code> the <code>name</code> will be used to get the specific attribute, e.g.</p>
<pre><code class="language-js">var attributeMeta = attributes.get(name);
callback.call(binding, name, type, attributeMeta);
</code></pre>
<p>The next change will be in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L117"><code>applyTransforms</code></a>, where the <code>attributeMeta</code> parameter is added and passed to <code>transform.deserialize</code> as the second argument.</p>
<p>You also have to handle the serialization part in <a href="https://github.com/emberjs/data/blob/master/packages/ember-data/lib/serializers/json_serializer.js#L528"><code>serializeAttribute</code></a>, where you pass through the <code>attribute</code> parameter to <code>transform.serialize</code>.</p>
<h2 id="using"><a class="header" href="#using">Using</a></h2>
<p>A convoluted example:</p>
<pre><code class="language-js">// Example based on https://github.com/chjj/marked library
App.PostModel = DS.Model.extend({
  title: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: false,
      sanitize: true
    }
  })
});

App.TechnicalPostModel = DS.Model.extend({
  title: DS.attr('string'),
  gistUrl: DS.attr('string'),
  markdown: DS.attr('markdown', {
    markdown: {
      gfm: true,
      tables: true,
      sanitize: false
    }
  })
});

App.MarkdownTransform = DS.Transform.extend({
  serialize: function (deserialized, attributeMeta) {
    return deserialized.raw;
  },
  
  deserialize: function (serialized, attributeMeta) {
    var options = attributeMeta.options.markdown || {};
    
    return marked(serialized, options);
  }
});
</code></pre>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<p>Extra API surface area, although not much. This could also potentially introduce tight coupling between models and transforms if used improperly, e.g. not returning a default value if using type checking.</p>
<h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<ol>
<li>Passing the information from the server, which is a poor solution.</li>
<li>Writing a new transform for each model/attribute that needs a variation. Although this might be a good solution sometimes if you extend a base transform.</li>
</ol>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<p>Does the whole meta object need to be passed, or do we selectively pass in only the useful properties? Like
<code>options</code> and <code>parentType</code> and <code>name</code>..</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-08-18
RFC PR: https://github.com/emberjs/rfcs/pull/3
Issues:
Ember Stream support: emberjs/ember.js#5522
Handlebars parser support: wycats/handlebars.js#906
HTMLBars compiler support: tildeio/htmlbars#147</p>
<hr />
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>Introduce block parameters to the Handlebars language to standardize context-preserving helpers, for example:</p>
<pre><code class="language-handlebars">{{#each people as |person|}}
  {{person.name}}
{{/each}}
</code></pre>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<h3 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h3>
<p>There is no idiomatic way to write a helper that preserves context and yields values to its template. This is particularly painful for components which have strict context-preserving semantics.</p>
<h3 id="current-workarounds"><a class="header" href="#current-workarounds">Current workarounds</a></h3>
<ul>
<li>Don't write components that need to yield a value.
<ul>
<li><em>Problem:</em> This may not be an option.</li>
</ul>
</li>
<li>Invent a non-standard per-helper syntax (like <code>{{#with foo as bar}}</code> or <code>{{#each item in items}}</code>) that hook into the undocumented <code>keywords</code> to inject variables.
<ul>
<li><em>Problems:</em> Custom syntaxes are not in the spirit of the Handlebars language and require the consumer to know the special incantation. Component authors must an non-trivial understanding of how <code>keywords</code> work.</li>
</ul>
</li>
</ul>
<h3 id="new-possibilities"><a class="header" href="#new-possibilities">New possibilities</a></h3>
<pre><code class="language-handlebars">{{#for-each obj as |key val|}}
  {{key}}: {{val}}
{{/for-each}}
</code></pre>
<pre><code class="language-handlebars">{{#form-for post as |f|}}
  {{f.input &quot;title&quot;}}
  {{f.textarea &quot;body&quot;}}
  {{f.submit}}
{{/form-for}}
</code></pre>
<h1 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h1>
<ul>
<li>Phase 1: Add block params to the Handlebars language</li>
<li>Phase 2: Rewrite Ember's helpers to accept streams</li>
<li>Phase 3: Add block param support to <code>{{each}}</code> and <code>{{with}}</code></li>
</ul>
<h3 id="phase-1-add-block-params-to-the-handlebars-language"><a class="header" href="#phase-1-add-block-params-to-the-handlebars-language">Phase 1: Add block params to the Handlebars language</a></h3>
<p>The proposed syntax is <code>{{#x-foo a b w=x y=z as |param1 param2 ... paramN|}}</code> and is only available for block helpers.</p>
<p>The names of the block parameters are compiled into the inner template, but are not known to the helper (<code>x-foo</code> in the example above). To call a template and populate its block params we use the arguments option:</p>
<pre><code class="language-javascript">var template = compile('{{person.name}}', {
  blockParams: [ 'person' ]
});

template({}, ..., [ personModel ]);
</code></pre>
<p>More commonly, block params will be defined inside of the template.</p>
<pre><code>{{#with currentPost.author as |a|}}
  {{a.name}} &lt;em&gt;{{a.email}}&lt;/em&gt;
{{/with}}
</code></pre>
<pre><code class="language-javascript">registerHelper('with', function(object, options) {
  return options.fn(this, ..., [ object ]);
});
</code></pre>
<p>For compatibility reasons, the <em>number of block params</em> are passed to the helper so that the pre-block-params behaviour of the helper can be preserved. Example:</p>
<pre><code class="language-javascript">function eachHelper(..., options) {
  if (options.blockParamsLength &gt; 0) { /* do new behaviour */ }
  else { /* do old behaviour */ }
}
</code></pre>
<h3 id="phase-2-rewrite-embers-helpers-to-accept-streams"><a class="header" href="#phase-2-rewrite-embers-helpers-to-accept-streams">Phase 2: Rewrite Ember's helpers to accept streams</a></h3>
<p>In the <code>with</code> example above, if the <code>currentPost</code> changes the <code>a</code> block param should update. This means it's not sufficient to pass only the initial value of the author in the arguments. Instead, we pass a stream which emits values whenever the observed property changes.</p>
<p>In Handlebars, a block param can appear anywhere that an identifier can, for example <code>{{log a.name}}</code>. This means that all helpers would need to be modified to understand streams.</p>
<h3 id="phase-3-add-block-param-support-to-each-and-with"><a class="header" href="#phase-3-add-block-param-support-to-each-and-with">Phase 3: Add block param support to <code>{{each}}</code> and <code>{{with}}</code></a></h3>
<p>Deprecate context-changing and ad-hoc keyword flavors of <code>{{each}}</code> and <code>{{with}}</code> in favor of block params.</p>
<h1 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h1>
<ul>
<li>Handlebars already has a similar notion of with <code>data</code> which can lead to confusion.</li>
</ul>
<h1 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h1>
<p>To my knowledge, no other designs have been considered. Not implementing this feature would mean that components would continue to be difficult to compose.</p>
<h1 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h1>
<p>The associated HTML syntax for HTMLBars needs to be finalized.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-01-10
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/3</p>
<hr />
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<p>We need a way to run diagnostics on Ember CLI based projects to let developers know about potential system level incompatibilities. Developers should also be able to get a bill of health for their project for things like outdated dependencies.  This bill of health should also be extensible.  Output from running this command should be as consise and only ever log things that don't seem healthy.</p>
<h1 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h1>
<p>The motivation behind this is 2 pronged:</p>
<ol>
<li>Allows developers to submit system level information in pull requests, so that bugs can be filed and potentially replicated.</li>
<li>Gives developers the ability to know about the health of their project and to potentially help with stagnation.</li>
</ol>
<h1 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed design</a></h1>
<p>The design for this is rather simple. We would first introduce a command called <code>ember doctor</code> that would run some default checks. The default checks would do the following:</p>
<ul>
<li>Run <code>ember v --verbose</code> and complain loudly for incompatible versions</li>
<li>Run <code>npm outdated --depth 0</code> to check on outdated modules</li>
<li>Run <code>bower list</code> and display out of date bower components</li>
<li>Run check to grab OS information</li>
</ul>
<p>These are what is considered default <code>checks</code>.</p>
<p>In your project developers can setup their own Doctor <code>checks</code> that get merged in with the default checks. To allow for this Ember CLI will have <code>ember generate doctor check:service-health</code>.</p>
<p>This command will generate the following directory structure in the root of the project:</p>
<pre><code>doctor/
  checks/
    service-health.js
  index.js
</code></pre>
<p>When <code>ember doctor</code> is ran we simply will do a merge of the default checks and the ones provided by the application.</p>
<p>There should also be a way of excluding checks to be ran. Developers should be able to simply pass flags for things they do not care to run e.g. <code>ember doctor --skip=npm,os</code>.</p>
<h1 id="addon-design"><a class="header" href="#addon-design">Addon Design</a></h1>
<p>Much like the project addons can add their own diagnostics as projects.
In the addons main entry point there will be a hook much like
<code>includedCommands</code> that allows Ember CLI to look up the diagnostics and
role them into the consuming project.</p>
<pre><code>var checks = require('./checks');
...
includedChecks: function() {
  return checks;
}
...
</code></pre>
<h1 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h1>
<p>Output of running the doctor command should be as concise as possible.
Unless there are any issues with the project that is being analyzed, the
output should be something like the following:</p>
<pre><code>Success: All diagnostics checked out fine.
</code></pre>
<p>In the event that there is an issue with the project that is being
analyzed the output will look something like the following:</p>
<pre><code>Warning: NPM modules out of date. Below are the out of date modules.
╔══════╤═══════╤═════════╗
║ Name │ Yours │ Current ║
╟──────┼───────┼─────────╢
║ glob │ 1.1.2 │ 1.2.3   ║
╚══════╧═══════╧═════════╝
</code></pre>
<h1 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h1>
<p>This adds &quot;yet another thing&quot; to the Ember CLI API surface. Doctor will be bound to a network connection such as checking outdated dependencies.</p>
<h1 id="alternatives-2"><a class="header" href="#alternatives-2">Alternatives</a></h1>
<p>There have been other other attempts to put checking for system level checking in various places. The BDFL's would like to consolidate this into an <code>ember doctor</code> command.</p>
<h1 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-10-24
RFC PR: https://github.com/emberjs/rfcs/pull/10
Ember Issue: https://github.com/emberjs/ember.js/pull/12685</p>
<hr />
<h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<p>Engines allow multiple logical applications to be composed together into a
single application from the user's perspective.</p>
<h1 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h1>
<p>Large companies are increasingly adopting Ember.js to power their entire
product lines. Often this means separate teams (sometimes distributed
around the world) working on the same app. Typically, responsibility is
shared by dividing the application into one or more &quot;sections&quot;. How this
division is actually implemented varies from team to team.</p>
<p>Sometimes, each &quot;section&quot; will be a completely separate Ember app, with
a shared navigation bar allowing users to switch between each app. This
allows teams to work quickly without stepping on each others' toes, but
switching apps feels slow (especially compared to the normally speedy
route transitions in Ember) because the entire page must be thrown out,
then an entirely new set of the same assets downloaded and parsed.
Additionally, code sharing is largely accomplished via copy-and-paste.</p>
<p>Other times, the separation is enforced socially, with each team
claiming a section of the same app in the same repository.
Unfortunately, this approach leads to frequent conflicts around shared
resources, and feedback from tests gets slower and slower as test suites
grow in size.</p>
<p>A more modular approach is to break off elements of a single application into
separate <a href="http://www.ember-cli.com/user-guide/#addons">addons</a>. Addons are
essentially mixins for <a href="http://www.ember-cli.com/">ember-cli</a> applications. In
other words, the elements of an addon are merged with those of the application
that includes them. While addons allow for distributed development, testing, and
packaging, they do not provide the logical run-time separation required for
developing completely independent &quot;sections&quot; of an application. Addons must
function within the namespace, registry, and router of the application in which
they are included.</p>
<p>Engines provide an alternative to these approaches that allows for distributed
development, testing, and packaging, <em>as well as</em> logical run-time separation.
Because engines are derived from applications, they can be just as
full-featured. Each has its own namespace and registry. Even though engines are
isolated from the applications that contain them, the boundaries between them
allow for controlled sharing of resources.</p>
<p>Engines can be either &quot;routable&quot; or &quot;route-less&quot;:</p>
<ul>
<li>
<p>Routable engines provide a routing map which can be integrated with the
routing maps of parent applications or engines. Routing maps are always eager
loaded, which allows for deep linking into an engine's routes regardless of
whether the engine itself has been instantiated.</p>
</li>
<li>
<p>Route-less engines can isolate complex functionality that is not related to
routing (e.g. a chat engine in a sidebar). Route-less engines can be rendered
into outlets ad hoc as routes are loaded.</p>
</li>
</ul>
<p>The potential scope of engines is large enough that this feature merits
development and delivery in multiple phases. A minimum viable version could be
released sooner, which could be augmented with more advanced features later.</p>
<p>An initial release of engines could provide the following benefits:</p>
<ul>
<li>
<p>Distributed development - Engines can be developed and tested in isolation
within their own Ember CLI projects and included by applications or other
engines. Engines can be packaged and released as addons themselves.</p>
</li>
<li>
<p>Integrated routing - Support for mounting routable engines in the routing maps
of applications or other engines.</p>
</li>
<li>
<p>Ad hoc embedding - Support for embedding route-less engines in outlets as
needed.</p>
</li>
<li>
<p>Clean boundaries - An engine can cooperate with its parents through a few
explicit interfaces. Beyond these interfaces, engines and applications are
isolated.</p>
</li>
</ul>
<p>Subsequent releases of engines could allow for the following:</p>
<ul>
<li>
<p>Lazy loading - An engine could allow its parent to boot with only its routing
map loaded. The rest of the engine could be loaded only as required (i.e.
when a route in an engine is visited). This would allow applications to boot
faster and limit their memory consumption.</p>
</li>
<li>
<p>Namespaced access to engine resources from applications - This could open up
the potential for applications to use, and extend, an engine's resources much
like resources in other addons, but without the possibility of namespace
collisions.</p>
</li>
</ul>
<h2 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed design</a></h2>
<p>Engines are very similar to regular applications: they can be developed in
isolation in Ember CLI, include addons, and contain all the same elements,
including routes, components, initializers, etc. The primary differences are
that an engine does not boot itself and an engine does not control the router.</p>
<h3 id="engine-internals"><a class="header" href="#engine-internals">Engine internals</a></h3>
<p>New <code>Engine</code> and <code>EngineInstance</code> classes will be introduced.</p>
<p>Applications and engines will share ancestry. It remains TBD whether
applications will subclass engines, or whether a common ancestor will be
introduced.</p>
<p>Engines and applications will share the same pattern for registry / container
ownership and encapsulation. Both will also have initializers and instance
initializers.</p>
<p>Engine instances will have access to their parent instances. An engine's parent
could be either an application or engine.</p>
<h4 id="routable-vs-route-less-engines"><a class="header" href="#routable-vs-route-less-engines">Routable vs. route-less engines</a></h4>
<p>Routable engines will define their routes in a new <code>Ember.Routes</code> class. This
class will encapsulate the functionality provided by <code>Router#map</code>, and will be
used internally by <code>Ember.Router</code> as well (with no public interface changes of
course).</p>
<p>Route-less engines do not define routing maps nor can they contain routes.</p>
<h3 id="developing-engines"><a class="header" href="#developing-engines">Developing engines</a></h3>
<p>Engines can be developed in isolation as Ember CLI addon projects or as part of
a parent application.</p>
<h4 id="engines-as-addons"><a class="header" href="#engines-as-addons">Engines as addons</a></h4>
<p>Engines can be created as separate addon projects with:</p>
<pre><code>ember engine &lt;engine-name&gt;
</code></pre>
<p>This will create a special form of an ember addon. The file structure will match
that of a standard addon, but will have an <code>engine</code> directory instead of an
<code>addon</code> directory.</p>
<p>Engines can be unit tested and can also be integration tested within a dummy
app, just like standard addons.</p>
<h4 id="in-repo-engines"><a class="header" href="#in-repo-engines">In-repo engines</a></h4>
<p>An engine can be created within an existing application's project using a
special <code>in-repo-engine</code> generator (similar to the <code>in-repo-addon</code> generator):</p>
<pre><code>ember g in-repo-engine &lt;engine-name&gt;
</code></pre>
<p>In-repo engines can be unit tested in isolation or integration testing with the
main application (instead of a dummy application).</p>
<blockquote>
<p>Note: In-repo addons currently are created in the <code>/lib</code> directory (e.g.
<code>/lib/my-addon</code>). Unit tests and integration tests are currently co-mingled with
tests for the main application. It's recommended that in-repo engines provide
better test separation than is provided for regular addons, and perhaps the
whole in-repo addon directory structure should be re-examined at the same time
in-repo engines are introduced.</p>
</blockquote>
<h4 id="engine-directory-structure"><a class="header" href="#engine-directory-structure">Engine directory structure</a></h4>
<p>An engine's directory will contain a file structure identical to the <code>app</code>
directory in a standard ember-cli application, with the following exceptions:</p>
<ul>
<li>
<p><code>engine.js</code> instead of <code>app.js</code> - defines the <code>Engine</code> class and
loads its initializers.</p>
</li>
<li>
<p><code>routes.js</code> instead of <code>router.js</code> - defines an engine's routing map in a
<code>Routes</code> class. This file should be deleted entirely for route-less engines.</p>
</li>
</ul>
<h3 id="installing-engines"><a class="header" href="#installing-engines">Installing engines</a></h3>
<p>Engines developed as addons can be installed in an application just like any
other addon:</p>
<pre><code>ember install &lt;engine-name&gt;
</code></pre>
<p>During development, you can use <code>npm link</code> to make your engine available in
another parent engine or application.</p>
<h3 id="mounting-routable-engines"><a class="header" href="#mounting-routable-engines">Mounting routable engines</a></h3>
<p>The new <code>mount()</code> router DSL method is used to mount an engine at a particular
&quot;mount-point&quot; in a route map.</p>
<p>For example, the following route map mounts the <code>discourse</code> engine at the
<code>/forum</code> path:</p>
<pre><code>Router.map(function() {
  this.mount('discourse', {path: '/forum'});
});
</code></pre>
<blockquote>
<p>Note: If unspecified, <code>path</code> will match the name of the engine.</p>
</blockquote>
<p>Calls to <code>mount</code> can be nested within routes. An engine can be mounted at
multiple routes, and each will represent a new instance of the engine to be
created.</p>
<h3 id="mounting-route-less-engines"><a class="header" href="#mounting-route-less-engines">Mounting route-less engines</a></h3>
<p>A <code>mount()</code> DSL will also be added to routes, which will enable embedding of
route-less engines in outlets. This can be called from <code>renderTemplate</code> (or
<code>renderComponents</code> once routable components are introduced).</p>
<p><code>mount</code> has a similar signature to <code>render</code>, although it is obviously
engine-specific instead of template-specific. <code>mount</code> can be used to specify
a target template and outlet as follows:</p>
<pre><code>renderTemplate: function() {
  // Mount the chat engine in the sidebar
  this.mount('chat', {
    into: 'main',
    outlet: 'sidebar'
  });
}
</code></pre>
<p>As a result, the engine's <code>application</code> template will be rendered into the
<code>sidebar</code> outlet in the application's <code>main</code> template.</p>
<h3 id="loading-phases"><a class="header" href="#loading-phases">Loading phases</a></h3>
<p>Engines can exist in several phases:</p>
<ul>
<li>
<p>Booted - an engine that's been installed in a parent application will have
its dependencies loaded and its (non-instance) initializers invoked when the
parent application boots.</p>
</li>
<li>
<p>Mounted - Routable and route-less engines have slightly different concepts of
&quot;mounting&quot;. A routable engine is considered mounted when it has been included
by a router at one or more mount-points. A route-less engine is considered
mounted as soon as a route's <code>mount</code> call resolves.</p>
</li>
<li>
<p>Instantiated - When an engine is instantiated, an <code>EngineInstance</code> is created
and an engine's instance initializers are invoked. A routable engine is
instantiated when a route is visited at or beyond its mount-point. A
route-less engine is instantiated as soon as it is mounted.</p>
</li>
</ul>
<p>Special <code>before</code> and <code>after</code> hooks could be added to application instance
initializers that allow them to be ordered relative to engine instance
initializers.</p>
<h3 id="engine-boundaries"><a class="header" href="#engine-boundaries">Engine boundaries</a></h3>
<p>Besides its routing map, an engine does not share any other resources with its
parent by default. Engines maintain their own registries and containers, which
ensure that they stay isolated. However, some explicit sharing of resources
between engines and parents is allowed.</p>
<h4 id="engine--parent-dependencies"><a class="header" href="#engine--parent-dependencies">Engine / parent dependencies</a></h4>
<p>Dependencies between engines and parents can be defined imperatively or
declaratively.</p>
<p>Imperative dependencies can be defined in an engine's instance initializers.
When an engine is instantiated, the <code>parent</code> property on its <code>EngineInstance</code> is
set to its parent instance (either an <code>ApplicationInstance</code> or
<code>EngineInstance</code>). Since the engine instance is available in the instance
initializer, this <code>parent</code> property can also be accessed. This allows an engine
instance to interrogate its parent, specifically through its <code>RegistryProxy</code> and
<code>ContainerProxy</code> interfaces.</p>
<p>Alternatively, declarative dependencies can be defined on a limited basis. The
initial API will be limited: an engine can define an array of <code>services</code> that it
requires from its parent.</p>
<p>For example, the following engine expects its parent to provide <code>store</code> and
<code>session</code> services:</p>
<pre><code>import Ember from 'ember';

var Engine = Ember.Engine.extend({
  dependencies: {
    services: [
      'store',
      'session'
    ]
  }
});

export default Engine;
</code></pre>
<p>The parent application can provide a re-mapping of services from its namespace
to that of the engine via an <code>engines</code> declaration.</p>
<p>In the following example, the application shares its <code>store</code> service directly
with the <code>checkout</code> engine. It also shares its <code>current-user</code> service as the
<code>session</code> service requested by the engine.</p>
<pre><code>import Ember from 'ember';

var App = Ember.Application.extend({
  engines: {
    checkout: {
      dependencies: {
        services: [
          'store',
          {session: 'current-user'}
        ]
      }
    }
  }
});

export default App;
</code></pre>
<p>When engines are instantiated, the listed dependencies will be looked up on
the parent and made accessible within the engine.</p>
<p>Note that the <code>engines</code> declaration provides further space to define
characteristics about an engine, such as whether it should be eager or
lazy-loaded, URLs for manifest files, etc.</p>
<h1 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h1>
<p>This RFC introduces the new concept of engines, which increases the
learning curve of the framework. However, I believe this issue is
mitigated by the fact that engines are an opt-in packaging around
existing concepts.</p>
<p>In the end, I believe that &quot;engines&quot; are just a small API for composing
existing concepts. And they can be introduced at the top of the
conceptual ladder, once users are comfortable with the basics of Ember,
and only for those working on large teams or distributing addons.</p>
<h1 id="alternatives-3"><a class="header" href="#alternatives-3">Alternatives</a></h1>
<p>Several incomplete alternatives are discussed in the Motivations section above.</p>
<p>I know of no alternatives being discussed in the Ember community that meet the
same needs as engines; namely, for development <em>and</em> run-time isolation.</p>
<h1 id="unresolved-questions-3"><a class="header" href="#unresolved-questions-3">Unresolved questions</a></h1>
<h2 id="non-cli-users"><a class="header" href="#non-cli-users">Non-CLI Users</a></h2>
<p>This RFC assumes Ember CLI. I would prefer to prove this out in Ember
CLI before locking down the public APIs/hooks the router exposes for
locating and mounting engines. Once this is done, however, we should
expose and document those hooks so users who cannot use Ember CLI for
whatever reason can still take advantage of composability.</p>
<h2 id="declarative-dependencies"><a class="header" href="#declarative-dependencies">Declarative dependencies</a></h2>
<p>The initial scope of declarative dependency sharing is limited in scope to
services. Should other types of dependencies be declaratively shareable?
Should addons be the recommended path to share all other dependencies?</p>
<h2 id="async-mounting-of-route-less-engines"><a class="header" href="#async-mounting-of-route-less-engines">Async mounting of route-less engines</a></h2>
<p><code>Route#renderTemplate</code> is called synchronously, although <code>Route#mount</code> should
surely be async. How async mounting is represented in the route lifecycle is
TBD. A solution isn't proposed here because the problem is shared by routable
and async components, and a common solution should be reached.</p>
<h2 id="lazy-loading-manifests"><a class="header" href="#lazy-loading-manifests">Lazy loading manifests</a></h2>
<p>In order to facilitate lazy loading of engines, we will need to determine a
structure for manifest files that contain an engine's assets. Furthermore, an
application will need to be configurable with URLs for these manifests.</p>
<p>It's likely that an engine's routing map will always be needed at the time of
application deployment. Allowing lazy loading of routing maps would prevent the
formation of any links from a parent application into an engine's routes.</p>
<p>When developed in isolation as addons, engines will have their own sets of
dependencies. These dependencies will be treated like any other addons when
engines are deployed together with an application. However, in order to support
lazy loading, it would be ideal to dedupe dependencies in order to create a lean
and conflict-free asset manifest.</p>
<p>Reference: deduping strategy discussed by @wycats in
<a href="https://docs.google.com/a/tomdale.net/document/d/12CsR-zli5oP2TDWOef_-D28zjmbVD83hU4q9_VTk-9s/edit">this Google doc</a>.</p>
<h2 id="namespaced-access-to-engine-resources"><a class="header" href="#namespaced-access-to-engine-resources">Namespaced access to engine resources</a></h2>
<p>The concept of namespaced access to engine resources is mentioned above as a
potential goal of a future release of engines. This will require further
discussion to decide how it should work both technically and semantically, and
how it applies to lazy-loaded engines.</p>
<p>If these problems can be resolved, this feature would allow for more flexibility
in parent / engine interactions. Instead of just allowing engines to look up
resources in a parent, the inverse could also be allowed.</p>
<p>For example, if the <code>authentication</code> engine contains
<code>engines/authentication/models/user.js</code>, a parent application could look up this
same model through a namespace. Perhaps as follows:</p>
<pre><code class="language-js">container.lookup('authentication@model:user');
</code></pre>
<p>Other APIs in Ember would need to be extended to support namespaces to
take full advantage of this feature. For example, components that ship
with an engine might be accessed from the primary application like this:</p>
<pre><code class="language-handlebars">{{authentication@login-form obscure-password=true}}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-09-30
RFC PR: https://github.com/emberjs/rfcs/pull/11
Ember Issue: https://github.com/emberjs/ember.js/pull/9527</p>
<hr />
<h1 id="summary-4"><a class="header" href="#summary-4">Summary</a></h1>
<p>Improve computed property syntax</p>
<h1 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h1>
<p>Today, the setter variant of CP's is both confusing, and looks scary as sin.
(Too many concepts must be taught and it is too easy to screw it up.)</p>
<h1 id="detailed-design-4"><a class="header" href="#detailed-design-4">Detailed design</a></h1>
<h2 id="today"><a class="header" href="#today">today:</a></h2>
<pre><code class="language-js">fullName: Ember.computed('firstName', 'lastName', function(key, value) {
  if (arguments.length &gt; 1) {
    var names = value.split(' ');
    this.setProperties({
      firstName: names[0],
      lastName: names[1]
    });
    return value;
  }

  return this.get('firstName') + ' ' + this.get('lastName');
});
</code></pre>
<h2 id="tomorrow"><a class="header" href="#tomorrow">Tomorrow:</a></h2>
<pre><code class="language-js">fullName: Ember.computed('firstName', 'lastName', {
  get: function(keyName) {
    return this.get('firstName') + ' ' + this.get('lastName');
  },

  set: function(keyName, fullName, oldValue) {
   var names = fullName.split(' ');

   this.setProperties({
     firstName: names[0],
     lastName: names[1]
   });

   return fullName;
  }
});
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes:</a></h2>
<ul>
<li>we should keep <code>Ember.computed(fn);</code>  as shorthand for getter only</li>
<li><code>get</code> xor <code>set</code> variants would also be possible.</li>
<li><code>{ get() { } }</code> is es6 syntax for <code>{ get: function() { } )</code></li>
</ul>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<ul>
<li>1.x support both, detect new behaviour by testing if the last arg is not null and typeof object</li>
<li>1.x+1 deprecate if last arg is a function and its arity is greater than 1</li>
</ul>
<h1 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h1>
<p>N/A</p>
<h1 id="alternatives-4"><a class="header" href="#alternatives-4">Alternatives</a></h1>
<p>N/A</p>
<h1 id="unresolved-questions-4"><a class="header" href="#unresolved-questions-4">Unresolved questions</a></h1>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-05-16
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/12</p>
<hr />
<h1 id="summary-5"><a class="header" href="#summary-5">Summary</a></h1>
<p>This has come up in <a href="https://github.com/ember-cli/ember-cli/issues/3699">#3699</a> and <a href="https://github.com/EmberTown/ember-hearth/issues/66">EmberTown/ember-hearth/#66</a>.</p>
<p>In short, it would be nice for tools that depend on Ember-CLI to be able to read the help output as JSON (for example <code>ember g --help --json</code>).</p>
<h1 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h1>
<p>In our specific use case in <a href="https://github.com/EmberTown/ember-hearth/">Ember Hearth</a> we would like to be able to render a dynamic GUI for some tasks, like generating blueprints. This way we could also include any blueprints added by addons. This will also apply to any other tools interfacing with Ember-CLI.</p>
<h1 id="detailed-design-5"><a class="header" href="#detailed-design-5">Detailed design</a></h1>
<p>We should probably make the internal help-functions (like <code>printBasicHelp</code> and <code>printDetailedHelp</code>) use JSON internally, and parse to human readable before printing (unless <code>--json</code> is specified).</p>
<p>I'm imagining the json output would be something like this:</p>
<pre><code class="language-json">{
  &quot;name&quot;:&quot;generate&quot;,
  &quot;description&quot;:&quot;Generates new code from blueprints.&quot;,
  &quot;aliases&quot;:[&quot;g&quot;],
  &quot;flags&quot;:[
    {
      &quot;flag&quot;:&quot;--verbose&quot;,
      &quot;aliases&quot;:[&quot;-v&quot;],
      &quot;description&quot;:&quot;Verbose output&quot;
    }, {…}],
  &quot;commands&quot;:[
    {
      &quot;command&quot;:&quot;template&quot;,
      &quot;description&quot;:&quot;Generates a template.&quot;,
      &quot;arguments&quot;:[&quot;name&quot;]
    },
    {
      &quot;command&quot;:&quot;model&quot;,
      &quot;description&quot;:&quot;Generate an ember-data model.&quot;,
      &quot;arguments&quot;:[
        &quot;name&quot;,
        {
          &quot;argument&quot;:&quot;attr:type&quot;,
          &quot;description&quot;:&quot;Add attributes to the model, e.g. 'name:String age:Number'&quot;,
          &quot;multiple&quot;:true
        }]
    }, {…}]
}
</code></pre>
<p>Note that this output contains a bit more info than the current --help, specifically in the attr:type argument for the model command. This is something I feel is currently missing (I did not understand the model generator command without consulting a colleague, for example), and would be nice to add while we're at it.</p>
<p>It should be pretty straight forward to generate a human readable output from this JSON. There are a few things missing: However: The generate help command specifically groups commands by addon. I'm not sure how this should be accomplished, and if this matches the other help outputs. Ideally, any tools reading the JSON should be able to rely on the format being the same for all commands. This would keep the internals cleaner as well, including the human readable parser.</p>
<h1 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h1>
<ul>
<li>Requires rewrite of help methods, possibly also for some addons (unless we can provide backwards compatability)</li>
<li>Increases codebase size</li>
</ul>
<h1 id="alternatives-5"><a class="header" href="#alternatives-5">Alternatives</a></h1>
<ul>
<li>We could standardize help output enough that it can be safely regexed by other tools</li>
<li>We could not do this, and require any tools to update whenever Ember-CLI changes any commands</li>
</ul>
<h1 id="unresolved-questions-5"><a class="header" href="#unresolved-questions-5">Unresolved questions</a></h1>
<ul>
<li>Internal architecture specifics (rewrite printBasicHelp or create a new setup, etc)</li>
<li>Specifying JSON format details</li>
<li>List any dependencies, like docs, that will need to be updated with this change</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-12-03
RFC PR: https://github.com/emberjs/rfcs/pull/15
Ember Issue: This RFC is implemented over many Ember PRs</p>
<hr />
<h1 id="the-road-to-ember-20"><a class="header" href="#the-road-to-ember-20">The Road to Ember 2.0</a></h1>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>Today, we're announcing our plan for Ember 2.0. While the major version
bump gives us the opportunity to simplify the framework in ways that
require breaking changes, we are designing Ember 2.0 with migration in mind.</p>
<p>This is <strong>not</strong> a big-bang rewrite; we will continue development
on the <code>master</code> branch, and roll out changes incrementally on the 1.x
release train. The 2.0.0 release will simply remove features that have
been deprecated between now and then. Our goal is that you can move
your Ember app to 2.0 incrementally, one sprint at a time.</p>
<p>This RFC captures the results of the last two core team face-to-face
meetings, where we discussed community feedback about the future of the
project. While it explains the high-level goals and tries to paint a
picture of how all the pieces fit together, this document will be
updated over time with links to individual RFCs that contain additional
implementation detail.</p>
<p>We plan to flesh out these more-detailed RFCs in the next few weeks,
as the discussion here progresses, before finalizing this plan.</p>
<p>We are announcing Ember 2.0 through our community RFC process in advance
of a release, both so our proposals can be vetted by the community and
so the community can understand the goals and contribute their own ideas
back.</p>
<h2 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h2>
<h3 id="stability-without-stagnation"><a class="header" href="#stability-without-stagnation">Stability without Stagnation</a></h3>
<p>Ember is all about identifying common patterns that emerge from the web
development community and rolling them into a complete front-end stack.
This makes it easy to get started on new projects and jump into existing
ones, knowing that you will get a best-of-breed set of tools that the
community will continue to support and improve for years to come.</p>
<p>In the greater JavaScript community, getting the latest and greatest
often means rewriting parts of your apps once a year, as the community
abandons existing solutions in search of improvements. Progress is
important, but so is ending the constant cycle of writing and rewriting
that plagues so many applications.</p>
<p>The Ember community works hard to introduce new ideas with an eye
towards migration. We call this &quot;stability without stagnation&quot;, and it's
one of the cornerstones of the Ember philosophy.</p>
<p>Below, we introduce some of the major new features coming in Ember
2.0. Each section includes a transition plan, with details on how
we expect existing apps to migrate to the new API.</p>
<p>When breaking changes are absolutely necessary, we try to make those
changes ones you can apply without too much thought. We call these
&quot;mechanical&quot; refactors. Typically, they'll involve a change to
syntax without changing semantics. These are significantly easier to
adopt than those that require fundamental changes to your application
architecture.</p>
<p><strong>To further aid in these transitions, we are planning to add a new tab to the
Ember Inspector that will list all deprecations in your application</strong>,
as well as a list of the locations in the source code where the
deprecated code was triggered. This should serve as a convenient
&quot;punch list&quot; for your transitional work.</p>
<p>Every member of the core team works on up-to-date Ember applications,
and we feel the tension between stability and progress acutely. We want
to deliver cutting-edge products, but need to keep shipping, and many
companies that have adopted Ember for their products tell us the
same thing.</p>
<h3 id="big-bets"><a class="header" href="#big-bets">Big Bets</a></h3>
<p>In 2014, we made big bets in two areas, and they've paid off.</p>
<p>The first bet was on open standards: JavaScript modules, promises and
Web Components. We started the year off with globals-based apps,
callbacks and &quot;views&quot;, and incrementally (and compatibly) built towards
standards-based solutions as those standards solidified.</p>
<p>The second bet was that the community was as tired as we were of
hand-rolling their own build scripts for each project. We've invested
heavily in Ember CLI, giving us a single tool that unifies the community
and provides a venue for disseminating great ideas.</p>
<p><strong>In Ember 2.0, Ember CLI and ES6 modules will become first-class parts
of the Ember experience.</strong> We will update the website, guides, documentation,
etc. to teach new users how to build Ember apps with the CLI tools and
using JavaScript's new module syntax.</p>
<p>While globals-based apps will continue to work in 2.0, we may introduce
new features that rely on either Ember CLI or ES6 modules. <strong>You should
begin moving your app to Ember CLI as soon as possible.</strong></p>
<p>All of the apps maintained by the Ember core team have been migrated to
Ember CLI, and we believe that most teams should be able to make the
transition incrementally.</p>
<h3 id="learning-from-the-community"><a class="header" href="#learning-from-the-community">Learning from the Community</a></h3>
<p>We're well aware that we don't have a monopoly on good ideas, and we're
always analyzing competing frameworks and libraries to discover great
ideas that we can incorporate.</p>
<p>For example, AngularJS taught us the importance of making early on-ramp
easy, how cool directives/components could be, and how dependency
injection improves testing.</p>
<p>We've been analyzing and discussing React's approach to data flow and
rendering for some time now, and in particular how they make use of a
&quot;virtual DOM&quot; to improve performance.</p>
<p>Ember's view layer is one of the oldest parts of Ember, and was designed
for a world where IE7 and IE8 were dominant. We've spent the better part
of 2014 rethinking the view layer to be more DOM-aware, and the new
codebase (codenamed &quot;HTMLBars&quot;) borrows what we think are the
best ideas from React. We cover the specifics below.</p>
<p>React's &quot;virtual DOM&quot; abstraction also allowed them to simplify the
programming model of component-based applications. We really like these
ideas, and the new HTMLBars engine, landing in the next Ember release, lays
the groundwork for adopting the simplified data-flow model.</p>
<p><strong>In Ember 2.0, we will be adopting a &quot;virtual DOM&quot; and data flow model
that embraces the best ideas from React and simplifies communication
between components.</strong></p>
<p>Interestingly, we found that well-written Ember applications are already
written with this clear and direct data flow. This change will mostly
make the best patterns more explicit and easier for developers to find
when starting out.</p>
<h3 id="a-steady-flow-of-improvement"><a class="header" href="#a-steady-flow-of-improvement">A Steady Flow of Improvement</a></h3>
<p>Ember 1.0 shipped over a year ago and we have continued to improve the
framework while maintaining backwards-compatibility. We are proud of the
fact that Ember apps tend to track released versions.</p>
<p>You might expect us to do Ember 2.0 work on a separate &quot;2.0&quot; branch,
accumulating features until we ship. We aren't going to do that.</p>
<p>Instead, <strong>we plan to do the vast majority of new work on <code>master</code> (behind
feature flags), and land new features in 1.x as they become stable.</strong></p>
<p>The <code>2.0.0</code> release <strong>will simply remove the cruft</strong> that naturally
builds up when maintaining compatibility with old releases.</p>
<p>If we add features that change Ember idioms, we will add clear
deprecation warnings with steps to refactor to new patterns.</p>
<p>Our goal is that, as much as possible, people will be able to boot up
their app on the last <code>1.x</code> version, update to the latest set of idioms
by following the deprecation prompts, and have things working on <code>2.0</code>.</p>
<p>Because going from the last version of Ember 1.x to Ember 2.0 will be
just another six-week release, there simply won't be much time for us to
make it an incredibly painful upgrade. ;)</p>
<h2 id="simplifying-ember-concepts"><a class="header" href="#simplifying-ember-concepts">Simplifying Ember Concepts</a></h2>
<p>Ember evolved organically from a view-layer-only framework in 2011 into
the route-driven, complete front-end stack it is today. Along the way,
we've accumulated several concepts that are no longer widely used in idiomatic
Ember apps.</p>
<p>These vestigial concepts make file sizes larger, code more complex, and
make Ember harder to learn.</p>
<p><strong>Ember 2.0 is about simplification</strong>. This lets us reduce file sizes,
reduce code complexity, and generally make Ember apps easier to pick up
and maintain.</p>
<p>The high-level set of improvements that we have planned are:</p>
<ul>
<li>More intuitive attribute bindings</li>
<li>New HTML syntax for components</li>
<li>Block parameters for components</li>
<li>More consistent template scope</li>
<li>One-way data binding by default, with opt-in to mutable, two-way bindings</li>
<li>More explicit communication between components, which means less
implicit communication via two-way bindings</li>
<li>Routes drive components, instead of controller + template</li>
<li>Improved actions that are invoked inside components as simple callbacks</li>
</ul>
<p>In some sections, we provide estimates for when a feature will land.
These are our best-guesses, but because of the rapid-release train model
of Ember, we may be off by a version or two.</p>
<p>However, all features that are slated for &quot;before 2.0&quot; will land before
we cut over to a major new version.</p>
<h2 id="more-intuitive-attribute-bindings"><a class="header" href="#more-intuitive-attribute-bindings">More Intuitive Attribute Bindings</a></h2>
<p>Today's templating engine is the oldest part of Ember.js. Under the
hood, it generates a string of HTML and then inserts it into the page.</p>
<p>One unfortunate consequence of this architecture is that it is not
possible to intuitively bind values to HTML attributes.</p>
<p>You would expect to be able type something like:</p>
<pre><code class="language-handlebars">&lt;a href=&quot;{{url}}&quot;&gt;Click here&lt;/a&gt;
</code></pre>
<p>But instead, in today's Ember, you have to learn about and use the
<code>bind-attr</code> helper:</p>
<pre><code class="language-handlebars">&lt;a {{bind-attr href=url}}&gt;Click here&lt;/a&gt;
</code></pre>
<p>The new HTMLBars template engine makes <code>bind-attr</code> a thing of the past,
allowing you to type what you mean. It also makes it possible to express
many attribute-related concepts simply:</p>
<pre><code class="language-handlebars">&lt;a class=&quot;{{active}} app-link&quot; href=&quot;{{url}}.html&quot;&gt;Click here&lt;/a&gt;
</code></pre>
<h3 id="transition-plan"><a class="header" href="#transition-plan">Transition Plan</a></h3>
<p>The HTMLBars templating engine is being developed on master, and parts
of it have already landed in Ember 1.8. Doing the work this way means
that the new engine continues to support the old syntax: your existing
templates will continue to work.</p>
<p>The improved attribute syntax has not yet landed, but we expect it to
land before Ember 1.10.</p>
<p><strong>We do not plan to remove support for existing templating syntax (or
no-longer-necessary helpers like <code>bind-attr</code>) in Ember 2.0.</strong></p>
<h2 id="more-intuitive-components"><a class="header" href="#more-intuitive-components">More Intuitive Components</a></h2>
<p>In today's Ember, components are represented in your templates as
Handlebars &quot;block helpers&quot;.</p>
<p>The most important problem with this approach is that Handlebars-style
components do not work well with attribute bindings or the <code>action</code>
helper. In short, a helper that is meant to be used inside an HTML tag
cannot be used inside a call to a component.</p>
<p>Beginning in Ember 1.11, we will support an HTML-based syntax for
components. <strong>The new syntax can be used to invoke existing components,
and new components can be called using the old syntax.</strong></p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}}&gt;&lt;/my-video&gt;

&lt;!-- equivalent to --&gt;

{{my-video src=movie.url}}
</code></pre>
<h3 id="transition-plan-1"><a class="header" href="#transition-plan-1">Transition Plan</a></h3>
<p>The improved component syntax will (we hope) land in Ember 1.11. You can
transition existing uses of <code>{{component-name}}</code> to the new syntax
at that time. You will likely benefit by eliminating uses of computed
properties that can now be more tersely expressed using the
interpolation syntax.</p>
<p><strong>We have no plans to remove support for the old component syntax in
Ember 2.0.</strong></p>
<h2 id="block-parameters"><a class="header" href="#block-parameters">Block Parameters</a></h2>
<p>In today's templates, there are two special forms of built-in Handlebars
helpers: <code>#each post in posts</code> and <code>#with post as p</code>. These allow the
template inside the helper to retain the parent context, but get a piece
of helper-provided information as a named value (such as <code>post</code> in the previous examples).</p>
<pre><code>{{#with contact.person as p}}
  {{!-- this block of code is still in the parent's scope, but
        the #with helper provided a `p` name with a
        helper-provided value --}}
  &lt;p&gt;{{p.firstName}} {{p.lastName}}&lt;/p&gt;

  {{!-- `title` here refers to the outer scope's title --}}
  &lt;p&gt;{{title}}&lt;/p&gt;
{{/with}}
</code></pre>
<p>Today, this capability is hardcoded into the two special forms,
but it can be useful for other kinds of components. For example,
you may have a calendar component (<code>ui-calendar</code>) that displays a
specified month.</p>
<p>The <code>ui-calendar</code> component may want to allow users to supply a custom
template for each day in the month, but each repetition of the template
will need information about the day it represents (its day of the week,
date number, etc.) in order to render it.</p>
<p>With the new &quot;block parameters&quot; feature, any component will have
access to the same capability as <code>#each</code> or <code>#with</code>:</p>
<pre><code class="language-handlebars">&lt;ui-calendar month={{currentMonth}} as |day|&gt;
  &lt;p class=&quot;title&quot;&gt;{{day.title}}&lt;/p&gt;
  &lt;p class=&quot;date&quot;&gt;{{day.date}}&lt;/p&gt;
&lt;/ui-calendar&gt;
</code></pre>
<p>In this case, the <code>ui-calendar</code> component iterates over all of days
in <code>currentMonth</code>, rendering each instance of the template with
information about which date it should represent.</p>
<p>We also think that this feature will be useful to allow container
components (like tabs or forms) to supply special-case component
definitions as block params. We are still working on the details,
but believe that an approach along these lines could make these
kinds of components simpler and more flexible.</p>
<h3 id="transition-plan-2"><a class="header" href="#transition-plan-2">Transition Plan</a></h3>
<p>Block parameters will hopefully land in 1.12, and at that point the
two special forms for <code>{{each}}</code> and <code>{{with}}</code> will be deprecated.
You should refactor your templates to use the new block parameters
syntax once it lands, as it is a purely mechanical refactor.</p>
<p><strong>We have no plans to remove support for the <code>{{each}}</code> and <code>{{with}}</code>
special forms in Ember 2.0.</strong></p>
<h2 id="more-consistent-handlebars-scope"><a class="header" href="#more-consistent-handlebars-scope">More Consistent Handlebars Scope</a></h2>
<p>In today's Ember, the <code>each</code> and <code>with</code> helpers come in two flavors: a
&quot;context-switching&quot; flavor and a &quot;named-parameter&quot; flavor.</p>
<pre><code class="language-handlebars">{{#each post in posts}}
  {{!-- the context in here is the same as the outside context,
        and `post` references the current iteration --}}
{{/each}}

{{#each posts}}
  {{!-- the context in here has shifted to the individual post.
        the outer context is no longer accessible --}}
{{/each}}
</code></pre>
<p>This has proven to be one of the more confusing parts of the Ember
templating system. It is also not clear to beginners which to use,
and when they choose the context-shifting form, they lose access to
values in the outer context that may be important.</p>
<p>Because the helper itself offers no clue about the context-shifting
behavior, it is easy (even for more experienced Ember developers)
to get confused when skimming a template about which object a value
refers to.</p>
<p>In Ember 1.10, we will deprecate the context-shifting forms of
<code>#each</code> and <code>#with</code> in favor of the named-parameter forms.</p>
<h3 id="transition-plan-3"><a class="header" href="#transition-plan-3">Transition Plan</a></h3>
<p>To transition your code to the new syntax, you can change templates
that look like this:</p>
<pre><code class="language-hbs">{{#each people}}
  &lt;p&gt;{{firstName}} {{lastName}}&lt;/p&gt;
  &lt;p&gt;{{address}}&lt;/p&gt;
{{/each}}
</code></pre>
<p>with:</p>
<pre><code class="language-hbs">{{#each people as |person|}}
  &lt;p&gt;{{person.firstName}} {{person.lastName}}&lt;/p&gt;
  &lt;p&gt;{{person.address}}&lt;/p&gt;
{{/each}}
</code></pre>
<p><strong>We plan to deprecate support for the context-shifting helpers in Ember
1.10 and remove support in Ember 2.0.</strong> This change should be entirely
mechanical.</p>
<h2 id="one-way-bindings-by-default"><a class="header" href="#one-way-bindings-by-default">One-Way Bindings by Default</a></h2>
<p>After a few years of having written Ember applications, we have observed
that most of the data bindings in the templating engine do not actually
require two-way bindings.</p>
<p>When we designed the original templating layer, we figured that making
all data bindings two-way wasn't very harmful: if you don't set a
two-way binding, it's a de facto one-way binding!</p>
<p>We have since realized (with some help from our friends at React), that
components want to be able to hand out data to their children without
having to be on guard for wayward mutations.</p>
<p>Additionally, communication between components is often most naturally
expressed as events or callbacks. This is possible in Ember, but the
dominance of two-way data bindings often leads people down a path of
using two-way bindings as a communication channel. Experienced Ember
developers don't (usually) make this mistake, but it's an easy one to
make.</p>
<p>When you use the new component syntax, the <code>{{}}</code> interpolation syntax
defaults to creating one-way bindings in the components.</p>
<pre><code class="language-handlebars">&lt;my-video src={{url}}&gt;&lt;/my-video&gt;
</code></pre>
<p>In this example, the component's <code>src</code> property will be updated whenever
<code>url</code> changes, but it will not be allowed to mutate it.</p>
<p>If a template wishes to allow the component to mutate a property, it can
explicitly create a two-way binding using the <code>mut</code> helper:</p>
<pre><code class="language-handlebars">&lt;my-video paused={{mut isPaused}}&gt;&lt;/my-video&gt;
</code></pre>
<p>This can help ease the transition to a more event-based style of
programming.</p>
<p>It also eliminates the boilerplate associated with an event-based style
when working with form controls. Instead of copying state out of a
model, listening for callbacks, and updating the model, the <code>input</code>
helper can be given an explicit mutable binding.</p>
<pre><code class="language-handlebars">&lt;input value={{mut firstName}}&gt;
&lt;input value={{mut lastName}}&gt;
</code></pre>
<p>This is similar to the approach taken by <a href="http://facebook.github.io/react/docs/two-way-binding-helpers.html">React.Link</a>, but we think
that the use-case of form helpers is sufficiently common to make it
ergonomic.</p>
<h3 id="transition-plan-4"><a class="header" href="#transition-plan-4">Transition Plan</a></h3>
<p>The new one-way default is triggered by the use of new component syntax.
This means that component invocations in existing templates will
continue to work without changes.</p>
<p>When transitioning to the new HTML-based syntax, you will likely want to
evaluate whether bindings are actually being mutated, and avoid using
<code>mut</code> for values that the component never changes. This will make it
easier for future readers of your template to get an understanding of
what properties might be changed downstream.</p>
<p>To preserve the same semantics during a refactor to the new HTML-based
syntax, you can simply mark all bindings as <code>mut</code>.</p>
<pre><code class="language-handlebars">{{!-- these are semantically equivalent --}}

{{my-video src=movie.url paused=controller.isPaused}}

&lt;my-video src={{mut movie.url}} paused={{mut controller.isPaused}}&gt;
&lt;/my-video&gt;
</code></pre>
<p>While the above example preserves the same mutability semantics, it
should be clear that the video player component should never change the
<code>url</code> of the <code>movie</code> model.</p>
<p>To make sure you get an exception should this ever happen, simply remove
the <code>mut</code>:</p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}} paused={{mut controller.isPaused}}&gt;
&lt;/my-video&gt;
</code></pre>
<p><strong>We have no plans to remove the old-style component syntax in Ember
2.0, so the semantics of existing component invocations will not
change.</strong></p>
<h2 id="separated-component-parameters"><a class="header" href="#separated-component-parameters">Separated Component Parameters</a></h2>
<p>In today's Ember, parameters passed to components as attributes become
properties of the component itself, putting them in the same place as
other internal state.</p>
<p>This can be somewhat confusing, because it may not be obvious to the
reader of a component's JavaScript or template which values are
internal, and which are passed in as part of the public API.</p>
<p>To remind themselves, many Ember users write their components like this:</p>
<pre><code class="language-js">export default Component.extend({
  /* Public API */

  src: null,
  paused: null,
  title: null,

  /* Internal */
  scrubber: null
})
</code></pre>
<p>It can also be unclear how to react to a change in the external
properties. It is possible to use observers for this purpose in Ember,
but observers feel low-level and do not coordinate very well with the
rendering process.</p>
<p>To reduce confusion, we plan to move external attributes into a new
<code>attrs</code> hash.</p>
<p>If you invoke a component like this:</p>
<pre><code class="language-handlebars">&lt;my-video src={{movie.url}}&gt;&lt;/my-video&gt;
</code></pre>
<p>then the <code>my-video</code> component accesses the passed-in <code>src</code> attribute as
<code>this.attrs.src</code>.</p>
<p>We also plan to provide lifecycle callbacks (modelled after <a href="http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">React's
lifecycle callbacks</a>) for changes to <code>attrs</code> that will
integrate with the rendering lifecycle. We plan to supplement the API
with callbacks for changes in individual properties as well.</p>
<h3 id="transition-plan-5"><a class="header" href="#transition-plan-5">Transition Plan</a></h3>
<p>In Ember 1.10, we will begin installing provided attributes in the
component's <code>attrs</code> hash. If a provided attribute is accessed directly
on the component, a deprecation warning will be issued.</p>
<p>In applications, you should update your component JavaScript and
templates to access provided attributes via the component's <code>attrs</code>
property.</p>
<p><strong>In Ember 2.0, we will stop setting attributes as properties on the
component itself.</strong></p>
<p>We will also provide a transitional mixin that Ember addons can use that
will make provided attributes available as <code>attrs.*</code>. This will allow
add-ons to move to the new location, while maintaining support for older
versions of Ember. We expect people to upgrade to Ember 1.10 relatively
quickly, and do not expect addons to need to maintain support for Ember
1.9 indefinitely.</p>
<h2 id="routeable-components"><a class="header" href="#routeable-components">Routeable Components</a></h2>
<p>Many people have noticed that controllers in Ember look a lot like
components, but with an arbitrary division of responsibilities. We
agree!</p>
<p>In current versions of Ember, when a route is entered, it builds a
controller, associates a model with it, and hands it off to an
(old-style) view for rendering. The view itself is invisible; you just
write a template with the correct name.</p>
<p>We plan to transition to: when a route is entered, it renders a
<strong>component</strong>, passing along the model as an <code>attr</code>. This eliminates a
vestigial use of old-style views, and associates the top-level template
with a regular component.</p>
<h3 id="transition-plan-6"><a class="header" href="#transition-plan-6">Transition Plan</a></h3>
<p>Initially, we will continue to support routing to a controller+template,
so nothing will break. Going forward, routes will route to a component
instead.</p>
<p>In order to do that refactoring, several things will change:</p>
<ul>
<li>Instead of referring to model properties directly (or on <code>this</code>), you
will refer to them as <code>model.propName</code>.</li>
<li>Similarly, computed properties that move to your component will need
to depend on <code>model.propName</code> if they are migrated from an
<code>ObjectController</code>.</li>
<li>In both cases, the short version is that you can no longer rely on the
proxying behavior of <code>ObjectController</code> or <code>ArrayController</code>, but you
can remedy the situation by prefixing <code>model.</code> to the property name.</li>
<li>Unlike controllers, top-level components do not persist across
navigation. Persistent state should be stored in route objects and
passed as initial properties to routable components.</li>
<li>In addition to the asynchronous <code>model</code> hook in routes, routes will
also be able to define a <code>attrs</code> hook, which can return additional
asynchronous data that should be provided to the component.</li>
<li>Routeable Components should be placed in a &quot;pod&quot; naming convention. For 
example, the component for the <code>blog-post</code> route would be
<code>app/blog-post/component.js</code>.</li>
</ul>
<p><strong>We plan to land support for routeable components in Ember 1.12, and
deprecate routeable controllers at the same time. We plan to remove
support for routeable controllers in Ember 2.0.</strong> This will allow
you to move your codebases over to routeable components piecemeal before
making the jump to 2.0.</p>
<p><strong>We will also provide an optional plugin for Ember 2.0 apps that restores
existing behavior.</strong> This plugin will be included in the Ember automated
test suite to ensure that we do not introduce accidental regressions in
future releases on the 2.x series.</p>
<p>We realize that this is the change has the largest transitional cost of
all the planned features, and we plan to dedicate time to the precise
details in the full RFC on this topic.</p>
<h2 id="improving-actions"><a class="header" href="#improving-actions">Improving Actions</a></h2>
<p>Today's components can communicate with their parent component through
actions. In particular, the <code>sendAction</code> method allows a child component
to invoke a named action on the parent (inside of the <code>actions</code> hash).</p>
<p>Part of the reason for this API was a limitation in the original
Handlebars syntax:</p>
<pre><code class="language-handlebars">{{!-- we can't get too fancy with the value of key-press --}}
{{input key-press=&quot;valueChanged&quot;}}
</code></pre>
<p>In this example, when the <code>input</code> component calls
<code>this.sendAction('key-press')</code>, it invokes the <code>valueChanged</code> action on
its parent component.</p>
<p>With the new HTML syntax for components, we have more flexibility:</p>
<pre><code class="language-handlebars">&lt;input key-press={{action &quot;valueChanged&quot;}}&gt;
</code></pre>
<p>This will package up the parent's <code>valueChanged</code> action (in the
<code>actions</code> hash) as a callback function that is available to the child
component as <code>this.attrs['key-press']</code>.</p>
<pre><code class="language-js">export default Ember.Component.extend({
  keypress: function(event) {
    this.attrs['key-press'](event.target.value);
  }
});
</code></pre>
<p>The benefit of this approach is twofold:</p>
<ul>
<li>Actions are no longer treated specially in the component API. They are
simply properties packaged up to be called by the child component.</li>
<li>It is possible to pass an alternative function as the <code>key-press</code>,
reducing the child component's knowledge of what the callback is
doing. This has testing and abstraction benefits.</li>
</ul>
<h3 id="transition-plan-7"><a class="header" href="#transition-plan-7">Transition Plan</a></h3>
<p>We will continue to support the <code>sendAction</code> API for the forseeable
future in today's Handlebars syntax.</p>
<p>When calling an existing component with new HTMLBars syntax, you do not
need to change your existing <code>actions</code> hash. You should change syntax
that looks like this:</p>
<pre><code class="language-handlebars">{{video-player playing=&quot;playingBegins&quot;}}
</code></pre>
<p>To this:</p>
<pre><code class="language-handlebars">&lt;video-player playing={{action &quot;playingBegins&quot;}}&gt;
</code></pre>
<p>The <code>video-player</code> component's internal use of <code>sendAction</code> will work
with both calling styles.</p>
<p>New components should use <code>this.attrs.playing()</code>, but existing components
that want to continue supporting legacy callers should continue to use
<code>sendAction</code> for now. The <code>sendAction</code> API will seamlessly support both
calling styles, and will be supported for the forseeable future.</p>
<pre><code class="language-js">// instead of
this.sendAction('progress', value);

// new code can use
this.attrs.progress(value);
</code></pre>
<h2 id="onward"><a class="header" href="#onward">Onward</a></h2>
<p>Version 2.0 marks the transformation of Ember from simply an MVC framework
to a complete front-end stack. Between Ember's best-in-class router,
revamped components with virtual DOM, easy-to-use build tools, and a growing
ecosystem that makes taking advantage of additional libraries a breeze, there's
no better way to get started and stay productive developing web apps today.</p>
<p>Hopefully, this plan demonstrates that staying on the cutting-edge can be done
without rewriting your app. There are a huge number of Ember apps in production
today, and we're looking forward to a time in the very near future where they
can start to take advantage these new features.</p>
<p>Expect to see many more RFCs covering these features in depth soon (including
a roadmap for Ember Data 1.0). We look forward to hearing your feedback!</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-07-10
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/20</p>
<hr />
<h1 id="summary-6"><a class="header" href="#summary-6">Summary</a></h1>
<p>Enable <a href="http://www.w3.org/TR/SRI/">Subresource Integrity [SRI]</a> checks by default.</p>
<h1 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h1>
<p>To promote the use of SRI in Ember apps as a safe default. Applications should be built with integrity attributes when it is safe to do so. (Unfortunately the main advantage won't be met by default, however confirming one attribute will)</p>
<p>This solves having poisoned CDN content: <a href="https://blog.cloudflare.com/an-introduction-to-javascript-based-ddos/">An introduction to JavaScript-based DDoS</a></p>
<h1 id="detailed-design-6"><a class="header" href="#detailed-design-6">Detailed design</a></h1>
<p>Install <a href="https://www.npmjs.com/package/ember-cli-sri">ember-cli-sri</a> by default.</p>
<ul>
<li>Applications with relative paths will get SRI.</li>
<li>Applications with <code>SRI.crossorigin</code> will get SRI on <code>fingerprint.prepend</code> assets</li>
<li>Applications with <code>fingerprint.prepend</code> and <code>origin</code> specified and matching get a <code>SRI.crossorigin</code> of anonymous on <code>fingerprint.prepend</code> assets</li>
</ul>
<p>By default development environments wont run SRI for performance reasons.</p>
<p>Further explanation available in: <a href="https://www.npmjs.com/package/ember-cli-sri">ember-cli-sri</a></p>
<h1 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h1>
<ul>
<li>SRI won't always be on for sites with prepend due to SRI requiring CORS.</li>
<li>CORS requirement adds a barrier to entry to some users.</li>
<li>Broken SRI attrs would break the application.</li>
</ul>
<h1 id="alternatives-6"><a class="header" href="#alternatives-6">Alternatives</a></h1>
<p>No other alternatives appear suitable.</p>
<h1 id="unresolved-questions-6"><a class="header" href="#unresolved-questions-6">Unresolved questions</a></h1>
<ul>
<li>Adding origin attribute to add a safe same-origin check that doesn't need CORS.</li>
<li>Could users be warned until they explicitly set <code>SRI.enabled = false</code> or <code>SRI.crossorigin = </code>?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-08-18
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/23</p>
<hr />
<h1 id="summary-7"><a class="header" href="#summary-7">Summary</a></h1>
<p>Adds command line completion <em>(tab completion)</em> to ember-cli that fills in partially typed commands by the user and suggests available sub commands or options. <em>(from now on i will refer to &quot;strings in the command line&quot; as &quot;cli-commands&quot; and &quot;generate&quot; and &quot;new&quot; as unprefixed &quot;commands&quot;)</em></p>
<h1 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h1>
<p>With all the already existing commands and especially all blueprints, plus the fact that any addon can add even more blueprints to your tool kit, users can get overwhelmed. Currently, when you want to execute a specific task and you don't quite know the correct cli-command you have to invoke <code>ember help</code> which is noisy and slow <em>( especially when you just want to know the spelling of a specific thing)</em>. This feature will enable the user to choose from all existing cli-commands by pressing <strong>[tab]</strong> or just to let ember-cli fill partially typed cli-commands for speed.</p>
<h1 id="detailed-design-7"><a class="header" href="#detailed-design-7">Detailed design</a></h1>
<p>The two main components of that feature are a <strong>completion function</strong> that is responsible for the actual tab-completion, and a <strong>generation function</strong> that will write the cli-command hierarchy together with metadata into a JSON file for fast processing.</p>
<h2 id="completion-function"><a class="header" href="#completion-function">completion function</a></h2>
<p>To enable this feature, a <strong>completion function</strong> will run at the main entry point of the process <em>(making use of  <a href="https://github.com/f/omelettev">omelette</a> for shell completion)</em>. On every <strong>[tab]</strong> it will parse the command line and either completes a partially typed, unambiguous cli-command, or suggests possible cli-commands for the current context.</p>
<p>The user interface will work as you would expect it from a shell completion:</p>
<ul>
<li>
<p>it suggests all commands if none are typed yet</p>
<pre><code>  $ ember &lt;tab&gt;
  &gt; addon     destroy   help      install   serve     version
    build     generate  init      new       test
</code></pre>
</li>
<li>
<p>it completes partially typed commands</p>
<pre><code>  $ ember gen&lt;tab&gt;
  $ ember generate
</code></pre>
</li>
<li>
<p>it completes to suggests commands based on user input (note how it <strong>should</strong> understand aliases)</p>
<pre><code>  $ ember g ad&lt;tab&gt;
  &gt; adapter       adapter-test  addon
</code></pre>
</li>
<li>
<p>it, by default, will not suggest options</p>
<pre><code>  $ ember g resource &lt;tab&gt;
</code></pre>
</li>
<li>
<p>it will suggest options on demand (note how it <strong>should</strong> know when an option needs a value)</p>
<pre><code>  $ ember g resource post --&lt;tab&gt;
  --dry-run         --in-repo-addon=  --verbose
  --dummy           --pod
</code></pre>
</li>
</ul>
<h2 id="generation-function"><a class="header" href="#generation-function">generation function</a></h2>
<p>For a good user experience we don't want to figure out those suggestions on runtime or the completion feature would not be substantially faster then the <code>ember help</code> command. So there will be a <strong>generation function</strong> that generates a JSON file once after ember-cli is installed and then during every <code>ember install some-addon</code> command to ensure that blueprints added by new addons are recognized aswell.</p>
<p>Here an example snippet of a cli-command with one cli-subcommand:</p>
<pre><code>  ...
  {
    &quot;name&quot;: &quot;command-name&quot;,
    &quot;aliases&quot;: [
      &quot;cn&quot;,
      &quot;c&quot;
    ],
    &quot;options&quot;: [
    ],
    &quot;commands&quot;: [
      {
        &quot;name&quot;: &quot;some-subcommand&quot;,
        &quot;aliases&quot;: [
        ],
        &quot;options&quot;: [
          {
            &quot;name&quot;: &quot;pods&quot;,
            &quot;type&quot;: &quot;boolean&quot;
          }
        ],
        &quot;commands&quot;: [
        ]
      }
    ]
  }
  ...
</code></pre>
<p>The <strong>generation function</strong> will, as a first step, iterate over all commands and reads the following properties:</p>
<ul>
<li><strong>name:</strong> a string, the autocompletion function will suggest</li>
<li><strong>aliases:</strong> this is what the autocompletion function will accept in the cli-command chain</li>
<li><strong>availableOptions:</strong> an array of options that need to have a <code>name</code> and a <code>type</code> property those will be accumulated for every cli-command in the cli-command chain and suggested on <code>some-command --&lt;tab&gt;</code></li>
<li><strong>cliCommands:</strong> can either be an array or a function that returns an array of objects that themselfs will be parsed for the properties in this list those cli-commands will be accepted as subcommands of the current cli-command.</li>
<li><strong>skipHelp:</strong> whenever this property is set to true, the cli-command will also not be suggested by the autocompletion</li>
</ul>
<p>Whenever an object does not have one of the above properties, a reasonable default is chosen (except for <code>name</code>. If it has no name, it will not be shown at all). This way it is easy to extend that feature in the future to handle arbitrary nested cli-commands.</p>
<h1 id="alternatives-7"><a class="header" href="#alternatives-7">Alternatives</a></h1>
<ul>
<li>Currently the <strong>completion function</strong> will just expect certain properties to be on a cli-command, this way most commands and blueprints work out of the box but maybe some architectual pattern, like a cli-command mixin or the like would be more robust and obvious.</li>
<li>Someone with more experience with ember-cli could have an idea of how to generate all cli-commands fast enough at runtime. So that we would not need to store the data in a JSON file.</li>
</ul>
<h1 id="unresolved-questions-7"><a class="header" href="#unresolved-questions-7">Unresolved questions</a></h1>
<p>Currently the autocompletion will figure out your default shell and configures it to allow tab-completion for ember. However on <strong>first-time usage</strong> you would need to resource your config file (or close and open your terminal) and I haven't figured out how to do this programmatically.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-11-26 
RFC PR: https://github.com/emberjs/rfcs/pull/24</p>
<hr />
<h1 id="summary-8"><a class="header" href="#summary-8">Summary</a></h1>
<p>Unlike Handlebars, HTMLBars parses HTML as it parses a template.
Bound attributes are one syntax now possible.</p>
<p>For example, this variable <code>color</code> is bound to set a class:</p>
<pre><code class="language-hbs">&lt;div class=&quot;{{color}}&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Though traditional HTML attribute syntax should be preserved (using
<code>class</code> and not <code>className</code> for example), the default path will be
to set attributes as properties on the DOM node.</p>
<p>However this happy path has several important exceptions, and results
in a few strange edge cases. This rfc will go into detail about the
expected behavior without talking about the implementation of attribute
on the Ember rendering pipeline.</p>
<h1 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h1>
<p><code>{{bind-attr</code> is a verbose syntax and difficult for new developers to
understand.</p>
<h1 id="detailed-design-8"><a class="header" href="#detailed-design-8">Detailed design</a></h1>
<p>Given a use of bound attributes:</p>
<pre><code class="language-hbs">&lt;input type=&quot;checkbox&quot; checked={{isChecked}}&gt;
</code></pre>
<p>There are three important inputs:</p>
<ul>
<li>The element (<code>tagName</code>, <code>namespaceURI</code>)</li>
<li>The attribute name</li>
<li>The value (literal or stream)</li>
</ul>
<p>The following described the algorithm for updating the attribute/property
value on an element.</p>
<ol>
<li>If the element has an SVG namespace, use <code>setAttribute</code>. Setting SVG attributes
as properties is not supported.</li>
<li>If the attribute name is <code>style</code>, use <code>setAttribute</code>.</li>
<li>Normalize the property name as described in <code>propertyNameFor</code> below. If a normalized
name is returned, set that property on the element (<code>element[normalizedPropName]</code>).
If it is not returned, set with <code>setAttribute</code>.</li>
</ol>
<p><code>propertyNameFor</code> is a normalization setup for attribute names that takes the element
and attribute name as input.</p>
<ol>
<li>Build a list of normalized properties for the passed element <code>normalizedAttrs[element.tagName][elementAttrName.toLowerCase()] = elementAttrName</code></li>
<li>Fetch the normalized property name from this list <code>normalizedAttr = normalizedAttrs[element.tagName][passedAttrName.toLowerCase()]</code></li>
<li>Return this normalized attr. If an <code>attrName</code> is did not normalize to a property (for example <code>class</code>), null is returned</li>
</ol>
<h3 id="acknowledged-edge-cases"><a class="header" href="#acknowledged-edge-cases">Acknowledged edge cases</a></h3>
<ul>
<li>Boolean attrs with blank string won't work like they would in HTML: <code>&lt;input disabled=&quot;{{blankString}}&quot;&gt;</code> would be false</li>
<li>Some selectors may not work as expected. <code>&lt;input value=&quot;{{color}}&quot;&gt;</code> will not result in a working <code>[value=red]</code> selector</li>
</ul>
<h1 id="drawbacks-7"><a class="header" href="#drawbacks-7">Drawbacks</a></h1>
<p>None.</p>
<h1 id="alternatives-8"><a class="header" href="#alternatives-8">Alternatives</a></h1>
<p>Two obvious alternatives considered in detail are Angular and React.</p>
<p>In <strong>Angular 2.0</strong>, <a href="http://www.beyondjava.net/blog/angularjs-2-0-sneak-preview-data-binding/">a new prop/attr/event syntax</a>
is being introduced.</p>
<p>Setting an attribute just like setting an HTML attribute:</p>
<pre><code class="language-html">&lt;pui-tab title=&quot;What a nice tab!&quot;&gt;
</code></pre>
<p>Properties are flagged with the <code>[]</code> syntax:</p>
<pre><code class="language-html">&lt;input [disabled]=&quot;controller.isInputDisabled&quot;&gt;
</code></pre>
<p>Angular is limited by it's HTML templating here. The value must be quoted
to have complex content, where as in HTMLBars it is easier to bend the
rules to introduce literal values: <code>disabled={{controller.isInputDisabled}}</code>.</p>
<p>Events are out of our immediate purview in this RFC, but for completeness
note Angular's syntax:</p>
<pre><code class="language-html">&lt;button (click)=&quot;hide()&quot;&gt;hide image&lt;/button&gt;
</code></pre>
<p><strong>React's JSX</strong> has its own <a href="http://facebook.github.io/react/docs/jsx-in-depth.html">property syntax</a>,
one that diverges from traditional HTML by focusing entirely on properties
instead of attributes. This means the templates are well prepared for
use with components, but also that JSX must maintain a large whitelist of
special cases such as <a href="http://facebook.github.io/react/docs/tags-and-attributes.html">supported tags</a>
and <a href="http://facebook.github.io/react/docs/jsx-gotchas.html">some HTML attributes</a>.</p>
<p>In general we would prefer to have Ember templates be as close to HTML
as possible, without requiring developers to learn a new set of property
names replacing the attribute names they already know.</p>
<h1 id="unresolved-questions-8"><a class="header" href="#unresolved-questions-8">Unresolved questions</a></h1>
<ul>
<li>How do we deal with <code>on*</code> attributes?</li>
<li>Should we do anything special about generic element properties like <code>&lt;div outerhtml={{lol}}&gt;&lt;/div&gt;</code>?</li>
<li>Should HTMLBars unbound attributes use the same alorithm?</li>
</ul>
<p>There is a spike of significant depth <a href="https://github.com/emberjs/ember.js/pull/9721">in PR #9721</a>
and a followup <a href="https://github.com/emberjs/ember.js/pull/9977">in PR #9977</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-11-02
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/28</p>
<hr />
<h1 id="summary-9"><a class="header" href="#summary-9">Summary</a></h1>
<p>Allow <code>app.import</code> to specify outputFIle of a given import.
The default <code>app.import</code> would be considered to have an outputFile of
<code>assets/vendor.js</code></p>
<h1 id="motivation-10"><a class="header" href="#motivation-10">Motivation</a></h1>
<p>It is common for individuals to want control over the outputFile for a given
dependency. For example, one may want to load some asm.js code independently
rather then via the single vendor.js blob.</p>
<p>It is also common for developers to want to group various dependencies
together, and then lazy-load them in the routes they are required.</p>
<p>Although not as automatic as we would like, it does provide a rather elegant
escape valve. Further work will likely continue to explore automation.</p>
<h1 id="detailed-design-9"><a class="header" href="#detailed-design-9">Detailed design</a></h1>
<p><code>outputFile:</code> option, specifies the target file for the given import. If
multiple imports share an outputFile, they will be concatenated (regardless of
type, css/images/videos/js/txt) in the order they where imported.</p>
<p><code>outputFile:</code> will default to <code>assets/vendor.js</code></p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h4 id="variation-0-the-default"><a class="header" href="#variation-0-the-default">variation 0: the default</a></h4>
<pre><code class="language-js">app.import('vendor/vim.js', { outputFile: 'assets/vendor.js'});
</code></pre>
<h4 id="variation-1-1-file---1-outputfile"><a class="header" href="#variation-1-1-file---1-outputfile">variation 1: 1 file -&gt; 1 outputFile</a></h4>
<pre><code class="language-js">app.import('vendor/vim.js', { outputFile: 'assets/vim.js'});
</code></pre>
<ul>
<li><code>vendor/vim.js</code> becomes <code>assets/vim.js</code></li>
<li>in prod it is:
<ul>
<li>uglified (unless using the uglify options it is excluded)</li>
<li>fingerprinted (unless it is excluded via the asset-rev options)</li>
</ul>
</li>
</ul>
<h4 id="variation-2-multiple-files-to-same-outputfile"><a class="header" href="#variation-2-multiple-files-to-same-outputfile">variation 2, multiple files to same outputFile</a></h4>
<pre><code class="language-js">app.import('vendor/dependency-1.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-2.js', { outputFile: 'assets/alternate-vendor.js'});
</code></pre>
<ul>
<li>in-order of the corresponding <code>app.import</code> invocation, using sourceMap
concat, the files are combined into <code>assets/alternate-vendor.js</code>
<ul>
<li><code>vendor/dependency-1.js</code> + <code>vendor/dependency-2.js</code> &gt;&gt; <code>assets/alternative-vendor.js</code></li>
</ul>
</li>
</ul>
<h4 id="variation-n-multiple-files-to-same-outputfile"><a class="header" href="#variation-n-multiple-files-to-same-outputfile">variation n, multiple files to same outputFile</a></h4>
<pre><code class="language-js">app.import('vendor/dependency-1.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-2.js', { outputFile: 'assets/alternate-vendor.js'});
app.import('vendor/dependency-n.js', { outputFile: 'assets/alternate-vendor.js'});
</code></pre>
<ul>
<li>resulting concat is:
<ul>
<li><code>vendor/dependency-1.js</code> + <code>vendor/dependency-2.js</code> ... <code>vendor/dependency-n.js</code>&gt;&gt; <code>assets/alternative-vendor.js</code></li>
</ul>
</li>
</ul>
<h1 id="drawbacks-8"><a class="header" href="#drawbacks-8">Drawbacks</a></h1>
<ul>
<li>potential overlap with @chadhietala's packager/linker work</li>
<li>does not offer additional build-pipeline hooks for these files</li>
</ul>
<h1 id="alternatives-9"><a class="header" href="#alternatives-9">Alternatives</a></h1>
<p>Alternatives exist, such as adding support to the linker/packager
effort, or instructing developers to drop down and use
broccoli-funnel/source-map-concat.</p>
<p>The linker/packager effort is still a ways off, and could be thought of as
complementary.</p>
<p>Dropping down to broccoli is a solution available today, but for this problem,
it feels like a slightly too low level of abstraction.</p>
<h1 id="unresolved-questions-9"><a class="header" href="#unresolved-questions-9">Unresolved questions</a></h1>
<ul>
<li>how does this relate to <code>type</code> in <code>app.import(..., { type: ... })</code> ?</li>
<li>should additional build-steps be allowed for specific output files? (I
suspect maybe, but a future RFC can likely explore)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-11-11
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/29</p>
<hr />
<h1 id="summary-10"><a class="header" href="#summary-10">Summary</a></h1>
<p>It should be possible to white- and/or blacklist addons in <code>EmberApp</code>.</p>
<h1 id="motivation-11"><a class="header" href="#motivation-11">Motivation</a></h1>
<p>If there are two (or more) <code>EmberApp</code>s, it's very likely that not all applications need all addons.
E.g. if there is a main page application and one application for embeddable widgets, the main page might need all sorts of addons like <code>ember-modal-dialog</code> which adds completely useless bytes to widgets javascript and css files for the widgets. Other addons may add useless initializers or other things that have runtime performance penalties for no benefit.</p>
<h1 id="detailed-design-10"><a class="header" href="#detailed-design-10">Detailed design</a></h1>
<p>When EmberApp ctor gets passed a blacklist like this</p>
<pre><code class="language-javascript">  EmberApp({
    addonBlacklist: ['ember-modal-dialog']
  });
</code></pre>
<p>it won't add addons whose <code>name</code> matches <code>ember-modal-dialog</code> to the list of addons for this app, just as if the addon's <code>isEnabled()</code> hook returned <code>false</code>.</p>
<p>C.f. https://github.com/ember-cli/ember-cli/blob/master/lib/broccoli/ember-app.js#L344, this is also were I would add this check.</p>
<p>Whitelist could work analogously.</p>
<h1 id="drawbacks-9"><a class="header" href="#drawbacks-9">Drawbacks</a></h1>
<ul>
<li>
<p>It adds a bit of API surface while you (possibly) don't care for the multiple app use case of ember-cli.</p>
</li>
<li>
<p>It kinda makes the <code>name</code> of an addon public api, so people might change it, not noticing they are breaking people's build (and people might not notice it either). Some addons have names like <code>Ember CLI ic-ajax</code> which seems awkward to use as an identifier.</p>
</li>
</ul>
<h1 id="alternatives-10"><a class="header" href="#alternatives-10">Alternatives</a></h1>
<ul>
<li>Add a unified way to enable/disable an addon via normal config
<ul>
<li>if that is added one day, the white/blacklist could still be an abstraction for that</li>
</ul>
</li>
</ul>
<h1 id="unresolved-questions-10"><a class="header" href="#unresolved-questions-10">Unresolved questions</a></h1>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-06-07
RFC PR: https://github.com/emberjs/rfcs/pull/45</p>
<hr />
<h1 id="summary-11"><a class="header" href="#summary-11">Summary</a></h1>
<p>Solicit feedback about the support timeframe for Internet Explorer 8 and Internet Explorer 9.</p>
<h1 id="motivation-12"><a class="header" href="#motivation-12">Motivation</a></h1>
<p>As Ember heads towards version 2.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 2.0 until Ember 3.0.</p>
<p>Ember 1.x did not have an official browser support matrix, but we would like to correct this for Ember 2.0.</p>
<p>We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.</p>
<p>Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, no one was still supporting IE8.</p>
<p>Because of this, the core team's impression is that the costs of IE8 support now far exceed the benefits, and we are considering dropping support
for IE8 in Ember 2.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE8 incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.</p>
<p>Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. All of these are shackled to the limitations of IE8, and by dropping support for IE8, people can begin to rely on the improved baseline of ES5.</p>
<p>Below, we outline the costs of continuing to support IE8, so that you can help us make a considered decision.</p>
<h1 id="detailed-design-11"><a class="header" href="#detailed-design-11">Detailed design</a></h1>
<h2 id="ie8"><a class="header" href="#ie8">IE8</a></h2>
<h3 id="eliminate-get"><a class="header" href="#eliminate-get">Eliminate <code>get()</code></a></h3>
<p>Currently, accessing properties on an Ember object requires using the <code>.get()</code> method. By using this abstraction, we have been able to implement several powerful features, such as proxies and computed properties, even on older browsers like IE8 that lack getters and setters.</p>
<p>However, ECMAScript 5, which shipped in <strong>2009</strong>, added support for getters to JavaScript itself, and we would like to use this feature in Ember to eliminate the explicit calls to <code>get</code>. Developers new to the framework tell us that having to remember to use <code>.get()</code> is a big source of confusion. More seasoned developers get used to it, but moving the Ember object model closer to the pure JavaScript object model is a major goal for Ember 2.x. While many of the features of ES6 classes can be transpiled, getters and setters require engine support, and could not be used if we needed to support IE8.</p>
<h3 id="more-es6-features-today"><a class="header" href="#more-es6-features-today">More ES6 Features, Today</a></h3>
<p>While much of ES6 can be transpiled correctly to ES3 (the version of JavaScript included with IE8), transpiling ES6 modules and classes requires <code>defineProperty</code>.</p>
<p>Continued support for IE8 limits our ability to adopt new ES6 features in the internals of Ember, and to talk about them in our documentation.</p>
<p>One example: In ES6, classes define their methods as non-enumerable properties. Transpiling this to existing browsers is only possible with <code>defineProperty</code>, which is not included in IE8. Trying to transpile ES6 classes to work on IE8 would lead to apps exhibiting subtly different behavior that would be painful to debug. IE8 users would discover that the larger Ember ecosystem was incompatible with their apps in hard-to-predict ways, and we think the ecosystem is one of the biggest advantages Ember offers.</p>
<p>In other words, we don't think we can make the full transition to JavaScript classes a first-class part of the Ember experience if we still support IE8. As we did with modules, we would like to move more of our core to JavaScript features in the future, which would be significantly stymied by the lack of <code>defineProperty</code> in IE8.</p>
<h3 id="remove-the-jquery-dependency"><a class="header" href="#remove-the-jquery-dependency">Remove the jQuery Dependency</a></h3>
<p>For its entire lifetime, Ember has relied on jQuery to smooth the rough edges of browser compatibility when interacting with the DOM. When people think about that dependency, they often assume that we could just replace calls to things like <code>.attr</code> with their more verbose DOM counterpart and call it a day.</p>
<p>jQuery does more than just patch over IE8 rough spots; it also serves as the central place for normalizing behavior that can differ significantly across browsers. If we tried to pick-and-choose pieces of jQuery to pull into Ember, we would also be responsible for backporting any changes made to jQuery. We'd rather just rely on jQuery directly; that's what dependencies are for.</p>
<p>The jQuery dependency has helped us with a few cross-browser areas:</p>
<ul>
<li>Portable <code>DOMContentLoaded</code> (via <code>jQuery.ready</code>)</li>
<li>Support for event delegation across a wide variety of events.</li>
<li>Attribute and property normalization, which has already been implemented by HTMLBars</li>
<li>HTML parsing, which has also been implemented by HTMLBars</li>
</ul>
<p>Of these, proper support for event delegation is the largest remaining reason to rely on jQuery. IE9's support for the capture phase of events makes it simpler to support event delegation properly across all event types without a normalization layer.</p>
<h3 id="support-more-event-types"><a class="header" href="#support-more-event-types">Support More Event Types</a></h3>
<p>Many newly specified events in the web platform (such as the media events) do not bubble, which is a problem for frameworks like Ember that rely on event delegation. However, the capture API, which was added in IE9, is invoked properly for all events, and does not require a normalization layer. Not only would supporting the capture API allow us to drop the jQuery dependency, but it would allow us to properly handle these non-bubbling events. This would allow you to use events like <code>playing</code> in your components without having to manually set up event listeners.</p>
<h3 id="css-improvements-in-ember-2x"><a class="header" href="#css-improvements-in-ember-2x">CSS Improvements in Ember 2.x</a></h3>
<p>Today, the main Ember framework does very little to directly help with CSS. We expect that to change in the 2.x series, as we explore ways to help tame the CSS beast.</p>
<p>However, a number of important CSS features landed in IE9: CSS3 selectors, full support for <code>querySelectorAll</code>, <code>getComputedStyle</code>, <code>calc()</code> to name a few. Productively tackling the CSS problem without these features would be like fighting with both hands tied behind our backs, and it may be impossible for us to robustly tackle the problem until Ember 3.0 if we needed to continue to support IE8.</p>
<p>While it may be theoretically possible to implement some form of this feature in IE8, it is likely that the cost of doing so in a backwards-compatible way would significantly add to development time; perhaps so significantly it would be better to wait until we drop support for IE8 than attempt to bolt it on to a browser released half a decade ago.</p>
<h3 id="maintenance-costs"><a class="header" href="#maintenance-costs">Maintenance Costs</a></h3>
<p>While it's very easy to weigh the costs of features that we could not implement at all due to IE8, there is a much more pernicious cost that is harder to see.</p>
<p>Support for IE8 adds costs, sometimes significant, to every new feature we work on. For example, broken support for text nodes in IE8 significantly impeded early work on Glimmer. Every new area of work requires budgeting a significant amount of time for IE8 support.</p>
<p>This is not surprising. When asked many years ago what jQuery could do when IE6 was gone, John Resig replied that we would gain little from dropping IE6, and that the benefits would not come until jQuery could drop IE8, the last version of IE featuring the bugs that made IE6 so difficult to develop for.</p>
<p>Quite often, we will assume that a feature is ready to ship, and only discover subtle issues in IE8 very close to the release once it has been tested. We estimate that support for legacy Internet Explorer slowed down the development of HTMLBars by 2x.</p>
<p>In short, we would be able to implement more features more quickly without the burden of bugs that were first introduced 15 years ago.</p>
<h2 id="what-about-ie9"><a class="header" href="#what-about-ie9">What About IE9?</a></h2>
<p>In the first decade of 2000, browsers were updated very slowly, and every new release took a long time to be supplanted by the next release. As the last version of Internet Explorer supported by Windows XP, IE8 is a relic of this bygone era. In contrast, IE9 usage was quickly supplanted by IE10, and that pattern continues with IE11.</p>
<p>The public trackers have IE9 at a lower share of total usage than IE8, so it might be worth considering dropping them together. Our decision for Ember 2.0 will likely hold until late 2016, so it's worth considering more than just the current moment when making the decision.</p>
<p>While IE9 added support for the ES5 features we need to move into the future for JavaScript, IE10 added support for the last great wave of web features. Here is a sampling:</p>
<ul>
<li>Flexbox and Grid Layout</li>
<li>Offline storage (IndexedDB, File, Blob)</li>
<li>Web Workers</li>
<li>Typed Arrays</li>
<li>Web Sockets</li>
<li>App Cache</li>
<li>History API</li>
</ul>
<p>Several of these features are required for asm.js, and in total, they make the web platform a capable application runtime. While we don't have any immediate plans to take advantage of these web features right now, the best experiments that people are doing today rely on them. By assuming IE10 as the baseline across the entire ecosystem, we would be able to do much more aggressive experimentation on the web platform.</p>
<h1 id="drawbacks-10"><a class="header" href="#drawbacks-10">Drawbacks</a></h1>
<p>Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. When we announced in early 2014 that we would continue to support IE8 for at least another year, other libraries and frameworks had already dropped support. That being said, there will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.</p>
<p>However, in many cases, the requirement of IE8 support is driven by non-technical management who do not have a strong sense of the experience of using apps in IE8. In practice, many applications are not rigorously tested in older browsers, and the performance of IE8 is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with a DOM and JavaScript engine written in the 90s.</p>
<p>Still, some people make it work, and dropping IE8 support may prevent those teams from staying with the community as it migrates to Ember 2.0.</p>
<h1 id="alternatives-11"><a class="header" href="#alternatives-11">Alternatives</a></h1>
<h2 id="drop-ie8-support-during-2x"><a class="header" href="#drop-ie8-support-during-2x">Drop IE8 Support During 2.x</a></h2>
<p>One alternative we have considered is deprecating IE8 support prior to releasing 2.0, but still maintaining it for a few point releases to give IE8 more time to lose market share.</p>
<p>After discussing with the core team, we believe that this would be a violation of our Semantic Versioning commitment to users. Specifically, we want to avoid a large group of apps getting stuck midway through the 2.x cycle. Version numbers are an important tool for developers, maintainers and ecosystems to communicate compatibility. Tools such as package managers rely on version numbers correctly indicating breaking changes.</p>
<p>We consider browser compatibility to be a feature of Ember, and dropping IE8 support in a minor release would be akin to stripping out any other major feature. While the ecosystem would muddle along in either case, such a move would cause exactly the kind of ecosystem fragmentation that Semantic Versioning is designed to prevent.</p>
<p>If we want to communicate the idea that changing versions comes with a reduction in functionality, we should do that the same way we always do, by incrementing the major version.</p>
<h2 id="early-30"><a class="header" href="#early-30">Early 3.0</a></h2>
<p>Another option is to release 3.0 in six months, rather than the nearly two years between Ember 1.0 and Ember 2.0.</p>
<p>Correctly tuning the cadence of major releases is a delicate tradeoff. Semantic Versioning allows us to easily communicate about breaking changes, and some take this as a license to make them frequently. However, a robust ecosystem relies on a certain measure of stability.</p>
<p>We believe that the frustration of breaking changes every six months (or even a year) would outweigh whatever benefits it would provide. Ember's biggest goal is building a shared foundation for our ecosystem to build on, and this requires a careful commitment to stability.</p>
<p>While we could make a &quot;small&quot; breaking release soon after 2.0, breaking changes inherently fragment the ecosystem, and we hope that the years to come bring more stability for add-on authors and tool-makers, not less.</p>
<h2 id="bring-your-own-compatibility"><a class="header" href="#bring-your-own-compatibility">Bring Your Own Compatibility</a></h2>
<p>Some libraries attempt to thread the needle of IE8 compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if IE8 did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers. For example, React asks users to bring libraries such as <code>es5-shim</code>, <code>es5-sham</code>, <code>console-polyfill</code> and <code>html5shiv</code> if they want IE8 support.</p>
<p>Facebook.com supports IE8, and uses React, so there is a path to using React with IE8. This path is partially documented on the React website. This gives us a perfect opportunity to evaluate the impact of this strategy in the real world. We admire the React team's work in this area: support for IE8 is difficult and triaging and fixing IE8 bugs requires diligent effort.</p>
<p>After reviewing the <a href="https://github.com/facebook/react/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+ie8">IE8-compatibility issues filed on React.js tracker</a>, we believe there are significant user experience costs to this strategy.</p>
<p>We have spent considerable effort on first-class IE8 support in Ember 1.x, and we feel that users who require IE8 support will have a better experience using Ember 1.14 (with the subset of the ecosystem that supports 1.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.</p>
<h1 id="unresolved-questions-11"><a class="header" href="#unresolved-questions-11">Unresolved questions</a></h1>
<p>We are relying on the community to help us weigh the above tradeoffs. The more data you can provide about the browser makeup of your customers (especially as it affects revenue), the better we can reason whether now is the time to remove IE8 (and possibly IE9) support.</p>
<p>If you cannot share the information publicly, please email whatever information you consider useful to browserusage@emberjs.com. We will keep it in the strictest of confidence.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-03-26
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/46</p>
<hr />
<h1 id="improved-release-process"><a class="header" href="#improved-release-process">Improved Release Process</a></h1>
<h2 id="summary--motivation"><a class="header" href="#summary--motivation">Summary &amp; Motivation</a></h2>
<p>ember-cli has followed an ad hoc release process throughout its existence which has made it difficult to know exactly when releases would come out, what features would and would not be supported, and the degree to which it would support existing Ember applications. With the proposal for lockstep SemVer there were ideals of guaranteeing compatibility, which we have mostly met, but that resulted in making decisions of delaying an official 2.X release of ember-cli to avoid additional major version bumps.</p>
<p>We propose that we adopt a pattern similar to Ember itself in order to align with the expectations of the Ember community, more-clearly communicate around our release lifecycle, and provide rigor around our support structure. Anything which is not specifically called out as a difference in this document is inferred to be following the patterns specified by Ember itself.</p>
<h2 id="channel-design"><a class="header" href="#channel-design">Channel Design</a></h2>
<p>To begin there will be three separate channels: canary, beta, and release. We intend to investigate an LTS channel after this process has matured.</p>
<ul>
<li><strong>Canary</strong>: represents the latest work in ember-cli, and is synonymous with the <code>HEAD</code> of the <code>master</code> branch and is the least stable of all channels.</li>
<li><strong>Beta</strong>: branched off of master every six weeks, exact commit decided upon manually. Updated and released weekly with commits that are prefixed <code>[BUGFIX beta]</code>. Less stable than <code>release</code> as it is a proving ground. No new features will be added once the branch has been created to allow for existing features to mature. Tags will match Ember's patterns, for example <code>v2.6.0-beta.1</code>. Branch name: <code>beta</code>.</li>
<li><strong>Release</strong>: branched off of Beta every six weeks. Only rarely will this be updated, but possible for security issues and uncaught regressions. Branch name: <code>release</code>.</li>
</ul>
<p>ember-cli will not support daily releases as time-based packaging doesn't make a lot of sense.</p>
<h2 id="new-features"><a class="header" href="#new-features">New Features</a></h2>
<p>New features to ember-cli must be protected by feature flags. Incomplete and WIP features will be available in the Canary channel, but will not be available in the Beta or release channels.</p>
<h2 id="tooling-design"><a class="header" href="#tooling-design">Tooling Design</a></h2>
<p>We must create additional tooling and patterns in order to make this efficient. Since ember-cli successfully installs and works from npm without modification we don't need to bundle and publish an asset for each Canary build. We'll publish tags to npm for <code>beta</code> and <code>release</code> channel releases so that they're not tied to a git remote URL. The <code>latest</code> tag for npm (the default when installing via <code>npm install -g ember-cli</code>) will track our <code>release</code> channel at all times. We will publish tagged releases (i.e. v2.6.0-beta.1) to the npm <code>beta</code> tag which is used via <code>npm install --save-dev ember-cli@beta</code>.</p>
<h2 id="timeline"><a class="header" href="#timeline">Timeline</a></h2>
<p>Since the ember-cli project is presently designed to track Ember development, we'll run our release schedule on a one week delay from Ember itself. This ensures that we're able to incorporate the latest changes from Ember into ember-cli and gives us a week to check for Ember-introduced regressions. As Ember itself becomes an npm module this will become less of a concern and we can diverge on our release schedule as best suits the ember-cli project. We will ship the last beta coincidentally with the newest Ember release.</p>
<h2 id="drawbacks-11"><a class="header" href="#drawbacks-11">Drawbacks</a></h2>
<p>The largest drawback is also a feature: we require more rigor in our release processes. This process presently requires a weekly manual review of new commits to master and their prefixes which then get cherry-picked to the appropriate <code>release</code> and <code>beta</code> branches.</p>
<p>We've also encountered issues with <code>npm</code> in the past which may require investigation into other tools.</p>
<h2 id="effort"><a class="header" href="#effort">Effort</a></h2>
<p>In order to undertake this task, there are multiple workflows which must occur:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Updates to the website and documentation communicating this plan.</li>
<li><input disabled="" type="checkbox"/>
Teaching new patterns to ember-cli contributors, most specifically commit tagging and feature flagging.</li>
<li><input disabled="" type="checkbox"/>
Increased automation of the release process.</li>
<li><input disabled="" type="checkbox"/>
Tooling to support feature flags.</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="http://emberjs.com/blog/2013/09/06/new-ember-release-process.html">Ember's Post-1.0 Release Cycle</a></li>
<li><a href="https://github.com/emberjs/rfcs/blob/master/text/0056-improved-release-cycle.md">Ember RFC #56 - Improved Release Cycle</a></li>
<li><a href="http://emberjs.com/blog/2016/02/25/announcing-embers-first-lts.html">Announcing Ember's First LTS Release</a></li>
<li><a href="https://github.com/ember-cli/ember-cli/blob/master/RELEASE.md">ember-cli Release Instructions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-04-09
RFC PR: https://github.com/emberjs/rfcs/pull/46
Ember Issue: https://github.com/emberjs/ember.js/pull/11440</p>
<hr />
<h1 id="summary-12"><a class="header" href="#summary-12">Summary</a></h1>
<p>Fully encapsulate and privatize the <code>Container</code> and <code>Registry</code> classes by
exposing a select subset of public methods on <code>Application</code> and
<code>ApplicationInstance</code>.</p>
<h1 id="motivation-13"><a class="header" href="#motivation-13">Motivation</a></h1>
<p>The <code>Container</code> and <code>Registry</code> classes currently lead a confusing life of
semi-private exclusion within Ember applications. They are undocumented
publicly but not fully private either, as knowledge of their particulars is
required for developing both initializers and unit tests. This situation has
become untenable as the new <code>Registry</code> class has been extracted from
<code>Container</code>, and the complexity of their usage has grown across
<code>Application</code> and <code>ApplicationInstance</code> classes.</p>
<p>We can bring sanity to this situation by continuing the work started at the
<code>Application</code> level to expose methods such as <code>register</code> and <code>inject</code> from the
internally maintained <code>Registry</code>.</p>
<p>Furthermore, once <code>Container</code> and <code>Registry</code> are fully private, their
architecture and documentation can be cleaned up. For instance, a
<code>Container</code> can freely reference its associated <code>Registry</code> as <code>registry</code>
rather than <code>_registry</code>, as it can be assumed that only framework developers
will reference this property.</p>
<h1 id="detailed-design-12"><a class="header" href="#detailed-design-12">Detailed design</a></h1>
<p><code>Application</code> will expose the following methods from its internally maintained
registry:</p>
<ul>
<li><code>register</code></li>
<li><code>inject</code></li>
<li><code>registerOptions</code> - mapped to <code>Registry#options</code></li>
<li><code>registerOptionsForType</code> - mapped to <code>Registry#optionsForType</code></li>
</ul>
<p><code>ApplicationInstance</code> will also expose the the same methods. However, these
methods will be exposed from its own internally maintained registry, which
has the associated <code>Application</code>'s registry configured as a &quot;fall back&quot;. No
direct path will be provided from the <code>ApplicationInstance</code> to the
<code>Application</code>'s registry.</p>
<p><code>ApplicationInstance</code> will also expose the following methods from its
internally maintained container:</p>
<ul>
<li><code>lookup</code></li>
<li><code>lookupFactory</code></li>
</ul>
<p><code>ApplicationInstance</code> will cease exposing <code>container</code>, <code>registry</code>, and
<code>applicationRegistry</code> publicly.</p>
<p><code>Application</code> initializers will receive a single argument to <code>initialize</code>:
<code>application</code>.</p>
<p>Likewise, <code>ApplicationInstance</code> initializers will receive a single argument
to <code>initialize</code>: <code>applicationInstance</code>.</p>
<p><code>Container</code> and <code>Registry</code> will be made fully private and documented as
such. Each <code>Container</code> will freely reference its associated <code>Registry</code> as
<code>registry</code> rather than <code>_registry</code>.</p>
<p><a href="https://github.com/switchfly/ember-test-helpers">ember-test-helpers</a>
will provide an <code>isolatedApplicationInstance</code> method instead of an
<code>isolatedContainer</code> for unit testing. A mechanism will be developed to specify
which initializers should be engaged in the initialization of this instance.
In this way, we can avoid duplication of registration logic, as is currently
done in a most un-DRY manner in the <a href="https://github.com/switchfly/ember-test-helpers/blob/master/lib/ember-test-helpers/isolated-container.js#L56-L79">isolatedContainer</a>.</p>
<h1 id="drawbacks-12"><a class="header" href="#drawbacks-12">Drawbacks</a></h1>
<p>This refactor will require maintaining backwards compatibility and
deprecation warnings until Ember 2.0. This will temporarily increase
internal code complexity and file sizes.</p>
<h1 id="alternatives-12"><a class="header" href="#alternatives-12">Alternatives</a></h1>
<p>The obvious alternative is to make <code>Container</code> and <code>Registry</code> fully public
and documented. An application's registry would be available as a <code>registry</code>
property. An application instance's container would remain available as
<code>container</code>.</p>
<p>We could still pass an <code>Application</code> into application initializers
and an <code>ApplicationInstance</code> into application instance initializers.</p>
<p>If this alternative is taken, I would suggest that <code>Application</code> should
deprecate <code>register</code> and <code>inject</code> in favor of calling the equivalents on its
public <code>registry</code>.</p>
<p>Regardless of which alternative is chosen, we should ensure that the public
aspects of container and registry usage are well documented.</p>
<h1 id="unresolved-questions-12"><a class="header" href="#unresolved-questions-12">Unresolved questions</a></h1>
<ul>
<li>
<p>Are the public methods listed above sufficient or should any others be
exposed?</p>
</li>
<li>
<p>What mechanism should be used to engage initializers in unit and
integration tests? Should test modules simply have an <code>initializers</code> array,
similar to the current <code>needs</code> array?</p>
</li>
<li>
<p>Given the semi-private nature of containers and registries, we may not need
to worry about semver for deprecations. However, we should be good citizens
and properly deprecate as much as possible. Some real world use cases in
initializers will no doubt be a surprise, so we need to tread carefully.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-04-06
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/50</p>
<hr />
<h1 id="summary-13"><a class="header" href="#summary-13">Summary</a></h1>
<p>A number of Ember framework function calls are no-ops in production. Ember CLI should strip these no-op function invocations from production builds by default.</p>
<h1 id="motivation-14"><a class="header" href="#motivation-14">Motivation</a></h1>
<p>Removing code that isn't required in production results in smaller and faster applications.</p>
<h1 id="detailed-design-13"><a class="header" href="#detailed-design-13">Detailed design</a></h1>
<p>The following framework function calls will be removed from ember-cli production builds by default:</p>
<ul>
<li><a href="http://emberjs.com/api/#method_assert"><code>Ember.assert</code></a></li>
<li><a href="http://emberjs.com/api/#method_debug"><code>Ember.debug</code></a></li>
<li><a href="http://emberjs.com/api/#method_deprecate"><code>Ember.deprecate</code></a></li>
<li><a href="http://emberjs.com/api/#method_info"><code>Ember.info</code></a></li>
<li><a href="http://emberjs.com/api/#method_runInDebug"><code>Ember.runInDebug</code></a></li>
<li><a href="http://emberjs.com/api/#method_warn"><code>Ember.warn</code></a></li>
</ul>
<p>The API documentation will be updated where necessary to indicate that these function calls will be stripped from production builds.</p>
<p>A babel plugin will execute the removal of these function calls based on provided configuration. The plugin will affect the code of the current app or addon only and won't affect code in child or grandchild addons. As this change becomes part of the default ember-cli configuration, addons will adopt the code stripping as they upgrade to newer ember-cli versions.</p>
<p>The plugin configuration will define an array of modules or global functions to remove. Here's an example of what this configuration might look like:</p>
<pre><code class="language-js">{
  removals: [
    {
      module: 'ember', //eg. import Em from 'ember';
      paths: [
        'assert', //Em.assert will be removed
        'debug',  //Em.debug will be removed
        'a.b.c'   //Em.a.b.c will be removed
      ]
    }, {
      global: 'Ember',
      paths: [
        'deprecate' //Ember.deprecate will be removed
      ]
    }, {
      paths: [
        'console.log' //console.log will be removed
      ]
    }
  ]
}
</code></pre>
<p>The plugin will support removal of destructured and reassigned invocations of these functions and will support both Babel 5 and 6.</p>
<p>An app or addon can disable the code removal by removing the babel plugin.</p>
<h1 id="how-we-teach-this"><a class="header" href="#how-we-teach-this">How We Teach This</a></h1>
<p>This change doesn't bring any new functionality. Other than updating the Ember API docs, we don't need to make guide or other documentation changes. At the time of releasing, we may want to point out the possible side effects in a release blog post (see the <em>Drawbacks</em> section below).</p>
<p>If we want to expose the configuration options so that application authors can customize the settings, we can include a new section in the Ember CLI docs.</p>
<h1 id="drawbacks-13"><a class="header" href="#drawbacks-13">Drawbacks</a></h1>
<p>This may introduce an unexpected change in production builds as arguments that have side effects will no longer be executed. For example:</p>
<pre><code class="language-js">Ember.assert('Some assertion', someSideEffect());
</code></pre>
<p>Currently, the <code>someSideEffect</code> function will be executed in production. When this RFC lands, it won't.</p>
<h1 id="alternatives-13"><a class="header" href="#alternatives-13">Alternatives</a></h1>
<p>An Ember addon could provide opt-in function stripping for applications that want it. If this RFC isn't deemed a good default for Ember CLI, that option should be explored.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2014-05-06
RFC PR: https://github.com/emberjs/rfcs/pull/50</p>
<hr />
<h1 id="summary-14"><a class="header" href="#summary-14">Summary</a></h1>
<p>The <code>{{action</code> helper should be improved to allow for the creation of
closed over functions that can be passed between components and passed
the action handlers.</p>
<p>See <a href="http://emberjs.jsbin.com/rwjblue/466/edit?html,js,output">this example JSBin from @rwjblue</a>
for a demonstration of some of these ideas.</p>
<h1 id="motivation-15"><a class="header" href="#motivation-15">Motivation</a></h1>
<p>Block params allow data to be passed from one component to a downstream
component, however there is currently no way to pass a callback to a downstream
component.</p>
<h1 id="detailed-design-14"><a class="header" href="#detailed-design-14">Detailed design</a></h1>
<p>First, the existing uses of <code>{{action</code> will be maintained. An action can be attached to an
element by using the helper in element space:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{! submit action will hit immediate parent }}
&lt;button {{action &quot;submit&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>An action can be passed to a component as a string:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button on-click=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction('on-click');
  }
});
</code></pre>
<p>Or a default action can be passed:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button action=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.sendAction();
  }
});
</code></pre>
<p>In all these cases, <code>submit</code> is called on the parent context relative to the scope <code>action</code> is
attached in. The value <code>&quot;submit&quot;</code> is attached to the component in the last two as
<code>this.attrs.on-click</code> or <code>this.attrs.action</code>, although it is not directly used.</p>
<h3 id="creating-closure-actions"><a class="header" href="#creating-closure-actions">Creating closure actions</a></h3>
<p>Closure actions are created in a template and may be used in all places a string
action name can be used. For example, this current functionality:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;submit&quot; on=&quot;click&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>Would be written using a closure action as:</p>
<pre><code class="language-hbs">&lt;button {{action (action &quot;submit&quot;) on=&quot;click&quot;}}&gt;Save&lt;/button&gt;
</code></pre>
<p>The functionality is exactly the same as the string-based action example.
How does that happen?</p>
<ul>
<li><code>(action &quot;submit&quot;)</code> reads the <code>submit</code> function off the current scope's
<code>actions.submit</code> property.</li>
<li>It then creates a closure to call that function.</li>
<li><code>{{action</code> receives that function as a param. It registers a listener (in
this case on click) and when fired calls the closure function.</li>
</ul>
<p>Consider usage on the calling side. With the current string-based actions:</p>
<pre><code class="language-hbs">{{my-component action=&quot;submit&quot;}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a string
    this.attrs.action; // =&gt; &quot;submit&quot;
  }
});
</code></pre>
<p>With closure actions, the action is available to call directly. The <code>(action</code> helper
wraps the action in the current context and returns a function:</p>
<pre><code class="language-hbs">{{my-component action=(action &quot;submit&quot;)}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  click: function(){
    this.sendAction(); // submit action, legacy
    // this.attrs.action is a function
    this.attrs.action(); // submit action, new style
  }
});
</code></pre>
<p>A more complete example follows, with a controller for context:</p>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      // some submission task
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs.save();
    // for backwards compat, you may also this.sendAction('save');
  }
});
</code></pre>
<h3 id="hole-punching-with-a-closure-based-action"><a class="header" href="#hole-punching-with-a-closure-based-action">Hole punching with a closure-based action</a></h3>
<p>The current system of action bubbling falls down quickly when you want to pass a message through multiple
levels of components. A closure based action system helps address this.</p>
<p>Instead of relying on bubbling, a closure action wraps an action from the current context's
<code>actions</code> hash in a function that will call it on that context. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{my-button on-click=attrs.submit}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-button/template.hbs }}
&lt;button&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    this.attrs['on-click']();
    // for backwards compat, you may also this.sendAction();
  }
});
</code></pre>
<p>A closure action can also be called by an action handler:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form submit=(action 'submit')}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{my-button on-click=submit}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-button/template.hbs }}
&lt;button {{action on-click}}&gt;&lt;/button&gt;
</code></pre>
<p>Lastly, closure actions allow for yielding an action to a block. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-form save=(action 'submit') as |submit reset|}}
  &lt;button {{action submit}}&gt;Save&lt;/button&gt;
  {{! ^ goes to my-form's save attr property, which
        is the submit action on the outer scope }}
  &lt;button {{action reset}}&gt;Reset&lt;/button&gt;
  {{! ^ goes to my-form }}
  &lt;button {{action &quot;cancel&quot;}}&gt;Cancel&lt;/button&gt;
  {{! ^ goes to outer scope }}
{{/my-form}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-form/template.hbs }}
{{yield attrs.save (action 'reset')}}
</code></pre>
<pre><code class="language-js">// app/components/my-form/component.js
export default Ember.Component.extend({
  actions: {
    reset: function(){
      // rollback
    }
  }
});
</code></pre>
<h3 id="currying-arguments-with-a-closure-based-action"><a class="header" href="#currying-arguments-with-a-closure-based-action">Currying arguments with a closure-based action</a></h3>
<p>With string-based actions, an argument can be passed to the called function. For
example:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;save&quot; model}}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  actions: {
    save: function(model) {
      model.save();
    }
  }
});
</code></pre>
<p>Closure actions allow for another opportunity to curry arguments. Arguments
set by an element action helper simply add to the end of the arguments list:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-component save=(action &quot;save&quot; model)}}
</code></pre>
<pre><code class="language-hbs">{{! app/components/my-component/template.hbs }}
&lt;button {{action attrs.save prefs}}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    save: function(model, prefs) {
      model.set('prefs', prefs);
      model.save();
    }
  }
});
</code></pre>
<p>Multiple arguments can be curried or set at any level. If an action is called ala
<code>this.attrs.save(additionalPrefs)</code>, that final argument is added
to the end of the arguments list.</p>
<h3 id="re-targeting-the-scope-of-a-closure-action"><a class="header" href="#re-targeting-the-scope-of-a-closure-action">Re-targeting the scope of a closure action</a></h3>
<p>The <code>target</code> option may be provided to specify what scope the closure is called
with. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-component on-click={{action &quot;save&quot; model target=someComponentInstance}}&gt;&lt;/my-component&gt;
</code></pre>
<p>Much like with the <code>{{action</code> helper, passing both a
target and a bound argument will throw.</p>
<p>The default target for a closure is always the current scope.</p>
<ul>
<li>When routable components land, the current component will be the default target.</li>
<li>If a controller is the current scope, that controller will also be a default target.</li>
<li>A route will <em>never</em> be a closure action target. String actions will continue
to have their current behavior of bubbling to the route.</li>
</ul>
<p>A later proposal will determine how actions on a route are passed to a routable
component.</p>
<h3 id="return-values-of-a-closure-action"><a class="header" href="#return-values-of-a-closure-action">Return values of a closure action</a></h3>
<p>Closure actions return the returned value of their called function. For example:</p>
<pre><code class="language-js">// app/index/controller.js
export default Ember.Controller.extend({
  actions: {
    submit: function(){
      return 'great success';
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
{{my-button save=(action 'submit')}}
</code></pre>
<pre><code class="language-js">// app/components/my-button/component.js
export default Ember.Component.extend({
  click: function(){
    var result = this.attrs.save();
    // for backwards compat, you may also this.sendAction('save') but
    // in that case you do not have access to the return value.
    result; // =&gt; 'great success'
  }
});
</code></pre>
<h3 id="actionable-object-with-invoke"><a class="header" href="#actionable-object-with-invoke">Actionable object with INVOKE</a></h3>
<p><code>{{mut</code> is a new helper in Ember.js. It is not yet widely used in Ember apps, but its
interaction with the action helper is important to align early on.</p>
<p>Mut objects represent a modifiable value. For example with tag-based components:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-form name={{mut model.name}}&gt;&lt;/my-component&gt;
</code></pre>
<p>This will cause a mutable property to be added to <code>attrs</code>. To update the name,
<code>this.attrs.name.update(newName)</code> can be called. The value can be read (in
JavaScript) as <code>this.attrs.name.value</code>.</p>
<p>Often, a mutable value will be set as the result of an action. Mutable values
can be called actionable. For example:</p>
<pre><code class="language-hbs">{{! app/index/template.hbs }}
&lt;my-form submit={{action (mut model.name)}}&gt;&lt;/my-component&gt;
</code></pre>
<pre><code class="language-js">// app/components/my-form/component.js
export default Ember.Component.extend({
  click() {
    const value = this.get('newValue');
    this.attrs.submit(value);
  }
});
</code></pre>
<p>What is happening here?</p>
<ul>
<li><code>(mut model.name)</code> creates a mutable object for the <code>model.name</code> value.</li>
<li><code>{{action (mut model.name)}}</code> tests the passed object for a property with the
key <code>INVOKE</code> (an internal symbol). This value is a function that updates the mutable value.</li>
<li>Action wraps the calling of the <code>INVOKE</code> property in a function like any
other action, and passes it to the <code>attrs</code>.</li>
</ul>
<p>Thus, when the action is called the argument is passed to <code>INVOKE</code> which uses
it to update the mutable value. This is a simple way to enable the &quot;actions up&quot;
part of component-driven app architecture without ceremony around changing state.</p>
<h3 id="plucking-a-property-from-the-first-argument-with-value"><a class="header" href="#plucking-a-property-from-the-first-argument-with-value">Plucking a property from the first argument with value</a></h3>
<p>A component (or when Ember supports this better, an element) may emit an event
object and pass it to an action. In this case the value will need to be read off
the event before it can be passed to the action function. For example:</p>
<pre><code class="language-hbs">{{input input=(action 'setName')}}
</code></pre>
<pre><code class="language-js">export default Ember.Component.extend({
  actions: {
    setName(event) {
      this.get('model').set('name', event.target.value);
    }
  }
});
</code></pre>
<p>The action serves only to read the value off of the event. Here the <code>value</code>
option can be used as sugar to accomplish the same task:</p>
<pre><code class="language-hbs">{{input input=(action (mut model.name) value=&quot;target.value&quot;)}}
</code></pre>
<p>The <code>value</code> path is read off of whatever the first argument to the actions is.</p>
<ul>
<li><code>(mut model.name)</code> becomes a function, our action</li>
<li>When the <code>input</code> event fires, the function is called with the event as the
first argument.</li>
<li>The first argument is re-written to the value of <code>event.target.value</code></li>
<li>The function wrapping the <code>mut</code> is set</li>
<li>The <code>mut</code> is updated.</li>
</ul>
<p>This option is designed to align with future plans for <code>on-some-event</code> handlers
for html elements.</p>
<h1 id="drawbacks-14"><a class="header" href="#drawbacks-14">Drawbacks</a></h1>
<p>Currently <code>{{action</code> is only used in an element space:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;booyah&quot;}}&gt;Fire&lt;/button&gt;
</code></pre>
<p>The closure usage is a new, perhaps <code>action</code> is not the right word. However the two
behaviors are pretty similar in their conceptual behavior.</p>
<ul>
<li><code>{{action</code> in element space attaches an event listener that fires a bubbling
action.</li>
<li><code>(action</code> closes over an action from the current scope so it can be attached
via <code>{{action</code> or passed around and called later.</li>
</ul>
<p>This confusion should go away as we move to an <code>on-click</code> event listener pattern,
ala <code>&lt;button on-click={{someClosureAction}}&gt;</code>.</p>
<p>Additionally, there may be developers who still have <code>{{action someActionName}}</code> instead
of the quoted version. This is long deprecated, but these apps may see some
unexpected behavior.</p>
<p>Also additionally, some emergent behaviors exist that may not be desired as real APIs. For example,
an action being a function means it can be passed directly to event handlers:</p>
<pre><code class="language-hbs">{{my-component mouseEnter=(action 'didEnter')}}
</code></pre>
<p>The actual API we plan for 2.0 (ideally) is:</p>
<pre><code class="language-hbs">{{my-component on-mouse-enter=(action 'didEnter')}}
</code></pre>
<p>These behaviors should not be documented, and we should make clear that they rely on behavior that
will be deprecated. A mitigating move is to <em>not</em> proxy actions through to
<code>get</code> on a component, and only allow them to be accessed on <code>attrs</code>.</p>
<p>Lastly, default actions may look a bit confusing:</p>
<pre><code class="language-hbs">{{my-button action=(action 'action')}}
{{! ^ this is valid }}
</code></pre>
<p>But the quoted string syntax is not being removed.</p>
<h1 id="alternatives-14"><a class="header" href="#alternatives-14">Alternatives</a></h1>
<p>There is maybe a thing called <code>ref</code> that solves this same problem. There has also
been discussion of accessing properties on <code>outlet</code> across all child components
and their layouts, which would allow easy targetting of the top level component.</p>
<h1 id="unresolved-questions-13"><a class="header" href="#unresolved-questions-13">Unresolved questions</a></h1>
<p>Interaction with <code>ref</code> or <code>outlet.</code> if any..</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-05-17
RFC PR: https://github.com/emberjs/rfcs/pull/53
Ember Issue: https://github.com/emberjs/ember.js/pull/11278</p>
<hr />
<h1 id="summary-15"><a class="header" href="#summary-15">Summary</a></h1>
<p>Ember.js 1.13 will introduce a new API for helpers. Helpers will come in two
flavors:</p>
<p><strong>Helpers</strong> are a class-based way to define HTMLBars subexpressions. Helpers:</p>
<ul>
<li>Have a single return value.</li>
<li>Must have a dash in their name.</li>
<li>Cannot be used as a block (<code>{{#some-helper}}{{/some-helper}}</code>).</li>
<li>Can store and read state.</li>
<li>Have lifecycle hooks analogous to components where appropriate. For
example, a helper may call <code>recompute</code> at any time to generate a new
value (this is akin to <code>rerender</code>).</li>
<li>Are a superset of shorthand helpers, the function-based syntax described
below. They can do more, but in many cases a shorthand helper is appropriate.</li>
</ul>
<p><strong>Shorthand helpers</strong> are a function-based way to define HTMLBars
subexpressions. Helpers written this way:</p>
<ul>
<li>Have all the limitations of regular helpers.</li>
<li>Have no instance associated with them, cannot store or read state.</li>
<li>Have no lifecycle hooks. The function is simply re-computed when any input
changes.</li>
</ul>
<p>These improved helpers fill a gap in Ember's current template APIs:</p>
<table><thead><tr><th></th><th>has positional params</th><th>has layout (shadow DOM)</th><th>can yield template</th><th>has lifecycle, instance</th><th>can control rerender</th></tr></thead><tbody>
<tr><td>components</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>helpers</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr>
<tr><td>shorthand helpers</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
</tbody></table>
<p>An example helper:</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.extend({
  nameBuilder: Ember.inject.service(),
  compute(params) {
    const builder = this.get('nameBuilder');
    return builder.fullName(params[0], params[1]);
  }
});
</code></pre>
<p>An example shorthand helper:</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.helper(function(params, hash) {
  let fullName = params.join(' ');
  if (hash.honorific) {
    fullName = `${hash.honorific} ${fullName}`
  }
  return fullName;
});
</code></pre>
<p>Helpers can be used anywhere an HTMLBars subexpression is valid:</p>
<pre><code class="language-hbs">{{full-name 'Bigtime' 'Beagle'}}
{{input value=(full-name 'Gyro' 'Gearloose') readonly=true}}
{{#if (eq (full-name 'Webbigail' 'Vanderquack') selectedFullName))}}
  You have chosen wisely.
{{/if}}
</code></pre>
<h1 id="motivation-16"><a class="header" href="#motivation-16">Motivation</a></h1>
<p>Ember.js 1.13 make a private API change that removed the ability to access
application containers. <code>Ember.HTMLBars._registerHelper</code> was previously passed
the <code>env</code> object, and this was removed as it is an internal implementation
detail.</p>
<p>Ember's helper API has not kept pace with improvements possible
after the introduction of HTMLBars. This has resulted in the community using
a variety of private APIs, many of which leak information about the outer
context of a helpers invocation as well as the render layer implementation.</p>
<p>The current public API is:</p>
<ul>
<li><a href="http://emberjs.com/api/classes/Ember.Handlebars.html#method_makeBoundHelper">Ember.Handlebars.makeBoundHelper</a></li>
</ul>
<p>This API is sorely lacking in functionality required by addon authors.</p>
<ul>
<li>Has no access to other parts of the app, like services</li>
<li>Leaks a private API for dealing with blocks</li>
<li>Results in less efficient helpers due to the Handlebars compatibility layer</li>
<li>Has poor support for hash arguments</li>
</ul>
<p>Additionally it remains difficult to write a helper that recomputes due to
something besides the change of its input.</p>
<p>Specifically, this RFC addresses many of the concerns in
<a href="https://github.com/emberjs/ember.js/issues/11080">emberjs/ember.js#11080</a>.
Libraries such as <a href="https://github.com/yahoo/ember-intl">yahoo/ember-intl</a>,
<a href="https://github.com/dockyard/ember-cli-i18n">dockyard/ember-cli-i18n</a>, and
<a href="https://github.com/minutebase/ember-can">minutebase/ember-can</a> will be
provided a viable public API to couple to.</p>
<h1 id="detailed-design-15"><a class="header" href="#detailed-design-15">Detailed design</a></h1>
<p>Helpers must have a dash in their name. In an Ember-CLI app, they can be named
according to the <code>app/helpers/full-name.js</code> convention (<code>app/full-name/helper.js</code>
in pods mode). For a globals app, naming a helper <code>App.FullNameHelper</code> is
sufficient.</p>
<h3 id="definition-and-lifecycle"><a class="header" href="#definition-and-lifecycle">Definition and lifecycle</a></h3>
<p>A helper is defined as a class inheriting from <code>Ember.Helper</code>. For
example:</p>
<pre><code class="language-js">// app/helpers/hello-world.js
import Ember from &quot;ember&quot;;

// Usage: {{hello-world}}
export default Ember.Helper.extend({
  compute() {
    return &quot;Hello Helper World&quot;;
  }
});
</code></pre>
<p>Upon initial render:</p>
<ul>
<li>The helper instance is created.</li>
<li>The <code>compute</code> method is called. The return value is outputted where the
helper is used. For example in <code>&lt;div class={{some-helper}}&gt;&lt;/div&gt;</code> the return
value is set to the class.</li>
</ul>
<p>The <code>compute</code> function is always called with <code>params</code> (the bare, ordered
arguments) and <code>hash</code> (the named arguments). For example:</p>
<pre><code class="language-js">// app/helpers/greet-someone.js
import Ember from &quot;ember&quot;;

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.extend({
  compute(params, hash) {
    return `Hello ${params[0]}, nice to ${hash.greeting}`;
  }
});
</code></pre>
<p>Which functions the same as this shorthand:</p>
<pre><code class="language-js">// app/helpers/greet-someone.js
import Ember from &quot;ember&quot;;

// Usage: {{greet-someone 'bob' greeting='say hello'}}
export default Ember.Helper.helper(function(params, hash) {
  return `Hello ${params[0]}, nice to ${hash.greeting}`;
});
</code></pre>
<p>When the <code>params</code> or <code>hash</code> contents change, the <code>compute</code> method is called
again. The instance of the helper is preserved across rerenders of the parent.
A shorthand helper, having no instance, is called every time a bound
argument changes.</p>
<p>The <code>init</code> and <code>destroy</code> methods can be subclassed for setup and teardown.</p>
<h3 id="consuming-a-helper"><a class="header" href="#consuming-a-helper">Consuming a helper</a></h3>
<p>Helpers can be used anywhere an HTMLBars subexpression can be
used. For example:</p>
<pre><code class="language-hbs">{{#if (can-access 'admin')}}
  {{link-to 'login'}}
{{/if}}
{{#if (eq (can-access 'admin') false)}}
  No login for you
{{/if}}
&lt;my-login-button isAdmin={{can-access 'admin'}} /&gt;
Can access? {{can-access 'admin'}}
</code></pre>
<p>Passing a helper to a <code>{{</code>- invoked component skips the auto-<code>mut</code> behavior:</p>
<pre><code class="language-hbs">{{my-login-button isAdmin=(can-access 'admin')}}
</code></pre>
<p>Let's step through exactly what happens when using an helper like this:</p>
<pre><code class="language-hbs">&lt;my-login-button isAdmin={{can-access 'admin'}} /&gt;
</code></pre>
<p>Upon initial render:</p>
<ul>
<li>The helper <code>can-access</code> is looked up on the container</li>
<li>The helper is identified as a full helper, not a shorthand helper function</li>
<li>The helper is initialized (<code>init</code> is called)</li>
<li>The <code>compute</code> function is called on the helper.</li>
<li>The return value from <code>compute</code> is passed as an <code>attr</code> to <code>my-login-button</code>.</li>
<li>The helper instance remains in memory.</li>
</ul>
<p>If the parent scope is rerendered:</p>
<ul>
<li>The <code>compute</code> function is called again.</li>
<li>The return value from <code>compute</code> is passed as an <code>attr</code> to <code>my-login-button</code>.</li>
</ul>
<p>Upon teardown:</p>
<ul>
<li>The helper is destroyed, calling the <code>destroy</code> method.</li>
</ul>
<h3 id="returning-a-value"><a class="header" href="#returning-a-value">Returning a value</a></h3>
<p>The return value of helper is passed through to where their subexpression
is called. For example, given a helper (this one a shorthand helper):</p>
<pre><code class="language-js">// app/helpers/full-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.helper(function fullName(params, hash) {
  return params.join(' ');
}
</code></pre>
<p>The following are effectively the same:</p>
<pre><code class="language-hbs">&lt;div data-name={{full-name &quot;Fenton&quot; &quot;Crackshell&quot;}}&gt;&lt;/div&gt;
&lt;div data-name={{&quot;Fenton Crackshell&quot;}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-hbs">{{my-component name=(full-name &quot;Magica&quot; &quot;De Spell&quot;)}}
{{my-component name=&quot;Magica De Spell&quot;}}
</code></pre>
<pre><code class="language-hbs">&lt;p&gt;{{full-name &quot;Bentina&quot; &quot;Beakley&quot;}}&lt;/p&gt;
&lt;p&gt;{{&quot;Bentina Beakley&quot;}}&lt;/p&gt;
</code></pre>
<p>An exclusion to this pattern is the following form:</p>
<pre><code class="language-hbs">&lt;div {{full-name &quot;Webbigail&quot; &quot;Vanderquack&quot;}}&gt;&lt;/div&gt;
</code></pre>
<p>This is a legacy form of mustache usage. Helpers will throw an exception when
used in this manner.</p>
<h3 id="consuming-services-and-recompute"><a class="header" href="#consuming-services-and-recompute">Consuming services and recompute</a></h3>
<p>Helpers are a valid target for service injection. For example:</p>
<pre><code class="language-js">// app/helpers/current-user-name.js
import Ember from &quot;ember&quot;;

export default Ember.Helper.extend({
  // Same API as components:
  session: Ember.inject.service(),
  compute() {
    return this.get('session.currentUser.name');
  }
});
</code></pre>
<p>However consuming a property from a service does not bind the data being
displayed to that property. After <code>{{current-user-name}}</code> has been computed
and rendered, it will never be invalidated.</p>
<p>For this reason, helpers are granted some control over their
computation lifecycle. A helper will recompute when:</p>
<ul>
<li>A value passed via the template changes (<code>params</code> or <code>hash</code>)</li>
<li>The <code>recompute</code> method is called</li>
</ul>
<p>For example, this helper checks if the current use has access to a
resource type:</p>
<pre><code class="language-js">// app/helpers/can-access.js
import Ember from &quot;ember&quot;;

// Usage {{if (can-access 'admin') 'Welcome, boss' 'Heck no!'}}
export default Ember.Helper.extend({
  session: Ember.inject.service(),
  onCurrentUserChange: Ember.observes('session.currentUser', function() {
    this.recompute();
  }),
  compute(params) {
    const currentUser = this.get('session.currentUser');
    return currentUser.can(params[0]);
  }
});
</code></pre>
<h1 id="drawbacks-15"><a class="header" href="#drawbacks-15">Drawbacks</a></h1>
<p>Helpers may superficially appear similar to components, but in
practice they have none of the special behavior of components such as managing
DOM. The intent of this RFC is that full class-based helpers remain very close
to the spirit of a pure function (as in the shorthand). However, despite this
intent they are a new concept for the framework.</p>
<h1 id="alternatives-15"><a class="header" href="#alternatives-15">Alternatives</a></h1>
<p>A <a href="https://github.com/emberjs/rfcs/pull/52">previous RFC</a> explored creating a new class called Expressions, which would have
more closely modeled the API of components (using positional params, attrs).
After discussion and consideration it was clear that a third kind of template
API would be very challenging to document and teach well.</p>
<h1 id="unresolved-questions-14"><a class="header" href="#unresolved-questions-14">Unresolved questions</a></h1>
<p>Perhaps there should be hooks in place for the lifecycle, instead of relying on
<code>init</code> and <code>destroy</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-06-14
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/55</p>
<hr />
<h1 id="summary-16"><a class="header" href="#summary-16">Summary</a></h1>
<p>This RFC proposes extending the <code>app.import</code> API to consume anonymous AMD modules. It accompanies <a href="https://github.com/ember-cli/ember-cli/pull/5976">ember-cli PR 5976</a>.</p>
<h1 id="motivation-17"><a class="header" href="#motivation-17">Motivation</a></h1>
<p>AMD modules come in two flavors: named and anonymous. <em>Anonymous AMD</em> is the more portable distribution format, but it typically requires preprocessing into <em>named AMD</em> before it can be included into an application.</p>
<pre><code>/* Anonymous AMD Examples */

// direct value
define({ color: 'black' });

// function returning value
define(function() { return { color: 'black' }; });

// function returning value, with declared dependencies
define([&quot;jquery&quot;, &quot;moment&quot;], function(jQuery, moment) {
  return {
    injectTime: function() {
      jQuery('#time-box').html(moment().format('HH:MM'));
    }
  }
});

/* Named AMD Examples */

// direct value
define('my-config', { color: 'black' });

// function returning value
define('my-config', function() { return { color: 'black' }; });

// function returning value, with declared dependencies
define('time-utils', [&quot;jquery&quot;, &quot;moment&quot;], function(jQuery, moment) {
  return {
    injectTime: function() {
      jQuery('#time-box').html(moment().format('HH:MM'));
    }
  }
});
</code></pre>
<p>Today, ember-cli users can add arbitrary third-party <em>named AMD</em> modules into their application via:</p>
<pre><code>app.import('/path/to/module.js');
</code></pre>
<p>But this does not support <em>anonymous AMD</em> modules, which is annoying because <em>anonymous AMD</em> is the better format for library distribution and is widely used.</p>
<h1 id="detailed-design-16"><a class="header" href="#detailed-design-16">Detailed design</a></h1>
<p>In order to de-anonymize AMD, it's necessary to choose a name for the module for use within a given application. So I propose extending the:</p>
<pre><code>app.import('/path/to/module.js');
</code></pre>
<p>API with an additional argument:</p>
<pre><code>app.import('/path/to/module.js', {
  using: [
    { transformation: 'amd', as: 'some-dep' }
  ]
});
</code></pre>
<p><code>using</code> provides a list of transformations. Each transformation is identified by its <code>transformation</code> property. Any other properties are treated as arguments to the transformation implementation -- they are opaque to ember-cli. Transformations will run in the given order.</p>
<p>In this particular case, the <code>amd</code> transformation will run and receive the argument <code>{as: 'some-dep'}</code>.</p>
<p>The exactly meaning of the <code>amd</code> transformation is: within this Javascript file, any call(s) to the global <code>define()</code> function will be intercepted and the given module name (<code>some-dep</code> in the above example) will be prepended to the argument list.</p>
<p><a href="https://github.com/ember-cli/ember-cli/pull/5976">A complete implementation is available here</a>. (As of this edit it lags behind updates to this RFC.)</p>
<h1 id="learning"><a class="header" href="#learning">Learning</a></h1>
<p>An appropriate place to document this feature is <a href="https://ember-cli.com/user-guide/#standard-amd-asset">here</a>. That existing documentation is silent on the distinction between named and anonymous AMD, which probably trips people up.</p>
<h1 id="drawbacks-16"><a class="header" href="#drawbacks-16">Drawbacks</a></h1>
<p>I am not attempting to specify static error detection, mostly because doing that well would require fully parsing and understanding the imported module, which is likely to be more expensive and fragile.</p>
<p>Examples of static errors that would theoretically be nice to detect would be the presence of a <em>named AMD</em> module in the file, the lack of any AMD module in the file, or the present of multiple <em>anonymous AMD</em> modules in the file.</p>
<p>The current implementation causes any sourcemap information inside the imported file to be discarded (you don't get an invalid sourcemap, but you lose detail).</p>
<p>I have not specified a pluggable way to add additional transformations. My intent is to reserve space in our public API so that future extraction and pluggability is fully backward compatible.</p>
<h1 id="alternatives-16"><a class="header" href="#alternatives-16">Alternatives</a></h1>
<p>Many libraries fall back to global variables if they cannot detect a valid AMD loader. I suspect this is the most common alternate pattern that's in use in the community.</p>
<p>Some applications include their own manually written shims in <code>vendor</code> or elsewhere.</p>
<h1 id="unresolved-questions-15"><a class="header" href="#unresolved-questions-15">Unresolved questions</a></h1>
<p>We should confirm that my implementation performs well in apps with very large dependency directories.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-10-02
RFC PR: https://github.com/emberjs/rfcs/pull/56</p>
<hr />
<h1 id="refining-the-release-process"><a class="header" href="#refining-the-release-process">Refining the Release Process</a></h1>
<p>Ember balances a desire for overall stability with a desire for continued improvements using a two-pronged approach:</p>
<ul>
<li>General adherence to Semantic Versioning, which means that we don't 
make breaking changes to public, documented APIs except when the 
major version changes.</li>
<li>A rapid release cycle that allows us to ship additive changes to the
framework on a regular, digestible basis.</li>
</ul>
<p>Since Ember 1.0, we have refined this approach:</p>
<ul>
<li>All new public APIs are added using feature flags onto the master
branch. Feature flagged features are not included in beta or release
builds until they are &quot;Go&quot;ed by the core team.</li>
<li>We avoid breaking heavily used but private APIs in minor versions.</li>
<li>When we feel we must break a private API that is heavily used, we
use a two-step deprecation approach: deprecate the private API in
one release and remove it in a subsequent release, once apps and
add-ons have had an opportunity to upgrade.</li>
<li>When we plan to make breaking changes in a future major release,
we first deprecate the changes in a previous minor release.</li>
<li>We never deprecate features until there is an already-landed
transition path to a new approach whose feature flag has already
been &quot;Go&quot;ed.</li>
</ul>
<p>And finally:</p>
<ul>
<li>A major release does not introduce any new breaking changes that
were not previously deprecated. Major versions simply remove
deprecated features that already landed.</li>
</ul>
<p>Ember 2.0 is the first major release cycle where we have followed these refinements; this document is an attempt to outline some additional refinements that we might adopt going forward.</p>
<h2 id="benefits-of-the-1x-model"><a class="header" href="#benefits-of-the-1x-model">Benefits of the 1.x Model</a></h2>
<ul>
<li>New features are added predictably, and it's relatively easy to
follow the list of new APIs that are under development, and where
they are in the process.</li>
<li>There is little pressure for contributors to land a feature 
prematurely, because missing a release deadline isn't
catastrophic–there will be another train six weeks hence.</li>
<li>We have a lot of very good automation tools that keep the trains
running–commits can be (mostly) automatically backported to the 
current beta or release version.</li>
<li>Upgrading Ember itself from version to version is typically a quick 
process, except when private APIs are in use. We aim for upgrades to
be possible to slot into existing product sprints, and the nature of
the process means that we tend to hit this goal for most users.</li>
<li>Upgrading Ember across a number of versions is typically pretty
straightforward, at least in theory.</li>
</ul>
<p>In total, this process provides a way for us to clearly message medium-term changes in a way that helps you make the changes predictably and as mechanically as possible.</p>
<p>The process of getting from <em>here</em> to <em>there</em> is a series of incremental releases with deprecations, which gives you a trail of breadcrumbs to follow as things change.</p>
<h2 id="problems-with-the-1x-model"><a class="header" href="#problems-with-the-1x-model">Problems with the 1.x Model</a></h2>
<p>While the approach we're using has provided a lot of benefits, there are a number of areas that could still use improvement:</p>
<ul>
<li>While it is in theory possible to upgrade only once every few 
releases, there is no guidance about exactly how to do that, and
little clarity about how many releases we plan to support with
security fixes. (Because of the two-step deprecations of heavily 
used  private APIs, it is in practice important to go through each
intermediate release to clear deprecation warnings before
proceeding.)</li>
<li>While SemVer guarantees apply to public APIs, many addons are forced
to use private APIs as part of experiments. These experiments are a
crucial part of the evolution of the Ember ecosystem, and the Ember
1.x series has had a fair bit of churn in these APIs.</li>
<li>While the SemVer guarantees apply to Ember proper, they do not apply
to parts of the blessed experience that have not yet reached 1.0.</li>
<li>While the SemVer guarantees promise that your code will continue
working, they do not address changes to idiomatic Ember usage, which
can change over time. In practice, this means that there can be
churn in the experience of using Ember without actual breakages.</li>
<li>While deprecations technically don't force you to change anything,
in practice clearing deprecations is a part of the upgrade process.
A constant stream of deprecations, like in the lead-up to Ember 2.0, 
can feel almost as bad as breaking changes.</li>
<li>In the lead-up to Ember 2.0, a desire to remove as much cruft as
quickly as possible led to a need to land new features with much
more urgency than usual.</li>
</ul>
<p>In total, these problems introduce churn in the experience of using Ember. In practice, things like moving to ES6 modules, moving to Ember CLI, and the changes in Ember Data have made the experience of &quot;keeping up&quot; more frenetic than we would have liked.</p>
<p>Because Ember releases a new version every six-weeks, it's easy to associate the overall churn with the rapid pace of releases.</p>
<h2 id="non-goals-of-the-improvements"><a class="header" href="#non-goals-of-the-improvements">Non-Goals of the Improvements</a></h2>
<p>The release process does not attempt to change the overall pace of change, but rather to make changes more predictable, easy to track, and easy to upgrade to.</p>
<p>The six-week cycle can incidentally affect the pace of change, because it means that large changes usually need to be broken up into pieces that can land a bit at a time. However, in practice this speeds up ecosystem-wide adoption of the entire feature, because people do not find themselves stuck behind a big-bang change that they can't schedule the time to upgrade to.</p>
<p>A recent survey of the Ember ecosystem, which had close to 1,000 respondents, showed that the vast majority of Ember users are using one of the past three versions of Ember.</p>
<h2 id="proposal-lts-releases"><a class="header" href="#proposal-lts-releases">Proposal: LTS Releases</a></h2>
<p>In theory, it's possible to upgrade every few releases, instead of every release. This has a few drawbacks:</p>
<ul>
<li>Because of the two-step deprecation process for heavily-used
private APIs that we want to remove, it is in practice necessary
to go through all intermediate releases in order to catch possible
deprecations.</li>
<li>We currently don't have any official policy about which exact
releases we backport security patches to, other than a promise
that we will always backport to the previous released version.</li>
<li>Since different people upgrade at different rates, it's hard for
add-ons and other parts of the Ember ecosystem that are not
bound by the same SemVer guarantees to know which versions to
continue to support.</li>
</ul>
<p><strong>I propose that every 4 releases is considered a &quot;Long-Term-Support (LTS) release&quot; . With the six-week cycle, that means every 24 weeks, or roughly twice per year.</strong></p>
<p>This means:</p>
<ul>
<li>We will only remove heavily used private APIs if they were 
deprecated in a previous LTS release. This means that
if a feature is deprecated in 2.3, the first LTS release that 
the deprecation will appear in is 2.4, and it can therefore be 
removed in 2.5.</li>
<li>We will provide release notes for each LTS release that
roll up the changes for the releases it includes, including new
deprecations and new features.</li>
<li>We will use the LTS releases to provide better big-picture 
messaging on the goals of any deprecations and changes to
idiomatic Ember.</li>
<li>Security fixes will always be backported to the most recent
LTS release.</li>
<li>We will encourage the Ember ecosystem to maintain support for
the LTS releases, and lead by example with our own
projects that have not yet reached SemVer stability. Ideally, this
will give more of a voice to people who are upgrading less 
frequently.</li>
</ul>
<p>This means that people who want to stay on the latest and greatest can continue to upgrade every six weeks (with the same SemVer guarantees we've come to expect), and people who want to upgrade less frequently can do so.</p>
<p>In practice, since these releases still abide by SemVer, upgrading from LTS release to LTS release should not be significantly more work than upgrading along the six-week release cycle.</p>
<p>Upgrading less frequently will mean, of course, that you would need to wait to take advantage of new features, and experience less gradual changes to idioms. It will also mean that every upgrade will come with a bigger bundle of deprecations to clear.</p>
<blockquote>
<p>It is important for us to keep an eye on the situation to see whether less frequent updates result in people getting left behind.</p>
</blockquote>
<h2 id="proposal-svelte-releases-and-major-releases"><a class="header" href="#proposal-svelte-releases-and-major-releases">Proposal: Svelte Releases and Major Releases</a></h2>
<p>Another problem worth addressing is that, as Ember gradually deprecates old idioms to make way for new ones, SemVer guarantees require that we continue shipping deprecated features until the next major release.</p>
<p>This has two related problems:</p>
<ol>
<li>Ember users who are not using deprecated features need to continue
shipping deprecated code, which increases both code bloat and
an opportunity to accidentally slip back into older idioms.</li>
<li>Ember itself needs to continue maintaining support for
deprecated features in its internals, which, over time, results
in cruft that impacts our ability to improve Ember.</li>
</ol>
<p>However, we also need to be cognizant of the fact that changes to Ember idioms take time to be reflected in online materials, so it's important for snippets copy-and-pasted from tutorials to continue to produce deprecation notices for some time.</p>
<p>In general, this is the question of how to &quot;garbage collect&quot; cruft in the framework gradually and with minimal impact.</p>
<p>Leading up to the 2.0 release, we thought we would address this issue with periodic &quot;cruft removal&quot; major releases. Every so often, we would issue a major release with the primary purpose of clearing out accumulated cruft. Minor releases could create deprecations, but not purge their associated code.</p>
<p>Unfortunately, because of the fact that <strong>Ember does not generally deprecate features without a clear transition to something else</strong>, this meant that the 2.0 release became a critical release for adding new features as well. In the run-up to 2.0, we felt a higher degree of urgency to add new features in the programming model to replace ones we expected to want to remove early in the 2.x series.</p>
<p>The goal of the train release model is to eliminate big-bang releases and the attendant stress on releasing particular features by a given date, and the 2.0 release has been far too disruptive to that goal.</p>
<p>In the 2.x cycle, I propose a few enhancements:</p>
<ol>
<li>Ember itself will more clearly mark deprecated features in a
similar way that it marks new features, including with the
release it was deprecated in.</li>
<li>Ember CLI will support &quot;svelte builds&quot;, which strip out
deprecated features.</li>
<li>In development mode, Ember CLI will convert deprecated features
into errors, to ensure that people running svelte builds can still
get clear messages when using code that was designed for earlier
builds, including addons.</li>
<li>We will still use major releases to remove built up cruft,
especially deeply intertwined cruft, but the svelte releases
should take the pressure off of the major release timeline.</li>
</ol>
<p><strong>The 1.x release cycle helped us establish an orderly process for adding features; this proposal establishes a more orderly process for removing them.</strong></p>
<h2 id="proposal-plugin-apis"><a class="header" href="#proposal-plugin-apis">Proposal: Plugin APIs</a></h2>
<p>Since the release of Ember 1.0, we have worked on refining the public APIs while maintaining stability. However, those public APIs do not cover all possible use-cases, and add-ons have cropped up to fill the gaps.</p>
<p>Unfortunately, this has placed a heavy compatibility burden on add-on authors who want to maintain stability in their public APIs even as versions of Ember have changed the private APIs they rely on.</p>
<p>In practice, the costs of the six-week release cycle weigh most heavily on add-on authors, who are often forced into using private APIs, but still want to keep their add-ons working with every release.</p>
<p>The canary and beta cycles help to ensure that popular add-ons work by the time the release version comes out, but only because add-on authors keep a close eye on the beta releases and absorb the churn on behalf of their users.</p>
<p><strong>I propose that as of Ember 2.0, any use of a private API in a plugin is considered a bug in Ember to be fixed.</strong></p>
<p>That doesn't mean that add-on authors should never use private APIs: to the contrary, use of private APIs when no other choice is available helps us discover what APIs are missing.</p>
<p>But a major goal of the 2.x series of Ember should be to identify ways to extend the stability promises that Ember offers to application authors to add-on authors.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-05-20
RFC PR: https://github.com/emberjs/rfcs/pull/57
Ember Issue: https://github.com/emberjs/data/pull/3303</p>
<hr />
<h1 id="summary-17"><a class="header" href="#summary-17">Summary</a></h1>
<p>This RFC adds a unified way to perform meta-operations on records, has-many relationships and belongs-to relationships:</p>
<ul>
<li>get the current local data synchronously without triggering a fetch or producing a promise</li>
<li>notify the store that a fetch for a given record has begun, and provide a promise for its result</li>
<li>similarly, notify a record that a fetch for a given relationship has begun, and provide a promise for its result</li>
<li>retrieve server-provided metadata about a record or relationship</li>
</ul>
<h1 id="motivation-18"><a class="header" href="#motivation-18">Motivation</a></h1>
<p>When we initially designed the Ember Data API for relationships, we focused on consumption and mutation of the relationship data. For example, you can retrieve the value of a <code>belongsTo</code> relationship via <code>get('post')</code>, or adding new records to a has-many relationship via <code>get('comments').pushObject(newComment)</code>.</p>
<p>The top-level reading operations are designed to be <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">zalgo</a>-proof: regardless of whether or not the record or relationship has been loaded already, you get back a promise for the result. Behind the scenes, this will trigger a fetch if needed, or simply return the current value if it has already been fetched. From a programming model perspective, this simplifies your code because you can handle locally-available data and remotely-available data in a single code path.</p>
<p>However, in sophisticated applications, there is often a need to refer to a record without triggering side effects.</p>
<p>For example, you may want to initiate the fetch for a record or relationship yourself, and provide Ember Data with a promise representing the result of that fetch. That use-case is supported by the <code>store.push</code> API, but it has a few problems:</p>
<ul>
<li>The <code>store.push</code> API supports pushing data once the fetch has completed, but no way of telling
Ember Data that a fetch has begun. As a result, any calls to <code>store.find</code> in the interim will
trigger unnecessary fetches.</li>
<li>The <code>store.push</code> API works only for top-level records with already-known types and IDs. It does
not support any way of &quot;feeding&quot; the data for a relationship to Ember Data.</li>
</ul>
<p>In sum, this makes it difficult to front-load work (especially asynchronous work). Instead, Ember Data is currently optimized for reacting to requests from the application layer, which is sometimes a very awkward way of structuring your code.</p>
<p>Second, Ember Data was originally designed with APIs that refer to data and operations on data. Over time, we have come to realize that people quite often need to look at metadata about records or relationships, as well as perform meta-operations on them.</p>
<p>Some examples:</p>
<ul>
<li>getting the expected count of a has-many relationship before it has been fetched</li>
<li>learning whether a relationship is already loaded or not</li>
<li>examining server-sent metadata</li>
<li>working with pages of records in a has-many relationship, especially when pages are loaded asynchronously (&quot;pagination&quot;)</li>
</ul>
<p>Third, because has-many relationships are represented as a <code>RecordArray</code>, we have been able to kludge around some of these issues by adding meta-operations to the has-many relationship itself. In contrast, belongs-to relationships have remained anemic. For example, there is no way to trigger a reload of a belongs-to relationship, whereas has-many relationships can be reloaded by calling <code>.reload()</code> on the <code>RecordArray</code>.</p>
<h1 id="detailed-design-17"><a class="header" href="#detailed-design-17">Detailed design</a></h1>
<p>This RFC proposes the addition of three new <strong>public</strong> APIs:</p>
<ul>
<li><code>RecordReference</code></li>
<li><code>HasManyReference</code></li>
<li><code>BelongsToReference</code></li>
</ul>
<h2 id="getting-references"><a class="header" href="#getting-references">Getting References</a></h2>
<ul>
<li><code>store.getReference(type, id)</code></li>
<li><code>record.getReference(name)</code></li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<h3 id="push"><a class="header" href="#push"><code>push</code></a></h3>
<pre><code class="language-js">/**
  This API allows you to provide a reference with new data. The simplest usage
  of this API is similar to `store.push`: you provide a normalized hash of data
  and the object represented by the reference will update.

  If you pass a promise to `push`, Ember Data will not ask the adapter for the
  data if another attempt to fetch it is made in the interim. When the promise
  resolves, the underlying object is updated with the new data, and the promise
  returned by *this function* is resolved with that object.

  For example, `recordReference.push(promise)` will be resolved with a record.

  @method
  @param {Promise|Object}
  @returns Promise&lt;T&gt; a promise for the value (record or relationship)
*/
</code></pre>
<h3 id="pushpayload"><a class="header" href="#pushpayload"><code>pushPayload</code></a></h3>
<pre><code class="language-js">/**
  This API is similar to `push`, but it invokes the serializer with the
  resolved data. This makes it possible to share normalization logic
  across multiple calls to `pushPayload` or between proactive pushes
  and reactive responses from the adapter.

  @method
  @param {Promise|Object}
  @returns Promise&lt;T&gt; a promise for the value (record or relationship)
*/
</code></pre>
<h3 id="state"><a class="header" href="#state"><code>state</code></a></h3>
<pre><code class="language-js">/**
  The current state of the entity, based on the semantics of the
  entity in question. For records, this should expose a subset of
  the named states in the internal state machine.

  @property
  @type String
*/
</code></pre>
<h3 id="value"><a class="header" href="#value"><code>value</code></a></h3>
<pre><code class="language-js">/**
  If the entity referred to by the reference is already loaded, it
  is present as `reference.value`. Otherwise, the value of this
  property is `null`.

  @property
*/
</code></pre>
<h3 id="data"><a class="header" href="#data"><code>data</code></a></h3>
<pre><code class="language-js">/**
  The value of the (normalized) representation of this entity. For
  example, `recordReference.data` will return a normalized dictionary
  of attributes and links.

  @property
*/
</code></pre>
<h3 id="metadata"><a class="header" href="#metadata"><code>metadata</code></a></h3>
<pre><code class="language-js">/**
  The most recent value of the metadata returned by the server for
  the value represented by this reference.

  @property
*/
</code></pre>
<h3 id="load"><a class="header" href="#load"><code>load</code></a></h3>
<pre><code class="language-js">/**
  Triggers a fetch for the backing entity based on its `remoteType`
  (see `remoteType` definitions per reference type).

  @method
  @param {Object} an options hash, similar to the one currently
    passed to `store.find`.
*/
</code></pre>
<h3 id="unload"><a class="header" href="#unload"><code>unload</code></a></h3>
<pre><code class="language-js">/**
  Unload the entity referred to by this relationship. After this
  operation, its `value`, `data` and `metadata` members will return
  to `null`, and the record itself will be purged from the identity
  map.

  @method
*/
</code></pre>
<h2 id="recordreference"><a class="header" href="#recordreference">RecordReference</a></h2>
<h3 id="remotetype"><a class="header" href="#remotetype"><code>remoteType</code></a></h3>
<pre><code class="language-js">/**
  How the reference will be looked up with it is loaded:

  * `link`, a URL
  * `identity`, by the `type` and `id`
*/
</code></pre>
<h3 id="type"><a class="header" href="#type"><code>type</code></a></h3>
<pre><code class="language-js">/**
  The type of the record that this reference refers to.

  @property
*/
</code></pre>
<h3 id="id"><a class="header" href="#id"><code>id</code></a></h3>
<pre><code class="language-js">/**
  The `id` of the record that this reference refers to.

  Together, the `type` and `id` properties form a composite key
  for the identity map.

  @property
*/
</code></pre>
<h2 id="hasmanyreference"><a class="header" href="#hasmanyreference">HasManyReference</a></h2>
<h3 id="remotetype-1"><a class="header" href="#remotetype-1"><code>remoteType</code></a></h3>
<pre><code class="language-js">/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `ids`, a list of IDs provided by the server
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
</code></pre>
<h3 id="link"><a class="header" href="#link"><code>link</code></a></h3>
<pre><code class="language-js">/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
</code></pre>
<h3 id="ids"><a class="header" href="#ids"><code>ids</code></a></h3>
<pre><code class="language-js">/**
  If the `remoteType` is `ids`, a list of IDs that is used to formulate
  the query to the server (together with `type`).

  @property
*/
</code></pre>
<h3 id="type-1"><a class="header" href="#type-1"><code>type</code></a></h3>
<pre><code>/**
  The model type represented by this relationship.

  @property
*/
</code></pre>
<h3 id="parent"><a class="header" href="#parent"><code>parent</code></a></h3>
<pre><code class="language-js">/**
  A reference to the record that has this `hasMany` on it.

  @property
*/
</code></pre>
<h3 id="inverse"><a class="header" href="#inverse"><code>inverse</code></a></h3>
<pre><code class="language-js">/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
</code></pre>
<h2 id="belongstoreference"><a class="header" href="#belongstoreference">BelongsToReference</a></h2>
<h3 id="remotetype-2"><a class="header" href="#remotetype-2"><code>remoteType</code></a></h3>
<pre><code class="language-js">/**
  How the reference will be looked up when it is fetched:

  * `link`, a URL provided by the server
  * `id`, an ID to use to form the URL
  * `dynamic`, a dynamic URL will be created based on the identity
    of the parent.

  @property
*/
</code></pre>
<h3 id="link-1"><a class="header" href="#link-1"><code>link</code></a></h3>
<pre><code class="language-js">/**
  If the `remoteType` is `link`, the URL to use to load the relationship.

  @property
*/
</code></pre>
<h3 id="ids-1"><a class="header" href="#ids-1"><code>ids</code></a></h3>
<pre><code class="language-js">/**
  If the `remoteType` is `id`, an ID that is used to formulate
  the query to the server (together with `type`).

  @property
*/
</code></pre>
<h3 id="type-2"><a class="header" href="#type-2"><code>type</code></a></h3>
<pre><code>/**
  The model type represented by this relationship.

  @property
*/
</code></pre>
<h3 id="parent-1"><a class="header" href="#parent-1"><code>parent</code></a></h3>
<pre><code class="language-js">/**
  A reference to the record that has this `belongsTo` on it.

  @property
*/
</code></pre>
<h3 id="inverse-1"><a class="header" href="#inverse-1"><code>inverse</code></a></h3>
<pre><code class="language-js">/**
  If there is an inverse relationship, this property is a reference
  to it.

  @property
*/
</code></pre>
<h1 id="drawbacks-17"><a class="header" href="#drawbacks-17">Drawbacks</a></h1>
<p>The main drawback to this proposal is that it adds significant surface area to Ember Data, which could easily be perceived as significant additional complexity. However, we believe that the unification of the various entities in Ember Data, as well as exposing internal tools that were previously only available to the store, will actually reduce the complexity of many common patterns.</p>
<h1 id="alternatives-17"><a class="header" href="#alternatives-17">Alternatives</a></h1>
<p>The main alternative is to address each use case with a new API:</p>
<ul>
<li><code>store.peek(record, id)</code>, <code>record.peek(relationship)</code> to retrieve the current value of the relationship only if it was loaded</li>
<li>extend <code>store.push</code> and <code>store.pushPayload</code> to take promises</li>
<li>APIs like <code>record.inverseFor(relationship)</code>, <code>record.typeFor(relationship)</code>, etc.</li>
<li>APIs like <code>record.idsFor(relationship)</code>, <code>record.metadataFor(relationship)</code>, and <code>store.metadataFor(type, id)</code></li>
</ul>
<p>We believe that the cumulative overhead of all of these APIs is far more than the overhead of the reference APIs.</p>
<h1 id="unresolved-questions-16"><a class="header" href="#unresolved-questions-16">Unresolved questions</a></h1>
<p>Is there a need to represent &quot;prefetch metadata&quot; separately? This is metadata that the app knows about before fetch, and which it would want to persist through an <code>unload()</code> operation (along with identity information like type, id and link).</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-05-24
RFC PR: https://github.com/emberjs/rfcs/pull/58
Ember Issue: https://github.com/emberjs/ember.js/pull/11393</p>
<hr />
<h1 id="summary-18"><a class="header" href="#summary-18">Summary</a></h1>
<p>This RFC outlines a new strategy for the registration of helpers in Ember 1.13.
In previous versions of Ember, helper lookup was a two-phase process of:</p>
<ul>
<li>Look in a whitelist of registered helpers. If in the whitelist, resolve that
path in the container.</li>
<li>If the path has a dash, try to resolve it in the container</li>
<li>If the container does not have a factory for this path, treat the path as a
bound value.</li>
</ul>
<p>This logic runs for every <code>{{somePath}}</code> in an Ember application.</p>
<p>This proposal attempts to simplify and unify that logic in a a single pass
against a whitelist, thus removing the special behavior of dashed paths.
Additionally, it attempts to design a solution that removes the current
<code>registerHelper</code> ceremony for undashed helpers.</p>
<h1 id="motivation-19"><a class="header" href="#motivation-19">Motivation</a></h1>
<p>In <a href="https://github.com/emberjs/rfcs/pull/53">RFC #53</a> a new API for helpers is
outlined. This RFC presumes helpers will continue to have the naming
requirement of including a dash character.</p>
<p>The dash requirement for helpers exists for two reasons:</p>
<ul>
<li>For every <code>{{path}}</code> in an Ember application, it must be decided if that path
is a bound value, component, or helper. Component and helper lookup (the
discovery of a class or template) is lazy in Ember, thus for every <code>{{path}}</code>
a lookup for that string in the container is required. Container lookups
(the first time) are fairly slow, and performing this lookup for every
path may significantly impact initial render time. Thus, helpers are either
added to a whitelist (with <code>registerHelper</code>) or require a way to differentiate
themselves from the majority of data-binding cases (the dash).</li>
<li>In Ember 1.x, components were treated as helpers for certain code paths. This
made the dash requirement for components a natural extension to helpers.</li>
</ul>
<p>The Glimmer engine has removed some of these concerns and limitations.</p>
<p>Addon authors and app authors have both felt a need for non-dashed helper
names, for example <code>{{t 'some-string-to-translate'}}</code>. New developers to Ember
often find the dash requirement arbitrary and the <code>registerHelper</code> work around
difficult to understand and use.</p>
<p>For the new helper API to provide feature parity with APIs available to addon
authors in 1.12, a path to dashless helpers must be present in 1.13.</p>
<p>Given that a solution exists that addresses the performance concern, dropping
the dash requirement would resolve a significant amount of developer pain and
confusion.</p>
<h1 id="detailed-design-18"><a class="header" href="#detailed-design-18">Detailed design</a></h1>
<p>At application boot, all known helper items (according to the resolver) are
iterated and added to a <code>helper-listing</code> service. This service is merely a
Set object with the names of all helpers.</p>
<p>When handling a <code>{{path}}</code>, the <code>helper-listing</code> service is consulted for the
presence of that <code>path</code>. If it is present, the path is looked up
on the container as a helper and the helper is used. Dashed paths are treated
no differently than any other path (for helpers).</p>
<h3 id="boot-time-discovery"><a class="header" href="#boot-time-discovery">Boot time discovery</a></h3>
<p>To discover what paths may be helpers in Ember-CLI, the module names are
iterated. For example:</p>
<pre><code>not helper: app/components/foo-bar/component
not helper: app/controllers/foo-bar
not helper: app/foo-bar/route
helper &quot;t&quot;: app/t/helper
helper &quot;t&quot;: app/helpers/t
helper &quot;foo-bar&quot;: app/helpers/foo-bar
helper &quot;foo/bar&quot;: app/helpers/foo/bar
</code></pre>
<p>In a globals-mode application, The app namespace is iterated:</p>
<pre><code>not helper: App.FooBarComponent
not helper: App.FooBarController
not helper: App.FooBarRoute
helper &quot;t&quot;: App.THelper
helper &quot;foo-bar&quot;: App.FooBarHelper &lt;- should dasherize
</code></pre>
<p>In both cases <strong>the resolver is responsible for providing a list of modules
by type</strong>. The proposed API is <code>eachOfType</code>, here with Ember-CLI as an example:</p>
<pre><code class="language-js">// Given helperListing as a Set:
resolver.eachOfType(‘helper’, function(parsedName, item) {
  helperListing.add(parsedName.fullName);
})
</code></pre>
<p>In Ember-CLI, the <code>app/</code> tree of an addon is merged with the app tree of an
application. This means for a helper like <code>t</code> to be discovered, nothing besides
adding it to <code>app/helpers/t.js</code> must be done.</p>
<p>In 1.13, this will impact existing apps by discovering all helpers regardless
of if <code>registerHelper</code> has been called. This is a small behavior change that
should match intent, and will not impact sanely written apps.</p>
<p>Note that only the path of the helper is added to the listing. During discovery,
the helper is not looked up from the container, instead lookup still occurs
at render time.</p>
<p>The helper listing is intended to be a private service in Ember, and will be
registered at <code>services:-helper-listing</code>. If the discovery semantics described
here are not sufficient for some edge-cases, wrapping this service in a
public API on application instances may be required.</p>
<h3 id="render-time-lookup-and-use"><a class="header" href="#render-time-lookup-and-use">Render-time lookup and use</a></h3>
<p>Let us consider how a path is rendered. For example:</p>
<pre><code class="language-hbs">{{date}}
</code></pre>
<ul>
<li>The <code>service:-helper-listing</code> service is fetched</li>
<li>The path <code>date</code> is checked for on the listing: <code>helperListing.has(path)</code></li>
<li>If the path is not in the listing, <code>date</code> is treated like a bound value</li>
<li>If the path is in the listing, the helper is looked up from Ember's
container as <code>helper:date</code></li>
<li>depending on the instance returned from the factory (a helper, shorthand
helper, or legacy <code>Ember.Handlebars</code> or <code>Ember.HTMLBars._registerHelper</code>
helper) the proper invocation for that helper is executed</li>
</ul>
<p>Every rendered path will hit the <code>helper-listing</code> service, but the check
against a well-implemented Set should be inexpensive.</p>
<h1 id="drawbacks-18"><a class="header" href="#drawbacks-18">Drawbacks</a></h1>
<p>Removing the dash requirement will likely result in a larger number of naming
conflicts between addons and apps than has existed before now. In general,
encouraging verbose helper names may mitigate this concern. Long term, there
have been several discussions to date about how to implement namespaces in
Ember templates and for Ember engines.</p>
<p>That the helper listing is eagerly discovered at application boot time may
impact the design of Ember engines and lazy-loading parts of an app. The
discovery cache may need to be flushed and re-generated, however this limitation
already exists for the container lookup itself (which caches failures).</p>
<p>That the helper listing is not based on the container means helpers registered,
but not added to the listing because of non-standard naming, may need to
manually register against the private helper listing API.</p>
<h1 id="alternatives-18"><a class="header" href="#alternatives-18">Alternatives</a></h1>
<p>Instead of a new across-the-board solution, Ember could continue to use a
<code>registerHelper</code> pattern very similar to what exists today. This would
perpetuate the existing pain, but would perhaps be more similar to what devs
already know.</p>
<h1 id="unresolved-questions-17"><a class="header" href="#unresolved-questions-17">Unresolved questions</a></h1>
<p>The exact timing of helper discovery in Ember-CLI and globals mode has not been
decided.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-06-03
RFC PR: https://github.com/emberjs/rfcs/pull/61
Ember Issue: This RFC is implemented over many Ember Data PRs</p>
<hr />
<h1 id="summary-19"><a class="header" href="#summary-19">Summary</a></h1>
<p>This RFC proposes new methods on the adapter to signal to the Ember Data store when it should re-request a record that is already cached in the store. It also proposes a new adapter options object that can be used by to provide instructions to the adapter from the place where the store's find method is called.</p>
<h1 id="motivation-20"><a class="header" href="#motivation-20">Motivation</a></h1>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>When it comes to fetching records, there are several different behaviors
that users may expect. The behavior that users expect is influenced by
unique quirks in their data model, pre-existing expectations based on
traditional development models, and implementation details of their
adapter.</p>
<p>Fundamentally, users may expect or want one of the following sets of
behavior when fetching a model for the <code>model()</code> hook:</p>
<ul>
<li>Fetching data from the server the first time a record is requested,
but using only cached data subsequent times the route is entered.
(This is the current behavior of <code>find()</code>.)</li>
<li>Fetching new data every time the route is entered. The route will
&quot;block&quot; (show a loading spinner) until fresh data is received.</li>
<li>Using local data if available, but otherwise not triggering any
fetches if the data is not available. This is useful if records will
be pushed into the store ahead of time, e.g. by a socket, and
non-existence in the store means non-existence on the server.</li>
<li>Immediately returning a model with local data if available, rendering
the route's template immediately, and updating the record in the
background. If the record changes after conferring with the server,
the template is re-rendered.</li>
</ul>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<h3 id="fetch-only-on-initial-render"><a class="header" href="#fetch-only-on-initial-render">Fetch Only On Initial Render</a></h3>
<p>In this model, the record data is fetched from the server the first time
a record with a given ID is requested. Subsequent requests (e.g. leaving
and re-entering the same route) use locally cached data. This is the
strategy used by the current <code>find()</code> method.</p>
<p>The advantage of this model is that it keeps conferring with the server
to a minimum. Once data is loaded, the client can render new routes with
the model data that it has cached, without a network roundtrip.</p>
<p>Additionally, in some data models, records are immutable. For example, on
Twitter, tweets never change. In an email app, emails cannot change once
they are sent. Asking the server for the most up-to-date version of an
immutable record is a waste of resources.</p>
<p>The downsides of this model are two-fold.</p>
<p>First, this model is surprising to new developers. When navigating
between pages, they expect the most up-to-date representation to be
fetched and displayed every time.</p>
<p>Second, even for developers who understand what is happening, it is very
easy for long-lived applications to accumulate stale information,
particularly if the model they are displaying updates frequently.
Developers must somehow disambiguate between the first time a model is
looked up, and allowing it to proceed, and detecting when a cached model
is being used and updating it manually.</p>
<h3 id="new-fetch-every-render"><a class="header" href="#new-fetch-every-render">New Fetch Every Render</a></h3>
<p>The advantages of this model are that it most closely matches the mental
model for developers coming from server-rendered and jQuery backgrounds.
In that model, every time a new page is loaded, the most up-to-date
information is guaranteed to be displayed. Because each page navigation
triggers a fetch from the database, the only way for information to
become stale is for the user to stop navigating.</p>
<p>The downside of this model is that it eliminates many of the advantages
of client-side routing. In traditional client apps, data is stored
locally, and navigations use that local data. In this model, every page
transition is blocked awaiting a network response from the server. It's
a slight improvement in that the data should be much smaller than a full
HTML page, but it is often latency and not bandwidth that causes
slowdowns.</p>
<h3 id="never-fetch"><a class="header" href="#never-fetch">Never Fetch</a></h3>
<p>While an edge case, many Ember Data users have requested the ability to
fetch a record out of the store only if it exists locally.</p>
<p>One use case is for stores that are optimistically populated via pushed
data from a socket. In that case, if the record doesn't exist in the
store, it means that it doesn't exist on the server.</p>
<p>For obvious reasons, this is an uncommon case for the majority of apps.
While we should support it, it should not be part of the happy path for
new developers.</p>
<h3 id="immediate-render-background-refresh"><a class="header" href="#immediate-render-background-refresh">Immediate Render, Background Refresh</a></h3>
<p>In this model, the first time a record is requested, it blocks the
render and shows a loading spinner. On subsequent requests, the locally
cached data is displayed and the render happens immediately without
making the user wait.</p>
<p>However, in the background, the store also kicks off a request to the
adapter to update the record. When the new data comes in, the record is
updated, and if there have been changes to the record since the initial
render, the template is re-rendered with the new information.</p>
<p>This is the model that I believe strikes the best tradeoff among the
options available.</p>
<p>First, it preserves the speed of client-side navigation. Once data for a
record is cached, transitioning to any route that relies on it is nearly
instantaneous and has no network bottleneck.</p>
<p>Second, because it triggers a background update, even users who expect a
new fetch every time will not be surprised as, ideally after a few
milliseconds, the new data will arrive and be persisted into the DOM.</p>
<p>Third, in most applications, models are not changing frequently.  Most
of the time, the cached version in the Ember Data store will be
identical to the latest server revision. In those cases, there is no
point in making users stare at a loading spinner</p>
<p>Of course, there are several downsides to this model that we should keep
in mind. For immutable records, fetching a new version in the background
is wasteful of bandwidth and server capacity and we should allow
developers to opt out of this behavior.</p>
<p>A second related case is apps using a socket to subscribe to record
changes once a record is fetched. In those cases, fetching up-to-date
information on subsequent requests for the model is wasteful because
they have guaranteed that they will keep the model up-to-date via change
events from the server. In this case, we need a way for adapter authors
to signal that subsequent update requests for a record are a no-op.</p>
<p>Third, it may be an unpleasant user experience for new information to
pop in suddenly after the initial render, particularly for records that
frequently change in dramatic ways. In those instances, we should make
sure we give developers the tools to build UIs that can indicate to the
user that the information is being updated, perhaps by greying it out or
displaying a loading spinner.</p>
<h1 id="detailed-design-19"><a class="header" href="#detailed-design-19">Detailed design</a></h1>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<h3 id="new-adapter-methods"><a class="header" href="#new-adapter-methods">New Adapter Methods.</a></h3>
<p><code>shouldRefetchRecord</code> is a new method on the adapter that will be called by the store to make initial decision whether to refetch the record form the adapter or return the cached record from the store. This could method could be used to implement caching logic (e.g. only refetch this record after the time specified in its cache expires token) or for improved offline support (e.g. always refetch unless there is no internet connection then use cached record).</p>
<p>This record would only be called if the record was already found in the store and is in the loaded state. </p>
<p>This method is only checked by <code>store.findById</code> and <code>store.findAll</code>. Methods with <code>fetch</code> in their name always refetch the record(s) from the adapter.</p>
<pre><code class="language-js">{
  /**
   `shouldRefetchRecord` returns true if the adapter determines the record is
   stale and should be refetch. It should return false if the record
   is not stale or some other condition indicates that a fetch should
   not happen at this time (e.g. loss of internet connection). 

   This method is synchronous.

   @method shouldRefetchRecord
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
   */
  shouldRefetchRecord: function(store, record, adapterOptions),
}
</code></pre>
<p>The method <code>shouldBackgroundUpdate</code> would be used by the store to make the decision to re-fetch the record after it has already been returned to the user. This would allow realtime adapter to opt out of the background fetch if the adapter is already subscribing to changes on the record. </p>
<pre><code class="language-js">{
  /**
   `shouldBackgroundUpdate` returns true if the store should re fetch a
   record in the store after returning it to the user to ensure the
   record has the most up to date data.
   
   This method is synchronous.

   @method shouldBackgroundUpdate
   @param {DS.Store} store
   @param {DS.Model} record
   @param {Object} adapterOptions
   @return {Boolean}
  */
  shouldBackgroundUpdate: function(store, record, adapterOptions),
}
</code></pre>
<p>In the next major version of Ember Data the recommend way of finding a record 
will be:</p>
<pre><code class="language-js">this.store.findById('person', 1);
</code></pre>
<p>This will return a promise that:</p>
<ol>
<li>Waits to resolve until the data is fetched from the server, on the
initial request.</li>
<li>Resolves immediately with the locally cached request for subsequent
requests, but triggers a request to the server for the updated
version and updates the record in-place if there are changes.</li>
</ol>
<p>In terms of the above methods <code>shouldRefetchRecord</code> will always return <code>false</code> and <code>shouldBackgroundUpdate</code> will always return <code>true</code> in the default <code>RESTAdapter</code>.</p>
<p>The fundamental guarantee of <code>findById()/findAll()</code> when using the default <code>RESTAdapter</code> is:</p>
<blockquote>
<p>Give me the information you have available locally, then give me the
most up-to-date information as soon as possible.</p>
</blockquote>
<p>Currently, the <code>find()</code> method takes an optional third parameters that
is passed to the adapter. In this API, that data structure is moved to
a field in the new options hash:</p>
<pre><code class="language-js">this.store.findById('person', 1, {
  preload: { comment_id: 1 }
});
</code></pre>
<h3 id="isupdating-flag"><a class="header" href="#isupdating-flag"><code>isUpdating</code> Flag</a></h3>
<p>To assist developers in building UIs that communicate the state of
models to their users, we should provide a helper that allows developers
to show UI elements when a model is in the process of being updated via
<code>fetch()</code>.</p>
<p>I propose adding an <code>isUpdating</code> flag to models, which can be used to
conditionally show a spinner:</p>
<pre><code class="language-handlebars">&lt;h1&gt;{{post.title}}&lt;/h1&gt;
{{#if isUpdating post}}
  &lt;small&gt;Updating...&lt;/small&gt;
{{/if}}

&lt;p&gt;{{post.body}}&lt;/p&gt;
</code></pre>
<p>(Currently, only <code>RecordArray</code>s have an <code>isUpdating</code> flag.)</p>
<p>Models have an <code>isReloading</code> flag. This will be deprecated in favor of the new <code>isUpdating</code> flag.</p>
<h1 id="drawbacks-19"><a class="header" href="#drawbacks-19">Drawbacks</a></h1>
<p>Why should we <em>not</em> do this?</p>
<p>After the record has been updated in the background Ember's Data binding will cause any views to automatically update with the latest changes. This can result an a surprising &quot;popping&quot; effect which is especially pronounced when the background fetch resolves quickly (The user sees an initial render with the stale data then a quick re-render with the fresh data).</p>
<h1 id="alternatives-19"><a class="header" href="#alternatives-19">Alternatives</a></h1>
<p>What other designs have been considered? What is the impact of not doing this?</p>
<p>One alternate option could be for Ember Data to track an expires token on a model. This would allow Ember 
Data to behave like a caching proxy when fetching. If the record is expired, fetch should block. 
If the record is not expired it would return a resolve the record right away however still issue a
second request. </p>
<p>When used with backends that do not return an expires token. Ember Data would assume that the 
record is stale (this could be configured on the adapter).</p>
<h1 id="unresolved-questions-18"><a class="header" href="#unresolved-questions-18">Unresolved questions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-06-12
RFC PR: https://github.com/emberjs/rfcs/pull/64</p>
<hr />
<h1 id="summary-20"><a class="header" href="#summary-20">Summary</a></h1>
<p>The goal of this RFC is to allow for better component composition and the
usage of components for domain specific languages.</p>
<p>Ember components can be invoked three ways:</p>
<ul>
<li><code>{{a-component</code></li>
<li><code>{{component someBoundComponentName</code></li>
<li><code>&lt;a-component</code> (coming soon!)</li>
</ul>
<p>In all these cases, attrs passed to the component must be set at the place of
invocation. Only the <code>{{component someBoundComponentName</code> syntax allows for the name
of the component invoked to be decided elsewhere.</p>
<p>All component names are resolved to components through one global resolution
path.</p>
<p>To improve composition, four changes are proposed:</p>
<ul>
<li>The <code>(component</code> helper will be introduced to close over component attrs in
a yielding context.</li>
<li>The <code>{{component</code> helper will accept an argument of the object created by
<code>(component</code> for invocation (as it invokes strings today).</li>
<li>Property lookups with a value containing a dot will be considered for
rendering as components. <code>{{form.input}}</code> would be considered, for instance.
Helper invocations with a dot will also be treated like a component if the
key has a value of a component, for instance <code>{{form.input value=baz}}</code>.</li>
<li>A <code>(hash</code> helper will be introduced.</li>
</ul>
<h1 id="motivation-21"><a class="header" href="#motivation-21">Motivation</a></h1>
<p>When building a complex UI from several components, it can be difficult to
share data without breaking encapsulation. For example this template:</p>
<pre><code class="language-hbs">{{#great-toolbar role=user.role}}
  {{great-button role=user.role}}
{{/great-toolbar}}
</code></pre>
<p>Causes the user to pass the <code>role</code> data twice for what are obviously related
components. A component can yield itself down:</p>
<pre><code class="language-hbs">{{! app/components/great-toolbar/template.hbs }}
{{yield this}}
</code></pre>
<pre><code class="language-hbs">{{#great-toolbar role=user.role as |toolbar|}}
  {{great-button toolbar=toolbar}}
{{/great-toolbar}}
</code></pre>
<p>And <code>great-button</code> can have knowledge about properties on <code>great-toolbar</code>, but
this break the isolation of components. Additionally the calling syntax is not
much better, <code>toolbar</code> must still be passed to each downstream component.</p>
<p>Often <code>nearestOfType</code> is used as a workaround for these limitations. This API
is poorly performing, and still results in the downstream child accessing the
parent component properties directly.</p>
<p>Consequently there is a demand by several addons for improvement. Our goal
is a syntax similar to DSLs in Ruby:</p>
<pre><code class="language-hbs">{{#great-toolbar role=user.role as |toolbar|}}
  {{toolbar.button}}
  {{toolbar.button orWith=additionalProperties}}
{{/great-toolbar}}
</code></pre>
<p>As laid out in this proposal, the <code>great-toolbar</code> implementation would look
like:</p>
<pre><code class="language-hbs">{{! app/components/great-toolbar/template.hbs }}
{{yield (hash
  button=(component 'great-button' role=user.role)
)}}
</code></pre>
<h1 id="detailed-design-20"><a class="header" href="#detailed-design-20">Detailed design</a></h1>
<h3 id="the-component-helper-and-component-helper"><a class="header" href="#the-component-helper-and-component-helper">The <code>(component</code> helper and <code>{{component</code> helper</a></h3>
<p>Much like <code>(action</code> creates a closure, it is proposed that the <code>(component</code>
helper create something similar. For example with actions:</p>
<pre><code class="language-hbs">{{#with (action &quot;save&quot; model) as |save|}}
  &lt;button {{action save}}&gt;Save&lt;/button&gt;
{{/with}}
</code></pre>
<p>The returned value of the <code>(action</code> nested helper (a function) closes over the
action being called (<code>actions.save</code> on the context and the <code>model</code> property).
The <code>{{action</code> helper can accept this resulting value and invoke the action
when the user clicks.</p>
<p>The <code>(component</code> helper will close over a component name. The
<code>{{component</code> helper will be modified to accept this resulting value and invoke
the component:</p>
<pre><code class="language-hbs">{{#with (component &quot;user-profile&quot;) as |uiPane|}}
  {{component uiPane}}
{{/with}}
</code></pre>
<p>Additionally, a bound value may be passed to the <code>(component</code> helper. For
example <code>(component someComponentName)</code>.</p>
<p>Attrs for the final component can also be closed over. Used with yield, this
allows for the creation of components that have attrs from other scopes. For
example:</p>
<pre><code class="language-hbs">{{! app/components/user-profile.hbs }}
{{yield (component &quot;user-profile&quot; user=user.name age=user.age)}}
</code></pre>
<pre><code class="language-hbs">{{#user-profile user=model as |profile|}}
  {{component profile}}
{{/user-profile}}
</code></pre>
<p>Of course attrs can also be passed at invocation. They smash any conflicting
attrs that were closed over. For example <code>{{component profile age=lyingUser.age}}</code></p>
<p>Passing the resulting value from <code>(component</code> into JavaScript is permitted,
however that object has no public properties or methods. Its only use would
be to set it on state and reference it in template somewhere.</p>
<h3 id="hash-helper"><a class="header" href="#hash-helper">Hash helper</a></h3>
<p>Unlike values, components are likely to have specific names that are semantically
relevent. When yielded to a new scope, allowing the user to change the name
of the component's variable would quickly lead to confusing addon documentation.
For example:</p>
<pre><code class="language-hbs">{{#with (component &quot;user-profile&quot;) as |dropDatabaseUI|}}
  {{component dropDatabaseUI}}
{{/with}}
</code></pre>
<p>The simplest way to enforce specific names is to make building hashes
of components (or anything) easy. For example:</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
</code></pre>
<p>The <code>(hash</code> helper is a generic builder of objects, given hash arguments. It
would also be useful in the same manner for actions:</p>
<pre><code class="language-hbs">{{#with (hash save=(action &quot;save&quot; model)) as |userActions|}}
  &lt;button {{action userActions.save}}&gt;Save&lt;/button&gt;
{{/with}}
</code></pre>
<h3 id="component-helper-shorthand"><a class="header" href="#component-helper-shorthand">Component helper shorthand</a></h3>
<p>To complete building a viable DSL, <code>.</code> invocation for <code>{{</code> components will be
introduced. For example this <code>{{component</code> invocation:</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{component userComponents.profile}}
{{/with}}
</code></pre>
<p>Could be converted to drop the explicit <code>component</code> helper call.</p>
<pre><code class="language-hbs">{{#with (hash profile=(component &quot;user-profile&quot;)) as |userComponents|}}
  {{userComponents.profile}}
{{/with}}
</code></pre>
<p>A component can be invoked like this only when it was created by the
<code>(component</code> nested helper form. For example unlike with the <code>{{component</code>
helper, a string is not acceptable.</p>
<p>To be a valid invocation, one of two criteria must be met:</p>
<ul>
<li>The component can be called as a path. For example <code>{{form.input}}</code> or <code>{{this.input}}</code></li>
<li>The component can be called as a helper. For example <code>{{form.input value=baz}}</code> or <code>{{this.input value=baz}}</code></li>
</ul>
<p>And of course a <code>.</code> must be present in the path.</p>
<h1 id="drawbacks-20"><a class="header" href="#drawbacks-20">Drawbacks</a></h1>
<p>This proposal encourages aggressive use of the <code>(</code> nested helper syntax.
Encouraging this has been slightly controversial.</p>
<p>No solution for angle components is presented here. The syntax for <code>.</code>
notation in angle components is coupled to a decision on the syntax for
bound, dynamic angle component invocation (a <code>{{component</code> helper for angle
components basically).</p>
<p><code>(component 'some-component'</code> may be too verbose. It may make sense to simply
allow <code>(some-component</code>.</p>
<p>Other proposals have leaned more heavy on extending factories in JavaScript
then passing an object created in that space. Some arguments against this:</p>
<ul>
<li>Getting the container correct is tricky. Who sets it when?</li>
<li>Properties on the classes would not be naturally bound, as they are in this proposal.</li>
<li>As soon as you start setting properties, you likely want a <code>mut</code> helper,
<code>action</code> helper, etc, in JavaScript space.</li>
<li>Keeping the component lookup in the template layer allows us to take advantage
of changes to lookup semantics later, such as local lookup in the pods
proposal.</li>
</ul>
<h1 id="alternatives-20"><a class="header" href="#alternatives-20">Alternatives</a></h1>
<p>All pain, no gain. Addons really want this.</p>
<h1 id="unresolved-questions-19"><a class="header" href="#unresolved-questions-19">Unresolved questions</a></h1>
<p>There has been discussion of if a similar mechanism should be available for
helpers.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-06-30
RFC PR: https://github.com/emberjs/rfcs/pull/65</p>
<hr />
<h1 id="summary-21"><a class="header" href="#summary-21">Summary</a></h1>
<p>Deprecations and warnings in Ember.js should have configurable runtime handlers.
This allows default behavior (logging, raise when <code>RAISE_ON_DEPRECATION</code> is true)
to be overridden by an enviornment (Ember's tests), addon, or other tool
(like the Ember Inspector).</p>
<p>Ember-Data and the Ember Inspector have both requested a public
API for changing how deprecation and warning messages are handled. The requirements
for these and other requests are complex enough that deferring the message
behavior into a runtime hook is the suggested path.</p>
<h1 id="motivation-22"><a class="header" href="#motivation-22">Motivation</a></h1>
<p><code>Ember.deprecate</code> and <code>Ember.warn</code> usually log messages. With <code>ENV.RAISE_ON_DEPRECATION</code>
all deprecations will throw an exception. In some scenarios, this
is less than ideal:</p>
<ul>
<li>Ember itself needs a way to silence some deprecations before their usage
is completely removed from tests. For example, many view APIs in Ember 1.13.</li>
<li>The Ember inspector desires to raise on specific deprecations, or silence
specific deprecations.</li>
<li>Ember-Data also desires to silence some deprecations in tests</li>
</ul>
<p>In <a href="https://github.com/emberjs/ember.js/pull/11419">PR #1141</a>
a private log level API has been introduced, which allows finer grained control
if specific deprecations should be logged, throwing an error or be silenced
completely. For example:</p>
<pre><code class="language-js">Ember.Debug._addDeprecationLevel('my-feature', Ember.Debug._deprecationLevels.LOG);
// ...
Ember.deprecate(&quot;x is deprecated, use Y instead&quot;, false, { id: 'my-feature' });
</code></pre>
<p>Initially a public version of this API was discussed, but it quickly became
clear that a runtime hook provided more flexibility without incurring the
cost of a complex log-level API.</p>
<p>Note that &quot;runtime&quot; refers to Ember itself. A custom handler could be injected
into Ember-CLI's template compilation code. &quot;runtime&quot; in this context still
refers to handling deprecations raised during compilation.</p>
<h1 id="detailed-design-21"><a class="header" href="#detailed-design-21">Detailed design</a></h1>
<p>A handler for deprecations can be registered. This handler will be called
with relevent information about a deprecation, including guarantees about
the presence of these items:</p>
<ul>
<li>The deprecation message</li>
<li>The version number where this deprecation (and feature) will be removed</li>
<li>The &quot;id&quot; of this deprecation, a stable identifier independent of the message</li>
</ul>
<p>Additionally, an application instance may be passed with the options. An example
handler would look like:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/deprecations&quot;;

registerHandler(function deprecationHandler(message, options) {
  // * message is the deprecation message
  // * options.until is the version this deprecation will be removed at
  // * options.id is the canonical id for this deprecation
  if (options.until === &quot;2.4.0&quot;) {
    throw new Error(message);
  } else {
    console.log(message);
  }
});
</code></pre>
<p>Warnings are similar, but will not recieve an <code>until</code> value:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/warnings&quot;;

registerHandler(function warningHandler(message, options) {
  // * message is the warning message
  // * options.id is the canonical id for this warning
  if (options.id !== 'view.rerender-on-set') {
    console.log(message);
  }
});
</code></pre>
<h5 id="chained-handlers"><a class="header" href="#chained-handlers">chained handlers</a></h5>
<p>Since several handlers may be registered, a method of deferring to a previously
registered handler must be allowed. A third option is passed to handlers, the
function <code>next</code> which represents the previously registered handler.</p>
<p>For example:</p>
<pre><code class="language-js">import { registerHandler } from &quot;ember-debug/deprecations&quot;;

registerHandler(function firstDeprecationHandler(message, options, next) {
  console.warn(message);
});

registerHandler(function secondDeprecationHandler(message, options, next) {
  if (options.until === &quot;2.4.0&quot;) {
    throw new Error(message);
  }
  next(...arguments);
});
</code></pre>
<p>The first registed handler will receive Ember's default behavior as <code>next</code>.</p>
<h5 id="new-assertions-for-deprecate-and-warn"><a class="header" href="#new-assertions-for-deprecate-and-warn">new assertions for deprecate and warn</a></h5>
<p>Ember's APIs for deprecation and warning do not currently require any information
beyond a message. It is proposed that deprecations be <strong>required</strong> to pass
the following information:</p>
<ul>
<li>Message</li>
<li>Test</li>
<li>Canonical id (with a format of <code>package-name.some-id</code>)</li>
<li>Release when this deprecation will be stripped</li>
</ul>
<p>For example:</p>
<pre><code>import Ember from &quot;ember&quot;;

Ember.deprecate(&quot;Some message&quot;, false, {
  id: 'ember-routing.query-params',
  until: '3.0.0'
});
</code></pre>
<p>If this information is not present and assertion will be made.</p>
<p>Warnings likewise will be required to pass a canonical id:</p>
<pre><code>import Ember from &quot;ember&quot;;

Ember.warn(&quot;Some warning&quot;, {id: 'ember-debug.something'});
</code></pre>
<h5 id="default-handlers"><a class="header" href="#default-handlers">default handlers</a></h5>
<p>The default handler for deprecation should be quite simple, and mirrors current
behavior:</p>
<pre><code class="language-js">function defaultDeprecationHandler(message, options) {
  if (Ember.ENV.RAISE_ON_DEPRECATION) {
   throw new Error(format(message, options));
  } else {
   console.log(format(message, options));
  }
}
</code></pre>
<p>The default handler for warnings would be simple <code>console.log</code>.</p>
<h1 id="drawbacks-21"><a class="header" href="#drawbacks-21">Drawbacks</a></h1>
<p>By not providing a robust log-level API, we are punting complexity to the
consumer of this API. For a low-level tooling API such as this one, it seems
and appropriate tradeoff.</p>
<h1 id="alternatives-21"><a class="header" href="#alternatives-21">Alternatives</a></h1>
<p>Each app can stub out <code>deprecate</code> and <code>warn</code>.</p>
<h1 id="unresolved-questions-20"><a class="header" href="#unresolved-questions-20">Unresolved questions</a></h1>
<p><code>RAISE_ON_DEPRECATION</code> could be considered deprecated with this new API.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-11-21
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/80</p>
<hr />
<h1 id="summary-22"><a class="header" href="#summary-22">Summary</a></h1>
<p>This RFC attempts to expose a public API in <code>ember-cli</code> to allow other platforms/infrastructure to serve the base page (index.html) and other assets from the <code>tmp</code> directory in their own custom way. This is only for development as this will only be used with <code>ember serve</code>. Currently <code>ember serve</code> serves files from the tmp directory (which is built as part of the build process) using the <code>broccoli-middleware</code>. This middleware in addition to serving the files also sets the correct headers for the assets it is serving. This RFC aims to split the work of setting the header and serving the files into two different addons such that any other infrastructure can easily create a middleware to serve assets using its own logic.</p>
<h1 id="motivation-23"><a class="header" href="#motivation-23">Motivation</a></h1>
<p>FastBoot and other infrastructure (for example the infrastructure at LinkedIn to serve the base page) does not require the index.html to be served from the disk directly. FastBoot requires to serve the index.html after it has appended the serialized template for the current request. It therefore requires to do some runtime replacements in the index.html before it can be served to the client. At LinkedIn, we stream the index.html in chunks for performance reasons and require to do some string replacements in index.html on per request basis.</p>
<p>During development, this requires us to create our own  express middleware via <code>serverMiddleware</code> which should run before the <code>serve-files</code> middleware. It also requires us to almost copy paste the headers that are set by <code>broccoli-middleware</code>. In addition to the above, the ability to be able to serve from <code>tmp</code> directory allows FastBoot and other infrastructure to correctly serve the assets from the directory pointing to the current build. Currently (with using their own middleware) FastBoot serves assets from the <code>dist</code> directory which is not the correct behavior.</p>
<p>In order to mitigate the need to diverge into another middleware which behaves almost same as <code>broccoli-middleware</code>, this RFC proposes to split the work of setting the headers and serving the files via <code>broccoli-middleware</code> and expose a public API that will allow an addon to define how it wants to serve the assets. It will be a low level public API that will be invoked by certain addons.</p>
<h1 id="detailed-design-22"><a class="header" href="#detailed-design-22">Detailed design</a></h1>
<p>Currently the <a href="https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L18"><code>serve-files</code></a> addon defines how it will serve the incoming asset requests. It invokes the <code>broccoli-middleware</code> which is responsible for three sets of things:</p>
<ol>
<li>
<p>Setting the response headers</p>
</li>
<li>
<p>serving the files and ending the response</p>
</li>
<li>
<p>Shows an error template if it is a build error</p>
</li>
</ol>
<h2 id="public-api"><a class="header" href="#public-api">Public API</a></h2>
<p>This RFC proposes expose two new in-repo addons in <code>ember-cli</code> which will now split the above work and remove the <code>serve-files</code> addon:</p>
<ol>
<li>
<p><code>ember-cli:broccoli:watcher</code>: This addon will contain the middleware which will be responsible for making sure the build is done and will set the response headers that <code>broccoli-middleware</code> is doing today. After setting the response headers, it will call the next middleware in the chain. In addition, if the build results in an error, it will show the error template and not terminate the response.</p>
</li>
<li>
<p><code>ember-cli:broccoli:serve-files</code>: This addon will always run <em>after</em> <code>ember-cli:broccoli:watcher</code> addon. It will contain a middleware that will be responsible for serving the files from the filesystem and ending the response.</p>
</li>
</ol>
<p>For any infrastructure that needs to serve the assets in its own way will be create an addon that will be injected between the above two addons. It will use the <code>serverMiddleware</code> public hook to provide its own middleware. Specifically the custom addon should run <em>before</em> <code>ember-cli:broccoli:serve-files</code> so that it can either override any response headers or can serve the files using its own logic and end the response. This will ensure that when the build is successful <code>ember-cli:broccoli:watcher</code> can call the correct next middleware in the chain.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<p>In order for the above API to be exposed, we need to drop the <code>serve-files</code> addon in <code>ember-cli</code>, refactor <code>broccoli-middleware</code> and create the two new addons.</p>
<h3 id="refactor-broccoli-middleware-to-expose-additional-middlewares"><a class="header" href="#refactor-broccoli-middleware-to-expose-additional-middlewares">Refactor <code>broccoli-middleware</code> to expose additional middlewares</a></h3>
<p><em>Note</em>: This refactor section is only for making the reader understand how the integration is meant to work in <code>ember-cli</code>. This is not going to be <code>ember-cli</code> public API.</p>
<p><code>broccoli-middleware</code> is currently responsible for setting the response headers and serving the files. It is a middleware that does these two tasks. It doesn't expose a proper middleware API to do the two tasks differently. We would like to refactor <code>broccoli-middleware</code> such that it exposes two additional middlewares:</p>
<ul>
<li><code>forWatcher(watcher)</code>:</li>
</ul>
<pre><code class="language-javascript">  /**
   * Function responsible for setting the response headers or creating the build error template
   *
   * @param {Object} watcher ember-cli watcher
   * @return {Function} middleware function
   */
   forWatcher: function(watcher) {
     var outputPath = watcher.builder.outputPath;
     ...
     return function middleware(request, response, next) {
       watcher.then(function() {
         // mostly all of this https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L96
         request.headers['x-broccoli'] = {
           outputPath: outputPath
         };
         next();
       }, function(buildError) {
         // mostly this: https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L121
       })
     }

   }
</code></pre>
<ul>
<li><code>serveFiles()</code>:</li>
</ul>
<pre><code class="language-javascript"> /**
  * This function will be responsible for serving the files from the filesystem
  *
  * @param {HTTP.Request} request
  * @param {HTTP.Response} response
  * @param {Function} next
  */
  serveFiles: function() {
    return function(req, resp, next) {
      // get the output path from from the request headers
      // most of `broccoli-middleware` https://github.com/ember-cli/broccoli-middleware/blob/master/lib/middleware.js#L115
    }
  }
</code></pre>
<h3 id="create-ember-clibroccoliwatcher-addon"><a class="header" href="#create-ember-clibroccoliwatcher-addon">Create <code>ember-cli:broccoli:watcher</code> addon</a></h3>
<p>The current <code>serve-files</code> addon invokes the <code>broccoli-middleware</code> and delegates the task to this middleware to serve the files and set the headers. We would like to change that and instead this new in-repo addon <code>ember-cli:broccoli:watcher</code> should only call <code>setResponseHeaders</code> function from <code>broccoli-middleware</code>. The <code>serverMiddleware</code> function of this <a href="https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L18">addon</a> will now look as follows:</p>
<pre><code class="language-javascript">  ServeFilesAddon.prototype.serverMiddleware = function(options) {
    var app = options.app;
    var watcher = options.options.watcher;
    var broccoliMiddleware = require('broccoli-middleware');

    app.use(function(req, resp, next) {
      // copy over this: https://github.com/ember-cli/ember-cli/blob/375f3a32f4564465d2eccc3815cb61b570ce29f0/lib/tasks/server/middleware/serve-files/index.js#L33
      if (options.options.middleware) {
        // call the middleware that is provided for testemMiddleware
      } else {
        var watcherMiddleware = broccoliMiddleware.forWatcher(watcher);

        watcherMiddleware(req, resp, function(err) {
          if (err) {
            // log error
          }
          next(err);
        });
      }
    });
  }
</code></pre>
<p>As seen above <code>ember-cli:broccoli:watcher</code> will only be responsible for setting the headers and calling the the next middleware which will serve the files.</p>
<h3 id="create-ember-clibroccoliserve-files-addon"><a class="header" href="#create-ember-clibroccoliserve-files-addon">Create <code>ember-cli:broccoli:serve-files</code> addon</a></h3>
<p>We will create a new in-repo addon called as <code>ember-cli:broccoli:serve-files</code> which will be responsible for serving the the files. This addon will run <em>after</em> <code>ember-cli:broccoli:watcher</code> addon.</p>
<p>This function will be responsible for serving the incoming asset request from the filesystem. It will use the <code>serverMiddleware</code> API to serve the files using <code>broccoli-middleware</code>.</p>
<pre><code class="language-javascript">  BroccoliServeFilesAddon.prototype.serverMiddleware = function(options) {
    var broccoliMiddleware = require('broccoli-middleware');
    var outputPath = options.watcher.builder.outputPath;
    var autoIndex = false;

    var options = { outputPath, autoIndex };
    app.use(function(req, resp, next) {
      var serveFileMiddlware = broccoliMiddleware.serveFiles();
      serveFileMiddlware(req, resp, function(err) {
        next(err);
      })
    });
  }
</code></pre>
<p>In order for FastBoot to be able to serve the assets using its own logic, it will specific that it run <em>before</em> <code>ember-cli:broccoli:serve-files</code> addon so that it can serve the assets. In this way, FastBoot will be able to inject itself into the correct order and be able to serve assets from the <code>tmp</code> directory.</p>
<h3 id="drop-serve-files-addon-in-ember-cli"><a class="header" href="#drop-serve-files-addon-in-ember-cli">Drop <code>serve-files</code> addon in ember-cli</a></h3>
<p>Since the work that <code>serve-files</code> does today is now split into two new in-repo addons, <code>serve-files</code> addon doesn't need to be present any longer. It is not exposing any public API or functionality that users may be using today and therefore can be dropped.</p>
<h1 id="how-we-teach-this-1"><a class="header" href="#how-we-teach-this-1">How We Teach This</a></h1>
<p>We will need to update the <code>ember-cli</code> website with this new in-repo addon and specify the above usecase with an example.</p>
<h1 id="drawbacks-22"><a class="header" href="#drawbacks-22">Drawbacks</a></h1>
<p>The only drawback is addon authors wanting to serve assets using their own logic, will need to know the correct order of middleware execution. Moreover, if someone has forked <code>ember-cli</code> to hack <code>serve-files</code> addon logic, it will be a breaking change for them.</p>
<h1 id="alternatives-22"><a class="header" href="#alternatives-22">Alternatives</a></h1>
<p>N/A</p>
<h1 id="unresolved-questions-21"><a class="header" href="#unresolved-questions-21">Unresolved questions</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
Should this addons be better named?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-04
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/86</p>
<hr />
<h1 id="summary-23"><a class="header" href="#summary-23">Summary</a></h1>
<p>Replace PhantomJS with Firefox as the default browser for continuous integration testing.</p>
<h1 id="motivation-24"><a class="header" href="#motivation-24">Motivation</a></h1>
<p>We want to provide the best possible out-of-the-box continuous integration testing experience for Ember apps. Today that means shipping with configurations for testem and TravisCI. Those configurations use PhantomJS.</p>
<p>But PhantomJS is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And &quot;how to debug in Phantom&quot; is an entire extra skill people are forced to learn.</p>
<p>A user-targeted, standards-compliant, modern browser makes a better default choice. Firefox is a good candidate because it's 100% open source, well-supported by Testem on all major operating system, and built-in to TravisCI. Debugging in Firefox has a dramatically nicer learner curve than PhantomJS.</p>
<h1 id="detailed-design-23"><a class="header" href="#detailed-design-23">Detailed design</a></h1>
<p>This is a proposed change to the blueprints for new apps and addons. Existing apps and addons would only be affected when they re-run <code>ember init</code> as part of an upgrade and choose to take the updated configuration.</p>
<h2 id="changes-in-testemjs"><a class="header" href="#changes-in-testemjs">Changes in testem.js</a></h2>
<p>Replace <code>PhantomJS</code> with <code>Firefox</code>.</p>
<h2 id="changes-in-travisyml"><a class="header" href="#changes-in-travisyml">Changes in travis.yml</a></h2>
<p>Add the following new section to start up a virtual display:</p>
<pre><code>before_script:
  - export DISPLAY=:99; sh -e /etc/init.d/xvfb start; sleep 3
</code></pre>
<h1 id="how-we-teach-this-2"><a class="header" href="#how-we-teach-this-2">How We Teach This</a></h1>
<p>In the guides, replace instructions for installing PhantomJS with instructions for installing Firefox. Since Firefox is a consumer-facing browser with widely-understood installers and behavior, this is one less intimidating thing for newbies to learn.</p>
<h1 id="drawbacks-23"><a class="header" href="#drawbacks-23">Drawbacks</a></h1>
<p>PhantomJS has two primary benefits over other browsers: being headless and being scriptable.</p>
<h2 id="headlessness"><a class="header" href="#headlessness">Headlessness</a></h2>
<p>Firefox is not headless, so it needs to render to a display. That is why the Travis configuration needs xvfb.</p>
<h2 id="scriptability"><a class="header" href="#scriptability">Scriptability</a></h2>
<p>PhantomJS is scriptable, but we don't rely on that functionality anyway. We want cross-browser test suites, so Phantom's scriptability is not particularly useful.</p>
<h1 id="alternatives-23"><a class="header" href="#alternatives-23">Alternatives</a></h1>
<p>The default alternative is to do nothing and keep PhantomJS.</p>
<p>Another alternative would be to pick Chrome, since it is a very popular browser. However, Chrome is not 100% open source, which complicates distribution. It's not built into Travis, and the popular methods of installing it there require users to opt into non-container-based images, which are heavier and slower to boot.</p>
<p>Chromium is the fully-open-source parts of Chrome, but like PhantomJS it is an odd duck that's not really well-packaged for end users. It's also not installed by default in Travis.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-11
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/90</p>
<hr />
<h1 id="summary-24"><a class="header" href="#summary-24">Summary</a></h1>
<p>In Ember CLI today, all addons at each level are built through the standard <code>treeFor</code> / <code>treeFor*</code> hooks. These hooks are responsible for preprocessing the JavaScript included by the tree returned from that specific hook (e.g., <code>treeForAddon</code> preprocesses the JS for the addon tree). This RFC proposes a mechanism that would allow these returned trees to be cached by default (when no build time customization is done) and expose proper hooks for addon authors to control the degree to which we dedupe these trees.</p>
<h1 id="motivation-25"><a class="header" href="#motivation-25">Motivation</a></h1>
<p>Today, given the dependency graph:</p>
<pre><code>ember-basic-dropdown:
  ember-wormhole@0.4.1

ember-modal-dialog:
  ember-wormhole@0.4.1

ember-paper:
  ember-wormhole@0.4.1
</code></pre>
<p>We would actually build <code>ember-wormhole</code>'s <code>addon</code> tree 3 different times, even though <a href="https://github.com/yapplabs/ember-wormhole/blob/0.4.1/index.js">as you can see</a> there is absolutely no build time customization being done. After all of these <code>ember-wormhole</code> tree instances are built, we merge them such that the last tree wins (thus making all of the work to preprocess these trees completely moot). If you extrapolate this out to larger applications or ones using multiple engines (lazy or not) it is fairly common to see these sorts of dependencies shared upwards of 4 to 5 times. This can lead to significant build performance degradation.</p>
<h1 id="detailed-design-24"><a class="header" href="#detailed-design-24">Detailed design</a></h1>
<ul>
<li>Add a <code>Addon.prototype.cacheKeyForTree</code> method to <a href="https://github.com/ember-cli/ember-cli/commits/master/lib/models/addon.js">lib/models/addon.js</a> that is invoked prior to calling <code>treeFor</code> for the same tree name. The <code>Addon.prototype.cacheKeyForTree</code> method is expected to return a cache key allowing multiple builds of the same tree to simply return the original tree (preventing duplicate work). If <code>Addon.prototype.cacheKeyForTree</code> returns <code>null</code> / <code>undefined</code> the tree in question will opt out of this caching system.</li>
<li>ember-cli's custom <a href="https://github.com/ember-cli/ember-cli/blob/4ec7b5951e8a9dd292029faf20d1858abf7bdfa0/lib/broccoli/merge-trees.js"><code>mergeTrees</code> implementation</a> (which is already aware of other tree reduction techniques) will be updated so that calling <code>mergeTrees([treeA, treeA]);</code> simply returns <code>treeA</code>, and <code>mergeTrees([treeA, treeB, treeA])</code> removes the duplicated <code>treeA</code> in the input nodes.</li>
</ul>
<p>The proposed declaration for <code>Addon.prototype.cacheKeyForTree</code> in Typescript syntax is:</p>
<pre><code class="language-ts">function cacheKeyForTree(treeType: string): string;
</code></pre>
<p>The default implementation for <code>Addon.prototype.cacheKeyForTree</code> will:</p>
<ul>
<li>
<p>Utilize a shared NPM package (e.g. <code>calculate-cache-key-for-tree</code>) that will generate a cache key that incorporates at least the following pieces of information:</p>
<ul>
<li><code>this.name</code> - The addon's name (generally from <code>package.json</code>).</li>
<li><code>this.pkg</code> - This builds a checksum accounting for the addon's <code>package.json</code>.</li>
<li><code>treeType</code> - The specific tree in question (e.g. <code>addon</code>, <code>vendor</code>, <code>addonTestSupport</code>, <code>templates</code>, etc).</li>
</ul>
</li>
<li>
<p>Resort to disabling all addon tree caching in the following scenarios</p>
<ul>
<li>The addon implements a custom <code>treeFor</code></li>
<li>The addon implements a custom <code>treeFor*</code> method (where <code>*</code> represents the tree type)</li>
</ul>
</li>
</ul>
<p>Addons that implement custom <code>treeFor</code> or <code>treeFor*</code> methods can still opt-in to caching in scenarios that they can confirm are safe. To do this, they would implement a custom <code>cacheKeyForTree</code> method and return a cache key as appropriate for their caching needs.</p>
<h1 id="how-we-teach-this-3"><a class="header" href="#how-we-teach-this-3">How We Teach This</a></h1>
<p>This is something that we do not expect 99% of ember-cli users to have to learn and understand, however it is still important for it to be possible to determine what is going on and how to work within the system when building addons.</p>
<p>The following should help us teach this to the correct audience (roughly &quot;addon power users&quot;):</p>
<ul>
<li>Document the shared NPM package (referred to above as <code>calculate-cache-key-for-tree</code>). This will help authors of addons that need to implement <code>treeFor*</code> hooks understand how they can properly implement <code>Addon.prototype.cacheKeyForTree</code>.</li>
<li>Write API docs for the newly added <code>Addon.prototype.cacheKeyForTree</code> method.</li>
</ul>
<h1 id="drawbacks-24"><a class="header" href="#drawbacks-24">Drawbacks</a></h1>
<ul>
<li>Cache invalidation is difficult to get right, and it is possible to accidentally troll our users. This can be mitigated by thorough review of the implementation and this RFC.</li>
</ul>
<h1 id="alternatives-24"><a class="header" href="#alternatives-24">Alternatives</a></h1>
<h1 id="unresolved-questions-22"><a class="header" href="#unresolved-questions-22">Unresolved questions</a></h1>
<ul>
<li>Confirm if including the same tree multiple times will only trigger a single build of that tree (this should be a Broccoli feature). We have confirmed that code exists in broccoli-builder (<a href="https://github.com/ember-cli/broccoli-builder/blob/0-18-x/lib/builder.js#L89-L97">see here</a>), but still need to actually confirm <code>.build</code> / <code>.read</code> / <code>.rebuild</code> are not called twice within the same build.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-14
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/91</p>
<hr />
<h1 id="summary-25"><a class="header" href="#summary-25">Summary</a></h1>
<p>Add an instrumentation hook that is available to addons.  This enables users to
write addons that do things like summarize and report build performance
information.</p>
<ul>
<li>see https://github.com/ember-cli/ember-cli/issues/6349 for additional context.</li>
<li>see https://github.com/ember-cli/ember-cli/pull/6606 for an experimental
implementation.</li>
</ul>
<h1 id="motivation-26"><a class="header" href="#motivation-26">Motivation</a></h1>
<p>Build performance is important to users.  We want to enable users to:</p>
<ol>
<li>Easily discover which portions of their build are costly;</li>
<li>Be able to summarize and report build information in an addon;</li>
<li>Be able to write addons that analyze build performance instrumentation so
that they can more easily help diagnose build performance issues in projects
to which they do not have direct access.  This is of particular interest to
@ember-cli/core &amp;c.</li>
</ol>
<p>In order to provide these hooks to enable iteration and experimentation prior to
making firm commitments to format, this rfc propose to initially expose them as
experiments (see the experiments section below).</p>
<h1 id="detailed-design-25"><a class="header" href="#detailed-design-25">Detailed design</a></h1>
<h2 id="experiments"><a class="header" href="#experiments">Experiments</a></h2>
<p>Experiments live in <code>lib/experiments/index.js</code>.  Unlike feature flags, there is
no need to strip them from production.  Experiments allow us to provide power
user features that are not fully stable without their resorting to private API
usage.</p>
<p>Experiments are available only in canary builds.  This is achieved by only
including <code>lib/experiements/index.js</code> in canary, and making it the entry point
for all experiments.</p>
<h2 id="instrumentation-hook"><a class="header" href="#instrumentation-hook">Instrumentation Hook</a></h2>
<p>We have already a build instrumentation hook as an
experiment in https://github.com/ember-cli/ember-cli/pull/6546</p>
<p>A more encompassing instrumentation hook is implemented in
https://github.com/ember-cli/ember-cli/pull/6606</p>
<p>The goal of this RFC is:</p>
<ol>
<li>To make the concept of experiments supported and explicit</li>
<li>To promote this particular experiment to public API</li>
</ol>
<h3 id="enabling-instrumentation"><a class="header" href="#enabling-instrumentation">Enabling Instrumentation</a></h3>
<p>Instrumentation is enabled if either the environment variable <code>BROCCOLI_VIZ</code> is
set to <code>1</code> or if <code>EMBER_CLI_INSTRUMENTATION</code> is set to <code>1</code>.</p>
<p>If <code>BROCCOLI_VIZ=1</code> then in addition to instrumentation hooks being invoked, a
serialized form of the instrumentation information is written to disk, that is
appropriate for consumption by <a href="https://github.com/ember-cli/broccoli-viz">broccoli-viz</a> which is the current behaviour.</p>
<h3 id="instrumentation"><a class="header" href="#instrumentation">Instrumentation</a></h3>
<h4 id="hook"><a class="header" href="#hook">Hook</a></h4>
<p>An addon that implements <code>instrumentation</code> will have this hook invoked when
instrumentation is enabled.</p>
<pre><code class="language-js">module.exports = {
  name: 'my-great-addon',

  instrumentation(name, payload) {
    // format of instrumentation payload outlined below
  }
};
</code></pre>
<h5 id="name"><a class="header" href="#name">name</a></h5>
<p>The <code>name</code> argument indicates what phase the instrumentation payload describes.
In beta and released versions this will always be a string.</p>
<p>On canary it could be a symbol from <code>lib/experiments</code> if we add more phases (eg
more fine-grained phases) for instrumentation information.</p>
<p>The initial set of phases this RFC advocates are:</p>
<ul>
<li><code>init</code></li>
<li><code>command</code></li>
<li><code>build</code></li>
<li><code>shutdown</code></li>
</ul>
<h5 id="payload"><a class="header" href="#payload">payload</a></h5>
<p><code>payload</code> is an object with two properties, <code>summary</code> and <code>graph</code>.</p>
<h5 id="payloadsummary"><a class="header" href="#payloadsummary">payload.summary</a></h5>
<p>The exact format of <code>payload.summary</code> depends on the specific phase for which
the instrumentation hook was called.  In each case, the keys listed are the
minimum keys that are guaranteed to be present, but there is no guarantee that
additional information might not also be present.</p>
<h6 id="init"><a class="header" href="#init">init</a></h6>
<p><code>init</code> covers the period up to, but not including, command execution.  This
means it's mostly dealing with <code>require</code> time.</p>
<p>For <code>init</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  totalTime,
  platform: {
    name,
  },
}
</code></pre>
<ul>
<li><code>summary.totalTime</code> The total time spent during <code>init</code></li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
</ul>
<h6 id="build"><a class="header" href="#build">build</a></h6>
<p><code>build</code> covers the time spent in an individual build or rebuild.</p>
<p>For <code>build</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  build: {
    type,
    count,
    outputChangedFiles

    // additional fields for rebuilds
    primaryFile,
    primaryFileCount,
    changedFiles
  },
  platform: {
    name,
  },
  output,
  totalTime,
  buildSteps,
}
</code></pre>
<ul>
<li><code>summary.build.type</code> one of <code>'initial'</code> or <code>'rebuild'</code></li>
<li><code>summary.build.count</code> the number of the build (0 for initial build, &gt; 0 for
rebuilds).</li>
<li><code>summary.build.outputChangedFiles</code> an array of paths to output files that
changed during this build.  These paths are relative to the <code>dist</code> directory.</li>
<li><code>summary.build.primaryFile</code> only present for rebuilds.  Indicates the first
file the watcher noticed had changed.</li>
<li><code>summary.build.changedFileCount</code> only present for rebuilds.  The number of
files the watcher had noticed changed before the build started.</li>
<li><code>summary.build.changedFiles</code> only present for rebuilds. The first 10 files
the watcher had noticed changed before the build started.</li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
<li><code>summary.output</code> The temp directory containing the results of the build.</li>
<li><code>summary.totalTime</code> The total time (in nanoseconds) of the build.</li>
<li><code>summary.buildSteps</code> The number of broccoli nodes built in this tree</li>
</ul>
<h6 id="command"><a class="header" href="#command">command</a></h6>
<p><code>command</code> covers the time spent during a command.  When the command includes a
build, there will be overlap between <code>command</code> and <code>build</code>.  When the command is
<code>serve</code>, this overlap will include only the last build, to avoid memory leaks.</p>
<p>For <code>command</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  totalTime,
  platform: {
    name,
  },
  name,
  args
}
</code></pre>
<ul>
<li><code>summary.totalTime</code> The total time spent during <code>init</code></li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
<li><code>summary.name</code> The name of the command that was run</li>
<li><code>summary.args</code> The args of the command that was run</li>
</ul>
<h6 id="shutdown"><a class="header" href="#shutdown">shutdown</a></h6>
<p><code>shutdown</code> covers the period from the command completing to process exit, ie
cleanup time.</p>
<p>For <code>shutdown</code>, the summary object has the following shape.</p>
<pre><code class="language-js">{
  totalTime,
  platform: {
    name,
  },
}
</code></pre>
<ul>
<li><code>summary.totalTime</code> The total time spent during <code>init</code></li>
<li><code>summary.platform.name</code> The value of <code>process.platform</code></li>
</ul>
<h5 id="payloadgraph"><a class="header" href="#payloadgraph">payload.graph</a></h5>
<p><code>graph</code> is an object that represents the instrumentation information we have
gathered for the build.  It is a DAG, whose flow is inverted from the broccoli
graph. It has a single source node (currently <code>TreeMerger (all trees)</code>).
<code>payload.graph</code> is this single source node.</p>
<p>Each node in the graph provides an API for iterating its subgraph as well as
iterating its own stats. The specific nodes in the graph will change over time as
the instrumentation within ember-cli changes.  There is no particular guarantee
about what the nodes will be, although we will continue to ensure that its
<code>toJSON</code> format is consumable by
<a href="https://github.com/ember-cli/broccoli-viz">broccoli-viz</a></p>
<p>The API that each node supports is:</p>
<ul>
<li><code>label</code></li>
<li><code>toJSON</code></li>
<li><code>adjacentIterator</code></li>
<li><code>dfsIterator</code></li>
<li><code>bfsIterator</code></li>
</ul>
<h6 id="label"><a class="header" href="#label">label</a></h6>
<p>A POJO property that describes the node.  It will always include a <code>name</code>
property and for broccoli nodes will include a <code>broccoliNode</code> property.</p>
<p>Example:</p>
<pre><code class="language-js">node.label === {
  name: 'TreeMerger (allTrees)',
  broccoliNode: true,
}
</code></pre>
<h6 id="tojson"><a class="header" href="#tojson">toJSON()</a></h6>
<p>Returns a POJO that represents the serialized subgraph rooted at this node (the
entire tree if called on the root node).</p>
<p>There is no particular guarantee about the format, except that whatever it is
will be supported by <a href="https://github.com/ember-cli/broccoli-viz">broccoli-viz</a>.</p>
<p>Example:</p>
<pre><code class="language-js">// for a graph
//  TreeMerger
//    |- Babel_1
//    |- Babel_2
//    |--|- Funnel
console.log(JSON.stringify(node.toJSON(), null, 2));
// might print
//
{
  nodes: [{
    id: 1,
    children: [2,3],
    stats: {
      time: {
        self: 5000000,
      },
      fs: {
        lstat: {
          count: 2,
          time: 2000000
        }
      },
      own: {
      }
    }
  }, {
    // ...
  }]
}
</code></pre>
<h6 id="adjacentiterator"><a class="header" href="#adjacentiterator">adjacentIterator</a></h6>
<p>Returns an iterator that yields each adjacent outbound node.  There is no
guarantee about the order in which they are yielded.</p>
<pre><code class="language-js">// for a tree
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
node.label.name === &quot;TreeMerger&quot;;
for (n of node.adjacentIterator()) {
  console.log(n.label.name);
}
// prints
//
// Babel_1
// Babel_2


for (n of node.preOrderIterator(x =&gt; x.label.name === 'Babel_2')) {
  console.log(n.label.name);
}
// prints
//
//  TreeMerger
//  |- Babel_1
</code></pre>
<h6 id="dfsiteratoruntil"><a class="header" href="#dfsiteratoruntil">dfsIterator(until)</a></h6>
<p>Returns an iterator that yields every node in the subgraph sourced at this node.
Nodes are yielded in depth-first order.  If the optional parameter <code>until</code> is
passed, nodes for which <code>until</code> returns <code>true</code> will not be yielded, nor will
nodes in their subgraph, unless those nodes are reachable by some other path.</p>
<p>Example:</p>
<pre><code class="language-js">// for a graph
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
for (n of node.dfsIterator()) {
  console.log(n.label.name);
}
// prints
//
// TreeMerger
// Babel_1
// Funnel
// Babel_2
</code></pre>
<h6 id="bfsiterator"><a class="header" href="#bfsiterator">bfsIterator()</a></h6>
<p>Returns an iterator that yields every node in the subgraph sourced at this node.
Nodes are yielded in breadth-first order.  If the optional parameter <code>until</code> is
passed, nodes for which <code>until</code> returns <code>true</code> will not be yielded, nor will
nodes in their subgraph, unless those nodes are reachable by some other path.</p>
<p>Example:</p>
<pre><code class="language-js">// for a tree
//  TreeMerger
//    |- Babel_1
//    |--|- Funnel
//    |- Babel_2
for (n of node.bfsIterator()) {
  console.log(n.label.name);
}
// prints
//
// TreeMerger
// Babel_1
// Babel_2
// Funnel
</code></pre>
<h6 id="statsiterator"><a class="header" href="#statsiterator">statsIterator()</a></h6>
<p>Returns an iterator that yields <code>[name, value]</code> pairs of stat names and values.</p>
<p>Example:</p>
<pre><code class="language-js">  //  for a typical broccoli node
  for ([statName, statValue] of node.statsIterator()) {
    console.log(statName, statValue);
  }
  // prints
  //
  // &quot;time.self&quot; 64232794
  // &quot;fs.statSync.count&quot; 40
  // &quot;fs.statSync.time&quot; 401232123
  // ...
</code></pre>
<h1 id="how-we-teach-this-4"><a class="header" href="#how-we-teach-this-4">How We Teach This</a></h1>
<p>This has no effect on day-to-day usage of ember-CLI.  It is a tool to help users
monitor and analyze their build performance, so documentation and teaching
belong primarily in <code>PERF_GUIDE.md</code>.  Having said that, we should also add a
section to <code>https://ember-cli.com/extending/</code> and the API docs to make using
this feature easier for addon authors and CLI power users.</p>
<h1 id="drawbacks-25"><a class="header" href="#drawbacks-25">Drawbacks</a></h1>
<ul>
<li>No drawbacks come to mind, besides the ever present issue of maintenance</li>
</ul>
<h1 id="alternatives-25"><a class="header" href="#alternatives-25">Alternatives</a></h1>
<p>One alternative is the status quo: with <code>BROCCOLI_VIZ=1</code> users can output a file
with a similar format that they can post-process offline.  Although this works
for manual analysis, it is considerably more cumbersome for any automated system
(such as ongoing monitoring of build performance).  It also does not include
instrumentation outside of the build, most notably startup.</p>
<h1 id="unresolved-questions-23"><a class="header" href="#unresolved-questions-23">Unresolved questions</a></h1>
<ul>
<li><a href="https://github.com/heimdalljs/heimdalljs-tree">heimdalljs-tree</a> supports
<code>Symbol.Iterator</code>; should we commit to this as part of our API?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-09-11
RFC PR: https://github.com/emberjs/rfcs/pull/91
Ember Issue: https://github.com/emberjs/ember.js/pull/12224 / https://github.com/emberjs/ember.js/pull/12990 / https://github.com/emberjs/ember.js/pull/13688</p>
<hr />
<h1 id="summary-26"><a class="header" href="#summary-26">Summary</a></h1>
<p>Introduce <code>Ember.WeakMap</code> (<code>@ember/weakmap</code>), an ES6 enspired WeakMap. A
WeakMap provides a mechanism for storing and retriving private state. The
WeakMap itself does not retain a reference to the state, allowing the state to
be reclaimed when the key is reclaimed.</p>
<p>A traditional WeakMap (and the one that will be part of the language) allows
for weakness from key -&gt; map, and also from map -&gt; key. This allows either the
Map, or the key being reclaimed to also release the state.</p>
<p>Unforunately, this bi-directional weakness is problemative to polyfil. Luckily,
uni-directional weakness, in either direction, &quot;just works&quot;. A polyfil must
just choose a direction.</p>
<p><em>Note: Just like ES2015 WeakMap, only non null Objects can be used as keys</em>
<em>Note: <code>Ember.WeakMap</code> can be used interchangibly with the ES2015 WeakMap. This
will allow us to eventually cut over entirely to the Native WeakMap.</em></p>
<h1 id="motivation-27"><a class="header" href="#motivation-27">Motivation</a></h1>
<p>It is a common pattern to want to store private state about a specific object.
When one stores this private state off-object, it can be tricky to understand
when to release the state. When one stores this state on-object, it will be
released when the object is released. Unfortunately, storing the state
on-object without poluting the object itself is non-obvious.</p>
<p>As it turns out, Ember's Meta already solves this problem for
listeners/caches/chains/descriptors etc. Unfortunately today, there is no
public API for apps or addons to utilize this. <code>Ember.WeakMap</code> aims to be
exactly that API.</p>
<p>Some examples:</p>
<ul>
<li>https://github.com/offirgolan/ember-cp-validations/blob/master/addon/utils/cycle-breaker.js</li>
<li>https://github.com/stefanpenner/ember-state-services/ (will soon utilize the user-land polyfil of this) to prevent common leaks.</li>
</ul>
<h1 id="detailed-design-26"><a class="header" href="#detailed-design-26">Detailed design</a></h1>
<h2 id="public-api-1"><a class="header" href="#public-api-1">Public API</a></h2>
<pre><code class="language-js">import WeakMap from '@ember/weak-map'

var private = new WeakMap();
var object = {};
var otherObject = {};

private.set(object, {
  id: 1,
  name: 'My File',
  progress: 0
}) === private;

private.get(object) === {
  id: 1,
  name: 'My File',
  progress: 0
});


private.has(object) === true;
private.has(otherObject) === false;

private.delete(object) === private;
private.has(object) === false;
</code></pre>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<p>The backing store for <code>Ember.WeakMap</code> will reside in a lazy <code>ownMap</code> named
<code>weak</code> on the key objects <code>__meta__</code> object.</p>
<p>Each <code>WeakMap</code> has its own internal GUID, which will be the name of its slot,
in the key objects meta weak bucket. This will allow one object to belong in
multiple weakMaps without chance of collision.</p>
<p>Concrete Implementation: https://github.com/emberjs/ember.js/pull/12224
Polyfill: https://www.npmjs.com/package/ember-weakmap</p>
<h1 id="drawbacks-26"><a class="header" href="#drawbacks-26">Drawbacks</a></h1>
<ul>
<li>implementing bi-direction Weakness in userland is problematic.</li>
<li>Using WeakMap will insert a non-enumerable <code>meta</code> onto the key Object.</li>
</ul>
<h1 id="alternatives-26"><a class="header" href="#alternatives-26">Alternatives</a></h1>
<ul>
<li>Weakness could be implemented in the other direction, but this has questionable utility.</li>
</ul>
<h1 id="unresolved-questions-24"><a class="header" href="#unresolved-questions-24">Unresolved questions</a></h1>
<p>N/A</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-17
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/92</p>
<hr />
<h1 id="summary-27"><a class="header" href="#summary-27">Summary</a></h1>
<p>Give blueprint generators the ability to clean up old files.</p>
<h1 id="motivation-28"><a class="header" href="#motivation-28">Motivation</a></h1>
<p>We want to eliminate the noise of having old files laying after updating
ember-cli using <code>ember init</code>.</p>
<h1 id="detailed-design-27"><a class="header" href="#detailed-design-27">Detailed design</a></h1>
<p>We'd like an API for blueprints to delete files instead of only
create. It would be essentially syntactic sugar for removing the file yourself
in an <code>afterInstall</code> hook. It would be a returned array on the blueprint's <code>index.js</code>.</p>
<pre><code class="language-js">// ember-cli/bluprints/blah/index.js
module.exports = {
  // ...

  get oldFilesToRemove() {
    return [
      'brocfile.js',
      'LICENSE.MD',
      'testem.json'
    ];
  }
};
</code></pre>
<h1 id="how-we-teach-this-5"><a class="header" href="#how-we-teach-this-5">How We Teach This</a></h1>
<p>The guides could use this addition in the blueprints section, but I envision it
being used by mostly power users.</p>
<p>A changelog entry should be sufficient to teach this.</p>
<h1 id="drawbacks-27"><a class="header" href="#drawbacks-27">Drawbacks</a></h1>
<p>The only reason to not do this is to hold out for a large blueprint reworking.
We would be locked into this API.</p>
<h1 id="alternatives-27"><a class="header" href="#alternatives-27">Alternatives</a></h1>
<p>The key name can be bikeshed. I chose <code>oldFilesToRemove</code> to be verbose and
explicit, but it can be changed.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-01-03
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/95</p>
<hr />
<h1 id="summary-28"><a class="header" href="#summary-28">Summary</a></h1>
<p>This RFC proposes the introduction of a official convention to specify the target browsers
and node versions of an application.</p>
<h1 id="motivation-29"><a class="header" href="#motivation-29">Motivation</a></h1>
<p>Javascript and the platforms it runs on are moving targets. NodeJS and browsers release new
versions every few weeks. Browsers auto update and each update brings new language features
and APIs.</p>
<p>Developers need an easy way to express intention that abstracts them from the ever-changing
landscape of versions and feature matrices, so this RFC proposes the introduction of a unique
place and syntax to let developers express their intended targets that all addons can use,
instead of having each addon define it in a different way.</p>
<p>This configuration should be easily available to addons, but this RFC doesn't impose
any mandatory behavior on those addons. All addons that want to customize their behavior
depending on the target browsers will have a single source of truth to get that
information but it's up to them how to use it.</p>
<p>The advantage of having a single source of truth for the targets compared to configure this
on a per-addon basis like we do today is mostly for better ergonomics and across-the-board
consistency.</p>
<p>Examples of addons that would benefit from this conventions are <code>babel-preset-env</code>, <code>autoprefixer</code>,
<code>stylelint</code> and <code>eslint</code> (vía <code>eslint-plugin-compat</code>) and more. Even Ember itself could,
once converted into an addon, take advantage of that to avoid polyfilling or even taking
advantage of some DOM API (<code>node.classList</code>?) deep in Glimmer's internals, helping the goal
of Svelte Builds.</p>
<h1 id="detailed-design-28"><a class="header" href="#detailed-design-28">Detailed design</a></h1>
<p>What seems to be the most popular tool and the state of the art on building suport matrices
for browser targets is the <a href="https://github.com/ai/browserslist">browserlist</a> npm package.</p>
<p>That package is the one behind <code>babel-preset-env</code>, <code>autoprefixer</code> and others, and uses the data from
<a href="http://caniuse.com/">Can I Use</a> for knowing the JS, CSS and other APIs available on every browser.</p>
<p>The syntax of this package is natural but also pretty flexible, allowing complex
queries like <code>Firefox &gt;= 20</code>, <code>&gt;2.5% in CA</code> (browsers with a market share over 2.5% in Canada)
and logical combinations of the previous.</p>
<p>The way this library work is by calculating the minimum common denominator support on a per-feature basis.</p>
<p>Per example, if the support matrix for an app is <code>['IE11', 'Firefox latest']</code> and we have a linter
that warns us when we use an unsupported browser API, it would warn us if we try to use
pointer events (supported in IE11 but not in Firefox), would warn us also when using <code>fetch</code> (supported
in firefox but not in IE) and would not warn us when using <code>MutationObserver</code> because it is supported by both.</p>
<p>This library is very powerful and popular, making relatively easy to integrate with a good amount of
tools that already use it with low effort.</p>
<p>This configuration must be made available to addons but it's up to the addon authors to take advantage
of it.</p>
<h3 id="browser-support"><a class="header" href="#browser-support">Browser support</a></h3>
<p>The configution of target browsers must be placed in a file that allows javascript execution and exports an object
with the configuration. The reason to prefer a javascript file over a JSON one is to allow users to
dinamically generate different config depending on things like the environment they are building the app in or
any other environment variable.</p>
<p>One possible location for this configuration is the <code>.ember-cli</code> file.
A new dedicated named <code>/config/targets.js</code> also seems a good option, similar way how addons use <code>config/ember-try.js</code>
to configure the test version matrix.</p>
<p>Ember CLI will require this file when building the app and make the configuration available to addons
in a <code>this.project.targets</code> property.</p>
<p>This <code>targets</code> object contains a getter named <code>browsers</code> that returns the provided configuration or the default
one if the user didn't provide any.</p>
<p>Example usage:</p>
<pre><code class="language-js">module.exports = {
  name: 'ember-data',

  included(app) {
    this._super.included.apply(this, arguments);

    console.log(this.project.targets.browsers); // ['&gt;2%', 'last 3 iOS versions', 'not ie &lt;= 8']
  }
};
</code></pre>
<p>This <code>targets</code> object can, and probably will, be expanded in the future with new properties
for different kind of targets, like cordoba apps or fastboot, but that will be
done in a different RFC.</p>
<h1 id="how-we-teach-this-6"><a class="header" href="#how-we-teach-this-6">How We Teach This</a></h1>
<p>This is a new concept in Ember CLI, so guides will have to be updated to explain this
concept. The good part is that this new concept can help enforcing with tools a task were
traditionally enforced only with peer reviews.</p>
<p>To ease the transition Ember CLI can also, in the absence of a specific value provided by the user,
default to a predefined matrix of browsers that matches the browsers officially supported by the framework.</p>
<p>As of today, the supported browser list for Ember.js, according to the platforms we test in saucelabs, is:</p>
<p><code>['IE9', 'Chrome current', 'Safari current', 'Firefox current']</code></p>
<p>There is no mention to IOS/Android, so this must be validated still.</p>
<h1 id="drawbacks-28"><a class="header" href="#drawbacks-28">Drawbacks</a></h1>
<p>While this RFC standardizes a concept that will open the door to better and more comprehensive tooling,
it makes us choose one syntax (the one used by <a href="https://github.com/ai/browserslist">browserlist</a>) over
any other perhaps superior choice that may exist or appear in the future.</p>
<h1 id="alternatives-28"><a class="header" href="#alternatives-28">Alternatives</a></h1>
<p>Let every addon that wants to deal with targets to have a <code>targets</code>-like option in its configuration
instead of standardizing a single configuration option, which effectively leaves things as they are
right now.</p>
<p>Example:</p>
<pre><code>var app = new EmberApp(defaults, {
  'ember-cli-autoprefixer': {
    browsers: ...
  },
  'ember-cli-babel': {
    targets: ...
  },
  'ember-cli-eslint': {
    engines: ...
  },
  ...
});
</code></pre>
<h1 id="unresolved-questions-25"><a class="header" href="#unresolved-questions-25">Unresolved questions</a></h1>
<p>The proposed syntax for node only supports a single version of node. Is it reasonable to
make this property an array of versions? P.e. <code>[&quot;4.4&quot;, &quot;6&quot;, &quot;7&quot;]</code></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-09-24
RFC PR: https://github.com/emberjs/rfcs/pull/95
Ember Issue: https://github.com/emberjs/ember.js/pull/14805</p>
<hr />
<h1 id="summary-29"><a class="header" href="#summary-29">Summary</a></h1>
<p>This RFC proposes:</p>
<ul>
<li>
<p>creating a public <code>router</code> service that is a superset of today's <code>Ember.Router</code>.</p>
</li>
<li>
<p>codifying and expanding the supported public API for the <code>transition</code> object that is currently passed to <code>Route</code> hooks.</p>
</li>
<li>
<p>introducing the <code>get-route-info</code> template helper</p>
</li>
<li>
<p>introducing the <code>#with-route-info</code> template keyword</p>
</li>
<li>
<p>introducing the <code>readsRouteInfo</code> static property on <code>Component</code> and <code>Helper</code>.</p>
</li>
</ul>
<p>These topics are closely related because they share a unified <code>RouteInfo</code> type, which will be described in detail.</p>
<h1 id="motivation-30"><a class="header" href="#motivation-30">Motivation</a></h1>
<p>Given the modern Ember concepts of Components and Services, it is clear that routing capability should be exposed as a Service. I hope this is uncontroversial, given that we already implement it as a service internally, and given that usage of these nominally-private APIs is already becoming widespread.</p>
<p>The immediate benefit of having a <code>RouterService</code> is that you can inject it into components, giving them a friendly way to initiate transitions and ask questions about the current global router state.</p>
<p>A second benefit is that we have the opportunity to add new capabilities to the <code>RouterService</code> to replace several common patterns in the wild that dive into private internals in order to get things done. There are several places where we leak internals from router.js, and we can plug those leaks.</p>
<p>A <code>RouterService</code> is great for asking global questions, but some questions are not global and today we incur complexity by treating them as if they are. For example:</p>
<ul>
<li>
<p><code>{{link-to}}</code> can use implicit models from its context, but that breaks when you're trying to animate to or from a state where those models are not present.</p>
</li>
<li>
<p><code>{{link-to}}</code> has a lot of complexity and performance cost that deals with changing its active state, and the precise timing of when that should happen.</p>
</li>
<li>
<p>there is no way to ask the router what it would do to handle a given URL without actually visiting that URL.</p>
</li>
</ul>
<p>All of the above can be addressed by embracing what is already internally true: &quot;the current route&quot; is not a single global, it's a dynamically-scoped variable that can have different values in different parts of the application simultaneously.</p>
<h1 id="detailed-design-29"><a class="header" href="#detailed-design-29">Detailed design</a></h1>
<h2 id="routerservice"><a class="header" href="#routerservice">RouterService</a></h2>
<p>By way of a simple example, the router service behaves like this:</p>
<pre><code class="language-js">import Component from 'ember-component';
import service from 'ember-service/inject';

export default Component.extend({
  router: service(),
  actions: {
    goToMars() {
      this.get('router').transitionTo('planet.mars');
    }
  }
});
</code></pre>
<p>Like any Service, it can also be injected into Helpers, Routes, etc.</p>
<h3 id="relationship-between-emberrouter-and-routerservice"><a class="header" href="#relationship-between-emberrouter-and-routerservice">Relationship between EmberRouter and RouterService</a></h3>
<p>Q: &quot;Why are you calling this thing 'router' when we already have a router? Shouldn't the new thing be called 'routing' or something else?&quot;.</p>
<p>A: We shouldn't have two things. From the user's perspective, there is just &quot;the router&quot;, and it happens to be available as a service. While we're free to continue implementing it as multiple classes under the hood, the public API should present as a single, coherent concept.</p>
<p>Terminology:</p>
<ul>
<li><code>EmberRouter</code> is the class that we already have today, defined in <code>ember-routing/system/router</code> and available publicly as <code>Ember.Router</code></li>
<li><code>RouterService</code> is the new class I am proposing.</li>
</ul>
<p><code>EmberRouter</code> has the following public API today:</p>
<ul>
<li><code>map</code></li>
<li><code>location</code></li>
<li><code>rootURL</code></li>
<li><code>willTransition</code></li>
<li><code>didTransition</code></li>
</ul>
<p>That API will be carried over verbatim to <code>RouterService</code>, and the publicly accessible <code>Ember.Router</code> class will <em>become</em> <code>RouterService</code>. In terms of implementation, I expect the existing <code>EmberRouter</code> class will continue to exist mostly unchanged. But public access to it will be moderated through <code>RouterService</code>.</p>
<h3 id="new-methods-initiating-transitions"><a class="header" href="#new-methods-initiating-transitions">New Methods: Initiating Transitions</a></h3>
<pre><code class="language-js">transitionTo(routeName, ...models, queryParams)
replaceWith(routeName, ...models, queryParams)
</code></pre>
<p>These two have the same semantics as the existing methods on <code>Ember.Route</code>:</p>
<h3 id="new-method-checking-for-active-route"><a class="header" href="#new-method-checking-for-active-route">New Method: Checking For Active Route</a></h3>
<ul>
<li><code>isActive(routeName, ...models, queryParams)</code></li>
</ul>
<p>The arguments have the same semantics as <code>transitionTo</code>, the return value is a boolean. This should provide the same logic that determines whether to put an active class on a <code>link-to</code>. Here's an example of how we can implement <code>is-active</code> as a helper, using this method:</p>
<pre><code class="language-js">import Helper from 'ember-helper';
import service from 'ember-service/inject';
import observer from 'ember-metal/observer';

export default Helper.extend({
  router: service(),
  compute([routeName, ...models], hash) {
    let allModels;
    if (hash.models) {
      allModels = models.concat(hash.models);
    } else {
      allModels = models;
    }
    return this.get('router').isActive(routeName, ...allModels, hash.queryParams);
  },
  didTransition: observer('router.currentRoute', function() {
    this.recompute();
  })
});
</code></pre>
<pre><code class="language-hbs">{{!- Example usage -}}
&lt;li class={{if (is-active &quot;person.detail&quot; model) 'chosen'}} &gt;

{{!- Example usage with generic routeName and list of models (avoids splat) -}}
&lt;a class={{if (is-active routeName models=models) 'chosen'}} &gt;

{{!- Note that the complexities of currentWhen can be avoided by composing instead. }}
&lt;a class={{if (or (is-active 'one') (is-active 'two')) 'active'}} href={{url-for 'two'}} &gt;

</code></pre>
<h3 id="new-method-url-generation"><a class="header" href="#new-method-url-generation">New Method: URL generation</a></h3>
<p><code>urlFor(routeName, ...models, queryParams)</code></p>
<p>This takes the same arguments as <code>transitionTo</code>, but instead of initiating the transition it returns the resulting root-relative URL as a string (which will include the application's <code>rootUrl</code>).</p>
<p>A <code>url-for</code> helper can be implemented almost identically to the <code>is-active</code> example above.</p>
<h3 id="new-method-url-recognition"><a class="header" href="#new-method-url-recognition">New Method: URL recognition</a></h3>
<p><code>recognize(url)</code></p>
<p>Takes a string URL and returns a <code>RouteInfo</code> for the leafmost route represented by the URL. Returns <code>null</code> if the URL is not recognized. This method expects to receive the actual URL as seen by the browser <em>including</em> the app's <code>rootURL</code>.</p>
<p>Example: this feature can replace <a href="https://github.com/intercom/ember-href-to/blob/b8cf0699eec6a65570b05e4fc22b27d8cea49c42/app/instance-initializers/browser/ember-href-to.js#L34">this use of private API in ember-href-to</a>.</p>
<h3 id="new-method-recognize-and-load-models"><a class="header" href="#new-method-recognize-and-load-models">New Method: Recognize and load models</a></h3>
<p><code>recognizeAndLoad(url)</code></p>
<p>Takes a string URL and returns a promise that resolves to a <code>RouteInfoWithAttributes</code> for the leafmost route represented by the URL. The promise rejects if the URL is not recognized or an unhandled exception is encountered. This method expects to receive the actual URL as seen by the browser <em>including</em> the app's <code>rootURL</code>.</p>
<h3 id="deprecating-willtransition-and-didtransition"><a class="header" href="#deprecating-willtransition-and-didtransition">Deprecating willTransition and didTransition</a></h3>
<p>Application-wide transition monitoring events belong on the Router service, not spread throughout the Route classes. That is the reason for the existing <code>willTransition</code> and <code>didTransition</code> hooks/events on the Router. But they are not sufficient to capture all the detail people need. See for example, https://github.com/nickiaconis/rfcs/blob/1bd98ec534441a38f62a48599ffa8a63551b785f/text/0000-transition-hooks-events.md</p>
<p>In addition, they receive handlerInfos in their arguments, which are an undocumented internal implementation detail of router.js that doesn't belong in Ember's public API. Everything you can do with handlerInfos can be done with the RouteInfo type that is proposed in this RFC, with the benefit of sticking to supported public API.</p>
<p>So we should deprecate willTransition and didTransition in favor of the following new events.</p>
<h3 id="new-events-routewillchange--routedidchange"><a class="header" href="#new-events-routewillchange--routedidchange">New Events: routeWillChange &amp; routeDidChange</a></h3>
<p>The <code>routeWillChange</code> event fires whenever a new route is chosen as the desired target of a transition. This includes <code>transitionTo</code>, <code>replaceWith</code>, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, <code>routeDidChange</code> fires. </p>
<p>Both events receive a single <code>transition</code> argument as described in the &quot;Transition Object&quot; section below, which explains the meaning of <code>from</code> and <code>to</code> in more detail.</p>
<p>Redirection example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>B redirects to C</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> C.</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> C.</li>
</ol>
<p>Abort example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>in response to the previous routeWillChange event, the transition is aborted.</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> A.</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> A.</li>
</ol>
<p>Error example:</p>
<ol>
<li>current route is A</li>
<li>user initiates a transition to B.index</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B.</li>
<li>B throws an exception, and the router discovers a &quot;B-error&quot; template.</li>
<li>routeWillChange fires <code>from</code> A <code>to</code> B-error</li>
<li>routeDidChange fires <code>from</code> A <code>to</code> B-error</li>
</ol>
<p>These are events, not extension hooks -- now that we are exposing a Service, it makes more sense to subscribe to its events than extend it.</p>
<h3 id="new-properties"><a class="header" href="#new-properties">New Properties</a></h3>
<p><code>currentRoute</code>: an observable property. It is guaranteed to change whenever a route transition happens (even when that transition only changes parameters and doesn't change the active route). You should consider its value deeply immutable -- we will replace the whole structure whenever it changes. The value of <code>currentRoute</code> is a <code>RouteInfo</code> representing the current leaf route. <code>RouteInfo</code> is described below.</p>
<p><code>currentRouteName</code>:  a convenient alias for <code>currentRoute.name</code>.</p>
<p><code>currentURL</code>: provides the serialized string representing <code>currentRoute</code>.</p>
<h3 id="query-parameter-semantics"><a class="header" href="#query-parameter-semantics">Query Parameter Semantics</a></h3>
<p>Today, <code>queryParams</code> impose unnecessarily high cost because we cannot generate URLs or determine if a link is active without taking into account the default values of query parameters. Determining their default values is expensive, because it involves instantiating the corresponding controller, even in cases where we will never visit its route.</p>
<p>Therefore, the <code>queryParams</code> argument to the new <code>urlFor</code>, <code>transitionTo</code>, <code>replaceWith</code>, and <code>isActive</code> methods defined in this document will behave differently.</p>
<ul>
<li>
<p>default values will not be stripped from generated URLs. For example, <code>urlFor('my-route', { sortBy: 'title' })</code> will always include <code>?sortBy=title</code>, whether or not <code>title</code> is the default value of <code>sortBy</code>.</p>
</li>
<li>
<p>to explicitly unset a query parameter, you can pass the symbol <code>Ember.DEFAULT_VALUE</code> as its value. For example, <code>transitionTo('my-route', { sortBy: Ember.DEFAULT_VALUE })</code> will result in a URL that does not contain any <code>?sortBy=</code>.</p>
</li>
</ul>
<p>(Sticky parameters are still allowed, because they only apply when the destination controller has already been instantiated anyway.)</p>
<h2 id="routeinfo-type"><a class="header" href="#routeinfo-type">RouteInfo Type</a></h2>
<p>A RouteInfo object has the following properties. They are all read-only.</p>
<ul>
<li>name: the dot-separated, fully-qualified name of this route, like <code>&quot;people.index&quot;</code>.</li>
<li>localName: the final part of the <code>name</code>, like <code>&quot;index&quot;</code>.</li>
<li>params: the values of this route's parameters. Same as the argument to <code>Route</code>'s <code>model</code> hook. Contains only the parameters valid for this route, if any (params for parent or child routes are not merged).</li>
<li>paramNames: ordered list of the names of the params required for this route. It will contain the same strings as <code>Object.keys(params)</code>, but here the order is significant. This allows users to correctly pass params into routes programmatically.</li>
<li>queryParams: the values of any queryParams on this route.</li>
<li>parent: another RouteInfo instance, describing this route's parent route, if any.</li>
<li>child: another RouteInfo instance, describing this route's active child route, if any.</li>
</ul>
<p>Notice that the <code>parent</code> and <code>child</code> properties cause <code>RouteInfos</code> to form a linked list. So even though the <code>currentRoute</code> property on <code>RouterService</code> points at the leafmost route, it can be traversed to discover everything about all active routes. As a convenience, <code>RouteInfo</code> also implements <code>Enumerable</code> over all the reachable <code>RouteInfos</code> from topmost to leafmost. This makes it possible to say things like:</p>
<pre><code class="language-js">router.currentRoute.find(info =&gt; info.name === 'people').params
</code></pre>
<h2 id="routeinfowithattributes"><a class="header" href="#routeinfowithattributes">RouteInfoWithAttributes</a></h2>
<p>This type is almost identical to <code>RouteInfo</code>, except it has one additional property named <code>attributes</code>. The attributes contain the data that was loaded for this route, which is typically just <code>{ model }</code>.</p>
<h2 id="transition-object"><a class="header" href="#transition-object">Transition Object</a></h2>
<p>A <code>transition</code> argument is passed to <code>Route#beforeModel</code>, <code>Route#model</code>, <code>Route#afterModel</code>, <code>Route#willTransition</code>, and <code>Router#willTransition</code>. Today <code>transition</code>'s public API is only really <code>abort()</code> and <code>retry()</code>.</p>
<h3 id="new-properties-from-and-to"><a class="header" href="#new-properties-from-and-to">New Properties: <code>from</code> and <code>to</code></a></h3>
<p>I'm proposing we add <code>from</code> and <code>to</code> properties on <code>transition</code> whose values are <code>RouteInfo</code> instances representing the initial and final leafmost routes for this transition. Like all RouteInfos, these are read-only and internally immutable. They are not observable, because a  <code>transition</code> instance is never changed after creation.</p>
<p>On an initial full-page load, the <code>from</code> property will be <code>null</code>. This creates a public API for distinguishing in-app transitions from full-page reloads.</p>
<h3 id="example-testing-whether-route-will-remain-active"><a class="header" href="#example-testing-whether-route-will-remain-active">Example: testing whether route will remain active</a></h3>
<p>Here's an example showing how <code>willTransition</code> can figure out if the current route will remain active after the transition:</p>
<pre><code class="language-js">willTransition(transition) {
  if (!this.transition.to.find(route =&gt; route.name === this.routeName)) {
    alert(&quot;Please save or cancel your changes.&quot;);
    transition.abort();
  }
}
</code></pre>
<h3 id="example-parent-redirecting-to-a-fallback-model"><a class="header" href="#example-parent-redirecting-to-a-fallback-model">Example: parent redirecting to a fallback model</a></h3>
<p>Here's an example of a parent route that can redirect to a fallback model, without losing its child route:</p>
<pre><code class="language-js">this.route('person', { path: '/person/:person_id' }, function() {
  this.route('index');
  this.route('detail');
});

//PersonRoute
const fallbackPersonId = 0;
model({ personId }, transition) {
  return this.get('store').find('person', personId).catch(err =&gt; {
    this.replaceWith(transition.to.name, fallbackPersonId);
  });
}

// If personId 5 is invalid, and the user visits /person/5/detail, they will get
// redirected to /person/0/detail. And /person/5 will get redirected to /person/0.
</code></pre>
<h3 id="actively-discourage-use-of-private-api"><a class="header" href="#actively-discourage-use-of-private-api">Actively discourage use of private API</a></h3>
<p>This RFC provides public API for doing the things people have become accustomed to doing via private API. To eliminate confusion over the correct way, we should hide all the private API away behind symbols, and provide deprecation warnings per our usual release policy around breaking &quot;widely-used private APIs&quot;.</p>
<p>Some of the private APIs we should mark and warn include:</p>
<ul>
<li>transition.state</li>
<li>transition.params</li>
<li><code>lookup('router:main')</code> (should use <code>service:router</code> instead)</li>
</ul>
<h2 id="dynamically-scoped-route-info"><a class="header" href="#dynamically-scoped-route-info">Dynamically-Scoped Route Info</a></h2>
<p>&quot;The current route&quot; is not a global value -- it varies from place to place within an application. Internally, Ember already models route info as a dynamically-scoped variable (currently named <code>outletState</code>). This RFC proposes publicly exposing that value in order to make things like <code>link-to</code> easier to implement directly on public primitives, and in order to enable stable public API for addons usage like <code>{{liquid-outlet}}</code>.</p>
<p>We propose <code>get-route-info</code> for reading the current route info in handlebars:</p>
<pre><code class="language-hbs">{{!- retrieve the value of a dynamically scoped variable }}
{{some-component currentRoute=(get-route-info)}}
</code></pre>
<p>We propose <code>readsRouteInfo</code> for defining a component that reads route info:</p>
<pre><code class="language-js">let MyComponent = Ember.Component.extend({
  didInsertElement() {
    // Accessing routInfo here is intended to be indistinguishable
    // from a normal, explicitly-passed input argument. 
    doSomethingWith(this.get('routeInfo'));
  }
});
MyComponent.reopenClass({
  // This is where we declare that we need access to routeInfo
  readsRouteInfo: true
});
</code></pre>
<p>And <code>readsRouteInfo</code> also works on <code>Helper</code>:</p>
<pre><code class="language-js">let MyHelper = Ember.Helper.extend({
  compute(params, hash) {
    // routeInfo is indistinguishable from a normally-passed hash argument
    return doSomethingWith(hash.routeInfo);
  }
});
MyHelper.reopenClass({
  readsRouteInfo: true
});
</code></pre>
<p>We propose the <code>#with-route-info</code> keyword for setting a new route info:</p>
<pre><code class="language-hbs">{{#with-route-info someValue}}
  {{!-
    within this block AND ALL ITS DESCENDANTS until
    otherwise overridden by another set-route-info statement, 
    `get-route-info` returns someValue.
  -}}
{{/with-route-info}}
</code></pre>
<p>Note that there is no <code>set-route-info</code>. You can only introduce new scopes, not mutate your containing scope. There is also no way to set routeInfo directly from Javascript -- your component must use a <code>with-route-info</code> block within its handlebars template.</p>
<h3 id="routeinfos-type-and-examples"><a class="header" href="#routeinfos-type-and-examples">routeInfo's type, and examples</a></h3>
<p>The value returned from <code>get-route-info</code> and acceptd by <code>with-route-info</code> is always a <code>RouteInfoWithAttributes</code> object. This enables several nice things, which I will illustrate with examples:</p>
<ol>
<li>Here is a simplified <code>is-active</code> helper that will always update at the appropriate time to match exactly what is rendered in the current outlet. It will maintain the correct state even during animations. Instead of injecting the router service, it consumes the <code>routeInfo</code> from its containing environment:</li>
</ol>
<pre><code class="language-js">Ember.Helper.extend({
  compute([routeName], { routeInfo }) {
    return !!routeInfo.find(info =&gt; info.name === routeName);
  }
}).reopenClass({
  readsRouteInfo: true
});
</code></pre>
<p>A more complete version that also matches models and queryParams can be written in the same way. </p>
<ol start="2">
<li>
<p>We can improve <code>link-to</code> so that it always finds implicit model arguments from the local context, rather than trying to locate them on the global router service. This will fix longstanding bugs like https://github.com/ember-animation/liquid-fire/issues/347 and it will make it easier to test components that contain <code>{{link-to}}</code>. This would also open the door to relative link-tos.</p>
</li>
<li>
<p><code>liquid-outlet</code> can be implemented entirely via public API. It would become:</p>
</li>
</ol>
<pre><code class="language-hbs">{{#liquid-bind (get-route-info) as |currentRouteInfo|}}
  {{#with-route-info currentRouteInfo}}
    {{outlet}}
  {{/with-route-info}}
{{/liquid-bind}}
</code></pre>
<ol start="4">
<li>Prerendering of non-current routes becomes possible. You can use <code>recognizeAndLoad</code> to obtain a <code>RouteInfoWithAttributes</code> and then use <code>{{#with-route-info myRouteInfo}} {{outlet}} {{/with-route-info}}</code> to render it.</li>
</ol>
<h1 id="drawbacks-29"><a class="header" href="#drawbacks-29">Drawbacks</a></h1>
<p>This RFC deprecates only two public extension hooks API, so the API-churn burden may appear low. However, we know that use of the private APIs we're deliberately disabling is widespread, so users will experience churn. We can provide our usual deprecation cycle to give them early warning, but it still imposes some cost.</p>
<p>This RFC doesn't attempt to change the existing and fairly rich semantics for initiating transitions. For example, you can pass either models or IDs, and those have subtle semantic differences. I think an ideal rewrite would also change the semantics of the route hooks and transitionTo to simplify that area.</p>
<h1 id="alternatives-29"><a class="header" href="#alternatives-29">Alternatives</a></h1>
<h2 id="less-churn"><a class="header" href="#less-churn">Less Churn</a></h2>
<p>We could adopt some of the existing broadly used APIs as de-facto public. This avoids churn, but imposes a complexity burden on every new learner, who needs to be told &quot;this is a weird API, but it's what we're stuck with&quot;.</p>
<h2 id="semver-lawyering"><a class="header" href="#semver-lawyering">Semver Lawyering</a></h2>
<p>I'm interpreting router.js's public/private documentation as out-of-scope for Ember's semver. The fact that we pass an instance of router.js's Transition as our <code>transition</code> argument is not documented. An alternative interpretation is that we need to continue supporting those methods marked as public in router.js's docs.</p>
<h2 id="optional-helpers"><a class="header" href="#optional-helpers">Optional Helpers</a></h2>
<p>I didn't propose shipping <code>is-active</code> and <code>url-for</code> template helpers -- I merely showed that they're easy to build using the router service. But we should arguably just ship them as part of the framework too.</p>
<h2 id="branching-route-hierarchies"><a class="header" href="#branching-route-hierarchies">Branching Route Hierarchies</a></h2>
<p>I am implicitly assuming we will only ever have linear route hierarchies, where a given route has at most one child. I can imagine eventually wanting a way to support branching route hierarchies, where each branch can transition independently. I'm not trying to account for that future.</p>
<h2 id="routeparentroute"><a class="header" href="#routeparentroute">Route.parentRoute</a></h2>
<p>This RFC makes it possible for a route to determine its parent's name dynamically via public API, and thus access its parent's model/params/controller:</p>
<pre><code class="language-js">beforeModel(transition) {
  const parentInfo = transition.to.find(info =&gt; info.name === this.routeName).parent;
  const parentModel = this.modelFor(parentInfo.name);
}
</code></pre>
<p>However, this pattern feels awkward, and I think it justifies just adding a public <code>parentRouteName()</code> method to <code>Route</code> that would simplify to:</p>
<pre><code class="language-js">beforeModel(transition) {
  const parentModel = this.modelFor(this.parentRouteName());
}
</code></pre>
<p>Possibly we <em>want</em> this to feel awkward because it's a weird thing to do.</p>
<h2 id="naming-of-emberdefault_value-symbol"><a class="header" href="#naming-of-emberdefault_value-symbol">Naming of Ember.DEFAULT_VALUE Symbol</a></h2>
<p>Should we introduce new API via the <code>Ember</code> global and switch to a module export once all the rest of Ember does, or should we just start with a module export right now? If so, what module?</p>
<pre><code>import { DEFAULT_VALUE } from 'ember-routing';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-02-02
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/96</p>
<hr />
<h1 id="summary-30"><a class="header" href="#summary-30">Summary</a></h1>
<p>Enable Ember CLI users to opt into using yarn for packagement management.</p>
<h1 id="motivation-31"><a class="header" href="#motivation-31">Motivation</a></h1>
<p>Ember CLI currently uses the npm command line tool to install dependencies when you run <code>ember install</code> or <code>ember new</code>/<code>ember addon</code>. However, several problems usually arise from npm's semantics.
Dependency resolution and install times can be significant enough to disrupt workflows, as well as offline support, non-deterministic, non-flat dependency graphs.</p>
<p>Yarn was introduced to the JavaScript community with the intent to provide a better developer experience in these areas:</p>
<ul>
<li>Faster installs</li>
<li>Offline support</li>
<li>Deterministic dependency graphs</li>
<li>Lockfile semantics</li>
</ul>
<p>While Ember CLI users can currently use Yarn to manage their dependencies, Ember CLI will use the npm client internally when running the above mentioned commands. By allowing users to specify that Ember CLI should use Yarn for everything, we're hoping to provide a more consistent experience.</p>
<h1 id="detailed-design-30"><a class="header" href="#detailed-design-30">Detailed design</a></h1>
<p>Enabling Yarn is designed as opt-in to prevent disruptions to the developer's current workflow.
We will address the two moments where this can happen.</p>
<h2 id="ember-install"><a class="header" href="#ember-install"><code>ember install</code></a></h2>
<p>There are two mechanisms through which to opt-in.
The first one is the presence of a <code>yarn.lock</code> file in the project root.</p>
<p>The <code>yarn.lock</code> file is generated by Yarn when you run <code>yarn install</code> (or the shorter <code>yarn</code>),
so we assume that its presence means the developer intends to use Yarn to manage their dependencies.</p>
<p>Alternatively you, you can force Ember CLI to use Yarn with the <code>--yarn</code> flag, and symmetrically,
you can force Ember CLI to not use Yarn with the <code>--no-yarn</code> flag.</p>
<p>To recap:</p>
<ul>
<li><code>ember install ember-cli-mirage</code> with <code>yarn.lock</code> present will use Yarn</li>
<li><code>ember install ember-cli-mirage</code> without <code>yarn.lock</code> present will use npm</li>
<li><code>ember install ember-cli-mirage --yarn</code> will use Yarn</li>
<li><code>ember install ember-cli-mirage --no-yarn</code> will use npm</li>
</ul>
<h2 id="ember-init-ember-new-ember-addon"><a class="header" href="#ember-init-ember-new-ember-addon"><code>ember init</code>, <code>ember new</code>, <code>ember addon</code></a></h2>
<p>Since this triad of commands is generally ran before a project is set up, there is no <code>yarn.lock</code> file presence to check.
This means we are left with the <code>--yarn</code>/<code>--no-yarn</code> pair of flags, that will also be added to these commands:</p>
<ul>
<li><code>ember new my-app</code> will use npm</li>
<li><code>ember new my-app --yarn</code> will use Yarn</li>
</ul>
<p>The above also applies to <code>ember addon</code> and <code>ember init</code>, noting that <code>ember init</code> doesn't receive any arguments.</p>
<h1 id="how-we-teach-this-7"><a class="header" href="#how-we-teach-this-7">How We Teach This</a></h1>
<p>Both the Ember.js Guides as well as the Ember CLI Guides will be updated to reflect the new flags,
as well as the new semantics of <code>ember install</code> in the presence of <code>yarn.lock</code>.</p>
<p>In addition, the built-in instructions for <code>ember help</code> will be updated to reflect this.</p>
<h1 id="drawbacks-30"><a class="header" href="#drawbacks-30">Drawbacks</a></h1>
<p>To be determined.</p>
<h1 id="alternatives-30"><a class="header" href="#alternatives-30">Alternatives</a></h1>
<p>Do nothing.</p>
<h1 id="unresolved-questions-26"><a class="header" href="#unresolved-questions-26">Unresolved questions</a></h1>
<p>To be determined.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2015-10-23
RFC PR: https://github.com/emberjs/rfcs/pull/101
Ember Issue: https://github.com/emberjs/data/pull/3930</p>
<hr />
<h1 id="summary-31"><a class="header" href="#summary-31">Summary</a></h1>
<p>Add more illustrative detail to the default Ember Data Adapter Errors.</p>
<h1 id="motivation-32"><a class="header" href="#motivation-32">Motivation</a></h1>
<p>With a production Ember project, it's common to have many errors of the form &quot;Adapter Error&quot;,
originating from deep in the Ember Data stack and carrying little context about what the
original error cause was.</p>
<p>The intent is to add the original request URL, the response code, and some payload information
to the default Error message for <code>DS.AdapterError</code>s. From there Errors can be handled or
tracked as normal.</p>
<h1 id="detailed-design-31"><a class="header" href="#detailed-design-31">Detailed design</a></h1>
<p>I've been using something similar to the following Adapter (<code>friendly-error-adapter.js</code>):</p>
<pre><code class="language-js">import ActiveModelAdapter from 'active-model-adapter';

import DS from 'ember-data';

export default ActiveModelAdapter.extend({

  ajax(url, method)  {
    this.lastRequest = {
      url:    url,
      method: method
    };
    return this._super(...arguments);
  },

  handleResponse: function (status, headers, payload) {
    let payloadContentType = headers[&quot;Content-Type&quot;].split(&quot;;&quot;).get(&quot;firstObject&quot;);
    let shortenedPayload;

    if (payloadContentType === &quot;text/html&quot; &amp;&amp; payload.length &gt; 250) {
      shortenedPayload = &quot;[omitted long blob of HTML]&quot;;
    } else {
      shortenedPayload = payload;
    }

    let errorMessage = `Ember Data Error (${this.lastRequest.method} ${this.lastRequest.url} returned a ${status}). \n Payload (${payloadContentType}): \n\n ${shortenedPayload}`;

    if (this.isSuccess(status, headers, payload)) {
      return payload;
    } else if (this.isInvalid(status, headers, payload)) {
      return new DS.InvalidError(payload.errors, errorMessage);
    }

    let errors = this.normalizeErrorResponse(status, headers, payload);

    return new DS.AdapterError(errors, errorMessage);
  }
});
</code></pre>
<p>(Note that the code inside the adapter could be MUCH simpler and cleaner, the above
is a very quick hacked up example! :bomb:)</p>
<p>The intent is to get an error message out of the form:</p>
<ol>
<li>&quot;Ember Data Error&quot;</li>
<li>Request Method &amp; URI</li>
<li>Response Status</li>
<li>Response Content Type</li>
<li>A sane representation of the Response payload</li>
</ol>
<h1 id="drawbacks-31"><a class="header" href="#drawbacks-31">Drawbacks</a></h1>
<p>Adding complexity to an Error handler always runs the risk of generating errors inside
the handler itself, which would not be overly friendly.</p>
<h1 id="alternatives-31"><a class="header" href="#alternatives-31">Alternatives</a></h1>
<p>There's probably quite a few different pieces of information that could be included
in the message.</p>
<p>We could also potentially look at attaching the extra information to other fields on
the <code>AdapterError</code> (and its subclasses). The only drawback there would be that most
error reporters would then not include that information by default.</p>
<h1 id="unresolved-questions-27"><a class="header" href="#unresolved-questions-27">Unresolved questions</a></h1>
<ul>
<li>Exact Error Message Format</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-04-23
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/105</p>
<hr />
<h1 id="summary-32"><a class="header" href="#summary-32">Summary</a></h1>
<p>It should be possible to specify packages/addons in <code>optionalDependencies</code> of the <code>package.json</code> of an <code>ember-cli project</code>, and ember-cli should scan for packages/addons mentioned in optionalDependencies while processing the build so that such packages/addons could also be included into the consuming application.</p>
<p>The build need not fail asserting &quot;missing dependency&quot; if any of the dependencies specified in optionalDependencies is missing/absent.</p>
<h1 id="motivation-33"><a class="header" href="#motivation-33">Motivation</a></h1>
<p>In general, the current ember-cli build process will scan for the packages specified in the <code>dependencies</code> hash and <code>devDependencies hash</code> from the downloaded packages in the node_modules folder, discovers and then includes them into the consuming application. The build is designed to fail if any of the packages specified in these two dependencies hash is missing in the <code>node_modules</code> folder. But this procedure may not be sufficient for a variety of cases.</p>
<p>So there could be an option for the developer to specify packages in optionalDependencies and ember-cli can lookup optionalDependencies while processing the build. The Build need not fail if there is any package specified in optionalDependencies is missing, since it is only optional and moreover may only be required for developmental purposes. This way the developer can have more control over the choice of packages he wishes to use for development and skip for production by giving appropriate commands like <code>npm install --no-optional</code>, thereby preventing the installation of packages itself rather than blacklisting in <code>ember-cli-build.js</code> which suggests preventing the installed addons sepcifed in the <code>blacklist</code> array from being included into the consuming application.</p>
<h1 id="detailed-design-32"><a class="header" href="#detailed-design-32">Detailed design</a></h1>
<p>We can tweak ember-cli addon/package discovery process to lookup for optionalDependencies as well and if the package is missing, we can make ember-cli proceed the build without terminating.</p>
<h1 id="how-we-teach-this-8"><a class="header" href="#how-we-teach-this-8">How We Teach This</a></h1>
<p>This functionality can simply be documented in ember-cli guides to teach.</p>
<h1 id="alternatives-32"><a class="header" href="#alternatives-32">Alternatives</a></h1>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-06-18
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/108</p>
<hr />
<h1 id="summary-33"><a class="header" href="#summary-33">Summary</a></h1>
<p>This RFC proposes to add a new API to allow addons to register a custom transformation. This transformation can then be used by other addons when calling <code>app.import</code> with <code>using</code> API.</p>
<h1 id="motivation-34"><a class="header" href="#motivation-34">Motivation</a></h1>
<p>Addons or apps may want import browser only compatible libraries using <code>app.import</code> via bower or npm. These libraries should not be running in Node.</p>
<p>When FastBoot was doing two builds (to generate different assets for browser and Node environment), addon or apps often conditionally imported these libraries relying on the value of <code>process.env.EMBER_CLI_FASTBOOT</code>. With the new scheme of the build where only additional Node assets are built, this enviornment is no longer exposed.</p>
<p>In order to expose better semantics to allow apps and addon authors to easily import these libraries without much overhead (see issue <a href="https://github.com/ember-fastboot/ember-cli-fastboot/issues/413">here</a>), we need to have these libraries wrapped with an FastBoot check. This can be achieved by extending the <code>using</code> API of <code>app.import</code>. FastBoot addon would like to register a custom transformation that other FastBoot compatible addons may chose to use in a declarative API.</p>
<h1 id="detailed-design-33"><a class="header" href="#detailed-design-33">Detailed design</a></h1>
<p>Today, Ember CLI supports transforming anonymous AMD modules imported via <code>app.import</code> into named AMD modules:</p>
<pre><code class="language-js">app.import('/path/to/module.js', {
  using: [
    { transformation: 'amd', as: 'some-dep' }
  ]
});
</code></pre>
<p>The <code>amd</code> transform is hardcoded in Ember CLI. However, it is not possible for addon authors to provide any additional transformation that other addons can use when importing third-party modules. Addons like, FastBoot would like to provide custom transformation for other addons to use so that they can wrap their third party libraries in Node environments.</p>
<p>In order to do this, we would like to expose an API that allows addons to register a custom transformation. This API will be an advanced API and will only be used by addons that want to provide custom transformation. Other addons can chose to use that custom transformation using its name.</p>
<p>The API to register a custom transformation in Ember CLI will be defined in <code>index.js</code> of the addon and will be an advanced API:</p>
<pre><code class="language-js">importTransforms() {
  return {
    'fastboot-shim': function(tree, options) {

      return stew.map(tree, function(content, relativePath) {
        return `if (typeof FastBoot === 'undefined) { ${content} }`;
      });
    }
  }
}
</code></pre>
<p><code>importTransforms</code> returns a map of the name of the transform and a callback function that will be run on every module that uses the transform. The callback function takes the <code>tree</code> as broccoli tree contain all the files that want to run this transform and <code>options</code> map (optional) that contains the additional key value pairs that a consumer transformer provides. The later argument would be used by transformations like <code>amd</code> (explained below).</p>
<p>With this, we also should move the hard coded <code>amd</code> transform into an in-repo addon in Ember CLI. This would allow other addons that define their own transformation to also control the order of their transformation (using <code>before</code> or <code>after</code> hooks of addon initialization). The registeration of <code>amd</code> transform would be:</p>
<pre><code class="language-js">importTransforms() {
  return {
    'amd': function(tree, options) {

      return stew.map(tree, function(content, relativePath) {
        const name = options[relativePath].using;
        if (name) {
          return [
            '(function(define){\n',
            content,
            '\n})((function(){ function newDefine(){ var args = Array.prototype.slice.call(arguments); args.unshift(&quot;',
            name,
            '&quot;); return define.apply(null, args); }; newDefine.amd = true; return newDefine; })());',
          ].join('');
        } else {
          return content;
        }
      });
    }
  }
}
</code></pre>
<p>As seen above, <code>options</code> contains the optional AMD module ID that the consumer of <code>amd</code> transform can provide. If registered transforms want to depend on any other user provided values, those can easily be available during the transforms.</p>
<p>When the addons are initialized, we will check if <code>importTransforms</code> is defined and store these callbacks and transform names in an array.</p>
<p>Now, if addon authors would like to use these transforms when importing libraries, they would simply do the following:</p>
<pre><code class="language-js">app.import('/path/to/module.js', {
  using: [
    {  transformation: 'fastboot-shim' },
    { transformation: 'amd', as: 'some-dep' }
  ]
});
</code></pre>
<p>As seen above, an addon author could provide the list of transformations to run and Ember CLI would run them in the order of when the transformations were registered.
Internally, for every transform we will maintain an array of file paths that need to run this transform. When the transformations need to run, we will read the registration order, run the transformation on those files. The output of the transformation will then be merged back and then the next transformation would run. This will ensure that more than one transformation can be correctly applied to a module.</p>
<h2 id="same-name-conflict"><a class="header" href="#same-name-conflict">Same name conflict</a></h2>
<p>Allowing addons to define custom transform could lead to naming conflicts where more than two addons may provide transform functions with the same name but slightly or totally different functionality. Therefore, if more than one addon provides a same name for a transform by default the last addon in the order that registered its transform will win. In addition, we will also warn the users of the name conflicts and which addon's registered transformation is going to run.</p>
<h1 id="how-we-teach-this-9"><a class="header" href="#how-we-teach-this-9">How We Teach This</a></h1>
<p>The registeration of transform is an advanced API of Ember CLI that very few addons would use. We will be updating the guides <a href="https://ember-cli.com/user-guide/#standard-anonymous-amd-asset">here</a>.</p>
<h1 id="drawbacks-32"><a class="header" href="#drawbacks-32">Drawbacks</a></h1>
<p>The drawback of this approach is that the order of running the transformation is controlled by the addon that provides the transform rather than the addon that uses the transform. The reasoning for this is mainly for performance reasons (in order to not create a funnel per asset path) and to make sure the more than one transform can be applied correctly on an asset path.</p>
<h1 id="alternatives-33"><a class="header" href="#alternatives-33">Alternatives</a></h1>
<p>Currently the alternative is for addons to import their bower or npm dependency in <code>vendor</code> via <code>treeForVendor</code> and manually use broccoli plugins to do transformations. The alternative for apps is to create an in-repo addon to do this.</p>
<h1 id="unresolved-questions-28"><a class="header" href="#unresolved-questions-28">Unresolved questions</a></h1>
<p>N/A</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-09-07
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/110</p>
<hr />
<h1 id="summary-34"><a class="header" href="#summary-34">Summary</a></h1>
<p>The goal of this RFC is to solidify the next version of the mechanism that
<code>ember-cli</code> uses to build final assets. It will allow for a more flexible build
pipeline for Ember applications. It also unlocks building experimental features
on top. It is a backward compatible change.</p>
<h1 id="motivation-35"><a class="header" href="#motivation-35">Motivation</a></h1>
<p>The <a href="https://github.com/chadhietala/rfcs/blob/packager/active/0002-packager.md">Packager
RFC</a>
submitted by <a href="https://github.com/chadhietala">Chad Hietala</a> is a little over 2
years old. A lot of things have changed since then and it requires a revision.</p>
<p>The current application build process merges and concatenates input broccoli
trees. This behaviour is not well documented and is a tribal knowledge. While
the simplicity of this approach is nice, it doesn't allow for extension. We can
refactor our build process and provide more flexibility when desired.</p>
<p>Most importantly, the approach described below helps us achieve:</p>
<ul>
<li>defining and developing a common language around the subject</li>
<li>removing highly coupled code and streamline technical implementation (Ember
Engines and Fastboot)</li>
<li>unlock a whole different set of plugins we couldn't have before:
+ ability to create custom bundles (i.e per-engine and per-route bundles)
+ take advantage of <a href="https://http2.github.io/faq/#why-is-http2-multiplexed">HTTP2
multiplexing</a> and
<a href="https://www.mnot.net/blog/2014/01/30/http2_expectations#4-cache-pushing">cache
pushing</a>
+ optimising plugins (JavaScript and CSS tree-shaking)</li>
</ul>
<h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<ul>
<li>New public API for customising build process and giving more granular control over
the final build output</li>
</ul>
<h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<ul>
<li><strong>Packaging</strong> - The process of designing, evaluating, and producing final build assets.</li>
</ul>
<h1 id="detailed-design-34"><a class="header" href="#detailed-design-34">Detailed design</a></h1>
<p>The detailed design is separated in various sections so that it is easier for a
reader to understand.</p>
<h2 id="packaging"><a class="header" href="#packaging">Packaging</a></h2>
<p>It gives you granular control over the final build output. It could be used in many
different ways (we are going to go over use cases below). Note, it isn't meant to be
used for &quot;postprocess&quot; transformations; &quot;postprocess&quot; is called after packaging is
finished.</p>
<p>Currently, Ember.js application and all of its depedencies get assembled under one
directory with the following structure:</p>
<pre><code class="language-ruby">bundler:js:input/
├── addon-tree-output/
├── the-app-name-folder/
├── node_modules/
└── vendor/
</code></pre>
<p>where:</p>
<ul>
<li><code>addon-tree-output</code> is a folder that contains dependencies from Ember add-ons.</li>
<li><code>the-app-name-folder</code> is a folder that contains Ember application code.</li>
<li><code>node_modules</code> is a folder that contains node dependencies.</li>
<li><code>tests</code> is a folder that contains test code.</li>
<li><code>vendor</code> is a folder that contains other dependencies.</li>
</ul>
<p>Note, for clarity purposes we should rename <code>addon-tree-output</code> to <code>addon-modules</code> as
both <code>tree</code> and <code>output</code> don't communicate well about the contents of the folder.</p>
<p>During packaging process the final output will be generated (everything that currently
resides under <code>dist/</code> folder when a developer runs <code>ember build</code>).</p>
<h3 id="package-api"><a class="header" href="#package-api"><code>package</code> API</a></h3>
<p>A new public <code>package</code> method will be introduced to open up a way to customise packaging process:</p>
<pre><code class="language-javascript">// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, {
    package(inputTree) {
      // customise `inputTree`
      // and return customised `inputTree`
    }
  });

  return app.toTree();
}
</code></pre>
<p><code>package</code> function has the following signature:</p>
<pre><code class="language-typescript">interface EmberApp {
  package(inputTree: BroccoliTree): BroccoliTree;
}
</code></pre>
<p>where <code>inputTree</code> will have the following structure:</p>
<pre><code class="language-ruby">bundler:js:input/
├── addon-modules/
├── the-app-name-folder/
├── node_modules/
├── tests/
└── vendor/
</code></pre>
<p>Note, that <code>package</code> method must return a broccoli tree.</p>
<p>This change should be behind an experiment flag, <code>PACKAGING</code>.
This will allow us to start experimenting right away and not being
tied to a particular release cycle.</p>
<p>Note, that <code>package</code> is optional. If you don't define it, you're
effectively &quot;opting out&quot; of the feature and using the default
behaviour.</p>
<h3 id="defaultpackager-api"><a class="header" href="#defaultpackager-api"><code>defaultPackager</code> API</a></h3>
<p>It's important to make it easy for users to still use default Ember CLI
packaging.</p>
<p><code>defaultPackager</code> is a way for the users to access out-of-the-box packaging while
still be able to customise the final build output.</p>
<pre><code class="language-javascript">// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const defaultPackager = require('ember-cli-default-packager');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, {
    package(inputTree) {
      // customise `inputTree`

      return defaultPackager(app, inputTree);
    }
  });

  return app.toTree();
}
</code></pre>
<p><code>defaultPackager</code> has the following signature:</p>
<pre><code class="language-typescript">function defaultPackager(app: EmberApp, inputTree: BroccoliTreel): BroccoliTree;
</code></pre>
<p><code>defaultPackager</code> must return a <code>BroccoliTree</code>.</p>
<h3 id="possible-usages"><a class="header" href="#possible-usages">Possible usages</a></h3>
<h4 id="debuganalyse"><a class="header" href="#debuganalyse">Debug/Analyse</a></h4>
<p>One of the applications of <code>package</code> API would be to run different analysis on the
Ember applications. Take
<a href="https://github.com/stefanpenner/broccoli-concat-analyser">broccoli-concat-analyser</a>,
for example. This could be easily incorporated into the build.</p>
<pre><code class="language-javascript">// ember-cli-build.js
const EmberApp = require('ember-cli/lib/broccoli/ember-app');
const defaultPackager = require('ember-cli-default-packager');

module.exports = function(defaults) {
  const app = new EmberApp(defaults, { });

  app.package = function(inputTree) {
    const analysedTree = new BroccoliConcatAnalyser(inputTree);

    return defaultPackager(app, analysedTree);
  }

  return app.toTree();
}
</code></pre>
<h4 id="static-assets-split"><a class="header" href="#static-assets-split">Static Assets Split</a></h4>
<p>One of the techniques for improving site speed is isolating changes throughout
application deployments. Assuming  the application assets are uploaded to CDN,
the reasoning is very simple: if <code>ember.js</code> or <code>jQuery</code> (possibly along with
other third party libraries) don't change with every deployment, why bust CDN
cache for them?</p>
<h4 id="es6-modules"><a class="header" href="#es6-modules">ES6 Modules</a></h4>
<p>ES6 modules are <a href="https://caniuse.com/#feat=es6-module">starting</a> to land in browsers.
This means that you can use <code>&lt;script type=&quot;module&quot; src=&quot;/my/app.js&quot;&gt;&lt;/script&gt;</code>.</p>
<p>This <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/">article</a> <a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/#is-this-really-worth-the-extra-effort">explains</a> the benefits of using ES6 modules over ES2015 (smaller total file sizes, faster to parse and evaluate).</p>
<p><code>package</code> API will make it possible to package your application for both ES2015 only browsers as well
the ones with ES6 modules support.</p>
<h1 id="topics-for-future-rfcs"><a class="header" href="#topics-for-future-rfcs">Topics for Future RFCs</a></h1>
<p>While working on this RFC, some ideas were brought into focus regarding existing
and new features in Ember CLI. They all likely require separate discussions in
future RFCs, but the discussion points have been included below.</p>
<h2 id="tree-shaking"><a class="header" href="#tree-shaking">Tree-shaking</a></h2>
<p>Firstly, what's <em>tree-shaking</em>? AFAIK, the term
<a href="https://groups.google.com/forum/#!msg/comp.lang.lisp/6zpZsWFFW18/-z_8hHRAIf4J">originated</a>
in Lisp. The gist of the idea is &quot;how about we start using <em>only</em> the code that
we actually need?&quot;</p>
<p>Secondly, how is it different from <a href="https://en.wikipedia.org/wiki/Dead_code_elimination">Dead Code
Elimination</a>? <a href="https://twitter.com/Rich_Harris">Rich
Harris</a>
<a href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80">offers</a>
a pretty good explanation in the context of <a href="https://rollupjs.org/">Rollup</a>. The
gist is dead code elimination happens on a final product by removing bits that
are unused. Tree-shaking is quite different - given an object we want to construct, what is the exact set of dependencies we need?.</p>
<p>With this RFC, we lay out the foundation and create a framework by which both
dead code elimination and tree-shaking code be implemented.</p>
<p>However, there are still several things that are missing:</p>
<ul>
<li><strong>Linker</strong> - Responsible for resolving and reducing the graph to a tree
containing only reachable modules.</li>
<li><strong>File System Resolver</strong> - Responsible for connecting a module name with a
file path.</li>
</ul>
<p><code>Linker</code> would be responsible for:</p>
<ul>
<li>building a minimal dependency graph as well as check for redundant edges in
the graph (more on the topic, <a href="https://en.wikipedia.org/wiki/Transitive_reduction#Graph_algorithms_for_transitive_reduction">Transitive reduction of a directed
graph</a>);</li>
<li>producing an application tree with only used modules</li>
</ul>
<p>Dependency graph represents dependencies using module names, there is a need to
be able to convert module name to file path. This is where <code>File System Resolver</code> comes in. Here's couple of examples:</p>
<pre><code class="language-javascript">fileSystemResolver.resolve('lodash') =&gt; `some-path/node_modules/lodash/lodash.js`
fileSystemResolver.resolve('ember-ajax') =&gt; `some-path/addon-modules/ember-ajax/index.js`
fileSystemResolver.resolve('ember-data') =&gt; `some-path/addon-modules/modules/ember-data/index.js`
fileSystemResolver.resolve('ember-data/-private') =&gt; `some-path/addon-modules/modules/-private.js`
</code></pre>
<p>This effort could be broken down into several phases:</p>
<ul>
<li>dead modules elimination inside of the <code>addons/</code> (application would be the
main entry point and unused modules are removed only from <code>addons/</code>)</li>
<li>dead modules elimination inside of the <code>app/</code>
+ removing unused components and helpers (requires analysing templates)
+ removing unused initializers/services (this likely entails work on
dependency injection layer as we would need access to a resolver resolution
map)</li>
<li>tree-shaking (Rollup-like tree-shaking where we include <em>only</em> the code that is
used)</li>
</ul>
<p><code>Linker</code> would be able to take an <code>exclude</code> list of modules as a parameter.
Although, valuable in some situations, it should be clearly marked as advanced
API. It should be used as a last resort and serve as an &quot;escape hatch&quot;.</p>
<p>It would make sense to implement <code>Linker</code> as a strategy. Developers would be
able to &quot;opt in&quot;/&quot;opt out&quot; of optimising behaviour.</p>
<h2 id="deprecating-appimport-api"><a class="header" href="#deprecating-appimport-api">Deprecating <code>app.import</code> API</a></h2>
<p>Ember applications which choose to use <code>Linker</code> strategy should be able to
remove usages of <code>app.import</code>.</p>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<p>With growing complexity of Ember applications, it is crucial to provide more
insights into final assets.</p>
<p>Main goals are:</p>
<ul>
<li>report raw/uglified/compressed asset sizes;
<a href="https://github.com/stefanpenner/broccoli-concat-analyser">broccoli-concat-analyser</a></li>
<li>find source code duplication across your javascript assets (enables you to
fine tune code splitting parameters to reduce bundle invalidation rates as
well as improve repeat page load performance)</li>
</ul>
<h1 id="how-we-teach-this-10"><a class="header" href="#how-we-teach-this-10">How We Teach This</a></h1>
<p>This is a backward compatible change to the existing Ember CLI ecosystem. In
order to teach users how to use <code>package</code> API, we need to update the API docs
with a section for this and the best practices of when to use this. A more
general purpose blog post could be beneficial as well.</p>
<h1 id="drawbacks-33"><a class="header" href="#drawbacks-33">Drawbacks</a></h1>
<p>There are several potential drawbacks that are worth noting.</p>
<p><em>Build performance</em>. There is minimal overhead in instantiating strategies and
calling methods on them and I believe this approach shouldn't degrade build
performance.</p>
<p><em>A note on add-ons</em>. Add-ons don't rely on the way Ember CLI does bundling. That
means existing build system continues to work as expected and add-ons won't have
to change their implementation.</p>
<h1 id="alternatives-34"><a class="header" href="#alternatives-34">Alternatives</a></h1>
<p>This RFC allows us to customise packaging when needed.
<a href="https://webpack.js.org">Webpack</a> has become very popular in solving this
similar problem. One could implement a <code>package</code> function that would use Webpack
for packaging. Ultimately, we need something that is aware of how Ember apps are
assembled and how Ember apps utilise dependency injection that takes advantage
of existing tools. The long term plan is to have a dependency graph that is
aware of application structure so can avoid the &quot;wall of configuration&quot; that
other asset packaging systems are susceptible to.</p>
<h1 id="unresolved-questions-29"><a class="header" href="#unresolved-questions-29">Unresolved questions</a></h1>
<ul>
<li>Will it increase build time?</li>
<li>Should we introduce the same API on add-on level?</li>
</ul>
<h1 id="thanks"><a class="header" href="#thanks">Thanks</a></h1>
<p>Many thanks for <a href="https://github.com/stefanpenner/">@stefanpenner</a>,
<a href="https://github.com/rwjblue/">@rwjblue</a> and
<a href="https://github.com/chadhietala/">@chadhietala</a> for helping me to drive this
forward.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-01-04
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/114</p>
<hr />
<h1 id="summary-35"><a class="header" href="#summary-35">Summary</a></h1>
<p>Add https://github.com/rwjblue/ember-cli-template-lint as a default addon for the app and addon blueprints using the recommended rules.</p>
<h1 id="motivation-36"><a class="header" href="#motivation-36">Motivation</a></h1>
<p>Linting and security in templates would help not only individual developers write better apps with better accessibility and security, but would also help teams to be on the same page and stick to a handful of standards.</p>
<h1 id="detailed-design-35"><a class="header" href="#detailed-design-35">Detailed design</a></h1>
<ol>
<li>Move ember-cli-template-lint to the ember-cli org (better for contributing and getting work off one person, @rwjblue)</li>
<li>Add the dependency to the app blueprint here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/package.json#L19</li>
<li>Also add it to the addon blueprint, like the eslint addon here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/addon/index.js#L66</li>
</ol>
<h1 id="how-we-teach-this-11"><a class="header" href="#how-we-teach-this-11">How We Teach This</a></h1>
<p>The same way that we teach ESLint being on by default.</p>
<h1 id="drawbacks-34"><a class="header" href="#drawbacks-34">Drawbacks</a></h1>
<ul>
<li>More chatter in the terminal.</li>
<li>An additional dependency.</li>
<li>Recommended rules might not be good for everyone.. but that same issue probably exists with ESLint.</li>
</ul>
<h1 id="alternatives-35"><a class="header" href="#alternatives-35">Alternatives</a></h1>
<p>Do nothing and have people write sub par template code.</p>
<h1 id="unresolved-questions-30"><a class="header" href="#unresolved-questions-30">Unresolved questions</a></h1>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-02-12
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/116</p>
<hr />
<h1 id="summary-36"><a class="header" href="#summary-36">Summary</a></h1>
<p>Introduce <a href="https://github.com/simplabs/qunit-dom"><code>qunit-dom</code></a> as a dependency by default in the <code>app</code> and <code>addon</code> blueprints.</p>
<h1 id="motivation-37"><a class="header" href="#motivation-37">Motivation</a></h1>
<blockquote>
<p>Why are we doing this?</p>
</blockquote>
<p>In a modern Ember application making assertions around the state of the DOM is
fundamental to confirming your applications functionality. These assertions are
often quite verbose:</p>
<pre><code class="language-js">assert.equal(this.element.querySelector('.title').textContent.trim(), 'Hello World!');
</code></pre>
<p>Using the <code>find()</code> helper of <code>@ember/test-helpers</code> we can simplify the DOM
element lookup, but the signal-to-noise ratio of the code is still not great:</p>
<pre><code class="language-js">assert.equal(find('.title').textContent.trim(), 'Hello World!');
</code></pre>
<p>With <code>qunit-dom</code> we can write much more readable assertions for DOM elements:</p>
<pre><code class="language-js">assert.dom('.title').hasText('Hello World!');
</code></pre>
<blockquote>
<p>What use cases does it support?</p>
</blockquote>
<p>It supports the most common assertions on DOM elements, like:</p>
<ul>
<li>what text does the element have?</li>
<li>what value does the <code>&lt;input&gt;</code> element have?</li>
<li>is a certain CSS class applied to the element</li>
</ul>
<p>The full API is documented at <a href="https://github.com/simplabs/qunit-dom/blob/master/API.md">https://github.com/simplabs/qunit-dom/blob/master/API.md</a>.</p>
<blockquote>
<p>What is the expected outcome?</p>
</blockquote>
<p>Using <code>qunit-dom</code> will lead to more simple and readable test code.</p>
<h1 id="detailed-design-36"><a class="header" href="#detailed-design-36">Detailed design</a></h1>
<p>The necessary changes to <code>ember-cli</code> are relatively small since we only need
to add the dependency to the <code>app</code> blueprint, and the <code>addon</code> blueprint will
inherit it automatically.</p>
<p>This has the advantage (over including it as an implicit dependency), that
apps and addons that don't want to use it for some reason can opt-out by
removing the dependency from their <code>package.json</code> file.</p>
<p>A WIP pull request has been created already at <a href="https://github.com/ember-cli/ember-cli/pull/7605">https://github.com/ember-cli/ember-cli/pull/7605</a>.</p>
<h1 id="how-we-teach-this-12"><a class="header" href="#how-we-teach-this-12">How We Teach This</a></h1>
<blockquote>
<p>Would the acceptance of this proposal mean the Ember guides must be
re-organized or altered? Does it change how Ember is taught to new users
at any level?</p>
</blockquote>
<p>Once we decide that this is the right way to go, we should update the official
Ember.js testing guides to use <code>qunit-dom</code> assertions by default. This has the
nice side effect of making the testing code in the guides easier to read too.</p>
<p>At the same time (same minor release) we should update the relevant blueprints
in the <code>ember-source</code> package to use <code>qunit-dom</code> by default. This should be a
relatively small change as only the <code>component</code> and <code>helper</code> tests use
DOM assertions.</p>
<blockquote>
<p>How should this feature be introduced and taught to existing Ember
users?</p>
</blockquote>
<p>We should also explicitly mention this change in the release blog post and
recommend that people use this from now on. For those users that want to
migrate their existing tests to <code>qunit-dom</code> a basic codemod exists at
<a href="https://github.com/simplabs/qunit-dom-codemod">https://github.com/simplabs/qunit-dom-codemod</a>.</p>
<h1 id="drawbacks-35"><a class="header" href="#drawbacks-35">Drawbacks</a></h1>
<blockquote>
<p>Why should we <em>not</em> do this? Please consider the impact on teaching Ember,
on the integration of this feature with other existing and planned features,
on the impact of the API churn on existing apps, etc.</p>
<p>There are tradeoffs to choosing any path, please attempt to identify them here.</p>
</blockquote>
<ul>
<li>
<p><code>qunit-dom</code> is &quot;owned&quot; by a third-party consulting company (simplabs) and
the Ember CLI team is not directly in control.</p>
</li>
<li>
<p><code>qunit-dom</code> has not reached v1.0.0 yet so there might be small breaking
changes in the future.</p>
</li>
<li>
<p><code>qunit-dom</code> is another abstraction layer on top of the raw QUnit assertions
which adds to the existing learning curve.</p>
</li>
<li>
<p>Adding <code>qunit-dom</code> to the default blueprint could make it look even more like
<code>ember-mocha</code> is only a second-class citizen. Since we add it to the default
<code>package.json</code> file it is easy to opt-out though and can be replaced with
<code>chai-jquery</code> or <code>chai-dom</code> for a roughly similar API.</p>
</li>
</ul>
<h1 id="alternatives-36"><a class="header" href="#alternatives-36">Alternatives</a></h1>
<blockquote>
<p>What other designs have been considered?</p>
</blockquote>
<ul>
<li>Using the <code>find()</code> helper functions can be considered an alternative, but
as mentioned above they still result in more verbose code than using
<code>qunit-dom</code>. Another advantage is that <code>qunit-dom</code> generates a useful
assertion description by default, while <code>assert.equal()</code> will just show
something like &quot;A does not match B&quot;. </li>
</ul>
<blockquote>
<p>What is the impact of not doing this?</p>
</blockquote>
<p>We will keep using hard-to-read assertions by default and leave it up to our
users to discover <code>qunit-dom</code> by themselves.</p>
<h1 id="unresolved-questions-31"><a class="header" href="#unresolved-questions-31">Unresolved questions</a></h1>
<ul>
<li>Should the <code>ember-source</code> blueprints detect <code>qunit-dom</code> usage and fallback
to raw QUnit assertions if the dependency can't be found?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-07-30
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/120</p>
<hr />
<h1 id="ember-cli-docs"><a class="header" href="#ember-cli-docs">Ember CLI Docs</a></h1>
<h2 id="summary-37"><a class="header" href="#summary-37">Summary</a></h2>
<p>This RFC proposes converting the existing <a href="https://ember-cli.com/">Ember CLI website</a> into an
Ember app, restructuring the table of contents, replacing a significant
portion of the learning material, and inviting community members to participate in writing new content.</p>
<h2 id="motivation-38"><a class="header" href="#motivation-38">Motivation</a></h2>
<p>The purpose of these changes are to empower new contributors, create a consistent
narrative structure, correct outdated information, and lead new readers through an easier learning progression.</p>
<p>Ember's public sites are being migrated from Ruby apps to Ember apps
in order to improve maintainability and empower new contributors. The CLI docs
are currently a Jekyll app. Similar migrations have been very successful.</p>
<p>The rewrite and/or reorganization of content is driven by an audit of the existing
content's relevance and balance. While trying to plan a refactor in place, it became clear that a greenfield approach is more time efficient and will lead to a 
better learning experience. A significant portion of the content from the current guides site can be ported over once a new structure is in place.</p>
<h2 id="detailed-design-37"><a class="header" href="#detailed-design-37">Detailed design</a></h2>
<p>This app will have a new table of contents. The architecture will follow the
same patterns successfully used in other apps that have been converted from
Middleman apps to Ember.</p>
<h3 id="writing-process"><a class="header" href="#writing-process">Writing process</a></h3>
<p>Writing new content and porting over existing information is a job that will require the help of many contributors! After this RFC is accepted, a call for contributors will be made. </p>
<p>Here are some strategies to help contributor work to be successful:</p>
<ul>
<li>A quest issue will outline sections that need work so that people can volunteer</li>
<li>Collaboration will be encouraged so that no one person blocks writing on a particular topic</li>
<li>Contributing can take multiple forms. For example, developers with some CLI expertise who don't have time/interest for formal writing can share some brief notes or suggestions to help out the writers. Writers don't need to be experts. In some cases, it's better when someone isn't very familiar with the content because they can help identify gaps.</li>
<li>Each unwritten section will have comments in the markdown indicating which topics to cover. In cases where content has been ported over, comments will indicate which sections to fact-check, clarify, or revise. </li>
<li>A strike team channel will be created on a chat</li>
<li>A writing styleguide will be provided for contributors</li>
<li>Following a verson one release, writing work will be organized via normal GitHub issues.</li>
</ul>
<p>Since maintaining consistent voice and structure across a blank slate is a challenge, beta content for the core learning experience has already been drafted, including Basic Use guides and a tutorial for creating an addon from start to finish.</p>
<p>The beta version of the CLI Guides content can be found at <a href="https://github.com/ember-learn/cli-guides-source">ember-learn/cli-guides-source</a>. The Markdown files there are rendered by <a href="https://github.com/ember-learn/cli-guides-source">ember-learn/cli-guides-app</a>. The app is currently deployed to a temporary endpoint for testing and UX validation. The link is available on the repositories.</p>
<h3 id="user-personas"><a class="header" href="#user-personas">User Personas</a></h3>
<p>The content layout should follow the progression of an Ember developer's
learning experience. There are four main user personas for the 
CLI documentation:</p>
<ol>
<li>A new or &quot;typical&quot; Ember CLI user - someone whose primary work is
running common commands like <code>ember serve</code> and who has a &quot;zero
config&quot; type of experience with Ember</li>
<li>Power users - developers who make their own configurations to the
build pipeline</li>
<li>Beginner addon authors - those who are looking to build simple
shared UI components, methods, or wrappers for existing npm libraries</li>
<li>Advanced addon authors - those who dig into internals to make their
addon work, or who are planning for broad extensibility</li>
</ol>
<h3 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h3>
<p>Applying these User Personas to the CLI content, the following topics layout emerges. &quot;Beginner&quot; topics will include links to later &quot;Advanced&quot;
topics, similar to how the Guides link to the API docs.</p>
<ul>
<li>Introduction 
<ul>
<li>how to install ember cli </li>
<li>a very simple, short definition of what it is (the official way to create, build, and test an Ember app)</li>
<li>Why is the CLI needed</li>
<li>Guidance on learning path</li>
<li>How to contribute</li>
</ul>
</li>
<li>Basic use (explain options of each)
<ul>
<li>CLI Commands: Explain how to use the <code>help</code> command and common commands like <code>ember new</code>, <code>ember server</code>, <code>ember generate</code>, etc. Each is explained briefly, together with an example usage and a link to the Main Ember Guides with more information about how to use those files.</li>
<li>How to find and use addons</li>
<li>How to use npm packages</li>
<li>Installation and Upgrading the CLI (including a note about upgrading your app, with a link to more resources)</li>
<li>feature flags &amp; configurations</li>
</ul>
</li>
<li>Advanced use
<ul>
<li>shims</li>
<li>broccoli</li>
<li>custom blueprints</li>
<li>CSS compilation</li>
<li>Using another testing library</li>
<li>more on dependencies</li>
<li>more configurations</li>
</ul>
</li>
<li>Writing Addons
<ul>
<li>Overview</li>
<li>Tutorial: Creating a standalone addon and an in-repo addon, </li>
<li>Using the dummy app</li>
<li>Including assets</li>
<li>Configuration</li>
<li>Nested addons</li>
<li>Testing your addon</li>
<li>Sharing your addon (deploying)</li>
</ul>
</li>
<li>API Documentation
<ul>
<li>brief description of the target audience and a link</li>
</ul>
</li>
</ul>
<h3 id="versioning"><a class="header" href="#versioning">Versioning</a></h3>
<p>Only one version of the documentation will be deployed and maintained.
The documentation app itself will have clear releases
as major changes are made, so that users working on
older apps can still go back in time if they need to.</p>
<p>The url will contain <code>/release/</code> so that if versioning is needed in the future,
the option is available.</p>
<h3 id="transition-and-legacy-links"><a class="header" href="#transition-and-legacy-links">Transition and legacy links</a></h3>
<p>While the project is in development, it will be worked on as a separate site, and the main site, <a href="https://ember-cli.com">https://ember-cli.com</a> will remain in place.</p>
<p>Legacy links should be maintained because deprecating the links would cause SEO problems. Consensus seems to be that the best option is to create individualized redirects from pages within <a href="https://ember-cli.com">https://ember-cli.com</a> to the new site.</p>
<p>Upon reaching feature parity, <a href="https://ember-cli.com">https://ember-cli.com</a> will redirect to the new site. Ultimately, content will be hosted at <a href="https://cli.emberjs.com/">https://cli.emberjs.com/</a>. This improves the SEO of our emberjs domain.</p>
<h3 id="application-architecture"><a class="header" href="#application-architecture">Application architecture</a></h3>
<p>The application architecture will follow similar patterns as other Middleman
apps that have been successfully turned into Ember apps. Some examples of past conversions are:</p>
<ul>
<li><a href="https://github.com/ember-learn/deprecation-app">Deprecations</a></li>
<li><a href="https://github.com/ember-learn/guides-app">The Guides</a></li>
<li><a href="https://github.com/ember-learn/ember-api-docs">The API docs</a></li>
</ul>
<p><a href="https://github.com/mansona?tab=overview&amp;from=2018-06-01&amp;to=2018-06-30">Chris Manson</a> has a project in development that automates the creation of documentation apps, integrating the lessons learned from these past conversions. Early results are looking great!</p>
<p>The resulting app will make use of typography and UI assets from 
<a href="https://github.com/ember-learn/ember-styleguide">ember-styleguide</a></p>
<p>Although only one version will be deployed/maintained for the forseeable future, the URL structure will allow for future growth, i.e. <code>https://cli.emberjs.com/release/some-topic</code></p>
<h3 id="maintaining-content"><a class="header" href="#maintaining-content">Maintaining content</a></h3>
<p>With module unification and tree shaking refactors underway, there may be some big changes to Ember's
file structure. There are a few ways to mitigate this, while still maintaining only one version of these guides:</p>
<ol>
<li>Whenever possible, the CLI guides should link to the Ember Guides. The details of file layout and syntax are best handled in a resource that is versioned.</li>
<li>The CLI guides can also frequently give a nod to past configurations/features. A url checker will make sure that these &quot;legacy&quot; resource links still exist. The pace of major version releases is slow enough that this should be sustainable.</li>
<li>As mentioned earlier, the urls for the cli guides will include <code>/release/</code> in case future versioning is needed</li>
</ol>
<p>Members of both the Learning Core Team and Ember CLI Core team will have merge access.</p>
<h2 id="how-we-teach-this-13"><a class="header" href="#how-we-teach-this-13">How we teach this</a></h2>
<p>Overall, bringing the CLI docs content up to speed and making it
more maintainable should result in better integration of the
CLI documentation into the Guides. The current content is out
of date, and so it is not frequently linked.</p>
<p>The impact to new users will be a better experience. Existing
Ember users may have an adjustment period to learn the new layout,
but the current layout is confusing, so we believe there will be
net improvement from day one. The addition of search tools will help
with the transition.</p>
<p>Links in the Guides will need to be updated to point
to the new documentation app. There are 41 links to the
current ember-cli website, but only a handful are unique.</p>
<p>The Ember CLI website is not referenced in the API docs.</p>
<h2 id="drawbacks-36"><a class="header" href="#drawbacks-36">Drawbacks</a></h2>
<p>Some potential drawbacks include:</p>
<ul>
<li>Old bookmarks will still point to old content, and it is significant engineering effort to maintain those legacy links</li>
<li>Users may be used to finding content in a particular place</li>
<li>Some existing content will be deemphasized or removed</li>
<li>It's another app to keep in step with the main website</li>
</ul>
<h2 id="alternatives-37"><a class="header" href="#alternatives-37">Alternatives</a></h2>
<p>An alternative is to refactor the content in place. This will be more
time consuming, and will not achieve a consistent narrative voice or cumulative learning experience.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-02-11
RFC PR: https://github.com/emberjs/rfcs/pull/120
Ember Issue: https://github.com/emberjs/ember.js/pull/13016</p>
<hr />
<h1 id="summary-38"><a class="header" href="#summary-38">Summary</a></h1>
<p>This RFC proposes replacing the existing <a href="http://emberjs.com/api/classes/Ember.Route.html#method_serialize"><code>Route#serialize</code></a> method with an equivalent method on the options hash passed into <a href="http://emberjs.com/api/classes/Ember.Router.html#method_map"><code>this.route</code> within <code>Router#map</code></a>. The primary goal here is to enable asynchronous Engines by decoupling information about how to link to a route from the actual route object.</p>
<h1 id="motivation-39"><a class="header" href="#motivation-39">Motivation</a></h1>
<p>As we move towards an increasingly asynchronous world with Engines, we need to separate knowledge about how to <em><strong>link</strong> to a route</em> and how to <em><strong>enter</strong> a route</em>. Linking to a route should be able to happen <em>before</em> a route object is instantiated, which is the behavior needed to asynchronously load Engines. However, in our current reality, these concerns are coupled and a route object must be instantiated before being able to link to <em>or</em> enter a route.</p>
<p>By separating these concerns, we can preemptively load the information on how to link to a route without also requiring all the knowledge of how to enter that route. This would be beneficial in both the asynchronous and synchronous worlds by allowing us to defer work.</p>
<p>Since the <code>serialize</code> method is the only method currently used by the <code>Route</code> class to define how to link to a route, the proposal is to extract this method into the space which currently contains the other linking information (e.g., the Router's map).</p>
<p><em><strong>Note:</strong> this separation of concerns will also need to be implemented in router.js for the preemptive loading proposed here to actually work, but we can prepare for that future world by creating a separation of concerns within application code now.</em></p>
<h1 id="detailed-design-38"><a class="header" href="#detailed-design-38">Detailed Design</a></h1>
<p>Since the current API is a simple function, the new hash option will also be a simple function that mirrors the signature of the original. Here's an example:</p>
<pre><code class="language-js">// app/router.js
function serializePostRoute(model, params) {
  // serialize the model into the dynamic paths
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
</code></pre>
<p>Preserving the current function signature means that refactoring existing code should be simple in most cases. Here's the example currently given in the Ember docs (updated to reflect Ember-CLI):</p>
<pre><code class="language-js">// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  },

  serialize(model) {
    // this will make the URL `/posts/12`
    return { post_id: model.id };
  }
});

// app/router.js
export default Router.map(function() {
  this.route('post', {
    path: '/post/:id'
  });
});
</code></pre>
<p>Here is that same code refactored for the proposal:</p>
<pre><code class="language-js">// app/routes/post.js
import Ember from 'ember';
export default Ember.Route.extend({
  model(params) {
    // the server returns `{ id: 12 }`
    return Ember.$.getJSON('/posts/' + params.post_id);
  }
});

// app/router.js
function serializePostRoute(model) {
  // this will make the URL `/posts/12`
  return { post_id: model.id };
}

export default Router.map(function() {
  this.route('post', { path: '/post/:id', serialize: serializePostRoute });
});
</code></pre>
<h1 id="migration-plan"><a class="header" href="#migration-plan">Migration Plan</a></h1>
<p>Even though the refactoring needed here is easy, we still need a clear (though simple) migration plan.</p>
<p>The first step will be to introduce the new option into the Router's callback <code>route</code> function. Once that is done, we can deprecate <code>Route#serialize</code> over the remainder of the 2.x series to give developers the time to update their code base. We can then remove support in 3.x.</p>
<p>As noted in the &quot;Motivation&quot; section, there is still work to be done in router.js in order to support this separation of concerns. Due to this, the initial implementation of this new option will essentially be a polyfill that proxies to the corresponding <code>Route#serialize</code> property internally. This will set us up for an internal migration at a later point to actually separate the two; this, however, should not affect developers as it will be internal.</p>
<h1 id="pedagogy-how-we-teach-this"><a class="header" href="#pedagogy-how-we-teach-this">Pedagogy (How We Teach This)</a></h1>
<p>Once the new option is introduced, the Ember guides will need to be updated to reflect this. Those changes should be relatively straightforward as shown in the example above. This will help introduce the feature to new users and those users that haven't used <code>Route#serialize</code> before. Since inline serializers in the router map can be distracting to understanding the general layout of a codebase, we should teach them as defined outside the map itself (as in the code example in this RFC).</p>
<p>For existing users, we can introduce this feature through deprecation warnings (as mentioned above). The deprecations should briefly introduce the new option and point to an appropriate deprecation guide that explains how to migrate.</p>
<h1 id="drawbacks-37"><a class="header" href="#drawbacks-37">Drawbacks</a></h1>
<ul>
<li>Adds another option to the Router map. Though this is largely mitigated due to the fact that this feature is not in wide use currently.</li>
<li>Can be sort of ugly to format.</li>
</ul>
<h1 id="alternatives-38"><a class="header" href="#alternatives-38">Alternatives</a></h1>
<ul>
<li>Introduce a standalone module to represent the <code>Route#serialize</code>. This was the first proposal of this RFC and there is much opposition to introducing yet another construct for Ember-CLI and developers to manage. The approach proposed above avoids this major drawback.</li>
<li>Introduce a holistic construct to represent route linking information. Instead of introducing a new option as a function, we could introduce a class that would represent all the information needed to link to a route. Since there is not currently much other information needed, this seems overkill and would suffer similar opposition as the first alternative.</li>
<li>Don't do this and continue loading and instantiating all route information upfront. This prevents us from improving performance by keeping concerns coupled with prevents introducing async engines. It also requires all Route classes be instantiaed upfront.</li>
</ul>
<h1 id="unresolved-questions-32"><a class="header" href="#unresolved-questions-32">Unresolved Questions</a></h1>
<ul>
<li>Do we wish to apply a similar approach for default query params? And if so, do we wish to incorporate that approach into this new construct?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-08-13
Relevant Team(s): Ember CLI
RFC PR: https://github.com/ember-cli/rfcs/pull/121</p>
<hr />
<h1 id="summary-39"><a class="header" href="#summary-39">Summary</a></h1>
<p>Remove https://github.com/ember-cli/ember-cli-eslint from projects generated by
<code>ember-cli</code>.</p>
<p><a href="https://github.com/ember-cli/ember-cli-eslint">ember-cli-eslint</a> is an addon
designed to show lint errors during test runs. Tooling around <code>eslint</code> has
improved enough where this feature may no longer be necessary.</p>
<p>To be clear, the proposal is <em>not</em> to remove linting in tests. It is to follow
the rest of JavaScript community and follow the standard tooling process.</p>
<p>There are multiple ways to run <code>eslint</code>:</p>
<ol>
<li>Integration with editors</li>
<li>Utilize precommit hooks with <code>eslint</code></li>
<li>Support a standard way to run <code>eslint</code> (such as <code>yarn lint:js</code>)</li>
</ol>
<p>We can also discuss configuring <code>testem</code> to automatically run <code>eslint</code> as part
of <code>yarn test</code></p>
<h1 id="motivation-40"><a class="header" href="#motivation-40">Motivation</a></h1>
<ol>
<li>Improve our build speed</li>
<li>Simplicity. <code>eslint</code> is common among JS stack, and integrations with editors
/ precommit-hooks are ubiquitous. Removing this layer of abstraction will
simplify how <code>eslint</code> is used throughout <code>ember-cli</code>. Most editors have
plugins available for <code>eslint</code>, and as long as the <code>.eslint.rc</code> is not
removed, we should still see the benefits of <code>eslint</code> in our Ember projects.</li>
<li>Hacks required to support features such as <a href="https://github.com/ember-cli/broccoli-lint-eslint/pull/122#discussion-diff-153937455R28">PR #122
broccoli-lint-eslint</a></li>
</ol>
<h1 id="detailed-design-39"><a class="header" href="#detailed-design-39">Detailed design</a></h1>
<ol>
<li>Change blueprint to pull in <code>eslint</code> as opposed to <code>ember-cli-eslint</code> under
<code>devDependencies</code>.</li>
<li>Provide documentation on <code>eslint</code> and editor integration as well as precommit hooks</li>
</ol>
<p>Redefine <code>npm test</code> or <code>yarn test</code> (depending on whether the <code>--yarn</code> option was
used to create project) to</p>
<pre><code>ember test &amp;&amp; npm run lint:js &amp;&amp; npm run lint:hbs
</code></pre>
<p>and</p>
<pre><code>ember test &amp;&amp; yarn lint:js &amp;&amp; yarn lint:hbs
</code></pre>
<h1 id="how-we-teach-this-14"><a class="header" href="#how-we-teach-this-14">How We Teach This</a></h1>
<p>Providing documentation regarding how to run linting should suffice as well as
documentation to editor integration.</p>
<p>Deleting abstractions and going towards a explicit path, <code>eslint</code> within the
<code>ember-cli</code> ecosystem becomes <em>easier</em> to teach.</p>
<h1 id="drawbacks-38"><a class="header" href="#drawbacks-38">Drawbacks</a></h1>
<ol>
<li>No console warnings during builds</li>
<li>lint failures are no longer included in browser tests</li>
</ol>
<h1 id="alternatives-39"><a class="header" href="#alternatives-39">Alternatives</a></h1>
<ol>
<li>Leave <code>ember-cli-eslint</code> alone</li>
</ol>
<h1 id="unresolved-questions-33"><a class="header" href="#unresolved-questions-33">Unresolved questions</a></h1>
<p>N/A</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-04-16
RFC PR: https://github.com/emberjs/rfcs/pull/136
Ember Issue: https://github.com/emberjs/ember.js/pull/13553</p>
<hr />
<h1 id="summary-40"><a class="header" href="#summary-40">Summary</a></h1>
<p><a href="http://emberjs.com/api/classes/Ember.Array.html#method_contains"><code>contains</code></a> is
implemented on <code>Ember.Array</code>, but [contains was renamed to includes in 2014]
(https://github.com/tc39/Array.prototype.includes/commit/4b6b9534582cb7991daea3980c26a34af0e76c6c)</p>
<ul>
<li>this proposal is for <code>contains</code> to be deprecated in favour of an <code>includes</code>
method on <code>Ember.Array</code></li>
</ul>
<h1 id="motivation-41"><a class="header" href="#motivation-41">Motivation</a></h1>
<p>Motivation is to stay in line with web standards</p>
<h1 id="detailed-design-40"><a class="header" href="#detailed-design-40">Detailed design</a></h1>
<p>First, implement <code>includes</code> polyfill in compliance with <code>includes</code> spec. Polyfill
sample from MDN is:</p>
<pre><code class="language-js">if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {
    'use strict';
    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1]) || 0;
    var k;
    if (n &gt;= 0) {
      k = n;
    } else {
      k = len + n;
      if (k &lt; 0) {k = 0;}
    }
    var currentElement;
    while (k &lt; len) {
      currentElement = O[k];
      if (searchElement === currentElement ||
         (searchElement !== searchElement &amp;&amp; currentElement !== currentElement)) { // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}
</code></pre>
<p>Then, alias <code>contains</code> to <code>includes</code> with deprecation warning, deprecate in line with standard
deprecation process. I don't believe that adding the additional parameter will
have any affect on existing usage of <code>contains</code>.</p>
<h1 id="how-we-teach-this-15"><a class="header" href="#how-we-teach-this-15">How We Teach This</a></h1>
<ul>
<li>Update any references in docs and guides to <code>includes</code></li>
<li>Write a deprecation guide, mentioning any edge cases where the new <code>includes</code> behaves differently to <code>contains</code>, and giving migration examples</li>
<li>Indicate in api docs that this is a polyfill</li>
</ul>
<h1 id="drawbacks-39"><a class="header" href="#drawbacks-39">Drawbacks</a></h1>
<ul>
<li>May break existing apps</li>
<li><a href="https://github.com/emberjs/ember.js/issues/5670#issuecomment-64084814">Was considered before but was too early</a></li>
</ul>
<h1 id="alternatives-40"><a class="header" href="#alternatives-40">Alternatives</a></h1>
<p>Keep current methods</p>
<h1 id="unresolved-questions-34"><a class="header" href="#unresolved-questions-34">Unresolved questions</a></h1>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-04-18
RFC PR: https://github.com/emberjs/rfcs/pull/139
Ember Issue: https://github.com/emberjs/ember.js/pull/13666</p>
<hr />
<h1 id="summary-41"><a class="header" href="#summary-41">Summary</a></h1>
<p>Introduce <code>Ember.String.isHtmlSafe()</code> to provide a reliable way to determine if an object is an &quot;html safe string&quot;, i.e. was it created with <code>Ember.String.htmlSafe()</code>.</p>
<h1 id="motivation-42"><a class="header" href="#motivation-42">Motivation</a></h1>
<p>Using <code>new Ember.Handlebars.SafeString()</code> is slated for deprecation. Many people are currently using the following snippet as
a mechanism of type checking: <code>value instanceof Ember.Handlebars.SafeString</code>. Providing <code>isHtmlSafe</code> offers a
cleaner method of detection. Beyond that, the aforementioned test is a bit leaky. It requires the developer to understand
<code>htmlSafe</code> returns a <code>Ember.Handlerbars.SafeString</code> instance and thus limits Ember's ability to change
<code>htmlSafe</code> without further breaking it's API.</p>
<p>Based on our app at Batterii and some research on Github, I see two valid use cases for introducing this API.</p>
<p>First, and most commonly, is to make it possible to test addon helpers that are expected to return a safe string. I believe this test on ember-i18n says it all: <a href="https://github.com/jamesarosen/ember-i18n/blob/master/tests/unit/utils/i18n/default-compiler-test.js#L56-L59">&quot;returns HTML-safe string&quot;</a>.</p>
<p>The second use case is to do type checking. In our app, we have an <code>isString</code> utility that is effectively:</p>
<pre><code class="language-javascript">import Ember from 'ember';

export default function(value) {
  return typeof value === 'string' || value instanceof Ember.Handlebars.SafeString;
}
</code></pre>
<p>Newer versions of ember-i18n, doing <code>this.get('i18n').t('someTranslatedValue')</code> will return a safe string. Thus our <code>isString</code> utility has to consider that.</p>
<h1 id="detailed-design-41"><a class="header" href="#detailed-design-41">Detailed design</a></h1>
<p><code>isHtmlSafe</code> will be added to the <code>Ember.String</code> module. The implementation will basically be:</p>
<pre><code class="language-javascript">function isHtmlSafe(str) {
  return str &amp;&amp; typeof str.toHTML === 'function';
}
</code></pre>
<p>It will be used as follows:</p>
<pre><code class="language-javascript">if (Ember.String.isHtmlSafe(str)) {
  str = str.toString();
}
</code></pre>
<h1 id="transition-path"><a class="header" href="#transition-path">Transition Path</a></h1>
<p>As part of landing <code>isHtmlSafe</code> we will simultaneously re-deprecate <code>Ember.Handlebars.SafeString</code>. This deprecation will
take care to ensure that <code>str instanceof Ember.Handlebars.SafeString</code> still passes so that we can continue to
maintain backwards compatibility.</p>
<p>Additionally, a polyfill will be implemented to help provide forward compatibility for addon maintainers and others
looking to get a head while still on older versions of Ember. Similar to <a href="https://github.com/rwjblue/ember-getowner-polyfill">ember-getowner-polyfill</a>.</p>
<h1 id="how-we-teach-this-16"><a class="header" href="#how-we-teach-this-16">How We Teach This</a></h1>
<p>I think we'll continue to refer to these strings as &quot;html safe strings&quot;. This RFC does not
introduce any new concepts, rather it builds on an existing concept.</p>
<p>I don't believe this feature will require guide discussion. I think API Docs will suffice.</p>
<p>The concept of type checking is a pretty common programming idiom. It should be relatively self
explanatory.</p>
<h1 id="drawbacks-40"><a class="header" href="#drawbacks-40">Drawbacks</a></h1>
<p>The only drawback I see is that it expands the surface of the API and it takes a step
towards prompting &quot;html safe string&quot; as a thing.</p>
<h1 id="alternatives-41"><a class="header" href="#alternatives-41">Alternatives</a></h1>
<p>An alternative would be to expose <code>Ember.Handlerbars.SafeString</code> publicly once again. Users
could revert back to using <code>instanceof</code> as their type checking mechanism.</p>
<h1 id="unresolved-questions-35"><a class="header" href="#unresolved-questions-35">Unresolved questions</a></h1>
<p>There are no unresolved questions at this time.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-05-09
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/143
Tracking: https://github.com/emberjs/rfc-tracking/issues/27 / https://github.com/emberjs/ember.js/issues/14882</p>
<hr />
<blockquote>
<p>Note: This RFC replaces the closely related RFC for <a href="https://github.com/emberjs/rfcs/pull/124">Module
Normalization</a>. As discussed in the
<a href="0143-module-unification.html#alternatives">Alternatives</a> section below, many concepts are shared between
the two proposals, but there is also a fundamental difference.</p>
</blockquote>
<h1 id="summary-42"><a class="header" href="#summary-42">Summary</a></h1>
<p>Create a unified pattern for organizing and naming modules in Ember projects
that is deterministic, extensible, and ergonomic.</p>
<h1 id="motivation-43"><a class="header" href="#motivation-43">Motivation</a></h1>
<p>Ember CLI's conventions for project layouts and file naming are central to every
Ember developer's experience. It's crucial to get both the technical and
ergonomic details right.</p>
<p>The existing conventions used by Ember CLI have evolved gradually and
organically over the years. Ember CLI and its predecessor Ember App Kit were
early adopters of ES modules and have always leveraged strong conventions to
deduce an understanding of modules based on their locations. Ember CLI's
resolver encodes those conventions to enable run-time module resolutions.</p>
<p>The current system works fairly well, but has some complexities and
inconsistencies that both steepen its learning curve and limit its technical
potential.</p>
<p>Drawbacks include:</p>
<ul>
<li>
<p>Confusion over which of two orthogonal approaches to use for organizing
modules:</p>
<ul>
<li>
<p>classic - modules are organized at the top-level by &quot;type&quot;
(<code>components</code>, <code>templates</code>, etc.) and then by namespace and name.</p>
</li>
<li>
<p>pods - modules are organized by namespace, then name, then type.</p>
</li>
</ul>
</li>
<li>
<p>Addons define modules to be merged into an application through a special <code>app</code>
directory. These public modules are typically private modules that are
imported and re-exported, which introduces an extra module per export and an
extra level of abstraction to learn.</p>
</li>
<li>
<p>Because addons' modules are mixed into an application, there's the possibility
of naming collisions between two addons or an addon and its consuming
application.</p>
</li>
<li>
<p>Modules don't have a clear sense of &quot;locality&quot;, which prevents the ability to
declare modules that are available only in a &quot;local&quot; namespace (this as-yet
unsupported feature has been called &quot;local lookup&quot;).</p>
</li>
<li>
<p>Resolution rules that are declared only in JavaScript are difficult to
analyze and optimize.</p>
</li>
<li>
<p>Module resolution is inefficient due to the number of potential places to
lookup a particular module by name.</p>
</li>
</ul>
<p>Recognizing these drawbacks, the Core Team compiled a set of
<a href="https://github.com/emberjs/core-notes/blob/master/ember.js/2016-01/january-22.md#summary-of-pods-design-constraints">design constraints</a>
for a rethink of Ember's approach to modules:</p>
<ol>
<li>Reasonable branching factor. Users should see a reasonable number of items at any given level in their hierarchy. Flattening out too much results in an unreasonably large number of items.</li>
<li>No slashes in component names. The existing system allows this, but we don't want to support invocation of nested components in Glimmer Components.</li>
<li>Addons need to participate in the naming scheme, most likely with namespace prefix and double-colon separator.</li>
<li>Subtrees should be relocatable. If you move a directory to a new place in the tree, its internal structure should all still work.</li>
<li>There should be no cognitive overhead when adding a new thing. The right way should be obvious and not impose unnecessary decisions.</li>
<li>We need clean separation between the namespace of the user's own components, helpers, routes, etc and the framework's own type names (&quot;component&quot;, &quot;helper&quot;, etc) so that we can disambiguate them and add future ones.</li>
<li>Ideally we will have a place to put tests and styles alongside corresponding components.</li>
<li>Local relative lookup for components and helpers needs to work.</li>
<li>Avoid the &quot;titlebar problem&quot;, in which many files are all named &quot;component.js&quot; and you can't tell them apart in your editor.</li>
<li>The resolver should be configured via declarative rules, not imperative
JavaScript. In addition to enforcing consistency, this allows addons to
augment the system with their own types in a predictable way.</li>
<li>Module structures must be statically analyzable at build time to enable
efficiency optimizations.</li>
<li>Module classifications must be extensible and allow for customizations by
apps, engines, and addons.</li>
</ol>
<blockquote>
<p>Note: Constraints &gt; 9 were added based on discussions subsequent to the
initial meeting.</p>
</blockquote>
<p>This proposal attempts to address these constraints with a single consistent
approach to modules that will make Ember easier to use and learn <em>and</em> improve
the efficiency of Ember's resolver at run-time.</p>
<h1 id="detailed-design-42"><a class="header" href="#detailed-design-42">Detailed Design</a></h1>
<p>This proposal introduces a new top-level directory, <code>src</code>, and establishes
conventions for organizing modules within it. Also proposed is a refactor of the
Ember resolver to enable efficient and flexible resolutions based upon the new
module conventions.</p>
<p>The <code>src</code> directory will be used to contain the core ES modules within an Ember
CLI project, whether that project contains an application, addon, or engine. To
maintain backward compatibility, the <code>src</code> directory will be allowed to
co-exist alongside existing <code>app</code> and/or <code>addon</code> directories, although these
directories should eventually be deprecated.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>Let's start by taking a look at some examples of Ember projects organized
according to the proposed conventions.</p>
<h3 id="example-application"><a class="header" href="#example-application">Example Application</a></h3>
<p>A simple blogging application could be structured as follows:</p>
<pre><code>src
├── data
│   ├── models
│   │   ├── comment
│   │   │   ├── adapter.js
│   │   │   ├── model.js
│   │   │   └── serializer.js
│   │   ├── post
│   │   │   ├── adapter.js
│   │   │   ├── model.js
│   │   │   └── serializer.js
│   │   └── author.js
│   └── transforms
│       └── date.js
├── init
│   ├── initializers
│   │   └── i18n.js
│   └── instance-initializers
│       └── auth.js
├── services
│   └── auth.js
├── ui
│   ├── components
│   │   ├── date-picker
│   │   │   ├── component.js
│   │   │   └── template.hbs
│   │   └── list-paginator
│   │       ├── paginator-control
│   │       │   ├── component.js
│   │       │   └── template.hbs
│   │       ├── component.js
│   │       └── template.js
│   ├── partials
│   │   └── footer.hbs
│   ├── routes
│   │   ├── application
│   │   │   └── template.hbs
│   │   ├── index
│   │   │   ├── controller.js
│   │   │   ├── route.js
│   │   │   └── template.hbs
│   │   └── posts
│   │       ├── -components
│   │       │   ├── -utils
│   │       │   │   └── strings.js
│   │       │   ├── capitalize.js
│   │       │   └── titleize.js
│   │       ├── post
│   │       │   ├── -components
│   │       │   │   └── post-viewer
│   │       │   │       ├── component.js
│   │       │   │       └── template.hbs
│   │       │   ├── edit
│   │       │   │   ├── -components
│   │       │   │   │   ├── post-editor
│   │       │   │   │   │   ├── post-editor-button
│   │       │   │   │   │   │   ├── component.js
│   │       │   │   │   │   │   └── template.hbs
│   │       │   │   │   │   ├── calculate-post-title.js
│   │       │   │   │   │   ├── component.js
│   │       │   │   │   │   └── template.hbs
│   │       │   │   │   ├── route.js
│   │       │   │   │   └── template.hbs
│   │       │   │   ├── route.js
│   │       │   │   └── template.hbs
│   │       │   ├── route.js
│   │       │   └── template.hbs
│   │       ├── route.js
│   │       └── template.hbs
│   ├── styles
│   │   └── app.scss
│   └── index.html
├── utils
│   └── md5.js
├── main.js
└── router.js
</code></pre>
<h3 id="example-engine"><a class="header" href="#example-engine">Example Engine</a></h3>
<p>An engine could provide the same blogging functionality with almost entirely the
same module structure as the example blog application. Only the following
notable changes would be needed:</p>
<ul>
<li>An engine should declare its routes in <code>src/routes.js</code> instead of <code>src/router.js</code></li>
<li>An engine would require a <code>dummy</code> app within <code>tests</code></li>
<li>An engine should export an <code>Engine</code> instead of an <code>Application</code> from <code>src/main.js</code></li>
</ul>
<h3 id="example-addon"><a class="header" href="#example-addon">Example Addon</a></h3>
<p>Here's how the
<a href="https://github.com/cibernox/ember-power-select">ember-power-select</a> addon could
be restructured:</p>
<pre><code>src
├── styles
│   └── ember-power-select.scss
├── ui
│   └── components
│       ├── main
│       │   ├── before-options
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── options
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── trigger
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── component.js
│       │   └── template.hbs
│       ├── multiple
│       │   ├── trigger
│       │   │   ├── component.js
│       │   │   └── template.hbs
│       │   ├── component.js
│       │   └── template.hbs
│       └── is-selected.js
└── main.js
</code></pre>
<h3 id="migration-tool"><a class="header" href="#migration-tool">Migration Tool</a></h3>
<p>As a proof of concept for the module layout described in this RFC, Robert
Jackson has created a <a href="https://github.com/rwjblue/ember-module-migrator">migration
tool</a> and used it to migrate
the following repos:</p>
<ul>
<li><a href="https://github.com/rwjblue/--ghost-modules-sample/tree/grouped-collections/src">Ghost admin client</a></li>
<li><a href="https://github.com/rwjblue/--travis-modules-sample/tree/modules/src">Travis client</a></li>
<li><a href="https://github.com/rwjblue/--new-app-blueprint/tree/modules/src"><code>ember new my-app</code></a></li>
</ul>
<p>You can also use Robert's migration tool on your own projects to gain a feel for
how this RFC will affect your work.</p>
<h2 id="es-modules"><a class="header" href="#es-modules">ES Modules</a></h2>
<p>It's important to understand how ES module paths are mapped from the file
system so that you can import modules from elsewhere in your project and its
associated dependencies.</p>
<p>ES module paths will be formed from a project's package name followed by a
direct mapping of file paths from the project root. The file's final extension
(e.g. <code>js</code> or <code>hbs</code>) will be excluded because all ES modules will of course be
compiled into JavaScript from their original format.</p>
<p>For example, the file <code>src/ui/components/date-picker.js</code> in the
<code>my-calendar</code> app will be exported with the module path
<code>my-calendar/src/ui/components/date-picker</code>.</p>
<p>An application and its associated addons and engines will all be merged into the
same ES module space, as is done today. Any module can import from any other
module within this space, although cross-package imports should be done with
care.</p>
<h2 id="module-naming-and-organization"><a class="header" href="#module-naming-and-organization">Module Naming and Organization</a></h2>
<p>This section describes the conventions proposed for naming and organizing a
project's modules within <code>src</code>. These conventions will allow Ember CLI's
resolver to determine the purpose of each module at run-time. They will also
enable static analysis of modules to lint against errors and to prepare a
normalized map for efficient resolutions.</p>
<p>Every resolvable module must have both a <code>name</code> and a <code>type</code>. The <code>type</code>
typically corresponds to the base class of the module's default export (e.g.
<code>route</code>, <code>template</code>, etc.).</p>
<p>Modules can be grouped together with other modules of related types in
&quot;collections&quot;. Collections are directories with type-aware resolution rules
which allow related modules to share a namespace. For example, the <code>models</code>
collection contains models, adapters, and serializers.</p>
<p>Collections that are related to each other can be further organized in &quot;group&quot;
directories. For example, the <code>ui</code> group contains the <code>components</code>, <code>partials</code>,
and <code>routes</code> collections.</p>
<p>Ember CLI will have a build step that normalizes modules to a common form and
builds a mapping between that form and the ES module path described above.
While building this normalized map, the build must error and provide useful
messages if any module naming errors are detected. Unregistered collections and
types should not be allowed. Also, the same normalized module path must not be
repeated through alternative naming forms.</p>
<h3 id="module-type"><a class="header" href="#module-type">Module Type</a></h3>
<p>The type of a module can be determined through the following file naming and
module export rules:</p>
<ol>
<li><code>src/${type}</code> - typed modules named <code>main</code> (explained further below), in
which default exports match the type specified by the file name.</li>
<li><code>src/${collection}/${namespace}/${name}/${type}</code> - expanded collection
modules, in which default exports match the type specified by the file name.</li>
<li><code>src/${collection}/${namespace}/${name}</code> - in which type can be inferred
based on the module's exports. Default exports must match the default
type for the collection. If there is no default export, named exports will
be scanned for a matching type allowed in the collection.</li>
</ol>
<p>Note that template precompilers will need to use default vs. named exports
appropriately in order to satisfy the expectations of Rules 2 and 3.</p>
<p>Here are a few example applications of the module type determination rules:</p>
<pre><code>// Rule 1

src/router (with `export default Ember.Router.extend()`)
=&gt; name: 'main',
   type: 'router'

// Rule 2

src/ui/routes/posts/post/route.js (with `export default Ember.Route.extend()`)
=&gt; collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'route'

src/ui/routes/posts/post/template (with `export default Ember.HTMLBars.template(COMPILED)`)
=&gt; collection: 'ui/routes',
   namespace: 'posts',
   name: 'post',
   type: 'template'

// Rule 3

src/data/models/author (with `export default DS.Model.extend()`)
=&gt; collection: 'data/models',
   name: 'author',
   type: 'model' (the default type for the models collection)

src/ui/components/titleize (with `export let helper = Ember.Helper.helper(function() { })`)
=&gt; collection: 'ui/components',
   name: 'titleize',
   type: 'helper'

src/ui/components/show-title (with `export let template = Ember.HTMLBars.template(COMPILED)`)
=&gt; collection: 'ui/components',
   name: 'show-title',
   type: 'template'
</code></pre>
<h3 id="main-modules"><a class="header" href="#main-modules">Main Modules</a></h3>
<p>Every project must have a &quot;main&quot; module, named <code>src/main.js</code>, that
serves as an entry point into the project.</p>
<p>The main module must export an <code>Application</code>, <code>Engine</code>, or (new) <code>Addon</code> class.
This class must define a <code>modulePrefix</code>, which must match the node package name
for the project.</p>
<p>The main module also declares other properties that help the Ember resolver
understand relationships between projects. For instance, the main module can
declare which modules in an addon are available to a consuming app's resolver.</p>
<p>The main module of an addon can also declare a <code>rootName</code>, which is used by the
resolver to lookup main modules. Initially, the <code>rootName</code> will be a read-only
property that equals the <code>modulePrefix</code> with any <code>ember-</code> and  <code>ember-cli-</code>
prefixes stripped (e.g. <code>ember-power-select</code> becomes <code>power-select</code>). It's
possible that we may allow overrides / aliases in the future.</p>
<p>Modules that appear alongside <code>main.js</code> in <code>src</code> are also considered <code>main</code>
modules for their respective <code>type</code>. For instance, <code>src/router.js</code> is registered
with a <code>name</code> of <code>main</code> and a <code>type</code> of <code>router</code>.</p>
<h3 id="module-collections"><a class="header" href="#module-collections">Module Collections</a></h3>
<p>Top-level namespaces within <code>src</code> serve to group modules into
type-aware &quot;collections&quot;.</p>
<p>The following rules apply to module collections and types:</p>
<ol>
<li>Each collection can contain one or more types. The types allowed
in a particular collection MUST be explicitly declared.</li>
<li>Each type MAY exist in any number of collections.</li>
<li>Each type MUST have only one &quot;definitive collection&quot;, which is the
collection the resolver will use for resolutions if a module can't be found
in the local (i.e. originating) collection.</li>
<li>Each collection MAY have a single &quot;default type&quot;. If a module does not
indicate its type through its file name, then its default export should
align with the default type for its collection.</li>
<li>Each collection can allow &quot;private collections&quot; to be defined at a namespace.
Private collections are localized additions to a top-level collection,
available only from the namespace at which they're defined.</li>
<li>Top-level collections may be grouped for organization purposes. No
resolvable modules must be placed in a group directory.</li>
<li>A collection can appear only once in a project (i.e. it can not be
contained in multiple group directories, or in a group as well as at the
top-level).</li>
</ol>
<p>The following collections and allowed types (rules 1 &amp; 2) are proposed:</p>
<ul>
<li><code>components</code> - COMPONENT, HELPER, template</li>
<li><code>initializers</code> - INITIALIZER</li>
<li><code>instance-initializers</code> - INSTANCE-INITIALIZER</li>
<li><code>models</code> - MODEL, ADAPTER, SERIALIZER</li>
<li><code>partials</code> - PARTIAL</li>
<li><code>routes</code> - ROUTE, CONTROLLER, template</li>
<li><code>services</code> - SERVICE</li>
<li><code>transforms</code> - TRANSFORM</li>
<li><code>utils</code> - UTIL</li>
</ul>
<blockquote>
<p>Note: ALL CAPS indicates which collections are definitive (rule 3) for a type.</p>
</blockquote>
<p>The following default types are proposed for collections (rule 4):</p>
<ul>
<li><code>components</code> - component</li>
<li><code>initializer</code> - initializer</li>
<li><code>instance-initializers</code> - instance-initializer</li>
<li><code>models</code> - model</li>
<li><code>partials</code> - partial</li>
<li><code>routes</code> - route</li>
<li><code>services</code> - service</li>
<li><code>transforms</code> - transform</li>
<li><code>utils</code> - util</li>
</ul>
<p>The following private collections are allowed within collections (rule 5):</p>
<ul>
<li><code>components</code> - utils</li>
<li><code>models</code> - utils</li>
<li><code>initializers</code> - utils</li>
<li><code>instance-initializers</code> - utils</li>
<li><code>routes</code> - components, utils</li>
<li><code>services</code> - utils</li>
<li><code>transforms</code> - utils</li>
</ul>
<p>The following groups are proposed for collections (rule 6):</p>
<ul>
<li><code>data</code> - models, transforms</li>
<li><code>init</code> - initializers, instance-initializers</li>
<li><code>ui</code> - components, partials, routes</li>
</ul>
<p>The collection and type system is designed to be extensible, so that addons can
contribute their own collections and types. The <code>data</code> collection and its
corresponding types should be defined in ember-data. Liquid-fire might want to
define an <code>animations</code> collection and a <code>transition</code> type, and expand <code>routes</code>
to allow <code>animations</code> as a private collection.</p>
<p>The specific format of collection and type declarations for addons is TBD.</p>
<h4 id="components-collection"><a class="header" href="#components-collection">&quot;Components&quot; Collection</a></h4>
<p>This proposal broadens the scope of the term &quot;component&quot; to include all
template-invocable parts of Ember. This includes today's components and helpers,
and the future implementation of &quot;glimmer components&quot; (with angle brackets) and
element modifiers.</p>
<p>Grouping template-invocable elements together in a single collection recognizes
that they already coexist in the same namespace. After all, only one helper OR
component can be invoked as <code>{{foo-bar}}</code>. Using a common collection will not
only simplify file management and searching, it will also provide implicit
linting against creating a helper and class-based component of the same name.</p>
<h4 id="private-collections"><a class="header" href="#private-collections">Private Collections</a></h4>
<p>You may wish to make a component available in a particular template without
polluting the top-level <code>components</code> collection with a more local concern.
Private collections allow you to augment a top-level collection's contents for
use at a particular namespace.</p>
<p>Private collections are declared as a directory sharing the name of the
top-level collection, prefixed with a <code>-</code>. So the top-level <code>routes</code>
collection could be augmented via a private <code>-components</code> collection.</p>
<p>Say that you want to define a <code>post-viewer</code> component to be available only from
within <code>src/ui/routes/posts/post/template.hbs</code>. You could achieve this by
creating your component module in
<code>src/ui/routes/posts/post/-components/post-viewer.js</code>.</p>
<h4 id="non-resolved-files"><a class="header" href="#non-resolved-files">Non-resolved Files</a></h4>
<p>The rules above apply to modules that are resolved, namely <code>*.js</code> and <code>*.hbs</code>
files. Other files that are used for documenting code, such as <code>*.md</code> and
<code>*.html</code> files, can be freely co-located in any directories.</p>
<p>Conventions will still be used for non-resolved files that have significance
within an Ember project, including:</p>
<ul>
<li><code>src/ui/styles</code> - A project's stylesheets.</li>
<li><code>src/ui/index.html</code> - A project's html container.</li>
</ul>
<h3 id="packages"><a class="header" href="#packages">Packages</a></h3>
<p>In-repo addons (including engines) will be placed in a new top-level <code>packages</code>
directory (a sibling of <code>src</code>). We can begin to use the term &quot;packages&quot; instead
of the rather clumsy &quot;in-repo addons&quot;. This differentiation will emphasize that
packages are internal and addons are external to a project. Packages should be
seen as a lightweight way to add new namespacing within a project without the
overhead of a full addon.</p>
<p>The <code>packages</code> directory will provide a separate space away from other library
modules that might be kept in <code>lib</code>, the current directory used for in-repo
addons. Introducing a new top-level directory will allow a clear migration path
for in-repo addons, in the same way that there's a clear migration path from
<code>app</code> to <code>src</code>.</p>
<p>Inside <code>packages</code>, packages should be grouped by name. Each package can have
its own <code>index.js</code>, <code>package.json</code>, and <code>src</code> directory.</p>
<h2 id="ember-resolver-refactor"><a class="header" href="#ember-resolver-refactor">Ember Resolver Refactor</a></h2>
<p>The Ember resolver must be refactored significantly to be made aware of the
new <code>src</code> and <code>packages</code> directories and associated conventions.</p>
<h3 id="module-normalization"><a class="header" href="#module-normalization">Module Normalization</a></h3>
<p>As discussed above, Ember CLI will perform a normalization process for all the
modules in a project and its associated projects. The normalization step will
involve the construction of a map from each module's normalized form to its
corresponding ES module path. If any conflicts are detected, the process should
error and notify the developer.</p>
<p>The Ember resolver will only look up modules in their normalized form, utilizing
the pre-built normalization map to resolve the actual module path.</p>
<h3 id="addon-modules"><a class="header" href="#addon-modules">Addon modules</a></h3>
<p>A resolver will only implicitly consider an addon's top-level modules named
<code>main</code> (e.g. a <code>main</code> component) to be public and available for resolution. More
explicit control over an addon's public modules can be declared in the addon's
<code>main</code> module (details TBD). An addon's public modules will all be resolvable at
the <code>rootName</code> of the addon (see above).</p>
<p>Public components and helpers can be invoked in templates using the <code>rootName</code>
as a namespace. For modules named <code>main</code>, the bare root name will suffice.</p>
<p>Let's say that the <code>ember-power-select</code> addon has a <code>rootName</code> of <code>power-select</code>
and a top-level <code>main</code> component declared in <code>src/ui/components/main.js</code>. An
app could invoke this component in a template as <code>{{power-select::main}}</code> or
more simply as <code>{{power-select}}</code>.</p>
<p>Addons should use the same namespacing that will be used by consuming apps when
invoking their own components and helpers from templates. For instance, if the
<code>ember-power-select</code> addon has a <code>date-picker</code> component that invokes multiple
<code>main</code> components, it should also invoke them in a template as
<code>{{power-select::main}}</code> or more simply as <code>{{power-select}}</code>.</p>
<h3 id="module-resolutions"><a class="header" href="#module-resolutions">Module Resolutions</a></h3>
<p>Module resolution rules must account for the following:</p>
<ul>
<li>The requested module's <code>type</code>, <code>name</code>, and (potentially) <code>namespace</code>.</li>
<li>(Optional) A &quot;source&quot; <code>rootName</code>, collection, and namespace from which the
lookup originates.</li>
<li>(Optional) An &quot;associated type&quot; for lookups that should start in a collection
that is not definitive for the requested <code>type</code>.</li>
</ul>
<p>Module resolutions occur in the following order:</p>
<ol>
<li>Local - If a source module is specified and the requested type is allowed in
the source module's collection, look in a namespace based on the source
module's namespace + name.</li>
<li>Private - If a source module is specified, look in a private collection at
the source module's namespace, if one exists that is definitive for the
requested type.</li>
<li>Associated - If an associated type is specified, look in the definitive
collection for that associated type. Only resolve if the collection can
contain the requested type.</li>
<li>Top-level - In the definitive collection for the requested type, defined at
its top-level.</li>
</ol>
<p>The resolver must maintain mappings of modules at multiple levels to make these
resolutions efficient. A lookup tree can be pre-built for production builds.</p>
<h4 id="example-resolutions"><a class="header" href="#example-resolutions">Example Resolutions</a></h4>
<p>Let's walk through some example resolutions from the above blogging app paired
with the <code>ember-power-select</code> addon. We'll assume that the package name for
the app is <code>blogmeister</code>, and the package name for the addon is
<code>ember-power-select</code>. The addon has a <code>rootName</code> of <code>power-select</code> for cleaner
references.</p>
<hr />
<p>From <code>blogmeister/src/ui/components/list-paginator/template</code>:</p>
<p><code>{{paginator-control}}</code> resolves to <code>blogmeister/src/ui/components/list-paginator/paginator-control/component</code></p>
<p><code>{{date-picker}}</code> resolves to <code>blogmeister/src/ui/components/date-picker/component</code></p>
<p><code>{{power-select}}</code> resolves to <code>ember-power-select/src/ui/components/main/component</code></p>
<p><code>{{power-select::multiple}}</code> resolves to <code>ember-power-select/src/ui/components/multiple/component</code></p>
<hr />
<p>From <code>blogmeister/src/routes/posts/post/template</code>:</p>
<p><code>{{post-viewer}}</code> resolves to <code>blogmeister/src/ui/routes/posts/post/-components/post-viewer/component</code></p>
<p><code>{{date-picker}}</code> resolves to <code>blogmeister/src/ui/components/date-picker/component</code></p>
<p><code>{{power-select}}</code> resolves to <code>ember-power-select/src/ui/components/main/component</code></p>
<h2 id="other-refactorings"><a class="header" href="#other-refactorings">Other Refactorings</a></h2>
<h3 id="generators-and-blueprints"><a class="header" href="#generators-and-blueprints">Generators and Blueprints</a></h3>
<p>Generators and blueprints will need to be made aware of the new module
conventions.</p>
<p>Let's take a look at the files that some generators will create (note: tests
have been left out of these examples for now):</p>
<p><code>ember g component date-picker</code>:</p>
<ul>
<li><code>src/ui/components/date-picker/component.js</code></li>
<li><code>src/ui/components/date-picker/template.hbs</code></li>
</ul>
<p><code>ember g component ui/routes/posts/post-editor</code>:</p>
<ul>
<li><code>src/ui/routes/posts/-components/post-editor/component.js</code></li>
<li><code>src/ui/routes/posts/-components/post-editor/template.hbs</code></li>
</ul>
<p><code>ember g helper titleize</code>:</p>
<ul>
<li><code>src/ui/components/titleize.js</code></li>
</ul>
<h1 id="how-we-teach-this-17"><a class="header" href="#how-we-teach-this-17">How We Teach This</a></h1>
<p>The Ember guides will need to be updated significantly to reflect the new
conventions.</p>
<h2 id="teaching-conventions-through-tooling"><a class="header" href="#teaching-conventions-through-tooling">Teaching Conventions through Tooling</a></h2>
<p>As discussed above, generators and blueprints will be made aware of the new
module conventions. This will help new projects start on track and stay on
track as modules are added.</p>
<p>Developers with existing projects will be able to use Robert Jackson's
<a href="https://github.com/rwjblue/ember-module-migrator">migration tool</a> to move their
projects over to use the new conventions. This tool is a WIP and will continue
to be refined to work well with both the classic and pods structures. It's
possible these migration capabilities will eventually be rolled into Ember
Watson.</p>
<p>Furthermore, the Ember Inspector should be enhanced to understand the new
conventions and become more type and collection aware.</p>
<h2 id="new-concepts"><a class="header" href="#new-concepts">New Concepts</a></h2>
<p>It will be important for both new and experienced Ember developers to
understand some core concepts that are proposed in this RFC.</p>
<h3 id="collections-and-types"><a class="header" href="#collections-and-types">Collections and Types</a></h3>
<p>This proposal's concept of collections and types should feel familiar enough to
users of both the classic and pods layouts to enable a smooth transition. In
many ways, this proposal merges the classic and pods layouts into a single
uniform layout.</p>
<p>The core driver to collections is to store &quot;like with like&quot;. However, instead of
the classic layout's narrow definition of &quot;like&quot; to be of a <em>single</em> type, this
proposal takes the pods approach that <em>multiple</em> types can be related. A good
test of whether multiple module types should be stored together is whether they
should be considered to share a common namespace. Routes, controllers, and
templates are a good example, as are models, adapters, and serializers.</p>
<p>A related concept to understand about collections is the notion of a default
type. Every top-level module within a collection can be considered to match its
default type (unless named exports are used in those modules to represent types
other than the default). Within a collection's namespaces, every module must be
either that default type or related to it. It's helpful to consider that every
namespace within a collection represents a set of named module exports, and that
the default type represents the default export for that collection.</p>
<p>Here's an illustration of exports from a collection:</p>
<pre><code>src
  data
    models
      author.js &lt;- exports an Author `model`, the default type in the `models` collection
      comment
        adapter.js     &lt;- exports a Comment `adapter`
        model.js       &lt;- exports a Comment `model`
        serializer.js  &lt;- exports a Comment `serializer`
</code></pre>
<h4 id="components"><a class="header" href="#components">Components</a></h4>
<p>The term &quot;component&quot; has been widely adopted across most front-end frameworks
to describe a broad swath of UI concerns. Using the same term for the collection
of template-invocable UI elements will lower the learning curve for developers
who are new to Ember, while allowing for a useful set of specialized terms to
flourish to describe particular <em>types</em> of components.</p>
<p>We've already started down the road of component specialization by introducing
the concept of &quot;routable components&quot;. Once we start actually using &quot;routable
components&quot; in practice, it will become necessary to refer to plain old
components as something more specific, like &quot;template components&quot;. And this
distinction will probably lead to plain old helpers being referred to as
&quot;template helpers&quot;. Other concepts, such as &quot;Glimmer components&quot; and &quot;template
component modifiers&quot; will soon be mixed in. We will end up with a multi-faceted
toolbox available at the template layer which deserves a simple name that
matches developer expectations. The general term &quot;components&quot; seems a good fit.</p>
<h3 id="scope-1"><a class="header" href="#scope-1">Scope</a></h3>
<p>Developers should understand the available levels of module scope, as well as
when each is appropriate to use. Scope should be considered when modules are
generated, and developers should feel free to move modules if they expand or
contract in scope.</p>
<p>The following levels of scope should be understood:</p>
<ul>
<li>
<p>Private - private collections should be used when a component or utility
function is needed from a single namespace.</p>
</li>
<li>
<p>Project - top-level, project-wide collections should be used for modules that
are needed throughout a project.</p>
</li>
<li>
<p>Local package - namespaced collections can be useful to group a common set of
cross-cutting concerns within a project.</p>
</li>
<li>
<p>Local engine - a type of local package that encapsulates a set of
functionality that benefits from run-time isolation and strict dependency
sharing.</p>
</li>
</ul>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>Unit, integration, and some acceptance tests can now be co-located with their
associated modules. Co-location should be encouraged because it makes test
modules easier to locate in the file system, and easier to move if a module's
scope changes.</p>
<p>Robert Jackson plans to adapt the
<a href="https://github.com/emberjs/rfcs/pull/119">Grand Testing Unification RFC</a>
to illustrate test co-location and to introduce module types for tests.</p>
<h1 id="drawbacks-41"><a class="header" href="#drawbacks-41">Drawbacks</a></h1>
<p>Any change to a pattern as fundamental as file naming will incur some mental
friction for developers who are accustomed to the current conventions. It is
hoped that tooling like Robert's migrator and Ember Watson can lessen this
friction by automating transitions, and that updated guides, generators, and
blueprints can make these conventions easy to follow.</p>
<p>Of course, we won't prevent usage of the currently used patterns for some time,
but they will eventually be deprecated. Some efficiencies, especially in the
resolver, may not be fully realized until the new patterns are used throughout
a project.</p>
<h1 id="alternatives-42"><a class="header" href="#alternatives-42">Alternatives</a></h1>
<h2 id="the-module-normalization-rfc"><a class="header" href="#the-module-normalization-rfc">The Module Normalization RFC</a></h2>
<p>Perhaps the most prominent alternative that has been explored is the
<a href="https://github.com/emberjs/rfcs/pull/124">Module Normalization RFC</a>. Module
Unification shares many aspects with Module Normalization, but with one
fundamental difference: buckets in Module Normalization are normalized away
for the resolver, while collections in Module Unification play an important
role in module resolution.</p>
<p>The Ember Core Team decided that the sleight of hand required to allow buckets
to be used for organization only, and not for resolution, could create
confusion. Essentially, modules could conflict across buckets, because they
could have matching namespaces, names, and types. This kind of conflict could
not be allowed, so developers would need to understand too much about the
resolution strategy to make it ergonomic.</p>
<h2 id="other-alternatives"><a class="header" href="#other-alternatives">Other Alternatives</a></h2>
<p><a href="https://gist.github.com/dgeb/396fed953184acb04f4f">A large number of other alternatives have been explored</a>
before settling on this recommendation. Feel free to explore the history of any
of the linked gists to understand some of the subtle alternatives.</p>
<p>Of course, one alternative is to simply not change anything and accept the
drawbacks discussed in the Motivation section above. However, even if we accept
inefficiencies in our resolver and confusion over divergent file structuring
strategies, we still need to solve the &quot;local lookup&quot; problem, which does not
have a clean solution in today's module system.</p>
<h1 id="unresolved-questions-36"><a class="header" href="#unresolved-questions-36">Unresolved questions</a></h1>
<h2 id="how-should-tests-be-co-located-in-src"><a class="header" href="#how-should-tests-be-co-located-in-src">How should tests be co-located in <code>src</code>?</a></h2>
<p>Should tests be allowed within <code>src</code> via <code>*-test</code> types (e.g.
<code>component-integration-test</code>, <code>component-unit-test</code>, etc.) within respective
collections?</p>
<p>If this RFC is approved, then Robert Jackson plans to adapt the
<a href="https://github.com/emberjs/rfcs/pull/119">Grand Testing Unification RFC</a> to
propose answers to these questions.</p>
<h2 id="what-about-routable-components"><a class="header" href="#what-about-routable-components">What about routable components?</a></h2>
<p>Should routable components have a type that's unique from other components?</p>
<p>Should they exist alongside <code>route</code> and <code>template</code> types in the <code>routes</code>
collection?</p>
<p>It seems plausible that routable components could simply use the <code>component</code>
type, and that we could lint against allowing template-invocable components
alongside routes.</p>
<h2 id="how-should-configuration-declarations-be-made-in-the-main-module"><a class="header" href="#how-should-configuration-declarations-be-made-in-the-main-module">How should configuration declarations be made in the <code>main</code> module?</a></h2>
<p>For example:</p>
<ul>
<li>How should resolvable exports be declared from addons?</li>
<li>Can apps override the root names of addons? For example, if
<code>ember-power-select</code> has a root name of <code>power-select</code>, could a consuming app
override this?</li>
<li>How do addons and apps declare their collection and type exports? For example,
how could liquid-fire allow for a <code>transition</code> type and an <code>animations</code>
collection?</li>
</ul>
<h2 id="should-we-allow-collection-groups"><a class="header" href="#should-we-allow-collection-groups">Should we allow collection groups?</a></h2>
<p>Do the organizational benefits of collection groups outweigh the potential
confusion over where lines are drawn between a group/collection/namespace
when viewing a project structure.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-06-11
RFC PR: https://github.com/emberjs/rfcs/pull/150
Ember Issue: https://github.com/emberjs/ember.js/pull/14360</p>
<hr />
<h1 id="summary-43"><a class="header" href="#summary-43">Summary</a></h1>
<p>With the goal of making significant performance improvements and of adding
public API to support use cases long-served by a private API, a new API of
<code>factoryFor</code> will be added to <code>ApplicationInstance</code> instances.</p>
<h1 id="motivation-44"><a class="header" href="#motivation-44">Motivation</a></h1>
<p>Ember's dependency injection container has long supported fetching a factory
that will be created with any injections present. Using the private API that
provided this support allows an instance of the factory to be created
with initial values passed via <code>create</code>. For example:</p>
<pre><code class="language-js">// app/logger/main.js
import Ember from 'ember';

export default Ember.Logger.extend({
  someService: Ember.inject.service()
});
</code></pre>
<pre><code class="language-js">import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let Factory = getOwner(this)._lookupFactory('logger:main');
    this.logger = Factory.create({ level: 'low' });
  }
});
</code></pre>
<p>In this API, the <code>Factory</code> is actually a subclass the original main logger
class. When <code>_lookupFactory</code> is called, an additional <code>extend</code> takes place
to add any injections (such as <code>someService</code> above). The class/object setup
looks like this:</p>
<ul>
<li>In the module: <code>MyClass = Ember.Object.extend(</code></li>
<li>In <code>_lookupFactory</code>: <code>MyFactoryWithInjections = MyClass.extend(</code></li>
<li>And when used: <code>MyFactoryWithInjections.create(</code></li>
</ul>
<p>The second call to <code>extend</code> implements Ember's owner/DI
framework and permits <code>someService</code> to be resolved later. The &quot;owner&quot; object
is merged into the new <code>MyFactoryWithInjections</code> class along with any
registered injections.</p>
<p>This &quot;double extend&quot; (once at define time, once at <code>_lookupFactory</code> time)
takes a toll on performance booting an app. This design flaw has motivated
a desire to keep <code>_lookupFactory</code> private.</p>
<p>The <code>MyFactoryWithInjections</code> class also features as a cache. Because it is
attached to the owner/container, it is cleared between test runs or
application instances. To illustrate, this flow-chart shows how
<code>MyFactoryWithInjections</code> diverges between tests:</p>
<pre><code>               +-------------------------------+
               |                               |
               |      /app/models/foo.js       |
               |                               |
               +-------------------------------+
                               |
              first test run   |    nth test run
              +----------------+---------------+
              |                                |
              v                                v
   +---------------------+          +--------------------+
   |resolve('model:foo') |   ===    |resolve('model:foo')|
   +---------------------+          +--------------------+
              |                                |
              |                                |
              v                                v

     extend(injections)               extend(injections)

              |                                |
              |                                |
              |                                |
              v                                v
+--------------------------+     +---------------------------+
|lookupFactory('model:foo')| !== |lookupFactory('model:foo') |
+--------------------------+     +---------------------------+
</code></pre>
<p>Despite the design flaws in this API, it does fill a meaningful role in
Ember's DI solution. Use of the private API is common. Some examples:</p>
<ul>
<li><a href="https://github.com/DockYard/ember-cart">ember-cart</a> uses the functionality to create model objects without
tying them to the store <a href="https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/controllers/application.js#L16">example a</a>,
<a href="https://github.com/DockYard/ember-cart/blob/c01eb22eaf2e97f8c80481c3174d4be917e476a9/tests/dummy/app/models/dog.js#L11">example b</a></li>
<li>Ember-Data's <a href="https://github.com/emberjs/data/blob/54ea432b1cbb0d1231d9a0454b09d3b3a0bc2533/addon/-private/system/store.js#L1868"><code>modelFactoryFor</code></a></li>
</ul>
<p>The goal of this RFC is to create a public API for fetching factories with
better performance characteristics than <code>_lookupFactory</code>.</p>
<h1 id="detailed-design-43"><a class="header" href="#detailed-design-43">Detailed design</a></h1>
<p>Throughout this document I reference Ember 2.12 as it is the next LTS at writing. This
proposal may ship for 2.12-LTS or be bumped to the next LTS.</p>
<p>This feature will be added in these steps.</p>
<ol>
<li>In Ember introduce a <code>ApplicationInstance#factoryFor</code> based on
<code>_lookupFactory</code>. It should be documented that certain behaviors
inherent to &quot;double extend&quot; are not supported. In development builds
and supporting browsers, wrap return values in a Proxy. The proxy should
throw an error when any property besides <code>create</code> or <code>class</code> is accessed.
<code>class</code> must return the registered factory, not the double extended factory.</li>
<li>In the same release add a deprecation message to usage of <code>_lookupFactory</code>.
As this API is intimate it must be maintained through at least one LTS
release (2.12 at this writing).</li>
<li>In 2.13 drop <code>_lookupFactory</code> and migrate the <code>factoryFor</code> implementation to avoid
&quot;double-extend&quot; entirely.</li>
</ol>
<p>Additionally, a polyfill will be released for this feature supporting prior
versions of Ember.</p>
<h4 id="design-of-applicationinstancefactoryfor"><a class="header" href="#design-of-applicationinstancefactoryfor">Design of <code>ApplicationInstance#factoryFor</code></a></h4>
<p>A new API will be introduced. This API will return both the original base
class registered into or resolved by the container, and will also return a function
to generate a dependency-injected instance. For example:</p>
<pre><code class="language-js">import Ember from 'ember';
const { Component, getOwner } = Ember;

export default Component.extend(
  init() {
    this._super(...arguments);
    let factory = getOwner(this).factoryFor('logger:main');
    this.logger = factory.create({ level: 'low' });
  }
});
</code></pre>
<p>Unlike <code>_lookupFactory</code>, <code>factoryFor</code> will not return an extended class with
DI applied. Instead it will return a factory object with two properties:</p>
<pre><code class="language-js">// factoryFor returns:
let {

  // a function taking an argument of initial properties passed to the object
  // and returning an instance
  create,

  // The class registered into (or resolved by) the container
  class

} = owner.factoryFor('type:name');
</code></pre>
<p>This API should meet two requirements of the use-cases described in
&quot;Motivation&quot;:</p>
<ul>
<li>Because <code>factoryFor</code> only returns a <code>create</code> method and reference to the
original class, its internal implementation can diverge away from the
&quot;double extend&quot;. A side-effect of this is that the
class of an object instantiated via <code>_lookupFactory(name).create()</code>
and <code>factoryFor(name).create()</code> may not be the same, given the
same original factory.</li>
<li>The presence of <code>class</code> will make it easy to identify the base class of the
factory at runtime.</li>
</ul>
<p>For example today's <code>_lookupFactory</code> creates an inheritance structure like
the following:</p>
<pre><code>                    Current:
       +-------------------------------+
       |                               |
       |      /app/models/foo.js       |
       |                               |
       +-------------------------------+
                       |
                       |
                       |
                       v
            +--------------------+
            |  Class[model/Foo]  |
            +--------------------+
                       |
                       |
                       |
       first test run  |   nth test run
           +-----------+----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     subclass of    | |     subclass of    |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
</code></pre>
<p>Between test runs 2 instances of <code>model:foo</code> will have a common
shared ancestor the grandparent <code>Class[model/Foo]</code>.</p>
<p>This implementation of <code>factoryFor</code> proposes to remove the intermediate
subclass and instead have a generic
factory object which holds the injections and allows for injected instances
to be created. The resulting object graph would look something like this:</p>
<pre><code>                  Proposed:
      +-------------------------------+
      |                               |
      |      /app/models/foo.js       |
      |                               |
      +-------------------------------+
                      |
                      |
                      |
                      v
           +--------------------+
           |  Class[model/Foo]  |
           +--------------------+
                      |
                      |
                      |
      first test run  |   nth test run
           +----------+-----------+
           |                      |
           |                      |
           |                      |
           v                      v
+--------------------+ +--------------------+
|     Factory of     | |     Factory of     |
|  Class[model/Foo]  | |  Class[model/Foo]  |
+--------------------+ +--------------------+
</code></pre>
<p>With <code>factoryFor</code> instances of <code>model:foo</code> will share a common constructor.
Any state stored on the constructor would of course leak between the tests.</p>
<p>An example implementation of <code>factoryFor</code> can be reviewed <a href="https://github.com/emberjs/rfcs/issues/125#issuecomment-193827658">on this GitHub
comment</a>.</p>
<h5 id="implications-for-ownerregister"><a class="header" href="#implications-for-ownerregister">Implications for <code>owner.register</code></a></h5>
<p>Currently, factories registered into Ember's DI system are required to
provide an <code>extend</code> method. Removing support for extend-based DI in <code>_lookupFactory</code>
will permit factories without <code>extend</code> to be registered. Instead factories
must only provide a <code>create</code> method. For example:</p>
<pre><code class="language-js">let factory = {
  create(options={}) {
    /* Some implementation of `create` */
    return Object.create({});
  }
};
owner.register('my-type:a-factory', factory);
let factoryWithDI = owner.factoryFor('my-type:a-factory');

factoryWithDI.class === factory;
</code></pre>
<h5 id="development-mode-proxy"><a class="header" href="#development-mode-proxy">Development-mode Proxy</a></h5>
<p>Because many developers will simply re-write <code>_lookupFactory</code> to <code>factoryFor</code>,
it is important to provide some aid and ensure they actually complete the
migration completely (they they avoid setting state on the factory). A proxy
wrapping the return value of <code>factoryFor</code> and raising assertions when any
property besides <code>create</code> or <code>class</code> is accessed will be added in development.</p>
<p>Additionally, using <code>instanceof</code> on the result of <code>factoryFor</code> should be
disallowed, causing an exception to be raised.</p>
<p>A good rule of thumb is that, in development, using anything besides <code>class</code> or
<code>create</code> on the return value of <code>factoryFor</code> should fail with a helpful message.</p>
<h5 id="releasing-a-polyfill"><a class="header" href="#releasing-a-polyfill">Releasing a polyfill</a></h5>
<p>A polyfill addon, similar to <a href="https://github.com/rwjblue/ember-getowner-polyfill">ember-getowner-polyfill</a>
will be released for this feature. This polyfill will provide the <code>factoryFor</code>
API going back to at least 2.8, provide the API and silence the deprecation
in versions before <code>factoryFor</code> is available, and be a no-op in versions where
<code>factoryFor</code> is available.</p>
<h1 id="how-we-teach-this-18"><a class="header" href="#how-we-teach-this-18">How We Teach This</a></h1>
<p>This feature should be introduced along side <code>lookup</code> in the
<a href="https://guides.emberjs.com/v2.6.0/applications/dependency-injection/">relevant guide</a>.
The return value of <code>factoryFor</code> should be taught as a POJO and not as
an extended class.</p>
<h4 id="example-deprecation-guide-migrating-from-_lookupfactory-to-factoryfor"><a class="header" href="#example-deprecation-guide-migrating-from-_lookupfactory-to-factoryfor">Example deprecation guide: Migrating from <code>_lookupFactory</code> to <code>factoryFor</code></a></h4>
<p>Ember owner objects have long provided an intimate API used to
fetch a factory with dependency injections. This API, <code>_lookupFactory</code>, is deprecated
in Ember 2.12 and will be removed in Ember 2.13. To ease the transition to this
new public API, a polyfill is provided with support back to at least Ember 2.8.</p>
<p><code>_lookupFactory</code> returned the class of resolved factory extended with
a mixin containing its injections. For example:</p>
<pre><code class="language-js">let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner._lookupFactory('my-type:a-name');
klass.constructor.superclass === factory; // true
let instance = klass.create();
</code></pre>
<p><code>factoryFor</code> instead returns an object with two properties: <code>create</code> and <code>class</code>.
For example:</p>
<pre><code class="language-js">let factory = Ember.Object.extend();
owner.register('my-type:a-name', factory);
let klass = owner.factoryFor('my-type:a-name');
klass.class === factory; // true
let instance = klass.create();
</code></pre>
<p>A common use-case for <code>_lookupFactory</code> was to fetch an factory with
specific needs in mind:</p>
<ul>
<li>The factory needs to be created with initial values (which cannot be
provided at create-time via <code>lookup</code>.</li>
<li>The instances of that factory need access to Ember's DI framework (injections,
registered dependencies).</li>
</ul>
<p>For example:</p>
<pre><code class="language-js">// app/widgets/slow.js
import Ember from 'ember';

export default Ember.Object.extend({
  // this instance requires access to Ember's DI framework
  store: Ember.inject.service(),

  convertToModel() {
    this.get('store').createRecord('widget', {
      widgetType: 'slow',
      name, canWobble
    });
  }

});
</code></pre>
<pre><code class="language-js">// app/services/widget-manager.js
import Ember from 'ember';

export default Ember.Service.extend({

  init() {
    this.set('widgets', []);
  },

  /*
   * Create a widget of a type, and add it to the widgets array.
   */
  addWidget(type, name, canWobble) {
    let owner = Ember.getOwner(this);
    // Use `_lookupFactory` so the `store` is accessible on instances.
    let WidgetFactory = owner._lookupFactory(`widget:${type}`);
    let widget = WidgetFactory.create({name, canWobble});
    this.get('widgets').pushObject(widget);
    return widget;
  }

});
</code></pre>
<p>For these common cases where only <code>create</code> is called on the factory, migration
to <code>factoryFor</code> is mechanical. Change <code>_lookupFactory</code> to <code>factoryFor</code> in the
above examples, and the migration would be complete.</p>
<h5 id="migration-of-static-method-calls"><a class="header" href="#migration-of-static-method-calls">Migration of static method calls</a></h5>
<p>Factories may have had static methods or properties that were being accessed
after resolving a factory with <code>_lookupFactory</code>. For example:</p>
<pre><code class="language-js">// app/widgets/slow.js
import Ember from 'ember';

const SlowWidget = Ember.Object.extend();
SlowWidget.reopenClass({
  SPEEDS: [
    'slow',
    'verySlow'
  ],
  hasSpeed(speed) {
    return this.SPEEDS.contains(speed);
  }
});

export default SlowWidget;
</code></pre>
<pre><code class="language-js">let factory = owner._lookupFactory('widget:slow');
factory.SPEEDS.length; // 2
factory.hasSpeed('slow'); // true
</code></pre>
<p>With <code>factoryFor</code>, access to these methods or properties should be done via
the <code>class</code> property:</p>
<pre><code class="language-js">let factory = owner.factoryFor('widget:slow');
let klass = factory.class;
klass.SPEEDS.length; // 2
klass.hasSpeed('slow'); // true
</code></pre>
<h1 id="drawbacks-42"><a class="header" href="#drawbacks-42">Drawbacks</a></h1>
<p>The main drawback to this solution is the removal of double extend. Double
extend is a performance troll, however it also means if a single class is registered
multiple times each <code>_lookupFactory</code> returns a unique factory. It is plausible
that some use-case relying on this behavior would get trolled in the migration
to <code>factoryFor</code>, however it is unlikely.</p>
<p>For example these cases where state is stored on the factory would no
longer be scope to one instance of the owner (like one test). Instead, setting
a value on the class would set it on the registered class.</p>
<p>Some real-world examples of setting state on the factory class:</p>
<ul>
<li>ember-model
<ul>
<li>https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L404 and https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L457
with <code>factoryFor</code> will increment a shared counter across application and
container instances.</li>
<li>https://github.com/ebryn/ember-model/blob/master/packages/ember-model/lib/model.js#L723-L725
would also set properties on the base <code>Ember.Model</code> factory instead of
an extension of that class.</li>
</ul>
</li>
<li>ember-data
<ul>
<li>If attrs change between test runs (seems very unlikely) then https://github.com/emberjs/data/blob/387630db5e7daec6aac7ef8c6172358a3bd6394c/addon/-private/system/model/attr.js#L57
would be affected. The CP of <code>attributes</code> will have a value cached on the
factory, and where with <code>_lookupFactory</code>'s double-extend the cache would be
on the extended class, in <code>factoryFor</code> that CP cache will be on the
class registered as a factory.</li>
</ul>
</li>
<li>Any other of the following:
<ul>
<li><code>lookupFactory(x).reopen</code> / <code>reopenClass</code> at runtime (or test time to monkey patch code)</li>
<li><code>lookupFactory(x).something = value</code></li>
</ul>
</li>
</ul>
<h1 id="alternatives-43"><a class="header" href="#alternatives-43">Alternatives</a></h1>
<p>More aggressive timelines have been considered for this change.</p>
<p>However we have considered the possibility that removing <code>_lookupFactory</code> in 2.13
(something LTS technically permits) would be too aggressive for the
community of addons. Providing a polyfill is part of the strategy to handle
this change.</p>
<h1 id="unresolved-questions-37"><a class="header" href="#unresolved-questions-37">Unresolved questions</a></h1>
<p>Are there any use-cases for the double extend not considered?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-11-05
RFC PR: https://github.com/emberjs/rfcs/pull/176</p>
<hr />
<h1 id="summary-44"><a class="header" href="#summary-44">Summary</a></h1>
<p>Make Ember feel less overwhelming to new users, and make Ember applications
start faster, by replacing the <code>Ember</code> global with a first-class system for
importing just the parts of the framework you need.</p>
<h1 id="motivation-45"><a class="header" href="#motivation-45">Motivation</a></h1>
<p>ECMAScript 2015 (also known as ES2015 or ES6) introduced a syntax for importing
and exporting values from modules. Ember aggressively adopted modules, and if
you've used Ember before, you're probably familiar with this syntax:</p>
<pre><code class="language-js">import Ember from &quot;ember&quot;;
import Analytics from &quot;../mixins/analytics&quot;;

export default Ember.Component.extend(Analytics, {
  // ...
});
</code></pre>
<p>One thing to notice is that the entire Ember framework is imported as a single
package. Rather than importing <code>Component</code> directly, for example, you import
<code>Ember</code> and subclass <code>Ember.Component</code>. (And this example still works even if
you forget the import, because we also create a global variable called
<code>Ember</code>.)</p>
<p>Using Ember via a monolithic package or global object is not ideal for several
reasons:</p>
<ul>
<li>It's overwhelming for learners. There's a giant list of classes and functions
with no hints about how they're related. The API documentation reflects this.</li>
<li>Experienced developers who don't want all of Ember's features feel like
they're adding unnecessary and inescapable bloat to their application.</li>
<li>The <code>Ember</code> object must be built at boot time, requiring that we ship the
entire framework to the browser. This has two major costs:
<ol>
<li>Increased download time, particularly noticeable on slower connections.</li>
<li>Increased parsing/evaluation cost, which still must be paid even when
assets are cached. On some browsers/devices, this can far exceed the cost of the
download itself.</li>
</ol>
</li>
</ul>
<p>Defining a public API for importing parts of Ember via JavaScript modules helps
us lay the groundwork for solving all of these problems.</p>
<h4 id="reducing-load-time"><a class="header" href="#reducing-load-time">Reducing Load Time</a></h4>
<p>Modules help us eliminate unneeded code. The module syntax is <em>statically
analyzable</em>, meaning that a tool like Ember CLI can analyze an application's
source code and reliably determine which files, in both the framework and the
application, are actually needed. Anything that's not needed is omitted from the
final build.</p>
<p>This allows us to provide the file size benefits of a &quot;small modules&quot; approach
to building web applications while retaining the productivity benefits of a
complete, opinionated framework.</p>
<p>For example, if your application never used the <code>Ember.computed.union</code> computed
property helper, Ember could detect this and remove its code when you build your
application. This technique for slimming down the payload automatically is often
referred to as <em>tree shaking</em> or <em>dead code elimination</em>.</p>
<p>Building the module graph doesn't just mean we get a list of files used by the application—
we also know which files are used <em>route-by-route</em>.</p>
<p>We can use this knowledge to optimize boot time even more, by prioritizing
sending only the JavaScript needed for the requested route, rather than the
entire application.</p>
<p>For example, if the user requests the URL
<code>https://app.example.com/articles/123</code>, the server could first send the code for
<code>ArticlesRoute</code>, the <code>Article</code> model, the <code>articles</code> template, and any
components and framework code used in the route. Only after the route is
rendered would we start to send the remainder of the application and framework
code in the background.</p>
<h4 id="guiding-learners"><a class="header" href="#guiding-learners">Guiding Learners</a></h4>
<p>We can group framework classes and utilities by functionality, making it clear
what things are related and how they should work together. People can feel
confident they are getting only what they need at that moment, not an entire
framework that they're not sure they're benefiting from.</p>
<h4 id="modernizing-ember"><a class="header" href="#modernizing-ember">Modernizing Ember</a></h4>
<p>Lastly, developers are growing increasingly accustomed to using JavaScript
modules to import libaries. If we don't adapt to modules, Ember will feel clunky
and antiquated compared to modern alternatives.</p>
<h3 id="prior-art"><a class="header" href="#prior-art">Prior Art</a></h3>
<p>Initial efforts to define a module API for Ember began with the
<a href="https://github.com/ember-cli/ember-cli-shims"><code>ember-cli-shims</code></a> addon. This addon provides a set of &quot;shim&quot; modules
that re-export a value off the global <code>Ember</code>. While this setup doesn't offer
the benefits of true modules, it did allow us to rapidly experiment with a
module API without making changes to Ember core.</p>
<p>Common feedback from shim users was that, while they were a net improvement,
they introduced too much verbosity and were hard for beginners to remember.</p>
<p>An oft-cited example of this verbosity is that implementing an object and using
<code>Ember.get</code> and <code>Ember.set</code> requires three different imports:</p>
<pre><code class="language-js">import EmberObject from &quot;ember-object&quot;;
import get from &quot;ember-metal/get&quot;;
import set from &quot;ember-metal/set&quot;;
</code></pre>
<p>In fact, one of the principles outlined in this RFC is designed to correct this
verbosity; namely, that <a href="0176-javascript-module-api.html#utility-functions-are-named-exports">utility functions and the class they are related to
should share a module</a>.</p>
<p>For those who have already adopted modules via the <code>ember-cli-shims</code> package, we
will provide a migration tool to rewrite shim modules into the final module API.
The static nature of the import syntax makes this even easier and more reliable
than migrating globals-based apps. The upgrade process should take no more than
a few minutes (see <a href="0176-javascript-module-api.html#migration">Migration</a>).</p>
<p>This RFC also builds significantly on <a href="https://github.com/zeppelin">@zeppelin's</a>
previous <a href="https://github.com/emberjs/rfcs/pull/68">ES6 modules RFC</a>, which drove
initial discussion, including the idea to use scoped packages.</p>
<h1 id="detailed-design-44"><a class="header" href="#detailed-design-44">Detailed Design</a></h1>
<h2 id="terminology-1"><a class="header" href="#terminology-1">Terminology</a></h2>
<ul>
<li><strong>Package</strong> - a bundle of JavaScript addressable by npm and other package
managers, it may contain many modules (but has a default module, usually
called <code>index.js</code>).</li>
<li><strong>Scoped Package</strong> - a namespaced package whose name starts with an <code>@</code>, like
<code>import Thing from &quot;@scope/thing&quot;</code>.</li>
<li><strong>Module</strong> - a JavaScript file with at least one default export or named
export.</li>
<li><strong>Top-Level Module</strong> - the module provided by importing a package directly,
like <code>import Component from &quot;@ember/component&quot;</code>.</li>
<li><strong>Nested Module</strong> - a module provided at a path <em>inside</em> a package, like
<code>import { addObserver } from &quot;@ember/object/observers&quot;</code>.</li>
</ul>
<h2 id="module-naming--organization"><a class="header" href="#module-naming--organization">Module Naming &amp; Organization</a></h2>
<p>Because our goal is to eliminate the <code>Ember</code> global object, any public classes,
functions or properties that currently exist on the global need an equivalent
module that can be imported.</p>
<p>Given how fundamental modules are to the development process, how we organize
and name them impacts new learners and seasoned veterans alike. Thus we must try
to find a balance between predictability for new and intermediate users, and
terseness for experienced developers with large apps.</p>
<p>There is another goal at play: we would like to help dispel the misconception
that Ember is a monolithic framework. Ideally, module names help us tell a story
about Ember's layered features. Rather than inheriting the entire framework at
once, you can pull in just the pieces you need.</p>
<p>For that reason, package names should assist the developer in understanding what
capabilities are added by bringing in that new package. We should pick
meaningful names, not let our public API be a by-product of how Ember's
internals are organized.</p>
<p>A full table of proposed mappings from global to module is available in
<a href="0176-javascript-module-api.html#addendum-1---table-of-module-names-and-exports-by-global">Addendum 1 - Table of Module Names and Exports by
Global</a> and <a href="0176-javascript-module-api.html#addendum-2---table-of-module-names-and-exports-by-package">Addendum
2 - Table of Module Names and Exports by
Package</a>. Because
there is some implicit functionality that you get when loading Ember that is not
encapsulated in a global property (for example, automatically adding prototype
extensions), there is also <a href="0176-javascript-module-api.html#addendum-3---table-of-modules-with-side-effects">Addendum 3 - Table of Modules with Side
Effects</a>.</p>
<p>Before diving in to these tables, however, it may be helpful to understand some
of the thinking that guided this proposal. And keep in mind, this RFC specifies
a <em>baseline</em> module API. Nothing here precludes adding additional models in the
future, as we discover missing pieces.</p>
<h3 id="use-scoped-packages"><a class="header" href="#use-scoped-packages">Use Scoped Packages</a></h3>
<p>Last year, <a href="http://blog.npmjs.org/post/116936804365/solving-npms-hard-problem-naming-packages">npm introduced support for scoped packages</a>. Scopes
are similar to organizations on GitHub. They allow us to use any package name,
even if it's already in use on npm, by namespacing it inside a scope.</p>
<p>For example, the <a href="https://www.npmjs.com/package/component"><code>component</code></a> package is already reserved by an
unmaintained tool; we couldn't use <code>component</code> as a package name even if we
wanted to.</p>
<p>However, scopes allow us to create a package named <code>component</code> that lives under
the <code>@ember</code> scope: <code>import Component from &quot;@ember/component&quot;</code>.</p>
<p>The advantages of using scoped packages, as this proposal does, are two-fold:</p>
<ol>
<li>&quot;Official&quot; packages are clearly differentiated from community packages.</li>
<li>There is no risk of naming conflicts with existing community packages.</li>
</ol>
<p>Note that actually publishing packages to npm may not be immediately necessary
to implement this RFC. We should still design around this constraint so that we
have the option available to us in the future. For more discussion, see the
<a href="0176-javascript-module-api.html#distribution">Distribution unresolved question</a>.</p>
<h3 id="prefer-common-terminology"><a class="header" href="#prefer-common-terminology">Prefer Common Terminology</a></h3>
<p>Module names should use terms people are more likely to be familiar with. For
example, instead of the ambiguous <code>platform</code>, polyfills should be in a module
called <code>polyfill</code>.</p>
<p>Similarly, the vast majority of advanced Ember developers couldn't crisply
articulate the difference between <code>ember-metal</code> and <code>ember-runtime</code>. Instead, we
should prefer <code>ember-object</code>, to match how people actually talk about these
features: the Ember object model.</p>
<h3 id="organize-by-mental-model"><a class="header" href="#organize-by-mental-model">Organize by Mental Model</a></h3>
<p>One of the biggest barriers to learning is the fact that short-term memory is
limited. To understand a complex system like a modern web application, the
learner must hold in their head many different concepts—more concepts than most
people can reason about at once.</p>
<p><a href="https://en.wikipedia.org/wiki/Chunking_(psychology)">Chunking</a> is a strategy for dealing with this. It means that you
present concepts that are conceptually related together. When the learner needs
to reason about the overall system, in their mind they can replace a group of
related concepts with a single, overarching concept.</p>
<p>For example, if you tell someone that in order to build an Ember app, they will
need to understand computed properties, actions (bubbling and closure),
components, containers, registries, routes, helpers (stateful and stateless),
dependent keys, controllers, route maps, observers, transitions, mixins,
computed property macros, injected properties, the run loop, and array
proxies—they will rightfully feel like Ember is an overwhelming, overcomplicated
framework. Most people (your RFC author included) simply cannot keep this many
discrete concepts in their head at once.</p>
<p>The day-to-day reality of building an Ember app, of course, is not nearly so
complex. For those developers who stick through the learning curve, they end up
with a greatly simplified mental model.</p>
<p>This proposal attempts to re-align module naming with that simplified mental
model, placing everything into packages based on the chunk of functionality they
provide:</p>
<ul>
<li><code>@ember/application</code> - Application-level concerns, like bootstrapping,
initializers, and dependency injection.</li>
<li><code>@ember/component</code> - Classes and utilities related to UI components.</li>
<li><code>@ember/routing</code> - Classes used for multi-page routing.</li>
<li><code>@ember/service</code> - Classes and utilities for cross-cutting services.</li>
<li><code>@ember/controller</code> - Classes and utilities related to controllers.</li>
<li><code>@ember/object</code> - Classes and utilities related to Ember's object model,
including <code>Ember.Object</code>, computed properties and observers.</li>
<li><code>@ember/runloop</code> - Methods for scheduling behavior on to the run loop.</li>
</ul>
<p>It includes a few other packages that, over time, your author hopes become
either unneeded or can be moved outside of core into standalone packages:</p>
<ul>
<li><code>@ember/array</code> - Array utilities and observation. Ideally these can be replaced
with a combination of ES2015+ features and array diffing in Glimmer.</li>
<li><code>@ember/enumerable</code> - Replaced by iterables in ES2015.</li>
<li><code>@ember/string</code> - String formatting utilities (dasherize, camelize, etc.).</li>
<li><code>@ember/map</code> - Replaced by <code>Map</code> and <code>WeakMap</code> in ES2015.</li>
<li><code>@ember/polyfills</code> - Polyfills for <code>Object.keys</code>, <code>Object.assign</code> and <code>Object.create</code>.</li>
<li><code>@ember/utils</code> - Grab bag of utilities that could likely be replaced with
something like lodash.</li>
</ul>
<p>And finally, some packages that may be used by internals, extensions, or addons
but are not used day-to-day by app developers:</p>
<ul>
<li><code>@ember/instrumentation</code> - Instrumentation hooks for measuring performance.</li>
<li><code>@ember/debug</code> - Utility functions for debugging, and hooks used by debugger tools like Ember Inspector.</li>
</ul>
<h3 id="classes-are-default-exports"><a class="header" href="#classes-are-default-exports">Classes are Default Exports</a></h3>
<p>Classes that the user is supposed to import and subclass are always the default
export, never a named export. In the case where a package has more than one primary class,
those classes live in a nested module.</p>
<p>This rule ensures there is no ambiguity about whether something is a named
export or a default export: classes are always default exports. In tandem with
the following rule (<a href="0176-javascript-module-api.html#utility-functions-are-named-exports">Utility Functions are Named
Exports</a>), this also means that classes
and the functions that act on them are grouped into the same <code>import</code> line.</p>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<p>Primary class only:</p>
<pre><code class="language-js">import EmberObject from &quot;@ember/object&quot;;
</code></pre>
<p>Primary class plus secondary classes:</p>
<pre><code class="language-js">import Component from &quot;@ember/component&quot;;
import Checkbox from &quot;@ember/component/checkbox&quot;;

import Map from &quot;@ember/map&quot;;
import MapWithDefault from &quot;@ember/map/with-default&quot;;
</code></pre>
<p>Multiple primary classes:</p>
<pre><code class="language-js">import Router from &quot;@ember/routing/router&quot;;
import Route from &quot;@ember/routing/route&quot;;
</code></pre>
<h3 id="utility-functions-are-named-exports"><a class="header" href="#utility-functions-are-named-exports">Utility Functions are Named Exports</a></h3>
<p>Functions that are only useful with a particular class, or are used most frequently with
that class, are named exports from the package that exports the class.</p>
<h4 id="examples-3"><a class="header" href="#examples-3">Examples</a></h4>
<pre><code class="language-js">import Service, { inject } from &quot;@ember/service&quot;;
import EmberObject, { get, set } from &quot;@ember/object&quot;;
</code></pre>
<p>In cases where there are many utility functions associated with a class, they can be further subdivided into
nested packages but remain named exports:</p>
<pre><code class="language-js">import EmberObject, { get, set } from &quot;@ember/object&quot;;
import { addObserver } from &quot;@ember/object/observers&quot;;
import { addListener } from &quot;@ember/object/events&quot;;
</code></pre>
<p>In the future, <a href="http://tc39.github.io/proposal-decorators/">decorators</a> would be included under this rule as
well. In fact, designing with an eye towards decorators was a large driver
behind this principle. For more discussion, see the <a href="0176-javascript-module-api.html#everything-is-a-named-export">Everything is a Named
Export alternative</a>.</p>
<h3 id="one-level-deep"><a class="header" href="#one-level-deep">One Level Deep</a></h3>
<p>To avoid deep directory hierarchies with mostly-empty directories, this proposal
limits nesting inside a top-level package to a single level. Deep nesting like
this can add additional time to navigating the hierarchy without adding much
benefit.</p>
<p>Java packages often have this problem due to their URL-based namespacing; see
e.g. <a href="https://github.com/elvishew/xLog/tree/fbfb60f9472e32723436b3d6bdd6c1878a5afb37/library/src">this Java
library</a>
where you end up with deeply nested directories, like
<code>xLog/library/src/test/java/com/elvishew/xlog/printer/AndroidPrinterTest.java</code>.</p>
<p>This rule leads to including the type in the name of the module in some cases
where it might otherwise be grouped instead. For example, instead of
<code>@ember/routing/locations/none</code>, we prefer <code>@ember/routing/none-location</code> to
avoid the second level of nesting.</p>
<h3 id="no-non-module-namespaces"><a class="header" href="#no-non-module-namespaces">No Non-Module Namespaces</a></h3>
<p>The global version of Ember includes several functions that also act as a
namespace to group related functionality.</p>
<p>For example, <code>Ember.run</code> can be used to run some code inside a run loop, while
<code>Ember.run.scheduleOnce</code> is used to schedule a function onto the run loop once.</p>
<p>Similarly, <code>Ember.computed</code> can be used to indicate a method should be treated as
a computed property, but computed property macros also live on <code>Ember.computed</code>, like
<code>Ember.computed.alias</code>.</p>
<p>When consumed via modules, these functions no longer act as a namespace. That's
because tacking these secondary functions on to the main function requires us to
eagerly evaluate them (not to mention the potential deoptimizations in
JavaScript VMs by adding properties to a function object).</p>
<p>In practice, that means that this won't work:</p>
<pre><code class="language-js">// Won't work!
import { run } from &quot;@ember/runloop&quot;;
run.scheduleOnce(function() {
  // ...
});
</code></pre>
<p>Instead, you'd have to do this:</p>
<pre><code class="language-js">import { scheduleOnce } from &quot;@ember/runloop&quot;;
scheduleOnce(function() {
  // ...
});
</code></pre>
<p>The <a href="0176-javascript-module-api.html#migration">migration tool</a>, described below, is designed to detect these
cases and migrate them correctly.</p>
<h3 id="prototype-extensions-and-other-code-with-side-effects"><a class="header" href="#prototype-extensions-and-other-code-with-side-effects">Prototype Extensions and Other Code with Side Effects</a></h3>
<p>Some parts of Ember change global objects rather than exporting classes or
functions. For example, Ember (by default) installs additional methods on
<code>String.prototype</code>, like the <code>camelize()</code> method.</p>
<p>Any code that has side effects lives in a module without any exports; importing
the module is enough to produce the desired side effects. For example, if I
wanted to make the string extensions available to the application, I could
write:</p>
<pre><code class="language-js">import &quot;@ember/extensions/string&quot;
</code></pre>
<p>Generally speaking, modules that have side effects are harder to debug and can
cause compatibility issues, and should be avoided if possible.</p>
<h2 id="migration-1"><a class="header" href="#migration-1">Migration</a></h2>
<p>To assist in assessing this RFC in real-world applications, and to help upgrade
apps should this RFC be accepted and implemented, your author has provided an
automatic migration utility, or &quot;codemod&quot;:</p>
<p><a href="https://github.com/tomdale/ember-modules-codemod">ember-modules-codemod</a></p>
<p>To run the codemod, <code>cd</code> into an existing Ember app and run the following commands.</p>
<pre><code class="language-sh">npm install ember-modules-codemod -g
ember-modules-codemod
</code></pre>
<p><strong>Note</strong>: The codemod currently requires Node 6 or later to run.</p>
<p>This codemod uses <a href="https://github.com/facebook/jscodeshift"><code>jscodeshift</code></a> to
update an Ember application in-place to the module syntax proposed in this RFC.
It can update apps that use the global <code>Ember</code>, and will eventually also support
apps using <a href="https://github.com/ember-cli/ember-cli-shims">ember-cli-shims</a>.</p>
<p><strong>Make sure you save any changes in your app before running the codemod, because
it modifies files in place. Obviously, because this RFC is speculative, your app
will not function after applying this codemod. For now, the codemod is only
useful for assessing how this proposal looks in real-world applications.</strong></p>
<p>For example, it will rewrite code that looks like this:</p>
<pre><code class="language-js">import Ember from 'ember';

export default Ember.Component.extend({
  isAnimal: Ember.computed.or('isDog', 'isCat')
});
</code></pre>
<p>Into this:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { or } from '@ember/object/computed';

export default Component.extend({
  isAnimal: or('isDog', 'isCat')
});
</code></pre>
<p>For more information, see the <a href="https://github.com/tomdale/ember-modules-codemod">README</a>.</p>
<h1 id="how-we-teach-this-19"><a class="header" href="#how-we-teach-this-19">How We Teach This</a></h1>
<p>This RFC makes changes to one of the most foundational (and historically stable)
concepts in Ember: how you access framework code. Because of that, it is hard to
overstate the impact these changes will have. We need to proceed carefully to
avoid confusion and churn.</p>
<p>It is possible that the work required to update the documentation and other
learning materials will be significantly more than the work required to do the
actual implementation. That means we need to start getting ready <em>now</em>, so that
when the code changes are ready, it is not blocked by a big documentation
effort.</p>
<p>That said, we do have the advantage of the new modules being &quot;just JavaScript.&quot;
We can lean heavily on the greater JavaScript community's learning materials,
and any teaching we do has the benefit of being transferable and not an
&quot;Ember-only&quot; skill.</p>
<h2 id="documentation-examples"><a class="header" href="#documentation-examples">Documentation Examples</a></h2>
<p>Examples in the Getting Started tutorial, guides and API docs will need to be
updated to the new module syntax.</p>
<p>Probably the most efficient and least painful way to do this would be to write a
tool that can extract code snippets from Markdown files and run the
<a href="0176-javascript-module-api.html#migration">migrator</a> on them, then replace the extracted code with the updated
version. For the API docs, this tool would need to be able to handle Markdown embedded
in JSDoc-style documentation.</p>
<p>The benefit of this approach is that, once we have verified the script works
reliably, we can wait until the last possible moment to make the switch. If we
attempt to update everything by hand, the duration and tediousness of that
process will likely take out an effective &quot;lock&quot; on the documentation code base,
where people will put off making big changes because of the potential for merge
conflicts.</p>
<h2 id="generators"><a class="header" href="#generators">Generators</a></h2>
<p>Generators are used by new users to help them get a handle on the framework, and
by experienced users to avoid typing repetitive boilerplate. We need to ensure
that the generators that ship with Ember are updated to use modules as soon as
they are ready. The recent work by the Ember CLI team to ship generators with
the Ember package itself, rather than Ember CLI, should make this relatively
painless.</p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>Our API documentation has long been a source of frustration, because the laundry
list of (often rarely used or internal) classes makes Ember feel far more
overwhelming than it really is.</p>
<p>The shift to modules gives us a good opportunity to rethink the presentation of
our API documentation. Instead of the imposing mono-list, we should group the
API documentation by package–which, conveniently in this proposal, means they
will also be grouped by area of functionality.</p>
<p>We should investigate the broader ecosystem to see if there is a good tool that
generates package-oriented documentation for JavaScript projects. If not, we may
wish to adapt an existing tool to do so.</p>
<h2 id="explaining-the-migration"><a class="header" href="#explaining-the-migration">Explaining the Migration</a></h2>
<p>Once the guides and API documentation are updated, modules should be
straightforward for new learners—indeed, more and more new learners are starting
with JavaScript modules as the baseline.</p>
<p>The most challenging aspect of teaching the new modules API, counterintuitively,
will likely be <em>existing</em> users. In particular, for changes that touch nearly
every file, most teams working on large apps cannot pause work for a week to
implement the change.</p>
<p>Our focus needs to be:</p>
<ul>
<li>Communicating clearly that the existing global build will work for the
foreseeable future.</li>
<li>Making clear the file size benefits of moving to modules.</li>
<li>Building robust tooling that allows even large apps to migrate in a day or
two, not a week.</li>
</ul>
<p>It is important to frame the module transition as a carrot, not a stick. We
should avoid dire warnings or deprecation notices. Instead, we should provide
good reporting when doing Ember CLI builds. If an app is compiled in globals
mode, we can offer suggestions for how to reduce the file size, providing a
helpful pointer to the modules migration guide. This will make the transition
feel less like churn and more like an optimization opportunity that developers
can take advantage of when they have the time or resources.</p>
<h3 id="addons"><a class="header" href="#addons">Addons</a></h3>
<p>One pitfall is that a <em>single</em> use of the <code>Ember</code> global means we have to
include the entire framework. That means that a developer could migrate their
entire app to modules, but a single old addon that uses the Ember globals will
negate the benefits.</p>
<p>This requires a two-pronged strategy:</p>
<ul>
<li>Tight integration into Ember CLI
<ul>
<li>Good reporting to make it obvious when a fallback to globals mode
occurs, and which addons/files are causing it.</li>
<li>An opt-in mode to prohibit globals mode. Installing an incompatible addon
would produce an error.</li>
</ul>
</li>
<li>Community outreach and pull requests to help authors update addons.</li>
</ul>
<h1 id="drawbacks-43"><a class="header" href="#drawbacks-43">Drawbacks</a></h1>
<h2 id="complexity"><a class="header" href="#complexity">Complexity</a></h2>
<p>There is something elegantly simple about a single <code>Ember</code> global that contains
everything. Introducing multiple packages means you don't just have to know what
you need—you also need to know where to import it from.</p>
<p>JavaScript module syntax is also something not everyone will be familiar with,
given its newness. However, this is something we must deal with anyway because
module syntax is already in use within apps.</p>
<h2 id="module-churn"><a class="header" href="#module-churn">Module Churn</a></h2>
<p>The <code>ember-cli-shims</code> package is already included by default in new Ember apps,
and is in fairly common usage. Many developers are already familiar with its
API. This drawback can be at least partially mitigated by <a href="0176-javascript-module-api.html#migration">the automated
migration process</a>, which will be easily applied to existing shimmed
apps.</p>
<h2 id="scoped-packages-are-an-unknown-quantity"><a class="header" href="#scoped-packages-are-an-unknown-quantity">Scoped Packages Are an Unknown Quantity</a></h2>
<p>This proposal relies on scoped packages. Despite being released over a year ago,
scoped packages are not always well supported.</p>
<p>For example, <a href="https://github.com/yarnpkg/yarn/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20scoped%20packages">scoped packages currently wreak havoc on Yarn</a>. Until very
recently, the <a href="https://npmjs.com">npmjs.com</a> search did not include scoped
packages. Generally speaking, there will be a long-tail of tools in the
ecosystem that will choke on scoped packages.</p>
<p>That said, Angular 2 is distributed under the <code>@angular</code> scope, and TypeScript
recently adopted the <code>@types</code> scope for publishing TypeScript typings to npm.
The popularity of both of these should drive compatibility. Despite this, we can
expect <a href="https://github.com/angular/angular/issues/8422">similar compatibility issues</a> for some time.</p>
<h2 id="nested-modules"><a class="header" href="#nested-modules">Nested Modules</a></h2>
<p>To satisfy the <a href="0176-javascript-module-api.html#classes-are-default-exports">Classes are Default Exports</a> rule,
this RFC proposes the use of nested modules. That is, a module name may contain
an additional path segment beyond the package name. For example,
<code>@ember/object/observers</code> is a nested module, while <code>@ember/object</code> is not.</p>
<p>In the Node/CommonJS world, nested modules are unusual but not unheard of. For
example, Lodash offers a <a href="https://github.com/lodash/lodash/wiki/FP-Guide">functional programming
style</a> accessed by calling
<code>require('lodash/fp')</code>.</p>
<p>There are two drawbacks associated with nested modules:</p>
<ol>
<li>Because they are uncommon, developers may be confused by the syntax.</li>
<li>Because they allow you to &quot;reach in&quot; to the package for an
arbitrary file, encouraging the end user to use nested modules may
inadvertently <em>also</em> encourage them to access private modules, thinking they are
public.</li>
</ol>
<p>The first issue is surmountable with education, good reference documentation,
and good tools to help guide developers in the right direction. That this style
is uncommon in the Node ecosystem seems to be more a <a href="http://blog.izs.me/post/44149270867/why-no-directorieslib-in-node-the-less-snarky">function of
dogma</a>
than any technical shortcoming of nested modules.</p>
<p>To ensure that developers don't inadvertently access private modules, we have
two good options:</p>
<ol>
<li>Package modules in such a way that private modules <em>cannot</em> be accessed.</li>
<li>Take a page from Ember Data and put all private modules in a <code>-private</code>
directory, hopefully making it clear accessing this module is not playing by
the rules.</li>
</ol>
<p>We could avoid using this uncommon style by hoisting nested modules up to their
own package. For example, <code>@ember/object/observers</code> could become
<code>@ember/observers</code> or <code>@ember/object-observers</code>. However, because I could not
find a strong technical reason against it, and because having more packages is
in tension with the explicit goal to <a href="0176-javascript-module-api.html#organize-by-mental-model">make Ember feel less
overwhelming</a>, I decided it was worth the small cost.</p>
<h1 id="alternatives-44"><a class="header" href="#alternatives-44">Alternatives</a></h1>
<h3 id="ember--prefix"><a class="header" href="#ember--prefix"><code>ember-</code> prefix</a></h3>
<p>One alternative to the <code>@ember</code> scope is to use the <code>ember-</code> prefix. This avoids
the drawbacks around scoped packages described above. However, they would be
indistinguishable from the large number of community packages that begin with
<code>ember-</code>.</p>
<h3 id="everything-is-a-named-export"><a class="header" href="#everything-is-a-named-export">Everything is a Named Export</a></h3>
<p>This proposal argues that classes should be a module's default export, and any
utility functions should be a named export. That means you can never have more
than one class per module, and <em>that</em> means, inherently, more <code>import</code>
statements than a system where multiple classes can live in one module.</p>
<p>Additionally, in cases where there is not a clear &quot;primary&quot; class, this can feel
a little awkward:</p>
<pre><code class="language-js">import Route from &quot;@ember/routing/route&quot;;
import Router from &quot;@ember/routing/router&quot;;
</code></pre>
<p>One commonly proposed alternative is to say that classes become named exports,
and default exports are not used at all. The above example would become:</p>
<pre><code class="language-js">import { Route, Router } from &quot;@ember/routing&quot;;
</code></pre>
<p>In this case, classes are distinguished by being capitalized, rather than by
being a default export.</p>
<p>There is one major change coming to JavaScript and Ember that, your author
believes, deals a fatal blow to this approach: decorators.</p>
<p>If you're unfamiliar with decorators, see <a href="http://tc39.github.io/proposal-decorators/">Addy Osmani's great
overview</a>. Decorators provide a mechanism for adding declarative
annotations to classes, methods, properties and functions.</p>
<p>For example, Robert Jackson has an <a href="https://github.com/rwjblue/ember-computed-decorators">experimental library for using decorators to
annotate computed properties in a class</a>. Something
like this will probably make its way into Ember in the future:</p>
<pre><code class="language-js">import EmberObject, { computed } from &quot;@ember/object&quot;;

export default class Cat extends EmberObject {
  @computed(&quot;hairLength&quot;)
  isDomesticShortHair(hairLength) {
    return hairLength &lt; 3;
  }
}
</code></pre>
<p>Most decorators are tightly coupled to a particular class because they configure
some aspect of behavior that is only relevant to that class. If every decorator
and every class share a namespace, it is hard to identify which go with each
other.</p>
<pre><code class="language-js">import { Router, Route, resource, model, location, inject, queryParam } from &quot;@ember/routing&quot;;
</code></pre>
<p>Can you tell me which of these decorators goes with which class?</p>
<p>And this import is getting so long, you'd probably be tempted to break it up
into multiple lines <em>anyway</em>, so it's not clear that it's actually a win over
separate imports.</p>
<p>Contrast this with the same thing expressed using the rules in
this RFC:</p>
<pre><code class="language-js">import Router, { resource, location } from &quot;@ember/routing/router&quot;;
import Route, { model, inject, queryParam } from &quot;@ember/routing/route&quot;;
</code></pre>
<p>Here, the decorators are clearly tied to their class. And it's far nicer from a
refactoring perspective: if you delete a class from a file, you then delete a
single line from your imports.</p>
<p>Contrast that with making fiddly edits to a long list of named exports unrelated
to each other.</p>
<h1 id="unresolved-questions-38"><a class="header" href="#unresolved-questions-38">Unresolved Questions</a></h1>
<h3 id="intimate-apis"><a class="header" href="#intimate-apis">Intimate APIs</a></h3>
<p>How much do we want to provide module API for so-called &quot;intimate
APIs&quot;—technically private, but in widespread use?</p>
<h3 id="backwards-compatibility-for-addons"><a class="header" href="#backwards-compatibility-for-addons">Backwards Compatibility for Addons</a></h3>
<p>How do we provide an API for addons to use modules but fall back to globals mode
in older versions of Ember? We should ensure that, at minimum, addons can
continue to support LTS releases. At the same time, it's critical that adding an
addon doesn't opt your entire application back in to the entire framework.</p>
<p>Because there is a lot of implementation-specific detail to get right here, and
because it doesn't otherwise block landing this module naming RFC, the final
design of API for addon authors should be broken out into a separate RFC.</p>
<h3 id="distribution"><a class="header" href="#distribution">Distribution</a></h3>
<p>In practice, how do we ship this code to end users of Ember CLI?</p>
<p>When building client-side apps, it's very important to avoid duplicate
dependencies, which can quickly cause file size to balloon out of control.</p>
<p>Unfortunately, npm@3's de-duping is so naïve that it's likely that users would
end up in dependency hell if we shipped the framework as separate npm packages.
There's no good way to ship dependencies in version lockstep and feel confident
that they will reliably be de-duped.</p>
<p>Until Yarn usage is more widespread, and to eliminate significant complexity in
the first iteration, it probably makes sense for the first phase of
implementation to continue shipping a single npm package that Ember CLI apps can
depend on. This gives us atomic updates and makes sure you never have one piece
of the framework interacting with a different piece that is inadvertently three
versions old.</p>
<p>What this means is that, rather than shipping <code>@ember/object</code> on npm, we'd ship
a single <code>ember-source</code> (or something) package that includes the entire
framework. At build time, the Ember build process would virtually map the
<code>@ember/object</code> package to the right file inside <code>ember-source</code>. In essence, all
of the benefits of smaller bundles without the boiling hellbroth of managing
dependencies.</p>
<p>That said, because this RFC is designed with an eye towards eventually
publishing each package to npm individually, we will have that option available
to us in the future once we determine that we can do so without causing lots of
pain.</p>
<h1 id="addenda"><a class="header" href="#addenda">Addenda</a></h1>
<p><em>(Ed. note: These tables are automatically generated from the scripts in the <a href="https://github.com/tomdale/ember-modules-codemod">codemod</a> repository.)</em></p>
<h2 id="addendum-1---table-of-module-names-and-exports-by-global"><a class="header" href="#addendum-1---table-of-module-names-and-exports-by-global">Addendum 1 - Table of Module Names and Exports by Global</a></h2>
<table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody>
<tr><td><code>Ember.$</code></td><td><code>import $ from &quot;jquery&quot;</code></td></tr>
<tr><td><code>Ember.A</code></td><td><code>import { A } from &quot;@ember/array&quot;</code></td></tr>
<tr><td><code>Ember.Application</code></td><td><code>import Application from &quot;@ember/application&quot;</code></td></tr>
<tr><td><code>Ember.Array</code></td><td><code>import EmberArray from &quot;@ember/array&quot;</code></td></tr>
<tr><td><code>Ember.ArrayProxy</code></td><td><code>import ArrayProxy from &quot;@ember/array/proxy&quot;</code></td></tr>
<tr><td><code>Ember.AutoLocation</code></td><td><code>import AutoLocation from &quot;@ember/routing/auto-location&quot;</code></td></tr>
<tr><td><code>Ember.Checkbox</code></td><td><code>import Checkbox from &quot;@ember/component/checkbox&quot;</code></td></tr>
<tr><td><code>Ember.Component</code></td><td><code>import Component from &quot;@ember/component&quot;</code></td></tr>
<tr><td><code>Ember.ContainerDebugAdapter</code></td><td><code>import ContainerDebugAdapter from &quot;@ember/debug/container-debug-adapter&quot;</code></td></tr>
<tr><td><code>Ember.Controller</code></td><td><code>import Controller from &quot;@ember/controller&quot;</code></td></tr>
<tr><td><code>Ember.DataAdapter</code></td><td><code>import DataAdapter from &quot;@ember/debug/data-adapter&quot;</code></td></tr>
<tr><td><code>Ember.DefaultResolver</code></td><td><code>import GlobalsResolver from &quot;@ember/application/globals-resolver&quot;</code></td></tr>
<tr><td><code>Ember.Enumerable</code></td><td><code>import Enumerable from &quot;@ember/enumerable&quot;</code></td></tr>
<tr><td><code>Ember.Evented</code></td><td><code>import Evented from &quot;@ember/object/evented&quot;</code></td></tr>
<tr><td><code>Ember.HashLocation</code></td><td><code>import HashLocation from &quot;@ember/routing/hash-location&quot;</code></td></tr>
<tr><td><code>Ember.Helper</code></td><td><code>import Helper from &quot;@ember/component/helper&quot;</code></td></tr>
<tr><td><code>Ember.Helper.helper</code></td><td><code>import { helper } from &quot;@ember/component/helper&quot;</code></td></tr>
<tr><td><code>Ember.HistoryLocation</code></td><td><code>import HistoryLocation from &quot;@ember/routing/history-location&quot;</code></td></tr>
<tr><td><code>Ember.LinkComponent</code></td><td><code>import LinkComponent from &quot;@ember/routing/link-component&quot;</code></td></tr>
<tr><td><code>Ember.Location</code></td><td><code>import Location from &quot;@ember/routing/location&quot;</code></td></tr>
<tr><td><code>Ember.Map</code></td><td><code>import EmberMap from &quot;@ember/map&quot;</code></td></tr>
<tr><td><code>Ember.MapWithDefault</code></td><td><code>import MapWithDefault from &quot;@ember/map/with-default&quot;</code></td></tr>
<tr><td><code>Ember.Mixin</code></td><td><code>import Mixin from &quot;@ember/object/mixin&quot;</code></td></tr>
<tr><td><code>Ember.MutableArray</code></td><td><code>import MutableArray from &quot;@ember/array/mutable&quot;</code></td></tr>
<tr><td><code>Ember.NoneLocation</code></td><td><code>import NoneLocation from &quot;@ember/routing/none-location&quot;</code></td></tr>
<tr><td><code>Ember.Object</code></td><td><code>import EmberObject from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.RSVP</code></td><td><code>import RSVP from &quot;rsvp&quot;</code></td></tr>
<tr><td><code>Ember.Resolver</code></td><td><code>import Resolver from &quot;@ember/application/resolver&quot;</code></td></tr>
<tr><td><code>Ember.Route</code></td><td><code>import Route from &quot;@ember/routing/route&quot;</code></td></tr>
<tr><td><code>Ember.Router</code></td><td><code>import Router from &quot;@ember/routing/router&quot;</code></td></tr>
<tr><td><code>Ember.Service</code></td><td><code>import Service from &quot;@ember/service&quot;</code></td></tr>
<tr><td><code>Ember.String.camelize</code></td><td><code>import { camelize } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.capitalize</code></td><td><code>import { capitalize } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.classify</code></td><td><code>import { classify } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.dasherize</code></td><td><code>import { dasherize } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.decamelize</code></td><td><code>import { decamelize } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.fmt</code></td><td><code>import { fmt } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.htmlSafe</code></td><td><code>import { htmlSafe } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.loc</code></td><td><code>import { loc } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.underscore</code></td><td><code>import { underscore } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.String.w</code></td><td><code>import { w } from &quot;@ember/string&quot;</code></td></tr>
<tr><td><code>Ember.TextArea</code></td><td><code>import TextArea from &quot;@ember/component/text-area&quot;</code></td></tr>
<tr><td><code>Ember.TextField</code></td><td><code>import TextField from &quot;@ember/component/text-field&quot;</code></td></tr>
<tr><td><code>Ember.addListener</code></td><td><code>import { addListener } from &quot;@ember/object/events&quot;</code></td></tr>
<tr><td><code>Ember.addObserver</code></td><td><code>import { addObserver } from &quot;@ember/object/observers&quot;</code></td></tr>
<tr><td><code>Ember.aliasMethod</code></td><td><code>import { aliasMethod } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.assert</code></td><td><code>import { assert } from &quot;@ember/debug&quot;</code></td></tr>
<tr><td><code>Ember.assign</code></td><td><code>import { assign } from &quot;@ember/polyfills&quot;</code></td></tr>
<tr><td><code>Ember.cacheFor</code></td><td><code>import { cacheFor } from &quot;@ember/object/internals&quot;</code></td></tr>
<tr><td><code>Ember.compare</code></td><td><code>import { compare } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.computed</code></td><td><code>import { computed } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.computed.alias</code></td><td><code>import { alias } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.and</code></td><td><code>import { and } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.bool</code></td><td><code>import { bool } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.collect</code></td><td><code>import { collect } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.deprecatingAlias</code></td><td><code>import { deprecatingAlias } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.empty</code></td><td><code>import { empty } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.equal</code></td><td><code>import { equal } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.filter</code></td><td><code>import { filter } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.filterBy</code></td><td><code>import { filterBy } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.filterProperty</code></td><td><code>import { filterProperty } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.gt</code></td><td><code>import { gt } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.gte</code></td><td><code>import { gte } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.intersect</code></td><td><code>import { intersect } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.lt</code></td><td><code>import { lt } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.lte</code></td><td><code>import { lte } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.map</code></td><td><code>import { map } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.mapBy</code></td><td><code>import { mapBy } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.mapProperty</code></td><td><code>import { mapProperty } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.match</code></td><td><code>import { match } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.max</code></td><td><code>import { max } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.min</code></td><td><code>import { min } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.none</code></td><td><code>import { none } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.not</code></td><td><code>import { not } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.notEmpty</code></td><td><code>import { notEmpty } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.oneWay</code></td><td><code>import { oneWay } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.or</code></td><td><code>import { or } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.readOnly</code></td><td><code>import { readOnly } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.reads</code></td><td><code>import { reads } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.setDiff</code></td><td><code>import { setDiff } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.sort</code></td><td><code>import { sort } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.sum</code></td><td><code>import { sum } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.union</code></td><td><code>import { union } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.computed.uniq</code></td><td><code>import { uniq } from &quot;@ember/object/computed&quot;</code></td></tr>
<tr><td><code>Ember.copy</code></td><td><code>import { copy } from &quot;@ember/object/internals&quot;</code></td></tr>
<tr><td><code>Ember.create</code></td><td><code>import { create } from &quot;@ember/polyfills&quot;</code></td></tr>
<tr><td><code>Ember.debug</code></td><td><code>import { debug } from &quot;@ember/debug&quot;</code></td></tr>
<tr><td><code>Ember.deprecate</code></td><td><code>import { deprecate } from &quot;@ember/application/deprecations&quot;</code></td></tr>
<tr><td><code>Ember.deprecateFunc</code></td><td><code>import { deprecateFunc } from &quot;@ember/application/deprecations&quot;</code></td></tr>
<tr><td><code>Ember.get</code></td><td><code>import { get } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.getOwner</code></td><td><code>import { getOwner } from &quot;@ember/application&quot;</code></td></tr>
<tr><td><code>Ember.getProperties</code></td><td><code>import { getProperties } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.guidFor</code></td><td><code>import { guidFor } from &quot;@ember/object/internals&quot;</code></td></tr>
<tr><td><code>Ember.inject.controller</code></td><td><code>import { inject } from &quot;@ember/controller&quot;</code></td></tr>
<tr><td><code>Ember.inject.service</code></td><td><code>import { inject } from &quot;@ember/service&quot;</code></td></tr>
<tr><td><code>Ember.inspect</code></td><td><code>import { inspect } from &quot;@ember/debug&quot;</code></td></tr>
<tr><td><code>Ember.instrument</code></td><td><code>import { instrument } from &quot;@ember/instrumentation&quot;</code></td></tr>
<tr><td><code>Ember.isArray</code></td><td><code>import { isArray } from &quot;@ember/array&quot;</code></td></tr>
<tr><td><code>Ember.isBlank</code></td><td><code>import { isBlank } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.isEmpty</code></td><td><code>import { isEmpty } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.isEqual</code></td><td><code>import { isEqual } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.isNone</code></td><td><code>import { isNone } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.isPresent</code></td><td><code>import { isPresent } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.keys</code></td><td><code>import { keys } from &quot;@ember/polyfills&quot;</code></td></tr>
<tr><td><code>Ember.makeArray</code></td><td><code>import { makeArray } from &quot;@ember/array&quot;</code></td></tr>
<tr><td><code>Ember.observer</code></td><td><code>import { observer } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.on</code></td><td><code>import { on } from &quot;@ember/object/evented&quot;</code></td></tr>
<tr><td><code>Ember.onLoad</code></td><td><code>import { onLoad } from &quot;@ember/application&quot;</code></td></tr>
<tr><td><code>Ember.platform.defineProperty</code></td><td><code>import { defineProperty } from &quot;@ember/polyfills&quot;</code></td></tr>
<tr><td><code>Ember.platform.hasPropertyAccessors</code></td><td><code>import { hasPropertyAccessors } from &quot;@ember/polyfills&quot;</code></td></tr>
<tr><td><code>Ember.removeListener</code></td><td><code>import { removeListener } from &quot;@ember/object/events&quot;</code></td></tr>
<tr><td><code>Ember.removeObserver</code></td><td><code>import { removeObserver } from &quot;@ember/object/observers&quot;</code></td></tr>
<tr><td><code>Ember.reset</code></td><td><code>import { reset } from &quot;@ember/instrumentation&quot;</code></td></tr>
<tr><td><code>Ember.run</code></td><td><code>import { run } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.begin</code></td><td><code>import { begin } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.bind</code></td><td><code>import { bind } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.cancel</code></td><td><code>import { cancel } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.debounce</code></td><td><code>import { debounce } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.end</code></td><td><code>import { end } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.join</code></td><td><code>import { join } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.later</code></td><td><code>import { later } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.next</code></td><td><code>import { next } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.once</code></td><td><code>import { once } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.schedule</code></td><td><code>import { schedule } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.scheduleOnce</code></td><td><code>import { scheduleOnce } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.run.throttle</code></td><td><code>import { throttle } from &quot;@ember/runloop&quot;</code></td></tr>
<tr><td><code>Ember.runInDebug</code></td><td><code>import { runInDebug } from &quot;@ember/debug&quot;</code></td></tr>
<tr><td><code>Ember.runLoadHooks</code></td><td><code>import { runLoadHooks } from &quot;@ember/application&quot;</code></td></tr>
<tr><td><code>Ember.sendEvent</code></td><td><code>import { sendEvent } from &quot;@ember/object/events&quot;</code></td></tr>
<tr><td><code>Ember.set</code></td><td><code>import { set } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.setOwner</code></td><td><code>import { setOwner } from &quot;@ember/application&quot;</code></td></tr>
<tr><td><code>Ember.setProperties</code></td><td><code>import { setProperties } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.subscribe</code></td><td><code>import { subscribe } from &quot;@ember/instrumentation&quot;</code></td></tr>
<tr><td><code>Ember.tryInvoke</code></td><td><code>import { tryInvoke } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.trySet</code></td><td><code>import { trySet } from &quot;@ember/object&quot;</code></td></tr>
<tr><td><code>Ember.typeOf</code></td><td><code>import { typeOf } from &quot;@ember/utils&quot;</code></td></tr>
<tr><td><code>Ember.unsubscribe</code></td><td><code>import { unsubscribe } from &quot;@ember/instrumentation&quot;</code></td></tr>
<tr><td><code>Ember.warn</code></td><td><code>import { warn } from &quot;@ember/debug&quot;</code></td></tr>
</tbody></table>
<h2 id="addendum-2---table-of-module-names-and-exports-by-package"><a class="header" href="#addendum-2---table-of-module-names-and-exports-by-package">Addendum 2 - Table of Module Names and Exports by Package</a></h2>
<p>Each package is sorted by module name, then export name.</p>
<h3 id="emberapplication"><a class="header" href="#emberapplication"><code>@ember/application</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import Application from &quot;@ember/application&quot;</code></td><td><code>Ember.Application</code></td></tr>
<tr><td><code>import { getOwner } from &quot;@ember/application&quot;</code></td><td><code>Ember.getOwner</code></td></tr>
<tr><td><code>import { onLoad } from &quot;@ember/application&quot;</code></td><td><code>Ember.onLoad</code></td></tr>
<tr><td><code>import { runLoadHooks } from &quot;@ember/application&quot;</code></td><td><code>Ember.runLoadHooks</code></td></tr>
<tr><td><code>import { setOwner } from &quot;@ember/application&quot;</code></td><td><code>Ember.setOwner</code></td></tr>
<tr><td><code>import { deprecate } from &quot;@ember/application/deprecations&quot;</code></td><td><code>Ember.deprecate</code></td></tr>
<tr><td><code>import { deprecateFunc } from &quot;@ember/application/deprecations&quot;</code></td><td><code>Ember.deprecateFunc</code></td></tr>
<tr><td><code>import GlobalsResolver from &quot;@ember/application/globals-resolver&quot;</code></td><td><code>Ember.DefaultResolver</code></td></tr>
<tr><td><code>import Resolver from &quot;@ember/application/resolver&quot;</code></td><td><code>Ember.Resolver</code></td></tr>
</tbody></table>
<h3 id="emberarray"><a class="header" href="#emberarray"><code>@ember/array</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import EmberArray from &quot;@ember/array&quot;</code></td><td><code>Ember.Array</code></td></tr>
<tr><td><code>import { A } from &quot;@ember/array&quot;</code></td><td><code>Ember.A</code></td></tr>
<tr><td><code>import { isArray } from &quot;@ember/array&quot;</code></td><td><code>Ember.isArray</code></td></tr>
<tr><td><code>import { makeArray } from &quot;@ember/array&quot;</code></td><td><code>Ember.makeArray</code></td></tr>
<tr><td><code>import MutableArray from &quot;@ember/array/mutable&quot;</code></td><td><code>Ember.MutableArray</code></td></tr>
<tr><td><code>import ArrayProxy from &quot;@ember/array/proxy&quot;</code></td><td><code>Ember.ArrayProxy</code></td></tr>
</tbody></table>
<h3 id="embercomponent"><a class="header" href="#embercomponent"><code>@ember/component</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import Component from &quot;@ember/component&quot;</code></td><td><code>Ember.Component</code></td></tr>
<tr><td><code>import Checkbox from &quot;@ember/component/checkbox&quot;</code></td><td><code>Ember.Checkbox</code></td></tr>
<tr><td><code>import Helper from &quot;@ember/component/helper&quot;</code></td><td><code>Ember.Helper</code></td></tr>
<tr><td><code>import { helper } from &quot;@ember/component/helper&quot;</code></td><td><code>Ember.Helper.helper</code></td></tr>
<tr><td><code>import TextArea from &quot;@ember/component/text-area&quot;</code></td><td><code>Ember.TextArea</code></td></tr>
<tr><td><code>import TextField from &quot;@ember/component/text-field&quot;</code></td><td><code>Ember.TextField</code></td></tr>
</tbody></table>
<h3 id="embercontroller"><a class="header" href="#embercontroller"><code>@ember/controller</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import Controller from &quot;@ember/controller&quot;</code></td><td><code>Ember.Controller</code></td></tr>
<tr><td><code>import { inject } from &quot;@ember/controller&quot;</code></td><td><code>Ember.inject.controller</code></td></tr>
</tbody></table>
<h3 id="emberdebug"><a class="header" href="#emberdebug"><code>@ember/debug</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import { assert } from &quot;@ember/debug&quot;</code></td><td><code>Ember.assert</code></td></tr>
<tr><td><code>import { debug } from &quot;@ember/debug&quot;</code></td><td><code>Ember.debug</code></td></tr>
<tr><td><code>import { inspect } from &quot;@ember/debug&quot;</code></td><td><code>Ember.inspect</code></td></tr>
<tr><td><code>import { runInDebug } from &quot;@ember/debug&quot;</code></td><td><code>Ember.runInDebug</code></td></tr>
<tr><td><code>import { warn } from &quot;@ember/debug&quot;</code></td><td><code>Ember.warn</code></td></tr>
<tr><td><code>import ContainerDebugAdapter from &quot;@ember/debug/container-debug-adapter&quot;</code></td><td><code>Ember.ContainerDebugAdapter</code></td></tr>
<tr><td><code>import DataAdapter from &quot;@ember/debug/data-adapter&quot;</code></td><td><code>Ember.DataAdapter</code></td></tr>
</tbody></table>
<h3 id="emberenumerable"><a class="header" href="#emberenumerable"><code>@ember/enumerable</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import Enumerable from &quot;@ember/enumerable&quot;</code></td><td><code>Ember.Enumerable</code></td></tr>
</tbody></table>
<h3 id="emberinstrumentation"><a class="header" href="#emberinstrumentation"><code>@ember/instrumentation</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import { instrument } from &quot;@ember/instrumentation&quot;</code></td><td><code>Ember.instrument</code></td></tr>
<tr><td><code>import { reset } from &quot;@ember/instrumentation&quot;</code></td><td><code>Ember.reset</code></td></tr>
<tr><td><code>import { subscribe } from &quot;@ember/instrumentation&quot;</code></td><td><code>Ember.subscribe</code></td></tr>
<tr><td><code>import { unsubscribe } from &quot;@ember/instrumentation&quot;</code></td><td><code>Ember.unsubscribe</code></td></tr>
</tbody></table>
<h3 id="embermap"><a class="header" href="#embermap"><code>@ember/map</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import EmberMap from &quot;@ember/map&quot;</code></td><td><code>Ember.Map</code></td></tr>
<tr><td><code>import MapWithDefault from &quot;@ember/map/with-default&quot;</code></td><td><code>Ember.MapWithDefault</code></td></tr>
</tbody></table>
<h3 id="emberobject"><a class="header" href="#emberobject"><code>@ember/object</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import EmberObject from &quot;@ember/object&quot;</code></td><td><code>Ember.Object</code></td></tr>
<tr><td><code>import { aliasMethod } from &quot;@ember/object&quot;</code></td><td><code>Ember.aliasMethod</code></td></tr>
<tr><td><code>import { computed } from &quot;@ember/object&quot;</code></td><td><code>Ember.computed</code></td></tr>
<tr><td><code>import { get } from &quot;@ember/object&quot;</code></td><td><code>Ember.get</code></td></tr>
<tr><td><code>import { getProperties } from &quot;@ember/object&quot;</code></td><td><code>Ember.getProperties</code></td></tr>
<tr><td><code>import { observer } from &quot;@ember/object&quot;</code></td><td><code>Ember.observer</code></td></tr>
<tr><td><code>import { set } from &quot;@ember/object&quot;</code></td><td><code>Ember.set</code></td></tr>
<tr><td><code>import { setProperties } from &quot;@ember/object&quot;</code></td><td><code>Ember.setProperties</code></td></tr>
<tr><td><code>import { trySet } from &quot;@ember/object&quot;</code></td><td><code>Ember.trySet</code></td></tr>
<tr><td><code>import { alias } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.alias</code></td></tr>
<tr><td><code>import { and } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.and</code></td></tr>
<tr><td><code>import { bool } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.bool</code></td></tr>
<tr><td><code>import { collect } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.collect</code></td></tr>
<tr><td><code>import { deprecatingAlias } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.deprecatingAlias</code></td></tr>
<tr><td><code>import { empty } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.empty</code></td></tr>
<tr><td><code>import { equal } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.equal</code></td></tr>
<tr><td><code>import { filter } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.filter</code></td></tr>
<tr><td><code>import { filterBy } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.filterBy</code></td></tr>
<tr><td><code>import { filterProperty } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.filterProperty</code></td></tr>
<tr><td><code>import { gt } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.gt</code></td></tr>
<tr><td><code>import { gte } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.gte</code></td></tr>
<tr><td><code>import { intersect } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.intersect</code></td></tr>
<tr><td><code>import { lt } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.lt</code></td></tr>
<tr><td><code>import { lte } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.lte</code></td></tr>
<tr><td><code>import { map } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.map</code></td></tr>
<tr><td><code>import { mapBy } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.mapBy</code></td></tr>
<tr><td><code>import { mapProperty } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.mapProperty</code></td></tr>
<tr><td><code>import { match } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.match</code></td></tr>
<tr><td><code>import { max } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.max</code></td></tr>
<tr><td><code>import { min } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.min</code></td></tr>
<tr><td><code>import { none } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.none</code></td></tr>
<tr><td><code>import { not } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.not</code></td></tr>
<tr><td><code>import { notEmpty } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.notEmpty</code></td></tr>
<tr><td><code>import { oneWay } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.oneWay</code></td></tr>
<tr><td><code>import { or } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.or</code></td></tr>
<tr><td><code>import { readOnly } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.readOnly</code></td></tr>
<tr><td><code>import { reads } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.reads</code></td></tr>
<tr><td><code>import { setDiff } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.setDiff</code></td></tr>
<tr><td><code>import { sort } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.sort</code></td></tr>
<tr><td><code>import { sum } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.sum</code></td></tr>
<tr><td><code>import { union } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.union</code></td></tr>
<tr><td><code>import { uniq } from &quot;@ember/object/computed&quot;</code></td><td><code>Ember.computed.uniq</code></td></tr>
<tr><td><code>import Evented from &quot;@ember/object/evented&quot;</code></td><td><code>Ember.Evented</code></td></tr>
<tr><td><code>import { on } from &quot;@ember/object/evented&quot;</code></td><td><code>Ember.on</code></td></tr>
<tr><td><code>import { addListener } from &quot;@ember/object/events&quot;</code></td><td><code>Ember.addListener</code></td></tr>
<tr><td><code>import { removeListener } from &quot;@ember/object/events&quot;</code></td><td><code>Ember.removeListener</code></td></tr>
<tr><td><code>import { sendEvent } from &quot;@ember/object/events&quot;</code></td><td><code>Ember.sendEvent</code></td></tr>
<tr><td><code>import { cacheFor } from &quot;@ember/object/internals&quot;</code></td><td><code>Ember.cacheFor</code></td></tr>
<tr><td><code>import { copy } from &quot;@ember/object/internals&quot;</code></td><td><code>Ember.copy</code></td></tr>
<tr><td><code>import { guidFor } from &quot;@ember/object/internals&quot;</code></td><td><code>Ember.guidFor</code></td></tr>
<tr><td><code>import Mixin from &quot;@ember/object/mixin&quot;</code></td><td><code>Ember.Mixin</code></td></tr>
<tr><td><code>import { addObserver } from &quot;@ember/object/observers&quot;</code></td><td><code>Ember.addObserver</code></td></tr>
<tr><td><code>import { removeObserver } from &quot;@ember/object/observers&quot;</code></td><td><code>Ember.removeObserver</code></td></tr>
</tbody></table>
<h3 id="emberpolyfills"><a class="header" href="#emberpolyfills"><code>@ember/polyfills</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import { assign } from &quot;@ember/polyfills&quot;</code></td><td><code>Ember.assign</code></td></tr>
<tr><td><code>import { create } from &quot;@ember/polyfills&quot;</code></td><td><code>Ember.create</code></td></tr>
<tr><td><code>import { defineProperty } from &quot;@ember/polyfills&quot;</code></td><td><code>Ember.platform.defineProperty</code></td></tr>
<tr><td><code>import { hasPropertyAccessors } from &quot;@ember/polyfills&quot;</code></td><td><code>Ember.platform.hasPropertyAccessors</code></td></tr>
<tr><td><code>import { keys } from &quot;@ember/polyfills&quot;</code></td><td><code>Ember.keys</code></td></tr>
</tbody></table>
<h3 id="emberrouting"><a class="header" href="#emberrouting"><code>@ember/routing</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import AutoLocation from &quot;@ember/routing/auto-location&quot;</code></td><td><code>Ember.AutoLocation</code></td></tr>
<tr><td><code>import HashLocation from &quot;@ember/routing/hash-location&quot;</code></td><td><code>Ember.HashLocation</code></td></tr>
<tr><td><code>import HistoryLocation from &quot;@ember/routing/history-location&quot;</code></td><td><code>Ember.HistoryLocation</code></td></tr>
<tr><td><code>import LinkComponent from &quot;@ember/routing/link-component&quot;</code></td><td><code>Ember.LinkComponent</code></td></tr>
<tr><td><code>import Location from &quot;@ember/routing/location&quot;</code></td><td><code>Ember.Location</code></td></tr>
<tr><td><code>import NoneLocation from &quot;@ember/routing/none-location&quot;</code></td><td><code>Ember.NoneLocation</code></td></tr>
<tr><td><code>import Route from &quot;@ember/routing/route&quot;</code></td><td><code>Ember.Route</code></td></tr>
<tr><td><code>import Router from &quot;@ember/routing/router&quot;</code></td><td><code>Ember.Router</code></td></tr>
</tbody></table>
<h3 id="emberrunloop"><a class="header" href="#emberrunloop"><code>@ember/runloop</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import { begin } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.begin</code></td></tr>
<tr><td><code>import { bind } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.bind</code></td></tr>
<tr><td><code>import { cancel } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.cancel</code></td></tr>
<tr><td><code>import { debounce } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.debounce</code></td></tr>
<tr><td><code>import { end } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.end</code></td></tr>
<tr><td><code>import { join } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.join</code></td></tr>
<tr><td><code>import { later } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.later</code></td></tr>
<tr><td><code>import { next } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.next</code></td></tr>
<tr><td><code>import { once } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.once</code></td></tr>
<tr><td><code>import { run } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run</code></td></tr>
<tr><td><code>import { schedule } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.schedule</code></td></tr>
<tr><td><code>import { scheduleOnce } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.scheduleOnce</code></td></tr>
<tr><td><code>import { throttle } from &quot;@ember/runloop&quot;</code></td><td><code>Ember.run.throttle</code></td></tr>
</tbody></table>
<h3 id="emberservice"><a class="header" href="#emberservice"><code>@ember/service</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import Service from &quot;@ember/service&quot;</code></td><td><code>Ember.Service</code></td></tr>
<tr><td><code>import { inject } from &quot;@ember/service&quot;</code></td><td><code>Ember.inject.service</code></td></tr>
</tbody></table>
<h3 id="emberstring"><a class="header" href="#emberstring"><code>@ember/string</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import { camelize } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.camelize</code></td></tr>
<tr><td><code>import { capitalize } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.capitalize</code></td></tr>
<tr><td><code>import { classify } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.classify</code></td></tr>
<tr><td><code>import { dasherize } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.dasherize</code></td></tr>
<tr><td><code>import { decamelize } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.decamelize</code></td></tr>
<tr><td><code>import { fmt } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.fmt</code></td></tr>
<tr><td><code>import { htmlSafe } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.htmlSafe</code></td></tr>
<tr><td><code>import { loc } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.loc</code></td></tr>
<tr><td><code>import { underscore } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.underscore</code></td></tr>
<tr><td><code>import { w } from &quot;@ember/string&quot;</code></td><td><code>Ember.String.w</code></td></tr>
</tbody></table>
<h3 id="emberutils"><a class="header" href="#emberutils"><code>@ember/utils</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import { compare } from &quot;@ember/utils&quot;</code></td><td><code>Ember.compare</code></td></tr>
<tr><td><code>import { isBlank } from &quot;@ember/utils&quot;</code></td><td><code>Ember.isBlank</code></td></tr>
<tr><td><code>import { isEmpty } from &quot;@ember/utils&quot;</code></td><td><code>Ember.isEmpty</code></td></tr>
<tr><td><code>import { isNone } from &quot;@ember/utils&quot;</code></td><td><code>Ember.isNone</code></td></tr>
<tr><td><code>import { isPresent } from &quot;@ember/utils&quot;</code></td><td><code>Ember.isPresent</code></td></tr>
<tr><td><code>import { tryInvoke } from &quot;@ember/utils&quot;</code></td><td><code>Ember.tryInvoke</code></td></tr>
<tr><td><code>import { typeOf } from &quot;@ember/utils&quot;</code></td><td><code>Ember.typeOf</code></td></tr>
</tbody></table>
<h3 id="jquery"><a class="header" href="#jquery"><code>jquery</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import $ from &quot;jquery&quot;</code></td><td><code>Ember.$</code></td></tr>
</tbody></table>
<h3 id="rsvp"><a class="header" href="#rsvp"><code>rsvp</code></a></h3>
<table><thead><tr><th>Module</th><th>Global</th></tr></thead><tbody>
<tr><td><code>import RSVP from &quot;rsvp&quot;</code></td><td><code>Ember.RSVP</code></td></tr>
</tbody></table>
<h2 id="addendum-3---table-of-modules-with-side-effects"><a class="header" href="#addendum-3---table-of-modules-with-side-effects">Addendum 3 - Table of Modules with Side Effects</a></h2>
<table><thead><tr><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>import &quot;@ember/extensions&quot;</code></td><td>Adds all of Ember's prototype extensions.</td></tr>
<tr><td><code>import &quot;@ember/extensions/string&quot;</code></td><td>Adds just <code>String</code> prototype extensions.</td></tr>
<tr><td><code>import &quot;@ember/extensions/array&quot;</code></td><td>Adds just <code>Array</code> prototype extensions.</td></tr>
<tr><td><code>import &quot;@ember/extensions/function&quot;</code></td><td>Adds just <code>Function</code> prototype extensions.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-11-18
RFC PR: https://github.com/emberjs/rfcs/pull/178
Ember Issue: https://github.com/emberjs/ember.js/issues/14746</p>
<hr />
<h1 id="summary-45"><a class="header" href="#summary-45">Summary</a></h1>
<p>The <code>Ember.K</code> utility function is a low level utility that has lost most of its value today.</p>
<h1 id="motivation-46"><a class="header" href="#motivation-46">Motivation</a></h1>
<p>Let's start explaining what <code>Ember.K</code> is.</p>
<p>It is an utility function to avoid boilerplace code and limit the creation of function instances
in Ember's internals. The source code for this API is the following:</p>
<pre><code class="language-js">Ember.K = function() {
  return this;
}
</code></pre>
<p>In a world of globals, writing <code>somefn: Ember.K</code> was effectively shorter
than writing</p>
<pre><code class="language-js">someFn: function() {
  return this;
}
</code></pre>
<p>and generated fewer function allocations.</p>
<p>However with the introduction of ES6 modules and the modularization of Ember
in process (#176), keeping this feature would require to design an import path for it.</p>
<p>While doable, the transpiled output is actually bigger then defining the functions
inline, specially with the ES6 shorthand method syntax, and the perf difference
of saving a few function allocations is negligible.</p>
<p>The second downside of reusing the same instance in many places is that if for
some reason the VM deoptimizes that function, that deoptimization is spreaded
across all the usages of <code>Ember.K</code>.</p>
<p>Third, the chainable nature of <code>Ember.K</code> tends to surprise the users:</p>
<pre><code class="language-js">let derp = {
  foo: Ember.K,
  bar: Ember.K,
  baz: Ember.K
}

derp.foo().bar().baz(); // O_o
</code></pre>
<p>And lastly but more importantly for simplicity. Consider the following code:</p>
<pre><code class="language-js">export default Component.extend({
  onSubmit() {}
});
</code></pre>
<p>Any JS developer will understand that this is an empty function and will probably understand
that is a placeholder to provide your own function instead. However, JS developers that come
across <code>Ember.K</code> for the first time will se this:</p>
<pre><code class="language-js">export default Component.extend({
  onSubmit: Ember.K
});
</code></pre>
<p>and will think that it is some cryptic Ember magic that they have to learn.</p>
<h1 id="transition-path-1"><a class="header" href="#transition-path-1">Transition Path</a></h1>
<p>The necessary first step is to make sure Ember, Ember Data and other pieces of the
ecosystem don't use <code>Ember.K</code> internally.</p>
<p>Phased approach:</p>
<ul>
<li>Deprecate <code>Ember.K</code>: Use the deprecation API to signal the deprecation, and deprecation guide entry.
Target version will be 3.0, as usual.</li>
<li>Add rule to ember-watson</li>
<li>Do not include export path in https://github.com/emberjs/rfcs/pull/176, but include it until 3.0 in the &quot;globals&quot; build.</li>
</ul>
<h1 id="how-we-teach-this-20"><a class="header" href="#how-we-teach-this-20">How We Teach This</a></h1>
<p>Since it is a very low-level utility,
the amount of people that will have to update their code should be a limited set of developers, working mostly on addons.
This allows us to cover most use cases with the following strategy:</p>
<ul>
<li>Improve the current documentation to help developers finding the API for the first time in the future;</li>
<li>Provide an automated path forward through tooling such as <a href="https://github.com/abuiles/ember-watson">ember-watson</a>. (see Addendum 1)</li>
<li>Introduce the mandatory entry in the deprecations guide referencing the automated tooling.</li>
</ul>
<p>If this RFC is done as part of https://github.com/emberjs/rfcs/pull/176 as suggested,
it will be in the document or blog post announcing the final transition to modules.</p>
<h1 id="drawbacks-44"><a class="header" href="#drawbacks-44">Drawbacks</a></h1>
<p>Although this utility is not very used, there is a chance that is used by some
addons and as a placeholder of a hook that is called a lot and would trigger
hundreds of deprecation warnings.</p>
<h1 id="alternatives-45"><a class="header" href="#alternatives-45">Alternatives</a></h1>
<p>The feature could continue to exist.</p>
<h1 id="addenda-1"><a class="header" href="#addenda-1">Addenda</a></h1>
<h2 id="addendum-1---codemod-to-automatically-remove-all-usages-of-emberk-on-any-project"><a class="header" href="#addendum-1---codemod-to-automatically-remove-all-usages-of-emberk-on-any-project">Addendum 1 - Codemod to automatically remove all usages of <code>Ember.K</code> on any project.</a></h2>
<p>https://github.com/cibernox/ember-k-codemod</p>
<p>To use it you can install it globally and invoke the command on any app or addon.</p>
<p>The commands <strong>requires</strong> the user to decide the approach to replace occurenced of <code>Ember.K</code>. The
possible flags are <code>--empty</code> and <code>--return-this</code>.</p>
<ul>
<li><code>--empty</code> replaces <code>Ember.K</code> with an empty function. This leads to the most idiomatic and
intention-revealing code, but does not allow chaining, like the original <code>Ember.K</code> did.
Despite of that, chaining <code>Ember.K</code> was such an uncommon patterns that we thing virtually
everybody can use this option.</li>
<li><code>--return-this</code> replaces <code>Ember.K</code> with a function that just returns <code>this</code>. This allows chaining
like the original one.</li>
</ul>
<p>Example usage:</p>
<pre><code>npm install -g ember-k-codemod &amp;&amp; ember-k-codemod --empty
</code></pre>
<p>Versions of <a href="https://github.com/abuiles/ember-watson">ember-watson</a> starting in <code>0.8.5</code> wrap this
codemod so you can achieve the same transformation with it:</p>
<pre><code>ember-watson remove-ember-k --empty

// or if installed as an addon

ember watson:remove-ember-k --empty
</code></pre>
<h2 id="addendum-2---emberk-usage-across-published-addons"><a class="header" href="#addendum-2---emberk-usage-across-published-addons">Addendum 2 - <code>Ember.K</code> usage across published addons</a></h2>
<pre><code>ae-select/addon/components/ae-select.js:  action: Ember.K, // action to fire on change
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-change': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-add': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:    'on-search': Ember.K,
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-add') !== Ember.K;
antd-ember/addon/components/io-searchable-select/searchable-select.js:        return this.get('on-search') === Ember.K;
ella-list-view/addon/views/list-item.coffee:  prepareContent: Ember.K
ella-list-view/addon/views/list-item.coffee:  teardownContent: Ember.K
ella-list-view/addon/views/list.coffee:  arrayWillChange: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToTop: Ember.K
ella-list-view/addon/views/list.coffee:  didScrollToBottom: Ember.K
ella-list-view/addon/views/list.coffee:  visibleItemsDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    if @didRequestRange isnt Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:    unless (@didRequestLength is Ember.K) or get(@, 'isRequestingLength')
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentWillChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  sparseContentDidChange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didReplaceSparseArrayItem: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestIndex: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestRange: Ember.K
ella-sparse-array-controller/addon/controllers/sparse-array.coffee:  didRequestLength: Ember.K
elvis-network/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
elvis-network/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-animate/ember-animate.js:        willAnimateIn : Ember.K,
ember-animate/ember-animate.js:        willAnimateOut : Ember.K,
ember-animate/ember-animate.js:        didAnimateIn : Ember.K,
ember-animate/ember-animate.js:        didAnimateOut : Ember.K,
ember-animate/ember-animate.js:        _currentViewWillChange : Ember.K,
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  action: Ember.K, //@public
ember-aupac-typeahead/addon/components/aupac-typeahead.js:  source : Ember.K, //@public
ember-autoresize/addon/mixins/autoresize.js:let trim = Ember.K;
ember-bootstrap/addon/components/bs-form-element.js:  setupValidations: Ember.K,
ember-bootstrap/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bootstrap-components/addon/components/bs-select.js:  action: Ember.K, // action to fire on change
ember-bugsnag/app/instance-initializers/bugsnag.js:  let originalOnError = Ember.onerror || Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/bubble-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/horizontal-bar-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/pie-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/scatter-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/stacked-vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/time-series-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/components/vertical-bar-chart.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/legend.js:      return Ember.K;
ember-charts/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-charts/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeStart: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResizeEnd: Ember.K,
ember-charts/dependencies/ember-addepar-mixins/resize_handler.js:  onResize: Ember.K,
ember-cli-adapter-pattern/tests/dummy/app/starships/starship.js:  _makeItSo: Ember.K
ember-cli-airbrake/README.md:In all cases, an `airbrake` service will be exposed. If airbrake isn't configured the airbrake service uses the Ember.K &quot;no-op&quot; function for its methods. This facilitates the usage of the airbrake service without having to add environment-checking code in your app.
ember-cli-airbrake/README.md:exist, but all its methods will be no-ops (`Ember.K`). This way your tests will still run happily even
ember-cli-airbrake/app/instance-initializers/ember-cli-airbrake.js:  let originalOnError = Ember.onerror || Ember.K;
ember-cli-analytics/addon/integrations/base.js:  trackPage: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackEvent: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  trackConversion: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  identify: Ember.K,
ember-cli-analytics/addon/integrations/base.js:  alias: Ember.K
ember-cli-analytics/tests/unit/mixins/trackable-test.js:  const analytics = { trackPage: Ember.K };
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      initialValue: Ember.K
ember-cli-aptible-shared/tests/unit/utils/changeset-test.js:      key: Ember.K
ember-cli-bugsnag/app/instance-initializers/bugsnag.js:      const originalDidTransition = router.didTransition || Ember.K;
ember-cli-coreweb/app/initializers/ember-coreweb.js:  initialize: Ember.K
ember-cli-dialog/packages/ember-dialog/lib/ember-initializer.js:// var K = Ember.K;
ember-cli-dimple/addon/components/dimple-chart/component.coffee:  customizeChart: Ember.K
ember-cli-dimple/addon/components/dimple-chart/component.js:  customizeChart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeStart: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResizeEnd: Ember.K,
ember-cli-dimple/addon/mixins/resize.js:  onResize: Ember.K,
ember-cli-dynamic-forms/addon/components/dynamic-form.js:  renderSchema: Ember.K,
ember-cli-erraroo/addon/erraroo.js:    const oldEmberOnerror = Ember.onerror || Ember.K;
ember-cli-fullpagejs-view/addon/initializers/remove-fullpage.js:  initialize: Ember.K
ember-cli-infinite-scroll/addon/mixins/infinite-scroll.js:  beforeInfiniteQuery: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:          onChange: Ember.K,
ember-cli-ion-rangeslider/addon/ember-ion-rangeslider.js:      options.onFinish = Ember.K;
ember-cli-jsoneditor/addon/components/json-editor.js:  onChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onError: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onModeChange: Ember.K,
ember-cli-jsoneditor/addon/components/json-editor.js:  onEditable: Ember.K,
ember-cli-maskedinput/addon/components/masked-input.js:  'on-change': Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  beforeSetup: Ember.K,
ember-cli-nvd3/addon/components/nvd3-chart.js:  afterSetup: Ember.K,
ember-cli-nvd3-multichart/addon/components/nvd3-multichart.js:  chartContextFn: Ember.K,
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-remote-inspector/tests/acceptance.js:    this.ember.kill('SIGINT');
ember-cli-selectize/addon/components/ember-selectize.js:  _groupedContentArrayWillChange: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  didCreateLayer: Ember.K,
ember-cli-visjs/addon/components/visjs-child.js:  willDestroyLayer: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-collection/addon/components/ember-collection.js:          willChange: Ember.K,
ember-concurrency/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-confirm-dialog/addon/components/confirm-dialog.js:  confirmAction: Ember.K,//optional action executed when user confirms the dialog
ember-confirm-dialog/addon/components/confirm-dialog.js:  cancelAction: Ember.K,//optional action executed when user cancels confirmation dialog
ember-cookie-consent-cnil/app/mixins/click-else-where.js:  onOutsideClick: Ember.K,
ember-data-model-fragments/addon/states.js:  propertyWasReset: Ember.K,
ember-data-model-fragments/addon/states.js:  becomeDirty: Ember.K,
ember-data-model-fragments/addon/states.js:  rolledBack: Ember.K,
ember-data-model-fragments/addon/states.js:      pushedData: Ember.K,
ember-data-model-fragments/addon/states.js:      didCommit: Ember.K,
ember-data-sails/addon/initializers/ember-data-sails.js:      methods[level] = Ember.K;
ember-dev-fixtures/private/utils/dev-fixtures/module.js:      define(this.get('fullPath'), ['exports'], Ember.K);
ember-dp-map/addon/components/_dp-base-map-element.js:  didLoadMap: Ember.K
ember-drag-drop/addon/mixins/droppable.js:  acceptDrop: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOver: Ember.K,
ember-drag-drop/addon/mixins/droppable.js:  handleDragOut: Ember.K,
ember-form-object/tests/unit/forms/model-form-test.js:  }).catch(Ember.K);
ember-froala/addon/components/froala-editor.js:        var buttons = this.get('customButtons') || Ember.K;
ember-google-charts/tests/integration/components/options-change-test.js:    this.on('chartDidRender', Ember.K);
ember-img-cache/app/initializers/ember-img-cache.js:  initialize: Ember.K
ember-img-manager/app/utils/img-manager/img-clone-holder.js:  this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:      this.handler = Ember.K;
ember-img-manager/app/utils/img-manager/img-clone-holder.js:   * @param {Function} [handler=Ember.K]
ember-img-manager/app/utils/img-manager/img-clone-holder.js:    this.handler = handler || Ember.K;
ember-infinity/tests/unit/mixins/route-test.js:      pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-infinity/tests/unit/mixins/route-test.js:        pushObjects: Ember.K,
ember-jsonapi-resources/addon/adapters/application.js:    let cleanup = Ember.K;
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = {deserialize: sandbox.spy(), deserializeIncluded: Ember.K};
ember-jsonapi-resources/tests/unit/adapters/application-test.js:  adapter.serializer = { deserialize: sandbox.spy(), deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/fetch-test.js:  this.subject.serializer = { deserialize: function(res) { return res.data; }, deserializeIncluded: Ember.K };
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:        trigger: Ember.K
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      guns: {kind: 'hasMany', mapBy: Ember.K }, // hasMany('guns')
ember-jsonapi-resources/tests/unit/mixins/resource-operations-test.js:      horse: {kind: 'hasOne', get: Ember.K } // hasOne('horse')
ember-jsonapi-resources-form/addon/components/resource-form.js:    if (!action) { return Ember.K; /* fail silently if no action */ }
ember-jsonapi-resources-list/addon/mixins/controllers/jsonapi-list.js:    filtering: Ember.K,
ember-key-responder/app/key-responder.js:    comments for Ember.KeyResponderStack above for more insight.
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onSelect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown-item.js:   onDeselect: Ember.K,
ember-list-card/addon/components/list-card/header-dropdown.js:  onItemSelect: Ember.K,
ember-list-card/addon/components/list-card/header.js:  onQueryOptionSelect: Ember.K,
ember-material-design/addon/mixins/events.js:    start: Ember.K,
ember-material-design/addon/mixins/events.js:    move: Ember.K,
ember-material-design/addon/mixins/events.js:    end: Ember.K
ember-material-design/addon/mixins/gesture-events.js:    onStart: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onMove: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onEnd: Ember.K,
ember-material-design/addon/mixins/gesture-events.js:    onCancel: Ember.K,
ember-material-design/app/services/ripple.js:            return Ember.K;
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  init: Ember.K,
ember-metrics/tests/dummy/app/metrics-adapters/local-dummy-adapter.js:  willDestroy: Ember.K
ember-mixpanel/addon/mixpanel.js:          return Ember.K;
ember-mixpanel/addon/mixpanel.js:      return Ember.K;
ember-notifyme/addon/objects/notification-message.js:  onClick: Ember.K,
ember-notifyme/addon/objects/notification-message.js:  onClose: Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClick: options.onClick || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onClose: options.onClose || Ember.K,
ember-notifyme/addon/services/notification-service.js:           onCloseTimeout: options.onCloseTimeout || Ember.K,
ember-off-canvas-components/addon/initializers/custom-events.js:  initialize: Ember.K
ember-pardon/addon/mixins/ember-pardon.js:	beforeDestroy: Ember.K,
ember-phoenix-channel/tests/integration/components/socket-message-log-test.js:  on: Ember.K
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayOpen: Ember.K,
ember-pikaday/addon/components/pikaday-inputless.js:  onPikadayClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onOpen: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onClose: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onSelection: Ember.K,
ember-pikaday/addon/mixins/pikaday.js:  onDraw: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayOpen: Ember.K,
ember-pikaday-with-time/addon/components/pikaday-input.js:  onPikadayRedraw: Ember.K,
ember-processes/addon/utils.js:      let disposer = typeof maybeDisposer === 'function' ? maybeDisposer : Ember.K;
ember-render-stack/addon/route-mixin.js:  renderStack: Ember.K,
ember-restless/dist/ember-restless.js:  var noop = Ember.K;
ember-restless/dist/ember-restless.js:    _onPropertyChange: Ember.K
ember-restless/src/model/read-only-model.js:  _onPropertyChange: Ember.K
ember-restless/src/model/state.js:var noop = Ember.K;
ember-reveal-js/addon/components/reveal-presentation/component.js:      before: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onOpen: Ember.K,
ember-rl-dropdown/addon/mixins/rl-dropdown-component.js:  onClose: Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-change': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-add': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-search': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:  'on-close': Ember.K,
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-add') !== Ember.K;
ember-searchable-select/addon/components/searchable-select.js:    return this.get('on-search') === Ember.K;
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-change                 | Specify your own named action to trigger when the selection changes. eg. &lt;code&gt;(action &quot;update&quot;)&lt;/code&gt; &lt;br&gt; For single selection (default behaviour), the selected object is sent as an argument. For multiple selections, an array of options is sent. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-add                    | Allow unfound items to be added to the content array by specifying your own named action. eg. `(action &quot;addNew&quot;)` The new item name is sent as an argument. You must handle adding the item to the content array and selecting the new item outside the component. | Ember action  | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    provided.     | Ember action    | Ember.K
ember-searchable-select/tests/dummy/app/pods/components/options-table/template.hbs:    on-close                  | Specify your own named action to trigger when the menu closes. Useful hook for clearing out content that was previously passed in with AJAX. | Ember action | Ember.K
ember-select-list/addon/components/select-list.js:  action: Ember.K, // action to fire on change
ember-smart-banner/addon/components/smart-banner.js:      const visitFn = Ember.getWithDefault(this, 'attrs.onvisit', Ember.K);
ember-smart-banner/addon/components/smart-banner.js:      const closeFn = Ember.getWithDefault(this, 'attrs.onclose', Ember.K);
ember-sqlite-adapter/addon/migration.js:  run: Ember.K,
ember-stripe-service/addon/services/stripe.js:      this.card[name] = Ember.K;
ember-table/addon/components/ember-table.js:    addColumn: Ember.K,
ember-table/addon/components/ember-table.js:    sortByColumn: Ember.K
ember-table/addon/mixins/mouse-wheel-handler.js:  onMouseWheel: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeStart: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResizeEnd: Ember.K,
ember-table/addon/mixins/resize-handler.js:  onResize: Ember.K,
ember-table/addon/mixins/scroll-handler.js:  onScroll: Ember.K,
ember-table/addon/mixins/touch-move-handler.js:  onTouchMove: Ember.K,
ember-table/addon/models/column-definition.js:  setCellContent: Ember.K,
ember-table/addon/views/lazy-item.js:  prepareContent: Ember.K,
ember-table/addon/views/lazy-item.js:  teardownContent: Ember.K,
ember-ted-select/README.md:      &lt;td&gt;&lt;code&gt;Ember.K&lt;/code&gt; (noop)&lt;/td&gt;
ember-ted-select/tests/dummy/app/pods/application/template.hbs:        &lt;td&gt;&lt;code&gt;Ember.K&lt;/code&gt; (noop)&lt;/td&gt;
ember-theater/addon/ember-theater/director/directions/sound.js:  fadeTo(volume, duration, callback = Ember.K) {
ember-to-string/tests/unit/helpers/to-string-test.js:    lookup: Ember.K
ember-ui-components/addon/mixins/click-outside.js:  handleClickOutside: Ember.K,
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/access-test.js:  subject.set('authorize', Ember.K);
ember-unauthorized/tests/unit/mixins/route-access-test.js:      transitionTo: Ember.K
ember-watson/tests/fixtures/resource-router-mapping/new-complex-ember-cli-sample.js:    }, Ember.K);
ember-watson/tests/fixtures/resource-router-mapping/old-complex-ember-cli-sample.js:    this.resource('dashboard', Ember.K);
emberx-select/addon/components/x-select.js:  &quot;on-blur&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-click&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-change&quot;: Ember.K,
emberx-select/addon/components/x-select.js:  &quot;on-focus-out&quot;: Ember.K,
fireplace/addon/collections/indexed.js:      then(Ember.K.bind(this));
fireplace/addon/collections/object.js:    const promise = this.listenToFirebase().then(Ember.K.bind(this));
justa-table/addon/components/table-vertical-collection.js:  'on-row-click': Ember.K
list-view/addon/list-view-mixin.js:  _scrollTo: Ember.K,
list-view/addon/list-view-mixin.js:  arrayWillChange: Ember.K,
list-view/addon/reusable-list-item-view.js:  prepareForReuse: Ember.K,
mantel/addon/fireplace/collections/indexed.js:      then(Ember.K.bind(this));
mantel/addon/fireplace/collections/object.js:    var promise = this.listenToFirebase().then(Ember.K.bind(this));
plaid/addon/mixins/dimensions.js:  didMeasureDimensions: Ember.K,
plaid/addon/mixins/global-resize.js:  didResize: Ember.K
spree-ember-paypal-express/addon/services/paypal-express.js:  spree: Ember.K,
torii/addon/services/torii-session.js:  setUnknownProperty: Ember.K,
torii/tests/unit/redirect-handler-test.js:    close: Ember.K
torii/tests/unit/services/popup-test.js:    focus: Ember.K,
torii/tests/unit/services/popup-test.js:    close: Ember.K
</code></pre>
<h2 id="addendum-3---emberk-usage-via-destructuring-across-published-addons"><a class="header" href="#addendum-3---emberk-usage-via-destructuring-across-published-addons">Addendum 3 - <code>Ember.K</code> usage via destructuring across published addons</a></h2>
<pre><code>CogAuth/tests/helpers/flash-message.js:const { K } = Ember;
ember-annotative-models/addon/utils/action.coffee:{K, isBlank, A} = Ember
ember-annotative-models/tests/unit/utils/action-test.coffee:{K} = Ember
ember-cli-airbrake/addon/utils/get-client.js:const { K } = Ember;
ember-cli-flash/blueprints/ember-cli-flash/files/tests/helpers/flash-message.js:const { K } = Ember;
ember-cli-mapkit/addon/components/ui-abstract-map.js:const {isEmpty, computed, on, K, run} = Ember;
ember-cli-pixijs/addon/components/pixi-canvas.js:const { Component, computed, K } = Ember;
ember-click-outside/addon/mixins/click-outside.js:const { computed, K } = Ember;
ember-composable-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-composable-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-composable-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-d3-helpers/tests/unit/helpers/d3-line-test.js:const { K } = Ember;
ember-form-object/addon/forms/model-form.js:const { ObjectProxy, computed, computed: { readOnly }, assert, Logger, run, A: createArray, K: noop, String: { camelize } } = Ember;
ember-form-tool/addon/mixins/drag-drop.coffee:{K, Mixin, computed: {equal}} = Ember
ember-functional-helpers/addon/-private/create-needle-haystack-helper.js:const { K, isEmpty } = Ember;
ember-functional-helpers/tests/unit/helpers/pipe-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-functional-helpers/tests/unit/helpers/queue-test.js:const { RSVP: { resolve, reject }, K } = Ember;
ember-imdt-magic-crud/tests/helpers/flash-message.js:const { K } = Ember;
ember-keyword-complete/addon/components/keyword-complete.js:const {observer, computed, run, assert, K, $} = Ember;
ember-leaflet/addon/components/base-layer.js:const { assert, computed, Component, run, K, A, String: { classify } } = Ember;
ember-light-table/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-metrics/tests/unit/services/metrics-test.js:const { get, set, K } = Ember;
ember-paper/addon/components/paper-autocomplete.js:const { assert, computed, inject, isNone, defineProperty, K: emberNop } = Ember;
ember-paper/addon/mixins/events-mixin.js:const { Mixin, K } = Ember;
ember-redux/app/services/redux.js:const { assert, isArray, K } = Ember;
ember-responsive/blueprints/ember-responsive/files/tests/helpers/responsive.js:const { K, getOwner } = Ember;
ember-select-box/addon/mixins/select-box/select-box/inputtable.js:const { K } = Ember;
ember-shepherd/addon/services/tour.js:const { Evented, K, Service, isPresent, run, $, isEmpty, observer } = Ember;
ember-simple-auth/addon/session-stores/cookie.js:const { RSVP, computed, run: { next, cancel, later, scheduleOnce }, isEmpty, typeOf, testing, isBlank, isPresent, K, A } = Ember;
ember-simple-auth/tests/unit/internal-session-test.js:const { RSVP, K, run: { next } } = Ember;
ember-simple-auth/tests/unit/session-stores/shared/store-behavior.js:const { run: { next }, K } = Ember;
ember-simple-auth-chrome-app/tests/unit/session-stores/shared/store-behavior.js:const { K, run: { next } } = Ember;
ember-sinon-qunit/tests/helpers/assert-sinon-in-test-context.js:const { K: EmptyFunc, typeOf } = Ember;
ember-user-activity/tests/unit/services/user-activity-test.js:const { A: emberArray, K: noOp, typeOf } = Ember;
ui-bootstrap/tests/helpers/flash-message.js:const { K } = Ember;
yes-or-no/tests/helpers/responsive.js:const { K, getOwner } = Ember;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-11-22
RFC PR: https://github.com/emberjs/rfcs/pull/181</p>
<hr />
<h1 id="summary-46"><a class="header" href="#summary-46">Summary</a></h1>
<p>The goal of this RFC is to remove the <code>data-adapter</code>, <code>injectStore</code>,
<code>transforms</code>, and <code>store</code> Ember application initializers that Ember Data injects
into apps.  The <code>ember-data</code> initializer will not be changed and any code
that previously depended on the ordering of these initializers (via
the <code>before</code> or <code>after</code> properties on an initalizer) can be
changed to use the <code>ember-data</code> initializers for ordering.</p>
<h1 id="motivation-47"><a class="header" href="#motivation-47">Motivation</a></h1>
<p>The initializers <code>data-adapter</code>, <code>injectStore</code>, <code>transforms</code>, and
<code>store</code> have not been used by Ember Data since
<a href="https://github.com/emberjs/data/commit/d25e23f622a3677b8372db535b2ab824ad306a16">Apr 8, 2014</a>. However,
they are still injected into every Ember app that depends on Ember
Data because existing apps may depend on these initializers
for ordering their own initializers to run before or after Ember
Data's setup code.</p>
<p>Removing these initializers will help reduce the amount of code Ember
Data needs to support.</p>
<p>Since these initializers are noop functions that run after the
<code>ember-data</code> initializer, any initializers that depends on one of the
deprecated initializers listed in this rfc can easly be replaced by
depending on the <code>ember-data</code> initializer instead.</p>
<h1 id="detailed-design-45"><a class="header" href="#detailed-design-45">Detailed design</a></h1>
<p>Ember Data's instance initializer will start checking for any
initializers whose <code>before</code> or <code>after</code> properties depend on one of
these deprecated initalizer. If it finds an initalizer that references
one of the deprecated initalizers, Ember Data will then log a
deprecation message that states the name of the offending initalizers
and suggest changing the <code>before</code> or <code>after</code> property (the deprecation
message will refer to the correct property dynamically) to depend on
Ember Data instead.</p>
<p>This deprecation message will continue to appear until Ember Data
3.0.0 when these initalizers and the deprecation code will be finally
removed.</p>
<h1 id="how-we-teach-this-21"><a class="header" href="#how-we-teach-this-21">How We Teach This</a></h1>
<p>This change should have no impact on how we teach Ember or Ember
Data. The initalizers that will be removed have been unused for a long
time and are not mentioned anywhere in today's guides or API docs.</p>
<p>Users who need to run initalizer code before or after Ember Data
injects the store into routes should be taught to use <code>before: 'ember-data'</code>, or <code>after: 'ember-data'</code> on their initializers.</p>
<h1 id="drawbacks-45"><a class="header" href="#drawbacks-45">Drawbacks</a></h1>
<ul>
<li>This change will require users who depend on these deprecated initalizers to update their code.</li>
</ul>
<h1 id="alternatives-46"><a class="header" href="#alternatives-46">Alternatives</a></h1>
<ul>
<li>We could leave the noop initalizers in Ember Data and continue to support them in Ember Data 3.0.0 and beyond.</li>
</ul>
<h1 id="unresolved-questions-39"><a class="header" href="#unresolved-questions-39">Unresolved questions</a></h1>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-05
RFC PR: https://github.com/emberjs/rfcs/pull/186</p>
<hr />
<h1 id="summary-47"><a class="header" href="#summary-47">Summary</a></h1>
<p>Track unique history location states</p>
<h1 id="motivation-48"><a class="header" href="#motivation-48">Motivation</a></h1>
<p>The path alone does not provide enough information. For example, if you
visit page A, scroll down, then click on a link to page B, then click on
a link back to page A. Your actual browser history stack is [A, B, A].
Each of those nodes in the history should have their own unique scroll
position. In order to record this position we need a UUID 
for each node in the history.</p>
<p>This API will allow other libraries to reflect upon each location to
determine unique state. For example,
<a href="https://github.com/dollarshaveclub/ember-router-scroll">ember-router-scroll</a>
is making use of a <a href="https://github.com/dollarshaveclub/ember-router-scroll/blob/master/addon/locations/router-scroll.js">modified <code>Ember.HistoryLocation</code> object to get this
behavior</a>.</p>
<p>Tracking unique state is required when setting the scroll position
properly based upon where you are in the history stack, as described in
<a href="0186-track-unique-history-location-state.html#motivation">Motivation</a></p>
<h1 id="detailed-design-46"><a class="header" href="#detailed-design-46">Detailed design</a></h1>
<p>Code: <a href="https://github.com/emberjs/ember.js/pull/14011">PR#14011</a></p>
<p>We simply unique identifier (UUID) so we can track uniqueness on two
dimensions. Both <code>path</code> and the generated <code>uuid</code>. A simple UUID
generator such as
https://gist.github.com/lukemelia/9daf074b1b2dfebc0bd87552d0f6a537
should suffice.</p>
<h1 id="how-we-teach-this-22"><a class="header" href="#how-we-teach-this-22">How We Teach This</a></h1>
<p>We could describe what meta data is generated for each location in the
history stack. For example, it could look like:</p>
<pre><code class="language-js">// visit page A

[
  { path: '/', uuid: 1 }
]

// visit page B

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// visit page A

[
  { path: '/', uuid: 3 },
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]

// click back button

[
  { path: '/about', uuid: 2 },
  { path: '/', uuid: 1 }
]
</code></pre>
<h1 id="drawbacks-46"><a class="header" href="#drawbacks-46">Drawbacks</a></h1>
<ul>
<li>The property access is writable</li>
</ul>
<h1 id="alternatives-47"><a class="header" href="#alternatives-47">Alternatives</a></h1>
<p>The purpose for this behavior is to enable scroll position libraries.
There are two other solutions in the wild. One is in the guides that
suggests resetting the scroll position to <code>(0, 0)</code> on each new route
entry. The other is
<a href="https://github.com/ef4/memory-scroll">ember-memory-scroll</a> which I
believe is better suited for tracking scroll positions for components
rather than the current page.</p>
<p>However, in both cases neither solution provides the experience that
users have come to expect from server-rendered pages. The browser tracks
scroll position and restores it when you revisit the page in the history
stack. The scroll position is unique even if you have multiple instances
of the same page in the stack.</p>
<h1 id="unresolved-questions-40"><a class="header" href="#unresolved-questions-40">Unresolved questions</a></h1>
<p>None at this time.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-14
RFC PR: https://github.com/emberjs/rfcs/pull/191
Ember Issue: https://github.com/emberjs/ember.js/pull/14711</p>
<hr />
<h1 id="summary-48"><a class="header" href="#summary-48">Summary</a></h1>
<p>We would like to deprecate and remove the <strong>arguments</strong> passed to the <code>didInitAttrs</code>, <code>didReceiveAttrs</code> and <code>didUpdateAttrs</code> component lifecycle hooks. These arguments are currently undocumented on purpose and considered a private API, imposes an unnecessary performance hit on <em>all</em> components whether they are used or not, and can be easily replicated by the users in cases where they are needed.</p>
<h1 id="motivation-49"><a class="header" href="#motivation-49">Motivation</a></h1>
<p>In the road leading up to Ember.js 2.0, <a href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html#toc_component-lifecycle-hooks">new lifecycle hooks</a> were introduced to components in order to help users shift to a new mental model, dubbed Data Down Actions Up. The hooks were introduced by name, and their semantics explained, but there were no mentions of possible arguments received by them.</p>
<p>This lack of documentation for lifecycle hook arguments was deliberate. The hooks were introduced as an experiment with an eye to the then-upcoming angle bracket components, so the arguments to the hooks were considered private by the framework maintainers, as their design was still ongoing.</p>
<p>However, references to the lifecycle hook arguments started appearing in community resources. Users started betting on these arguments as the way forward, which in conjunction with the lack of an RFC process and clear messaging from the Ember.js maintainers lead to confusion.</p>
<p>This left the core team in a difficult position. Despite no longer endorsing lifecycle hook arguments, trying to communicate such could have the reverse effect by pointing a spotlight at them. The purpose of this RFC is then to clarify that lifecycle hook arguments have no future in the framework, and you should update your code to not make use of them.</p>
<p>The reason to officially deprecate lifecycle hook arguments is not only about messaging, but also because providing these arguments imposes an unnecessary performance penalty to every component in your application even if the arguments are not used.</p>
<p>To provide the arguments to the lifecycle hooks, Ember.js has to eagerly &quot;reify&quot; and save-off any passed-in attributes to allow diffing and construct several wrapper objects. In the few occasions where this logic is actually necessary, developers should be able to use programmatic patterns familiar to them and manually track changes as needed, as exemplified in the Transition Path section below.</p>
<h1 id="transition-path-2"><a class="header" href="#transition-path-2">Transition Path</a></h1>
<p>The transition path followed will be the standard one, which encompasses using the deprecation API to deprecate the feature and the related deprecation guide. While the lifecycle hooks share a deprecation identifier, they will be addressed in turn.</p>
<h3 id="didinitattrs"><a class="header" href="#didinitattrs"><code>didInitAttrs</code></a></h3>
<p>Since this lifecycle hook is <a href="http://emberjs.com/deprecations/v2.x/#toc_ember-component-didinitattrs">already deprecated</a>, we suggest taking this chance to address two deprecations at the same time. Imagine you have a component that stores a timestamp when it's initialized for later comparison.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didInitAttrs({ attrs }) {
    this.set('initialTimestamp', attrs.timestamp);
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  init() {
    this._super(...arguments);

    this.set('initialTimestamp', this.get('timestamp'));
  }
});
</code></pre>
<h3 id="didreceiveattrs"><a class="header" href="#didreceiveattrs"><code>didReceiveAttrs</code></a></h3>
<p>Let's say you want to animate a map widget from the old coordinates to the new coordinates.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didReceiveAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs &amp;&amp; oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didReceiveAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates &amp;&amp; oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
</code></pre>
<h3 id="didupdateattrs"><a class="header" href="#didupdateattrs"><code>didUpdateAttrs</code></a></h3>
<p>This hook is very similar to <code>didReceiveAttrs</code>, except it only runs on re-renders and not the initial render.</p>
<p>Before:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didUpdateAttrs({ oldAttrs, newAttrs }) {
    if (oldAttrs &amp;&amp; oldAttrs.coordinates !== newAttrs.coordinates) {
      this.map.move({ from: oldAttrs.coordinates, to: newAttrs.coordinates });
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-javascript">Ember.Component.extend({
  didUpdateAttrs() {
    let oldCoordinates = this.get('_previousCoordinates');
    let newCoordinates = this.get('coordinates');

    if (oldCoordinates &amp;&amp; oldCoordinates !== newCoordinates) {
      this.map.move({ from: oldCoordinates, to: newCoordinates });
    }

    this.set('_previousCoordinates', newCoordinates);
  }
});
</code></pre>
<h1 id="how-we-teach-this-23"><a class="header" href="#how-we-teach-this-23">How We Teach This</a></h1>
<p>Due to the previous undocumented nature of the arguments, there is no official documentation that will require updating deprecated usage.</p>
<p>As required for framework deprecations, there will be a deprecation guide written up and linked from within the deprecation message. This deprecation guide will address the more common usage patterns associated with lifecycle hook arguments, such as the Transition Path example.</p>
<p>Additionally, the usage patterns present in the deprecation guide could also be documented in the component section of the official Guides, as a proactive approach for teaching newcomers.</p>
<h1 id="drawbacks-47"><a class="header" href="#drawbacks-47">Drawbacks</a></h1>
<p>One immediate drawback of this proposal is that due to references to the arguments in community resources, there are uses of them in the wild. Updating deprecated code will have to be done mostly manually, as automation might prove difficult.</p>
<p>Another drawback is that by the very nature of publishing this RFC, attention will be drawn to the arguments. It is our hope that the increased awareness will be a net positive due to the clear guidance gained by users of the framework.</p>
<p>It is then our assessment that these drawbacks are outweighed by the benefits of the change.</p>
<h1 id="alternatives-48"><a class="header" href="#alternatives-48">Alternatives</a></h1>
<p>There are two standout alternatives to the proposal presented here which are doing nothing, or making the arguments public and supporting them going forward, both of which are less than ideal for reasons stated previously.</p>
<p>Doing nothing would perpetuate the confusion surrounding lifecycle hook arguments. While it might be argued that that ship has sailed, we prefer to think that it's never too late to provide users of the framework with clearer messaging regarding usage of certain features.</p>
<p>Making the arguments public and supported would mean supporting APIs that did not go through the RFC process, meaning they do not align with some of the current values of the framework, nor would iteration on them would be possible without introducing breakage. Additionally, there are some performance penalties to supporting these arguments, mentioned in the Motivation section.</p>
<h1 id="unresolved-questions-41"><a class="header" href="#unresolved-questions-41">Unresolved questions</a></h1>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2016-12-24
RFC PR: https://github.com/emberjs/rfcs/pull/194
Ember Issue: https://github.com/emberjs/ember.js/issues/14754</p>
<hr />
<h1 id="summary-49"><a class="header" href="#summary-49">Summary</a></h1>
<p>Support for component <code>eventManger</code>s is a seldom used feature and should
be deprecated.</p>
<h1 id="motivation-50"><a class="header" href="#motivation-50">Motivation</a></h1>
<p>We should strive to simplify the Ember API and source code where possible. As
the custom <code>eventManager</code> feature is rarely used in apps, we should deprecate
it.</p>
<h1 id="detailed-design-47"><a class="header" href="#detailed-design-47">Detailed design</a></h1>
<p>We'll introduce a deprecation warning which will be displayed when a component
defines an <code>eventManager</code> property or when <code>canDispatchToEventManager</code> is set to
true on <code>EventDispatcher</code>. The warning will have a target version of <code>3.0</code>.</p>
<p>If required, we can create an addon which extends the <code>EventDispatcher</code> allowing
for opt-in custom <code>eventManager</code>s in Ember apps.</p>
<h1 id="how-we-teach-this-24"><a class="header" href="#how-we-teach-this-24">How We Teach This</a></h1>
<p>As this is a seldom used feature, we can simply note the deprecation in a
future release blog post.</p>
<h1 id="drawbacks-48"><a class="header" href="#drawbacks-48">Drawbacks</a></h1>
<p>This adds a little more churn for apps that rely on this feature.</p>
<h1 id="alternatives-49"><a class="header" href="#alternatives-49">Alternatives</a></h1>
<p>This feature was <a href="https://github.com/emberjs/ember.js/pull/14756">recently made pay-as-you-go</a>,
so the immediate performance concerns have been addressed. We could decide to
leave this in the framework as an opt-in feature.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-03-13
RFC PR: https://github.com/emberjs/rfcs/pull/213
Ember Issue: https://github.com/emberjs/ember.js/issues/16301</p>
<hr />
<h1 id="summary-50"><a class="header" href="#summary-50">Summary</a></h1>
<p>This RFC aims to expose a <em>low-level primitive</em> for defining <em>custom
components</em>.</p>
<p>This API will allow addon authors to provide special-purpose component base
classes that their users can subclass from in apps. These components are
invokable in templates just like any other Ember components (descendants of
<code>Ember.Component</code>) today.</p>
<h1 id="motivation-51"><a class="header" href="#motivation-51">Motivation</a></h1>
<p>The ability to author reusable, composable components is a core feature of
Ember.js. Despite being a <a href="http://emberjs.com/blog/2013/06/23/ember-1-0-rc6.html">last-minute addition</a>
to Ember 1.0, the <code>Ember.Component</code> API and programming model has proven itself
to be an extremely versatile tool and has aged well over time into the primary
unit of composition in Ember's view layer.</p>
<p>That being said, the current component API (hereinafter &quot;classic components&quot;)
does have some noticeable shortcomings. Over time, classic components have also
accumulated some cruft due to backwards compatibility constraints.</p>
<p>These problems led to the original &quot;angle bracket components&quot; proposal (see RFC
<a href="https://github.com/emberjs/rfcs/blob/master/text/0015-the-road-to-ember-2-0.md">#15</a>
and <a href="https://github.com/emberjs/rfcs/pull/60">#60</a>), which promised to address
these problems via the angle bracket invocation opt-in (i.e. <code>&lt;foo-bar ...&gt;</code>
instead of <code>{{foo-bar ...}}</code>).</p>
<p>Since the transition to the angle bracket invocation syntax was seen as a rare,
once-in-a-lifetime opportunity, it became very tempting to debate every single
shortcomings and missing features in the classic components API in the process
and attempt to design solutions for all of them.</p>
<p>While that discussion was very helpful in capturing constraints and guiding the
overall direction, designing that One True API™ in the abstract turned out to
be extremely difficult. It also went against our philosophy that framework
features should be extracted from applications and designed iteratively with
feedback from real-world usage.</p>
<p>Since that original proposal, we have rewritten Ember's rendering engine from
the ground up (the &quot;Glimmer 2&quot; project). One of the goals of the Glimmer 2
effort was to build first-class support for Ember's view-layer features into
the rendering engine. As part of the process, we worked to rationalize these
features and to re-think the role of components in Ember.js. This exercise has
brought plenty of new ideas and constraints to the table.</p>
<p>The initial Glimmer 2 integration was completed in <a href="http://emberjs.com/blog/2016/11/30/ember-2-10-released.html">Ember 2.10</a>.
As of that version, classic components have been re-implemented using the new
primitives provided by the rendering engine, and we are very happy with the
results.</p>
<p>This approach yielded a number of very powerful and flexible primitives:
in addition to classic components, we were able to implement Ember's
<code>{{mount}}</code>, <code>{{outlet}}</code> and <code>{{render}}</code> helpers as &quot;components&quot; under the
hood.</p>
<p>Based on our experience, we believe it would be beneficial to open up these new
primitives to the wider community. Specifically, there are at least two clear
benefits that comes to mind:</p>
<p>First, it provides addon authors fine-grained control over the exact behavior
and semantics of their components in cases where the general-purpose components
are a poor fit. For example, a low-overhead component designed to be used in
performance hotspot can opt-out of certain convinence features using this API.</p>
<p>Second, it allows the community to experiment with and iterate on alternative
component APIs outside of the core framework. Following the success of FastBoot
and Engines, we believe the best way to design the new &quot;Glimmer Components&quot; API
is to first stablize the underlying primitives in the core framework and
experiment with the surface API through an addon.</p>
<h1 id="detailed-design-48"><a class="header" href="#detailed-design-48">Detailed design</a></h1>
<p>This RFC introduces the concept of <em>component managers</em>. A component manager is
an object that is responsible for coordinating the lifecycle events that occurs
when invoking, rendering and re-rendering a component.</p>
<h2 id="registering-component-managers"><a class="header" href="#registering-component-managers">Registering component managers</a></h2>
<p>Component managers are registered with the <code>component-manger</code> type in the
application's registry. Similar to services, component managers are singleton
objects (i.e. <code>{ singleton: true, instantiate: true }</code>), meaning that Ember
will create and maintain (at most) one instance of each unique component
manager for every application instance.</p>
<p>To register a component manager, an addon will put it inside its <code>app</code> tree:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
</code></pre>
<p>(Typically, the convention is for addons to define classes like this in its
<code>addon</code> tree and then re-export them from the <code>app</code> tree. For brevity, we will
just inline them in the <code>app</code> tree directly for the examples in this RFC.)</p>
<p>This allows the component manager to participate in the DI system – receiving
injections, using services, etc. Alternatively, component managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/initializers/register-basic-component-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('component-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
</code></pre>
<h2 id="determining-which-component-manager-to-use"><a class="header" href="#determining-which-component-manager-to-use">Determining which component manager to use</a></h2>
<p>For the purpose of this section, we will assume components with a JavaScript
file (such as <code>app/components/foo-bar.js</code> or the equivilant in &quot;pods&quot; and
<a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">Module Unification</a>
apps) and optionally a template file (<code>app/templates/components/foo-bar.hbs</code>
or equivilant). The example section has additional information about how this
relates to <a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">template-only components</a>.</p>
<p>When invoking the component <code>{{foo-bar ...}}</code>, Ember will first resolve the
component class (<code>component:foo-bar</code>, usually the <code>default</code> export from
<code>app/components/foo-bar.js</code>). Next, it will determine the appropiate component
manager to use based on the resolved component class.</p>
<p>Ember will provide a new API to assign the component manager for a component
class:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('awesome', EmberObject.extend({
  // ...
}));
</code></pre>
<p>This tells Ember to use the <code>awesome</code> manager (<code>component-manager:awesome</code>) for
the <code>foo-bar</code> component. <code>setComponentManager</code> function returns the class.</p>
<p>In the future, this function can also be invoked as a decorator:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default @componentManager('awesome') EmberObject.extend({
  // ...
});
</code></pre>
<p>In reality, an app developer would never have to write this in their apps,
since the component manager would already be assigned on a super-class provided
by the framework or an addon. The <code>setComponentManager</code> function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers.</p>
<p>For example, the <code>Ember.Component</code> class would have the <code>classic</code> component
manager pre-assigned, therefore the following code will continue to work as
intended:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import Component from '@ember/component';

export default Component.extend({
  // ...
});
</code></pre>
<p>Similarly, an addon can provided the following super-class:</p>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { componentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  // ...
}));
</code></pre>
<p>With this, app developers can simply inherit from this in their app:</p>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import BasicComponent from 'ember-basic-component';

export default BasicComponent.extend({
  // ...
});
</code></pre>
<p>Here, the <code>foo-bar</code> component would automatically inherit the <code>basic</code> component
manager from its super-class.</p>
<p>It is not advisable to override the component manager assigned by the framework
or an addon. Attempting to reassign the component manager when one is already
assinged on a super-class will be an error. If no component manager is set, it
will also result in a runtime error when invoking the component.</p>
<h2 id="component-lifecycle"><a class="header" href="#component-lifecycle">Component Lifecycle</a></h2>
<p>Back to the <code>{{foo-bar ...}}</code> example.</p>
<p>Once Ember has determined the component manager to use, it will be used to
manage the component's lifecycle.</p>
<h3 id="createcomponent"><a class="header" href="#createcomponent"><code>createComponent</code></a></h3>
<p>The first step is to create an instance of the component. Ember will invoke the
component manager's <code>createComponent</code> method:</p>
<pre><code class="language-javascript">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  // ...
});
</code></pre>
<p>The <code>createComponent</code> method on the component manager is responsible for taking
the component's factory and the arguments passed to the component (the <code>...</code> in
<code>{{foo-bar ...}}</code>) and return an instantiated component.</p>
<p>The first argument passed to <code>createComponent</code> is the result returned from the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0150-factory-for.md"><code>factoryFor</code></a>
API. It contains a <code>class</code> property, which gives you the the raw class (the
<code>default</code> export from <code>app/components/foo-bar.js</code>) and a <code>create</code> function that
can be used to instantiate the class with any registered injections, merging
them with any additional properties that are passed.</p>
<p>The second argument is a snapshot of the arguments passed to the component in
the template invocation, given in the following format:</p>
<pre><code class="language-js">{
  positional: [ ... ],
  named: { ... }
}
</code></pre>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">{{blog-post (titleize post.title) post.body author=post.author excerpt=true}}
</code></pre>
<p>You will get the following as the second argument:</p>
<pre><code class="language-js">{
  positional: [
    &quot;Rails Is Omakase&quot;,
    &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&quot;
  ],
  named: {
    &quot;author&quot;: #&lt;User name=&quot;David Heinemeier Hansson&quot;, ...&gt;,
    &quot;excerpt&quot;: true
  }
}
</code></pre>
<p>The arguments object should not be mutated (e.g. <code>args.positional.pop()</code> is no
good). In development mode, it might be sealed/frozen to help prevent these
kind of mistakes.</p>
<h3 id="getcontext"><a class="header" href="#getcontext"><code>getContext</code></a></h3>
<p>Once the component instance has been created, the next step is for Ember to
determine the <code>this</code> context to use when rendering the component's template by
calling the component manager's <code>getContext</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  // ...
});
</code></pre>
<p>The <code>getContext</code> method gets passed the component instance returned from
<code>createComponent</code> and should return the object that <code>{{this}}</code> should refer to
in the component's template, as well as for any &quot;fallback&quot; property lookups
such as <code>{{foo}}</code> where <code>foo</code> is neither a local variable or a helper (which
resolves to <code>{{this.foo}}</code> where <code>this</code> is here is the object returned by
<code>getContext</code>).</p>
<p>Typically, this method can simpliy return the component instance, as shown in
the example above. The reason this exists as a separate method is to enable the
so-called &quot;state bucket&quot; pattern which allows addon authors to attach extra
book-keeping metadata to the component:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  // ...
});
</code></pre>
<p>Since the &quot;state bucket&quot;, not the &quot;context&quot;, is passed back to other hooks on
the component manager, this allows the component manager to access the extra
metadata but otherwise hide them from the app developers.</p>
<p>We will see an example that uses this pattern in a later section.</p>
<p>At this point, Ember will have gathered all the information it needs to render
the component's template, which will be rendered with <a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">&quot;Outer HTML&quot; semantics</a>.</p>
<p>In other words, the content of the template will be rendered as-is, without a
wrapper element (e.g. <code>&lt;div id=&quot;ember1234&quot; class=&quot;ember-view&quot;&gt;...&lt;/div&gt;</code>),
except for subclasses of <code>Ember.Component</code>, which will retain the current
legacy behavior (the internal <code>classic</code> manager uses private capabilities to
achieve that).</p>
<p>This API does not currently provide any way to fine-tune the rendering behavior
(such as dynamically changing the component's template) besides <code>getContext</code>,
but future iterations may introduce extra capabilities.</p>
<h3 id="updatecomponent"><a class="header" href="#updatecomponent"><code>updateComponent</code></a></h3>
<p>When it comes time to re-render a component's template (usually because an
argument has changed), Ember will call the manager's <code>updateComponent</code> method
to give the manager an opportunity to reflect those changes on the component
instance, before performing the re-render:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  // ...
});
</code></pre>
<p>The first argument passed to this method is the component instance returned by
<code>createComponent</code>. As mentioned above, using the &quot;state bucket&quot; pattern will
allow this hook to access the extra metadata:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    let metadata = { ... };
    let instance = factory.create(args.named);
    return { metadata, instance, ... };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let { metadata, instance } = bucket;
    // do things with metadata
    instance.setProperties(args.named);
  },

  // ...
});
</code></pre>
<p>The second argument is a snapshot of the updated arguments, passed with the
same format as in <code>createComponent</code>. Note that there is no guarentee that
anything in the arguments object has <em>actually</em> changed when this method is
called. For example, given:</p>
<pre><code class="language-hbs">{{blog-post title=(uppercase post.title) ...}}
</code></pre>
<p>Imagine if <code>post.title</code> changed from <code>fOo BaR</code> to <code>FoO bAr</code>. Since the value
is passed through the <code>uppercase</code> helper, the component will see <code>FOO BAR</code> in
both cases.</p>
<p>Generally speaking, Ember does not provide any guarentee on how it determines
whether components need to be re-rendered, and the semantics may vary between
releases – i.e. this method may be called more or less often as the internals
changes. The <em>only</em> guarentee is that if something <em>has</em> changed, this method
will definitely be called.</p>
<p>If it is important to your component's programming model to <em>only</em> notify the
component when there are actual changes, the manager is responsible for doing
the extra book-keeping.</p>
<p>For example:</p>
<pre><code class="language-js">// ember-basic-component/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('basic', EmberObject.extend({
  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentWillChange: NOOP,

  // Users of BasicComponent can override this hook to be notified when an
  // argument will change
  argumentDidChange: NOOP,

  // ...
}));
</code></pre>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createComponent(factory, args) {
    return {
      args: args.named,
      instance: factory.create(args.named)
    };
  },

  getContext(bucket) {
    return bucket.instance;
  },

  updateComponent(bucket, args) {
    let instance = bucket.instance;
    let oldArgs = bucket.args;
    let newArgs = args.named;
    let changed = false;

    // Since the arguments are coming from the template invocation, you can
    // generally assume that they have exactly the same keys. However, future
    // additions such as &quot;splat arguments&quot; in the template layer might change
    // that assumption.
    for (let key in oldArgs) {
      let oldValue = oldArgs[key];
      let newValue = newArgs[key];

      if (oldValue !== newValue) {
        instance.argumentWillChange(key, oldValue, newValue);
        instance.set(key, newValue);
        instance.argumentDidChange(key, oldValue, newValue);
      }
    }

    bucket.args = newArgs;
  },

  // ...
});
</code></pre>
<p>This example also shows when the &quot;state bucket&quot; pattern could be useful.</p>
<p>The return value of the <code>updateComponent</code> is ignored.</p>
<p>After calling the <code>updateComponent</code> method, Ember will update the component's
template to reflect any changes.</p>
<h2 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h2>
<p>In addition to the methods specified above, component managers are required to
have a <code>capabilities</code> property.  This property must be set to the result of
calling the <code>capabilities</code> function provided by Ember.</p>
<h3 id="versioning-1"><a class="header" href="#versioning-1">Versioning</a></h3>
<p>The first, mandatory, argument to the <code>capabilities</code> function is the component
manager API, which is denoted in the <code>${major}.${minor}</code> format, matching the
minimum Ember version this manager is targeting. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  }
});
</code></pre>
<p>This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.</p>
<p>Here is a hypothical scenario for such a change:</p>
<ol>
<li>
<p>Ember 3.2 implemented and shipped the component manager API as described in
this RFC.</p>
</li>
<li>
<p>The <code>ember-basic-component</code> addon released version 1.0 with the component
manager shown above (notably, it declared <code>capabilities('3.2')</code>).</p>
</li>
<li>
<p>In Ember 3.5, we determined that constructing the arguments object passed to
the hooks is a major performance bottleneck, and changes the API to pass a
&quot;proxy&quot; object with getter methods instead (e.g. <code>args.getPositional(0)</code> and
<code>args.getNamed('foo')</code>).</p>
<p>However, since Ember sees that the <code>basic</code> component manager is written to
target the <code>3.2</code> API version, it will retain the old behavior and passes the
old (more expensive) &quot;reified&quot; arguments object instead, to avoid breakage.</p>
</li>
<li>
<p>The <code>ember-basic-component</code> addon author would like to take advantage of
this performance optimization, so it updates its component manager code to
work with the arguments proxy and changes its capabilities declaration to
<code>capabilities('3.5')</code> in version 2.0.</p>
</li>
</ol>
<p>This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.</p>
<p>Note that addon authors are not <em>required</em> to update to the newer API.
Concretely, component manager APIs have the following support policy:</p>
<ul>
<li>
<p>API versions will continue to be supported in the same major release of
Ember. As shown in the example above, <code>ember-basic-component</code> 1.0 (which
targets component manager API version 3.2), will continue to work on
Ember 3.5. However, the reverse is not true – component manager API version
3.5 will (somewhat obviously) not work in Ember 3.2.</p>
</li>
<li>
<p>In addition, to ensure a smooth transition path for addon authors and app
developers across major releases, each Ember version will support (at least)
the previous LTS version as of the release was made. For example, if 3.16 is
the last LTS release of the 3.x series, the component manager API version
3.16 will be supported by Ember 4.0 through 4.4, at minimum.</p>
</li>
</ul>
<p>Addon authors can also choose to target multiple versions of the component
manager API using <a href="https://github.com/pzuraq/ember-compatibility-helpers/">ember-compatibility-helpers</a>:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.5'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.2'),

    // ...
  });
}

export default ComponentManager;
</code></pre>
<p>Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.</p>
<h3 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h3>
<p>The second, optional, argument to the <code>capabilities</code> function is an object
enumerating the optional features requested by the component manager.</p>
<p>In the hypothical example above, while the &quot;reified&quot; arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical components. A component
manager written for Ember 3.5 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.5', {
    reifyArguments: true
  }),

  // ...
});
</code></pre>
<p>In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.</p>
<h2 id="optional-capabilities"><a class="header" href="#optional-capabilities">Optional Capabilities</a></h2>
<p>The following optionally capabilities will be available with the first version
of the component manager API. We expect future RFCs to propose additional
capabilities within the framework provided by this initial RFC.</p>
<h3 id="async-lifecycle-callbacks"><a class="header" href="#async-lifecycle-callbacks">Async Lifecycle Callbacks</a></h3>
<p>When the <code>asyncLifecycleCallbacks</code> capability is set to <code>true</code>, the component
manager is expected to implement two additional methods: <code>didCreateComponent</code>
and <code>didUpdateComponent</code>.</p>
<p><code>didCreateComponent</code> will be called after the component has been rendered the
first time, after the whole top-down rendering process is completed. Similarly,
<code>didUpdateComponent</code> will be called after the component has been updated, after
the whole top-down rendering process is completed. This would be the right time
to invoke any user callbacks, such as <code>didInsertElement</code> and <code>didRender</code> in the
classic components API.</p>
<p>These methods will be called with the component instance (the &quot;state bucket&quot;
returned by <code>createComponent</code>) as the only argument. The return value is
ignored.</p>
<p>These callbacks are called if and only if their synchronous APIs were invoked
during rendering. For example, if <code>updateComponent</code> was called on during
rendering (and it completed without errors), <code>didUpdateComponent</code> will always
be called. Conversely, if <code>didUpdateComponent</code> is called, you can infer that
the <code>updateComponent</code> was called on the same component instance during
rendering.</p>
<p>This API provides no guarentee about ordering with respect to siblings or
parent-child relationships.</p>
<h3 id="destructors"><a class="header" href="#destructors">Destructors</a></h3>
<p>When the <code>destructor</code> capability is set to <code>true</code>, the component manager is
expected to implement an additional method: <code>destroyComponent</code>.</p>
<p><code>destroyComponent</code> will be called when the component is no longer needed. This
is intended for performing object-model level cleanup.</p>
<p>Because this RFC does not provide ways to access or observe the component's DOM
tree, the timing relative to DOM teardown is undefined (i.e. whether this is
called before or after the component's DOM tree is removed from the document).</p>
<p>Therefore, this hook is not suitable for invoking user callbacks intended for
performing DOM cleanup, such as <code>willDestroyElement</code> in the classic components
API. We expect a subsequent RFC addressing DOM-related functionalities to
clarify this issues or provide another specialized method for that purpose.</p>
<p>Similar to the other async lifecycle callbacks, this API provides no guarentee
about ordering with respect to siblings or parent-child relationships. Further,
the exact timing of the calls are also undefined. For example, the calls from
several render loops might be batched together and deferred into a browser idle
callback.</p>
<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>
<h2 id="basic-component-manager"><a class="header" href="#basic-component-manager">Basic Component Manager</a></h2>
<p>Here is the simpliest end-to-end component manager example that uses a plain
<code>Ember.Object</code> super-class (as opposed to <code>Ember.Component</code>) with &quot;Outer HTML&quot;
semantics:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  createComponent(factory, args) {
    return factory.create(args.named);
  },

  getContext(component) {
    return component;
  },

  updateComponent(component, args) {
    component.setProperties(args.named);
  },

  destroyComponent(component) {
    component.destroy();
  }
});
</code></pre>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend());
</code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-js">// my-app/app/components/x-counter.js

import BasicCompoment from 'ember-basic-component';

export default BasicCompoment.extend({
  init() {
    this.count = 0;
  },

  down() {
    this.decrementProperty('count');
  },

  up() {
    this.incrementProperty('count');
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- my-app/app/templates/components/x-counter.hbs --}}

&lt;div&gt;
  &lt;button {{action this.down}}&gt;🔽&lt;/button&gt;
  {{this.count}}
  &lt;button {{action this.up}}&gt;🔼&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<h2 id="template-only-components"><a class="header" href="#template-only-components">Template-only Components</a></h2>
<p>This example implements a kind of component similar to what was proposed in the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">template-only components</a>
RFC.</p>
<p>Since the custom components API proposed in this RFC requires a JavaScript
files, we cannot implement true &quot;template-only&quot; components. We will need to
create a component JS file to export a dummy value, for the sole purpose of
indicating the component manager we want to use.</p>
<p>In practice, there is no need for an addon to implement this API, since it is
essentially re-implementing what the &quot;template-only-glimmer-components&quot;
optional feature does. Nevertheless, this example is useful for illustrative
purposes.</p>
<pre><code class="language-js">// ember-template-only-component/app/component-managers/template-only.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent() {
    return null
  },

  getContext() {
    return null;
  },

  updateComponent() {
    return;
  }
});
</code></pre>
<pre><code class="language-js">// ember-template-only-component/addon/index.js

import { setComponentManager } from '@ember/component';

// Our `createComponent` method does not actually do anything with the factory,
// so we don't even need to export a class here, `{}` would work just fine.
export default setComponentManager('template-only', {});
</code></pre>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><code class="language-js">// my-app/app/components/hello-world.js

import TemplateOnlyComponent from 'ember-template-only-component';

export default TemplateOnlyComponent;
</code></pre>
<pre><code class="language-hbs">Hello world! I have no backing class! {{this}} would be &lt;code&gt;null&lt;/code&gt;.
</code></pre>
<h2 id="recycling-components"><a class="header" href="#recycling-components">Recycling Components</a></h2>
<p>This example implements an API which maintain a pool of recycled component
instances to avoid allocation costs.</p>
<p>This example also make use of the &quot;state bucket&quot; pattern.</p>
<pre><code class="language-js">// ember-component-pool/app/component-managers/pooled.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

// How many instances to keep (per type/factory)
const LIMIT = 10;

export default EmberObject.extend({
  capabilities: capabilities('3.2', {
    destructor: true
  }),

  init() {
    this.pool = new Map();
  },

  createComponent(factory, args) {
    let instances = this.pool.get(factory);
    let instance;

    if (instances &amp;&amp; instances.length &gt; 0) {
      instance = instances.pop();
      instance.setProperties(args.named);
    } else {
      instance = factroy.create(args.named);
    }

    // We need to remember which factory does the instance belong to so we can
    // check it back into the pool later.
    return { factory, instance };
  },

  getContext({ instance }) {
    return instance;
  },

  updateComponent({ instance }, args) {
    instance.setProperties(args.named);
  },

  destroyComponent({ factory, instance }) {
    let instances;

    if (this.pool.has(factory)) {
      instances = this.pool.get(factory);
    } else {
      this.pool.set(factory, instances = []);
    }

    if (instances.length &gt;= LIMIT) {
      instance.destroy();
    } else {
      // User hook to reset any state
      instance.willRecycle();
      instances.push(instance);
    }
  },

  // This is the `Ember.Object` lifecycle method, called when the component
  // manager instance _itself_ is being destroyed, not to be confused with
  // `destroyComponent`
  willDestroy() {
    for (let instances of this.pool.values()) {
      instances.forEach(instance =&gt; instance.destroy());
    }

    this.pool.clear();
  }
});
</code></pre>
<pre><code class="language-js">// ember-component-pool/addon/index.js

import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

function NOOP() {}

export default setComponentManager('pooled', EmberObject.extend({
  // Override this to implement reset any state on the instance
  willRecycle(): NOOP,

  // ...
}));
</code></pre>
<h1 id="how-we-teach-this-25"><a class="header" href="#how-we-teach-this-25">How We Teach This</a></h1>
<p>What is proposed in this RFC is a <em>low-level</em> primitive. We do not expect most
users to interact with this layer directly. Instead, most users will simply
benefit from this feature by subclassing these special components provided by
addons.</p>
<p>At present, the classic components APIs is still the primary, recommended path
for almost all use cases. This is the API that we should teach new users, so we
do not expect the guides need to be updated for this feature (at least not the
components section).</p>
<p>For documentation purposes, each Ember.js release will only document the latest
component manager API, along with the available optional capabilities for that
realease. The documentation will also include the steps needed to upgrade from
the previous version. Documentation for a specific version of the component
manager API can be viewed from the versioned documentation site.</p>
<h1 id="drawbacks-49"><a class="header" href="#drawbacks-49">Drawbacks</a></h1>
<p>In the long term, there is a risk of fragmentating the Ember ecosystem with
many competing component APIs. However, given the Ember community's strong
desire for conventions, this seems unlikely. We expect this to play out similar
to the data-persistence story – there will be a primary way to do things (Ember
Data), but there are also plenty of other alternatives catering to niche use
cases that are underserved by Ember Data.</p>
<p>Also, because apps can mix and match component styles, it's possible for a
library like smoke-and-mirrors or Liquid Fire to take advantage of the
enhanced functionality internally without leaking those implementation
details to applications.</p>
<h1 id="alternatives-50"><a class="header" href="#alternatives-50">Alternatives</a></h1>
<p>Instead of focusing on exposing enough low-level primitives to build the new
components API, we could just focus on building out the user-facing APIs
without rationalizing or exposing the underlying primitives.</p>
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="follow-up-rfcs"><a class="header" href="#follow-up-rfcs">Follow-up RFCs</a></h2>
<p>We expect to rapidly iterate and improve the component manager API through the
RFC process and in-the-field usage/implementation experience. Here are a few
examples of additional capabilities that we hope to see proposed after this
initial (and intentionally minimal) proposal is finalized:</p>
<ol>
<li>
<p>Expose a way to access to the component's DOM structure, such as its bounds.
This RFC would also need to introduce a hook for DOM teardown and address
how event handling/delegation would work.</p>
</li>
<li>
<p>Expose a way to access to the <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>-based APIs. This could include
the ability to customize the component's &quot;tag&quot; (<a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/05-validators.md">validator</a>).</p>
</li>
<li>
<p>Expose additional features that are used to implement classic components,
<code>{{outlet}}</code> and other built-in components, such as layout customizations,
and dynamic scope access.</p>
</li>
<li>
<p>Angle bracket invocation.</p>
</li>
</ol>
<h2 id="using-es6-classes"><a class="header" href="#using-es6-classes">Using ES6 Classes</a></h2>
<p>Although this RFC uses <code>Ember.Object</code> in the examples, it is not a &quot;hard&quot;
dependency.</p>
<h3 id="using-es6-classes-for-components"><a class="header" href="#using-es6-classes-for-components">Using ES6 Classes For Components</a></h3>
<p>The main interaction between the Ember object model and the component class
is through the DI system. Specifically, the factory function returned by
<code>factoryFor</code> (<code>factoryFor('component:foo-bar').create(...)</code>), which is passed
to the <code>createComponent</code> method on the component manager, assumes a static
<code>create</code> method on the class that takes the &quot;property bag&quot; and returns the
created instance.</p>
<p>Therefore, as long as your ES6 super-class provides such a function, it will
work with the rest of the system:</p>
<pre><code class="language-js">// ember-basic-component/addon/index.js

import { setComponentManager } from '@ember/component';

class BasicComponent {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  // ...
}

export default setComponentManager('basic', BasicComponent);
</code></pre>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This Just Works™ since we have a static create method on the class
    return factory.create(args.named);
  },

  // ...
});
</code></pre>
<pre><code class="language-js">// my-app/app/components/foo-bar.js

import BasicCompoment from 'ember-basic-component';

export default class extends BasicCompoment {
  // ...
};
</code></pre>
<p>Alternatively, if you prefer not to add a static create method to your
super-class, you can also instantiate them in the component manager without
going through the DI system:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.2'),

  createComponent(factory, args) {
    // This does not use the factory function, thus no longer require a static
    // create method on the class
    return new factory.class(args.named);
  },

  // ...
});
</code></pre>
<p>However, doing do will prevent your components from receiving injections (as
well as setting the appropiate owner, etc). Therefore, when possible, it is
better to go through the DI system's factory function.</p>
<h3 id="using-es6-classes-for-component-managers"><a class="header" href="#using-es6-classes-for-component-managers">Using ES6 Classes For Component Managers</a></h3>
<p>It is also possible to use ES6 classes for the component managers themselves.
The main interaction here is that they are automatically instantiated by the DI
system on-demand, which again assumes a static <code>create</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';

export default class BasicComponentManager {
  static create(props) {
    return new this(props);
  }

  constructor(props) {
    // Do things with props, such as:
    Object.assign(this, props);
  }

  capabilities = capabilities('3.2');

  // ...
};
</code></pre>
<p>Alternatively, as shown above, you can also register the component manager
with <code>{ instantiate: false }</code>:</p>
<pre><code class="language-js">// ember-basic-component/app/initializers/register-basic-component-manager.js

import BasicComponentManager from 'ember-basic-component';

export function initialize(application) {
  application.register('component-manager:basic', new BasicComponentManager(), { instantiate: false });
}

export default {
  name: 'register-basic-component-manager',
  initialize
};
</code></pre>
<p>Note that this behaves a bit differently as the component manager instance is
shared across all application instances and is never destroyed, which might
affect stateful component managers such as the one shown in the &quot;Recycling
Components&quot; example above.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-04-26
RFC PR: https://github.com/emberjs/rfcs/pull/225
Ember Issue: https://github.com/emberjs/ember.js/pull/15174</p>
<hr />
<h1 id="summary-51"><a class="header" href="#summary-51">Summary</a></h1>
<p>This RFC proposes allowing parameters to be passed to the <code>{{mount}}</code> syntax.</p>
<h1 id="motivation-52"><a class="header" href="#motivation-52">Motivation</a></h1>
<p>This will enable developers to pass contextual data into routeless engines at
runtime, allowing individual engines to be used multiple times through a single
application under different contexts.</p>
<p>An example could be a dashboard of charts where each chart is a routeless engine.
Each chart could be of a different type and would require different data. This
RFC would enable the following:</p>
<pre><code class="language-hbs">{{!-- app/templates/application.hbs --}}
{{#each charts as |chart|}}
  {{mount &quot;chart&quot; type=chart.type data=chart.data}}
{{/each}}
</code></pre>
<h1 id="detailed-design-49"><a class="header" href="#detailed-design-49">Detailed design</a></h1>
<p>You can see the implementation for this RFC <a href="https://github.com/emberjs/ember.js/pull/15174">here</a>.</p>
<p>Implementing this functionality turns out to be relatively straight forward. With
routeless engines already supporting an application controller, we can use this
as a means of providing access to the parameters.</p>
<p>Parameters would be passed to the <code>{{mount}}</code> syntax in the same way that
they are currently passed to components and helpers.</p>
<pre><code class="language-hbs">{{mount &quot;foo&quot; bar=&quot;baz&quot;}}
</code></pre>
<p>These parameters would then be set as the <code>model</code> property on the engines
application controller; making them accessible from both a JS and HBS context.</p>
<pre><code class="language-js">// foo/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({

  actions: {
    exampleAction() {
      let barParam = this.get(&quot;model.bar&quot;);
    }
  }

});
</code></pre>
<pre><code class="language-hbs">{{!-- foo/templates/application.hbs --}}
The value of the bar param is: {{model.bar}}
</code></pre>
<h1 id="how-we-teach-this-26"><a class="header" href="#how-we-teach-this-26">How We Teach This</a></h1>
<p>This RFC re-uses concepts that are already heavily used throughout other areas
of the framework.</p>
<p>Updates will need to be made to the Ember API docs and <a href="http://ember-engines.com">ember-engines.com</a> guides in order to explain that
routeless engines can now accept parameters being passed via the <code>{{mount}}</code> syntax.</p>
<p>In addition, updates would need to include examples of both how to pass parameters
to <code>{{mount}}</code> as well as how any passed parameters can be accessed from within
the context of an engine.</p>
<h1 id="drawbacks-50"><a class="header" href="#drawbacks-50">Drawbacks</a></h1>
<h3 id="increased-risk-of-runtime-dependencies-reference"><a class="header" href="#increased-risk-of-runtime-dependencies-reference">Increased risk of runtime dependencies [<a href="https://github.com/ember-engines/ember-engines/issues/98#issuecomment-217347193">reference</a>]</a></h3>
<p>This RFC does increase the risk of introducing runtime dependencies.</p>
<p>Example:</p>
<pre><code class="language-js">import Ember from 'ember';

export default Ember.Component.extend({
  geo: Ember.inject.service('geolocation')
})
</code></pre>
<pre><code class="language-hbs">{{mount &quot;blog&quot; (hash geo=geo)}}
</code></pre>
<h1 id="alternatives-51"><a class="header" href="#alternatives-51">Alternatives</a></h1>
<h3 id="application-route-model-hook"><a class="header" href="#application-route-model-hook">Application route <code>model</code> hook</a></h3>
<p>This solution suggested that the parameters were provided to the engines
application route via the <code>model</code> hooks <code>params</code> argument. While viable,
this solution didn't <em>feel</em> quite right as you were using a route within a <em>routeless</em>
engine.</p>
<h3 id="introduction-of-new-routelessengine-primitive"><a class="header" href="#introduction-of-new-routelessengine-primitive">Introduction of new <code>routelessEngine</code> primitive</a></h3>
<p>This solution suggested that routeless engines should be given their own primitive
similar to that of a component. The primitive would follow a construct to
components and use the same hooks <code>(e.g., didReceiveAttrs)</code> for working with
parameters.</p>
<p>This solution was decided against for following main reasons:</p>
<ol>
<li>The current public API is that we use <code>application</code> controller to back the
<code>application.hbs</code> of a route-less engine.  Adding a new conceptual primitive
here would be a fairly difficult change without breakage.</li>
<li>Introducing a new primitive (e.g. not controller and not a component) is a
<em>very</em> heavy handed thing, and should not be taken lightly. We don't think this
rises to that level of need.</li>
<li>This is an ideal case for &quot;just using a component&quot;, but that would be roughly
akin to &quot;routable components&quot; and we should follow Ember's lead.  When routeable
components are introduced, we can refactor this in the same way with the same
backwards compatibility guarantees.</li>
</ol>
<h1 id="unresolved-questions-42"><a class="header" href="#unresolved-questions-42">Unresolved questions</a></h1>
<h3 id="positional-parameters"><a class="header" href="#positional-parameters">Positional parameters</a></h3>
<p>In addition to supporting named parameters, should the <code>{{mount}}</code> syntax also
support positional parameters? If so, should this be covered in this RFC, or
in a follow up RFC?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-05-05
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/226
Tracking: https://github.com/emberjs/rfc-tracking/issues/13</p>
<hr />
<h1 id="summary-52"><a class="header" href="#summary-52">Summary</a></h1>
<p>Introduce syntax for passing in multiple named template blocks into a component, and
unify the rendering syntaxes / semantics for
blocks/primitives/component-factories passed into a component.</p>
<p>This RFC is focused chiefly on bringing named blocks to Ember Components,
but it was necessary to define a basic roadmap of functionality for
Glimmer Components as well, but keep in mind that some of the Glimmer-centric details may
change and should hence be considered non-normative.</p>
<h1 id="motivation-53"><a class="header" href="#motivation-53">Motivation</a></h1>
<p>There are limitations to composition due to the inability to pass more than one block to a component (or 2 blocks if you include the inverse block).</p>
<p>The result of this is that Ember developers have this ultra-powerful, compositional API for overriding portions of a component, but they can only use it in one place in the component invocation; any remaining overrides/configuration needs to be expressed as data and passed in as attributes to the component when it'd be vastly preferable to just pass in a chunk of DOM.</p>
<p>Example:</p>
<pre><code class="language-html">{{#x-modal headerText=page.title as |c|}}
  &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
  &lt;button onclick={{c.close}}&gt;
     Close modal
  &lt;/button&gt;
{{/x-modal}}
</code></pre>
<p>This works, but the moment you need to render a component in the header (rather than just <code>headerText</code>), you end up having to add more config/data/attrs to <code>x-modal</code> just to support every one of those overrides, when really you just should be able to pass in another block of DOM to define what the header looks like. The API in this proposal would allow you to express this use case via:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |c|&gt;
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
    &lt;button onclick={{c.close}}&gt;
       Close modal
    &lt;/button&gt;
  &lt;/@main&gt;
{{/x-modal}}
</code></pre>
<p>and with Glimmer components:</p>
<pre><code class="language-html">&lt;x-modal&gt;
  &lt;@header as |c|&gt;
    {{page.title}}
    {{status-indicator status=status}}
    {{close-button action=c.close}}
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    &lt;p&gt;Modal Content {{foo}}&lt;/p&gt;
    &lt;button onclick={{c.close}}&gt;
       Close modal
    &lt;/button&gt;
  &lt;/@main&gt;
&lt;/x-modal&gt;
</code></pre>
<p>Other RFCs/addons that have attempted to address this:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/pull/72">named yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/43">multiple yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/193">yet another named yields rfc</a></li>
<li><a href="https://github.com/ciena-blueplanet/ember-block-slots">ember-block-slots</a></li>
<li><a href="https://github.com/knownasilya/ember-named-yields">ember-named-yields</a></li>
<li><a href="https://github.com/emberjs/rfcs/pull/199">local template blocks</a></li>
</ul>
<h1 id="detailed-design-50"><a class="header" href="#detailed-design-50">Detailed design</a></h1>
<h2 id="invocation-syntax-is-separate-from-component-type"><a class="header" href="#invocation-syntax-is-separate-from-component-type">Invocation Syntax is separate from Component type</a></h2>
<p>The features specified in this RFC require us to nail down
some specifics as to how Ember and
Glimmer components interop, which syntaxes can be used to render
them, and the mental/teaching model behind how it all works.</p>
<ul>
<li>Invocation Syntax (curly vs angle brackets) is conceptually separate from Component
type (Ember vs Glimmer component)</li>
<li>&quot;Curly Components&quot; is a misnomer since curly syntax can render both Ember
components AND Glimmer components</li>
<li>Angle-bracket syntax can only render Glimmer components</li>
<li><code>{{x-foo @k=v}}</code> will remain invalid curly syntax due to the <code>@k=v</code></li>
<li>The way KV pairs provided at invocation is handled depends on the
component type:
<ul>
<li>Given <code>{{x-foo k=v}}</code>, Ember Component <code>x-foo</code> will assign/bind <code>v</code>
to property <code>k</code> on the component instance, which can be rendered
within the component layout template as <code>{{k}}</code> (same behavior as always).
<code>{{@k}}</code> in an Ember component layout will remain a syntax error</li>
<li>Given <code>{{x-foo k=v}}</code>, Glimmer Component <code>x-foo</code> treats <code>k=v</code> as
assigning/binding arg <code>@k</code> to <code>v</code>; it will assign/bind <code>this.args.k</code>, and expose
the value as <code>{{@k}}</code> within the template. This example invocation
is functionally equivalent to <code>&lt;x-foo @k={{v}} /&gt;</code></li>
<li>The mental model is that with curly syntax, <code>k=v</code> is the syntax
for &quot;passing data&quot; to a component; Ember components receive/expose
this data via the properties on the component instance, and Glimmer
components receive the data as <code>@arg</code>s.</li>
</ul>
</li>
<li>Curly syntax will not be enhanced with syntax for passing HTML attrs
(at this time)</li>
<li>Angle-bracket syntax does not support passing positional params</li>
</ul>
<p>Implementation-wise, these varying semantics will be defined/implemented via
<a href="https://github.com/emberjs/rfcs/blob/custom-components/text/0000-custom-components.md#componentmanager">Component Managers</a>.</p>
<h2 id="multi-block-syntax"><a class="header" href="#multi-block-syntax">Multi-block Syntax</a></h2>
<p>Both curly and angle-bracket component invocation syntax will be enhanced
with a nested syntax for passing multiple blocks into a component.</p>
<p>The syntax for curly invocation is as follows:</p>
<pre><code class="language-html">{{#x-foo}}
  &lt;@header&gt;
    Howdy.
  &lt;/@header&gt;

  &lt;@body as |foo|&gt;
    Body {{foo}}
  &lt;/@body&gt;
{{/x-foo}}
</code></pre>
<p>and for angle-bracket invocation:</p>
<pre><code class="language-html">&lt;x-foo&gt;
  &lt;@header&gt;
    Howdy.
  &lt;/@header&gt;

  &lt;@body as |foo|&gt;
    Body {{foo}}
  &lt;/@body&gt;
&lt;/x-modal&gt;
</code></pre>
<p>As demonstrated above, the <em>nested</em> syntax for both curly and
angle-bracket multi-block syntax has the format <code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code>.</p>
<p>This multi-block syntax cannot be mixed with other syntaxes; either ALL
the nested &quot;children&quot; of a component invocation need to be
<code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code> (multi-block syntax), or none of them do
(classic single-block syntax). The presence of any non-whitespace
character between or around <code>&lt;@blockName&gt;...&lt;/@blockName&gt;</code>s is a
compile-time error.</p>
<p>Passing two blocks with the same name is a compiler error (though this
might be relaxed in a future RFC).</p>
<h3 id="blocks-are-just-opaque-data"><a class="header" href="#blocks-are-just-opaque-data">Blocks are just (opaque) data</a></h3>
<p>This RFC introduces the concept that blocks are just opaque values
passed into components as data, rather than living in what is
essentially a separate namespace only accessible to <code>{{yield}}</code>.</p>
<p>In the above example (with curly syntax), Ember Component <code>x-foo</code> would
have its <code>header</code> and <code>body</code> properties set on its instance. This means,
among other things, that there's no need for a
<a href="https://github.com/emberjs/rfcs/pull/102">hasBlock API for JavaScript</a>;
you can just use normal property lookup / computed properties / etc to
determine whether a block is provided. This means that blocks can
be stashed on services and rendered elsewhere, e.g. the
<a href="https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000">ember-elsewhere use case</a>.</p>
<h3 id="unified-renderable-syntax"><a class="header" href="#unified-renderable-syntax">Unified Renderable Syntax</a></h3>
<p>Rather than continuing to enhance the <code>{{yield}}</code> syntax, we should take
this opportunity to unify the various syntaxes for rendering things,
from blocks to primitive values to component factories.</p>
<p>We'll use the following example component invocation to explore
what this syntax looks like: the following (curly syntax) invocation is valid syntax for
rendering either an Ember.Component or a Glimmer Component named
<code>x-modal</code> and passing it 3 named blocks: <code>header</code>, <code>body</code>, and <code>footer</code>:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |title|&gt;
    Header {{title}}
  &lt;/@header&gt;

  &lt;@body&gt;
    Body
  &lt;/@body&gt;

  &lt;@footer&gt;
    Footer
  &lt;/@footer&gt;
{{/x-modal}}
</code></pre>
<p>Given the above invocation, here's how you could render these blocks:</p>
<pre><code>{{! within ember-component layout }}
{{this.header &quot;ima title&quot;}}
{{this.body}}
{{this.footer}}

{{! within glimmer-component layout }}
{{@header &quot;ima title&quot;}}
{{@body}}
{{@footer}}
</code></pre>
<p>Both of these Ember/Glimmer layouts would render:</p>
<pre><code>Header ima title
Body
Footer
</code></pre>
<p>The mental modal here is that is that for ECs, named blocks are
set/bound as a properties on the instance, which we're rendering the
same way we always rendering properties on the instance. For GCs, blocks
are just args that we're rendering with the standard @arg syntax</p>
<h4 id="why-thisheader-and-not-just-header"><a class="header" href="#why-thisheader-and-not-just-header">Why <code>{{this.header}}</code> and not just <code>{{header}}</code>?</a></h4>
<p>Unfortunately, we are constrained by the fact that <code>{{foo}}</code> means:</p>
<ul>
<li>Try and find a helper named <code>foo</code>, and render it</li>
<li>If no such helper exists, fall back to rendering property <code>foo</code>
on the template context</li>
</ul>
<p>There is a risk that still exists today that any time you introduce a
new helper to your codebase, for example, a <code>time</code> helper, you will break any
templates that try to render a <code>time</code> property via <code>{{time}}</code>. This is
an unfortunate hangover from the past, and we don't want to continue to
expand the scope of this footgun with this RFC. Hence, to render
blocks/component factories, you must use <code>{{this.time}}</code> in your Ember
Component templates.</p>
<p>This is actually an extension to behavior introduced by the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md">Contextual Component Lookup
RFC</a>;
today, the following is supported:</p>
<pre><code class="language-hbs">&lt;!-- invocation --&gt;
{{x-foo header=(component 'x-header')}}
</code></pre>
<pre><code class="language-hbs">&lt;!-- x-foo layout --&gt;
{{this.header}}
</code></pre>
<p>In the above example, <code>{{this.header}}</code> will actually render the
<code>x-header</code> component factory; this RFC merely proposes extending this
syntax so that it can render blocks as well.</p>
<p>Since the potential for forgetting this rule is somewhat high, we
should consider detecting when you use <code>{{foo}}</code> syntax when <code>foo</code> is a
component factory or a block, and provide a useful warning or error
message to use <code>{{this.foo}}</code> instead.</p>
<h4 id="rendering-primitives"><a class="header" href="#rendering-primitives">Rendering primitives</a></h4>
<p>Consider the following example, which modifies above example by changing
the <code>footer</code> block to a string:</p>
<pre><code class="language-html">{{#x-modal footer=&quot;ima footer&quot;}}
  &lt;@header as |title|&gt;
    Header {{title}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>If <code>x-modal</code> renders footer via <code>{{this.footer}}</code>, then it'll just
render the &quot;ima footer&quot; string just fine; this a nice benefit of having
a Unified Renderable syntax
and supports a common workflow where string args can be promoted
to full-on blocks without having to rework the component code
to support an alternative/parallel API.</p>
<h4 id="call-syntax-with-primitives-or-undefined"><a class="header" href="#call-syntax-with-primitives-or-undefined">Call syntax with primitives (or undefined)</a></h4>
<p>If you try to render a block/component with args, e.g. <code>{{this.foo 1 2 3}}</code>,
then <code>foo</code> MUST be a block or a component. If <code>foo</code> is any kind of
non-callable primitive, including undefined, it will be an error.</p>
<h4 id="unified-renderable-syntax-component-factories"><a class="header" href="#unified-renderable-syntax-component-factories">Unified Renderable Syntax: component factories</a></h4>
<p>The following invocation using component factories is also supported:</p>
<pre><code class="language-html">{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  &lt;@main&gt;
    Main
  &lt;/@main&gt;
{{/x-modal}}
</code></pre>
<p>(It's worth mentioning that since we're only defining the <code>main</code> block
here, this could also be expressed simply as:)</p>
<pre><code class="language-html">{{#x-modal
     header=(component 'my-modal-header')
     footer=(component 'my-modal-footer')}}
  Main
{{/x-modal}}
</code></pre>
<p>This demonstrates that the unified renderable syntax is also capable of
rendering component factories (previously only renderable via
<code>{{component header}}</code>).</p>
<p>Note since we're passing a positional param <code>&quot;ima title&quot;</code> to <code>header</code>,
the <code>my-modal-header</code> component would only be able to access that param if it were
using the <code>positionalParams</code> API with (<code>reopenClass</code>), which is a bit of
a clunky / pro-user API.</p>
<p>As a component author, if you want to write your components to support
passing data to both blocks (which accept positional params) and
components (which accept KV pairs), you can pass in both formats
of the same data, e.g.:</p>
<pre><code>// Ember.component layout
{{this.header headerTitle title=headerTitle}}

// Glimmer Component layout
{{@header headerTitle title=headerTitle}}
</code></pre>
<h4 id="named-block-params"><a class="header" href="#named-block-params">Named block params</a></h4>
<p>Prior to this RFC, there were only two ways to pass in overridable
chunks of DOM to a component:</p>
<ul>
<li>Passing in a block, which only accepts positional block params
(or a <code>(hash)</code> object of named params)</li>
<li>Passing in a component factory, which only accepts KV args (unless
you use the <code>reopenClass-positionalParams</code> api)</li>
</ul>
<p>Given that we're introducing a Unified Renderable syntax, it would be
unfortunate if we did nothing to address this impedance mismatch between
named and positional params. The goal is for component consumers/invokers to
be able to pass the most &quot;convenient&quot; kind of Renderable for their use
case, be it a simple primitive string value, a block if they want the
lexical scope + block params, or a component factory for rendering
a shared component that might be used in many places throughout the app.
Unfortunately, the component author will have to choose whether they
want to pass positional params (which would push consumers towards
only using  blocks) or named params (which are presently only supported
by component factories).</p>
<p>Hence, for this reason (among others), it makes sense to introduce a
syntax for named block params; with this syntax, there will be an
organic shift towards component authors using named KV pairs for passing
data in most cases (while still allowing positional params in certain
simpler cases were it only really makes sense to use a block, e.g.
control flow components that wrap <code>if</code> or <code>each</code>, etc.)</p>
<p>Here is the syntax for named block params:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |@title @data|&gt;
    The title: {{@title}}
    The data: {{@data}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>There is also a &quot;soaking&quot; syntax which is useful in cases where nested
blocks might introduce new named block params that clobber preexisting
identifiers in the scope, as well as cases where spelling out each
named block param consumes too much rightward space. The above example
can be expressed using the soaking syntax as follows:</p>
<pre><code class="language-html">{{#x-modal}}
  &lt;@header as |@...d|&gt;
    The title: {{d.title}}
    The data: {{d.data}}
  &lt;/@header&gt;
{{/x-modal}}
</code></pre>
<p>(The <code>@</code> is not included as part of the identifier as that would
suggest it was a KV arg rather than essentially a hash of args.)</p>
<h4 id="block-form-of-unified-renderable-syntax"><a class="header" href="#block-form-of-unified-renderable-syntax">Block form of Unified Renderable syntax</a></h4>
<p>It should be possible to pass a block TO the
block/component-factory that's been passed into a component.
The common use cases for this are:</p>
<h5 id="passing-a-block-to-a-component-factory"><a class="header" href="#passing-a-block-to-a-component-factory">Passing a block to a component factory</a></h5>
<p>Given the following invocation:</p>
<pre><code>{{x-modal header=(component 'my-header')}}
</code></pre>
<p>It should be possible for <code>x-modal</code> to pass a block to the <code>header</code>
renderable:</p>
<pre><code>// ember-component x-modal layout
{{#this.header title=&quot;ima title&quot;}}
  I'm a block provided by the component layout template.
{{/this.header}}
</code></pre>
<p>Assuming <code>my-header</code> had a layout of:</p>
<pre><code>&lt;div class=&quot;my-header-inner&quot;&gt;
  title is {{title}}
  {{yield}}
&lt;/div&gt;
</code></pre>
<p>This would render the following (assuming <code>x-modal</code> and <code>my-header</code> are
Ember components with <code>tagName: 'div'</code> with <code>classNames</code> set):</p>
<pre><code>&lt;div class=&quot;x-modal&quot;&gt;
  &lt;div class=&quot;my-header&quot;&gt;
    &lt;div class=&quot;my-header-inner&quot;&gt;
      title is ima title
      I'm a block provided by the component layout template.
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h5 id="passing-a-block-to-a-block-aka-contextual-components"><a class="header" href="#passing-a-block-to-a-block-aka-contextual-components">Passing a block to a block (aka contextual components)</a></h5>
<p>Given the following invocation:</p>
<pre><code>{{#x-modal}}
  &lt;@header as |@title @main|&gt;
    &lt;div class=&quot;header-block-content&quot;&gt;
      title is {{@title}}
      {{@main}}
    &lt;/div&gt;
  &lt;/header&gt;
{{/x-modal}}
</code></pre>
<p>This would render the following (assuming the same <code>x-modal</code> layout
as the previous example:</p>
<pre><code>&lt;div class=&quot;x-modal&quot;&gt;
  &lt;div class=&quot;header-block-content&quot;&gt;
    title is ima title
    I'm a block provided by the component layout template.
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>It would also be possible to pass a component factory to the header
block from <code>x-modal</code>'s layout:</p>
<pre><code>// ember-component x-modal layout
{{this.header title=&quot;ima title&quot;
         main=(component 'x-modal-inner-content')}}
</code></pre>
<p>The multi-block syntax can be used as well with Unified Renderable
syntax:</p>
<pre><code>{{#header}}
  &lt;@main&gt;
    I'm a block provided by the component layout template.
  &lt;/@main&gt;

  &lt;@title&gt;
    ima title
  &lt;/@title&gt;
{{/header}}
</code></pre>
<h5 id="block-form-of--prefixed-identifiers"><a class="header" href="#block-form-of--prefixed-identifiers">Block form of <code>@</code>-prefixed identifiers</a></h5>
<p>The syntax for passing a block to an <code>@</code>-prefixed identifier
(named block params and Glimmer <code>@arg</code>s) will be
<code>{{#@thing}} ... {{/@thing}}</code>, e.g.:</p>
<pre><code>{{#x-layout as |@widget|}}
  {{#@widget as |a b c|}}
    Hi.
  {{/@widget}}
{{/x-layout}}
</code></pre>
<h3 id="classic-single-block-syntax-main-and-else-args"><a class="header" href="#classic-single-block-syntax-main-and-else-args">Classic single-block syntax: <code>main</code> and <code>else</code> args</a></h3>
<p>It would be unfortunate if component authors had to use different
syntaxes for rendering named blocks vs the traditional &quot;default&quot;
and &quot;inverse&quot; blocks provided by the classic single-block syntax.</p>
<p>Hence, the blocks provided in classic single-block syntax should also
be exposed as properties (Ember) and args (Glimmer), and should have
conventional, meaningful names: instead of &quot;default&quot; (which is a
bit misleading) and &quot;inverse&quot;, we standardize on <code>main</code> and <code>else</code>.</p>
<h4 id="glimmer-components-main-and-else"><a class="header" href="#glimmer-components-main-and-else">Glimmer Components: <code>@main</code> and <code>@else</code></a></h4>
<p>Given Glimmer component invocation:</p>
<pre><code>{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-component}}
</code></pre>
<p>The component layout could be:</p>
<pre><code>{{#if cond}}
  {{@main}}
{{else}}
  {{@else}}
{{/if}}
</code></pre>
<p>Note that angle-bracket syntax doesn't support passing in an
inverse/else block, but the block provided to angle-bracket invocation
would be passed in as <code>@main</code>.</p>
<h4 id="ember-components-main-and-else"><a class="header" href="#ember-components-main-and-else">Ember Components: <code>main</code> and <code>else</code></a></h4>
<p>For Ember, we can't suddenly start setting <code>main</code> and <code>else</code> properties
on the component instances as this would be a breaking change, and
<code>main</code> in particular is not an uncommon property name.</p>
<p>We also shouldn't punt on this feature for Ember components for the
following reasons/use cases:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/pull/226#issuecomment-299949000">ember-elsewhere</a>
(and other similar patterns) require having access to the opaque block
so that it can be stashed on a service and rendered elsewhere</li>
<li>wrapper components that forward args/properties/blocks to another
internal component; blocks need to be accessible as properties in order
to pass them into another component (otherwise you'd have to use a
combinatoric mess of block syntax + <code>if hasBlock</code> checks to forward
blocks through to the inner component)</li>
</ul>
<p>So we need an opt-in API; any Ember Component that wants <code>main</code>/<code>else</code>
properties to be set on the component instance need to opt into this
behavior via a mixin provided by Ember:</p>
<pre><code>import { ImplicitBlockPropertyMixin } from &quot;@ember/implicit-block-property-support&quot;;

export default Ember.Component.extend(ImplicitBlockPropertyMixin, {
  blockManager: inject.service(),
  init() {
    this._super();
    this.get('blockManager').registerBlock(this.get('main'));
  },
});
</code></pre>
<p>So if <code>fancy-if</code> were an Ember component that used this mixin, then
given the component invocation:</p>
<pre><code>{{#fancy-if cond=trueOrFalse}}
  True
{{else}}
  False
{{/fancy-if}}
</code></pre>
<p>The following ember component layout would work:</p>
<pre><code>{{#if cond}}
  {{this.main}}
{{else}}
  {{this.else}}
{{/if}}
</code></pre>
<h1 id="how-we-teach-this-27"><a class="header" href="#how-we-teach-this-27">How We Teach This</a></h1>
<p>We teach this as a followup to classic block syntax; once the user is comfortable with single-block syntax, we can introduce named block syntax for more complex use cases.</p>
<p>We teach that what <code>&lt;@blockName&gt;&lt;/@blockName&gt;</code> syntax really means is
that we're just passing in an arg named <code>@blockName</code>, which is like
any other arg we might pass into a component, but it happens to point
to a template block than, say, some simple string value.</p>
<h1 id="drawbacks-51"><a class="header" href="#drawbacks-51">Drawbacks</a></h1>
<h3 id="different-from-wc-slot-syntax"><a class="header" href="#different-from-wc-slot-syntax">Different from WC slot syntax</a></h3>
<p>This isn't really anything like the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot">WebComponents slot syntax</a>
that intends to address similar use cases, so there is some risk of
introducing an API that doesn't fit in with what the rest of the world
is doing.</p>
<h3 id="syntax-highlighting-changes"><a class="header" href="#syntax-highlighting-changes">Syntax highlighting changes</a></h3>
<p>Some syntax highlighters might have trouble with this syntax; all
the editors I've tried it on look reasonable, but GitHub's Handlebars
parser isn't too kind (hence I've been using <code>html</code> snippets instead
of <code>handlebars</code> snippets):</p>
<pre><code class="language-hbs">&lt;x-modal&gt;
  &lt;@header as |c|&gt;
    ...
  &lt;/@header&gt;

  &lt;@main as |c|&gt;
    ...
  &lt;/@main&gt;
&lt;/x-modal&gt;
</code></pre>
<h3 id="conditionally-passing-blocks"><a class="header" href="#conditionally-passing-blocks">Conditionally passing blocks?</a></h3>
<p>This RFC does NOT introduce any kind of facility for conditionally passing
blocks, e.g.:</p>
<pre><code class="language-html">{{! this syntax is INVALID! }}
&lt;x-layout&gt;
  &lt;@header&gt;...&lt;/@header&gt;
  &lt;@main&gt;...&lt;/@main&gt;

  {{#if userCanProceed}}
    &lt;@footer&gt;
      {{submit-button}}
    &lt;/@footer&gt;
  {{/if}}
&lt;/x-layout&gt;
</code></pre>
<p>This might be desirable in the future, particularly for use cases
involving flex-ish layouts where the component changes behavior /
appearance based on whether blocks on passed in.</p>
<h1 id="alternatives-52"><a class="header" href="#alternatives-52">Alternatives</a></h1>
<p>I'd proposed a JSX-y <a href="https://github.com/emberjs/rfcs/pull/203">attr/component-centric</a> syntax for passing what are essentially DOM lambdas, rendered with <code>{{component}}</code>. Perhaps we'll add something like that feature in the future, but it's a much less natural enhancement to Ember than named blocks.</p>
<h1 id="considerations-for-future-rfcs"><a class="header" href="#considerations-for-future-rfcs">Considerations for Future RFCs</a></h1>
<h2 id="defining-default-blocks"><a class="header" href="#defining-default-blocks">Defining Default Blocks</a></h2>
<p>There's not really a nice way defining default blocks inside your
component layout (i.e. the block you render when known is provided at
invocation time), but then again I believe the following would be
a workable approach that is probably support by the features proposed in
this RFC?</p>
<pre><code>{{#with-blocks}}
  &lt;@mainOrDefault&gt;
    {{#if main}}
      {{main}}
    {{else}}
      I am the default main block when none is passed in.
    {{/if}}
  &lt;/@mainOrDefault&gt;

  &lt;@footerOrDefault&gt;
    {{#if footer}}
      {{footer}}
    {{else}}
      I am the default footer block when none is passed in.
    {{/if}}
  &lt;/@footerOrDefault&gt;

  &lt;@render as |@mainOrDefault @footerOrDefault|&gt;
    {{! this specially-named block gets passed all the other blocks above}}

    {{mainOrDefault}}
    {{footerOrDefault}}
  &lt;/@render&gt;
{{/with-blocks}}
</code></pre>
<p>Either way, it feels hacky and weird and I would be surprised if we'd
want/need a future RFC to define a nicer way to support default blocks.</p>
<h2 id="allow-passing-multiple-blocks-with-the-same-name"><a class="header" href="#allow-passing-multiple-blocks-with-the-same-name">Allow passing multiple blocks with the same name</a></h2>
<p>e.g.</p>
<pre><code class="language-html">{{#power-select}}
  &lt;@option value=&quot;foo&quot;&gt;
    &lt;em&gt;Foo&lt;/em&gt;
  &lt;/@option&gt;
  &lt;@option value=&quot;bar&quot;&gt;
    &lt;blink&gt;Bar&lt;/blink&gt;
  &lt;/@option&gt;
{{/power-select}}
</code></pre>
<p>This RFC defines that passing multiple blocks with the same name is a
syntax error, but it's something we might want to relax in the future
for certain cases where you want to pass arrays of blocks, such as
<code>power-select</code> or use cases involving tables.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-06-11
RFC PR: https://github.com/emberjs/rfcs/pull/229</p>
<hr />
<h1 id="summary-53"><a class="header" href="#summary-53">Summary</a></h1>
<p>In order to largely reduce the brittleness of tests, this RFC proposes to
remove the concept of artificially restricting the resolver used under
testing.</p>
<h1 id="motivation-54"><a class="header" href="#motivation-54">Motivation</a></h1>
<p>Disabling the resolver while running tests leads to extremely brittle tests.</p>
<p>It is not possible for collaborators to be added to the object (or one
of its dependencies) under test, without modifying the test itself (even if
exactly the same API is exposed). </p>
<p>The ability to restrict the resolver is <strong>not</strong> actually a feature of Ember's
container/registry/resolver system, and has posed as significant maintenance
challenge throughout the lifetime of ember-test-helpers.</p>
<p>Removing this system of restriction will make choosing what kind of test to
be used easier, simplify many of the blueprints, and enable much simpler refactoring 
of an applications components/controllers/routes/etc to use collaborating utilties
and services.</p>
<h1 id="transition-path-3"><a class="header" href="#transition-path-3">Transition Path</a></h1>
<h2 id="deprecate-functionality"><a class="header" href="#deprecate-functionality">Deprecate Functionality</a></h2>
<p>Issue a deprecation if <code>integration: true</code> is not included in the specified 
options for the APIs listed below. This specifically includes specifying 
<code>unit: true</code>, <code>needs: []</code>, or specifying none of the &quot;test type options&quot; 
(<code>unit</code>, <code>needs</code>, or <code>integration</code> options) to the following <code>ember-qunit</code>
and <code>ember-mocha</code> API's:</p>
<ul>
<li><code>ember-qunit</code>
<ul>
<li><code>moduleFor</code></li>
<li><code>moduleForComponent</code></li>
<li><code>moduleForModel</code></li>
</ul>
</li>
<li><code>ember-mocha</code>
<ul>
<li><code>setupTest</code></li>
<li><code>setupComponentTest</code></li>
<li><code>setupModelTest</code></li>
</ul>
</li>
</ul>
<h3 id="non-component-test-apis"><a class="header" href="#non-component-test-apis">Non Component Test APIs</a></h3>
<p>The migration path for <code>moduleFor</code>, <code>moduleForModel</code>, <code>setupTest</code>, and 
<code>setupModelTest</code> is very simple:</p>
<pre><code class="language-js">// ember-qunit

// before
moduleFor('service:session');

moduleFor('service:session', {
  unit: true
});

moduleFor('service:session', {
  needs: ['type:thing']
});

// after
moduleFor('service:session', {
  integration: true
});
</code></pre>
<pre><code class="language-js">// ember-mocha

// before
describe('Session Service', function() {
  setupTest('service:session');
  
  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { unit: true });
  
  // ...snip...
});

describe('Session Service', function() {
  setupTest('service:session', { needs: [] });
  
  // ...snip...
});

// after

describe('Session Service', function() {
  setupTest('service:session', { integration: true });
  
  // ...snip...
});
</code></pre>
<p>The main change is adding <code>integration: true</code> to options (and removing <code>unit</code> or <code>needs</code>
if present).</p>
<h3 id="component-test-apis"><a class="header" href="#component-test-apis">Component Test APIs</a></h3>
<p>Implicitly relying on &quot;unit test mode&quot; has been deprecated for quite some time 
(<a href="https://github.com/emberjs/ember-test-helpers/pull/38">introduced 2015-04-07</a>),
so all consumers of <code>moduleForComponent</code> and <code>setupComponentTest</code> are specifying
one of the &quot;test type options&quot; (<code>unit</code>, <code>needs</code>, or <code>integration</code>).</p>
<p>This RFC proposes to deprecate completely using <code>unit</code> or <code>needs</code> options with
<code>moduleForComponent</code> and <code>setupComponentTest</code>. The vast majority of component tests
should be testing via <code>moduleForComponent</code> / <code>setupComponentTest</code> with the <code>integration: true</code>
option set, but on some rare occaisions it is easier to use the &quot;unit test&quot; style is
desired (e.g. non-rendering test) these tests should be migrated to using <code>moduleFor</code> 
/ <code>setupTest</code> directly.</p>
<pre><code class="language-js">// ember-qunit

// before
moduleForComponent('display-page', {
  unit: true
});

moduleForComponent('display-page', {
  needs: ['type:thing']
});

// after

moduleFor('component:display-page', {
  integration: true
});
</code></pre>
<pre><code class="language-js">// ember-mocha
describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { unit: true });
  
  // ...snip...
});

describe('DisplayPageComponent', function() {
  setupComponentTest('display-page', { needs: [] });
  
  // ...snip...
});

// after

describe('DisplayPageComponent', function() {
  setupTest('component:display-page', { integration: true });
  
  // ...snip...
});
</code></pre>
<h2 id="ecosystem-updates"><a class="header" href="#ecosystem-updates">Ecosystem Updates</a></h2>
<p>The blueprints in all official projects (and any provided by popular
addons) will need to be updated to avoid triggering a deprecation.</p>
<p>This includes:</p>
<ul>
<li><code>ember-source</code></li>
<li><code>ember-data</code></li>
<li><code>ember-cli-legacy-blueprints</code></li>
<li>Others?</li>
</ul>
<h2 id="remove-deprecated-unit--needs-options"><a class="header" href="#remove-deprecated-unit--needs-options">Remove Deprecated <code>unit</code> / <code>needs</code> Options</a></h2>
<p>Once the changes from this RFC are made, we will be able to remove
support for the <code>unit</code> and <code>needs</code> options from <code>ember-test-helpers</code>,
<code>ember-qunit</code>, and <code>ember-mocha</code>. This would be a &quot;semver major&quot;
version bump for all of the related libraries to properly signal that
functionality was removed.</p>
<p>Once the underlying libraries have done a major version bump, we will
introduce a deprecation for using the <code>integration</code> option. This
deprecation would be issued once for the entire test suite (not once
per test module which has <code>integration</code> passed in). We will also update
the blueprints to remove the extraneous <code>integration</code> option.</p>
<h1 id="how-we-teach-this-28"><a class="header" href="#how-we-teach-this-28">How We Teach This</a></h1>
<p>This RFC would require an audit of the main Ember.js guides to ensure
that all usages of the APIs in question continue to be non-deprecated
valid usages.</p>
<h1 id="drawbacks-52"><a class="header" href="#drawbacks-52">Drawbacks</a></h1>
<h2 id="churn"><a class="header" href="#churn">Churn</a></h2>
<p>One drawback to this deprecation proposal is the churn associated with
modifying the options passed for each test. This can almost certainly
be mitigated by providing a codemod to enable automated updating.</p>
<p>There are additional changes being entertained that would require changes
for the default testing blueprints, we should ensure that these RFCs do not
conflict or cause undue churn/pain.</p>
<h2 id="integration-true-confusion"><a class="header" href="#integration-true-confusion"><code>integration: true</code> Confusion</a></h2>
<p>Prior to this deprecation we had essentially 4 options for testing components:</p>
<ul>
<li><code>moduleFor(..., { unit: true })</code></li>
<li><code>moduleFor(..., { integration: true })</code></li>
<li><code>moduleForComponent(..., { unit: true })</code></li>
<li><code>moduleForComponent(..., { integatrion: true })</code></li>
</ul>
<p>With this RFC the option <code>integration</code> no longer provides value (we aren't talking
about &quot;unit&quot; vs &quot;integration&quot; tests), and may be seen as confusing.</p>
<p>I believe that this concern is mitigated by the ultimate removal of the <code>integration</code>
(it is only required in order to allow us a path forward that is compatible with
todays ember-qunit/ember-mocha versions).</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-06-13
RFC PR: https://github.com/emberjs/rfcs/pull/232</p>
<hr />
<h1 id="summary-54"><a class="header" href="#summary-54">Summary</a></h1>
<p>In order to embrace newer features being added by QUnit (our chosen default
testing framework), we need to reduce the brittle coupling between <code>ember-qunit</code>
and QUnit itself. </p>
<p>This RFC proposes a new testing syntax, that will expose QUnit API directly while
also making tests much easier to understand. </p>
<h1 id="motivation-55"><a class="header" href="#motivation-55">Motivation</a></h1>
<p>QUnit feature development has been accelerating since the ramp up to QUnit 2.0.
A number of new features have been added that make testing our applications
much easier, but the current structure of <code>ember-qunit</code> impedes our ability 
to take advantage of some of these features.</p>
<p>Developers are often confused by our <code>moduleFor*</code> APIs, questions like these
are very common: </p>
<ul>
<li>What &quot;magic&quot; is <code>ember-qunit</code> doing? </li>
<li>Where are the lines between QUnit and ember-qunit? </li>
<li>How can I use QUnit for plain JS objects? </li>
</ul>
<p>The way that <code>ember-qunit</code> wraps QUnit functionality makes the division
of responsiblity much harder to understand, and leads folks to believe that there
is much more going on in <code>ember-qunit</code> than there is. It should be much clearer
what <code>ember-qunit</code> is responsible for and what we rely on QUnit for.</p>
<p>This RFC also aims to remove a number of custom testing only APIs that exist today
(largely because the container/registry system was completely private when the
current tools were authored). Instead of things like <code>this.subject</code>, <code>this.register</code>,
<code>this.inject</code>, or <code>this.lookup</code> we can rely on the standard way of performing these
functions in Ember via the owner API.</p>
<p>When this RFC has been implemented and rolled out, these questions should all be
addressed and our testing system will both: embrace QUnit much more <strong>and</strong> 
be much more framework agnostic, all the while dropping custom testing only APIs
in favor of public APIs that work across tests and app code.</p>
<p>Sounds like a neat trick, huh?</p>
<h1 id="detailed-design-51"><a class="header" href="#detailed-design-51">Detailed design</a></h1>
<p>The primary change being proposed in this RFC is to migrate to using the QUnit
nested module syntax, and update our custom setup/teardown into a more functional
API.</p>
<p>Lets look at a basic example:</p>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
</code></pre>
<p>As you can see, this proposal leverages QUnit's nested module API in a way that
makes it much clearer what is going on. It is quite obvious what QUnit is doing
(acting like a general testing framework) and what <code>ember-qunit</code> is doing 
(setting up rendering functionality).</p>
<p>This API was heavily influenced by the work that 
<a href="https://github.com/Turbo87">Tobias Bieniek</a> did in 
<a href="https://github.com/emberjs/ember-mocha/pull/84">emberjs/ember-mocha#84</a>.</p>
<h2 id="qunit-nested-modules-api"><a class="header" href="#qunit-nested-modules-api">QUnit Nested Modules API</a></h2>
<p>Even though it is not a proposal of this RFC, the QUnit nested module
syntax may seem foreign to some folks so lets briefly review.</p>
<p>With nested modules, a normal 1.x QUnit module setup changes from:</p>
<pre><code class="language-js">QUnit.module('some description', {
  before() {},
  beforeEach() {},
  afterEach() {},
  after() {}
});

QUnit.test('it blends', function(assert) {
  assert.ok(true, 'of course!');
});
</code></pre>
<p>Into:</p>
<pre><code class="language-js">QUnit.module('some description', function(hooks) {

  hooks.before(() =&gt; {});
  hooks.beforeEach(() =&gt; {});
  hooks.afterEach(() =&gt; {});
  hooks.after(() =&gt; {});

  QUnit.test('it blends', function(assert) {
    assert.ok(true, 'of course!');
  });
});
</code></pre>
<p>This makes it much simpler to support multiple <code>before</code>, <code>beforeEach</code>, <code>afterEach</code>,
and <code>after</code> callbacks, and it also allows for arbitrary nesting of modules.</p>
<p>You can read more about QUnit nested modules
<a href="http://api.qunitjs.com/QUnit/module#nested-module-nested-hooks-">here</a>. The new APIs
proposed in this RFC expect to be leveraging nested modules. </p>
<h2 id="new-apis"><a class="header" href="#new-apis">New APIs</a></h2>
<p>The following new methods will be exposed from <code>ember-qunit</code>:</p>
<pre><code class="language-ts">interface QUnitModuleHooks {
  before(callback: Function): void;
  beforeEach(callback: Function): void;
  afterEach(callback: Function): void;
  after(callback: Function): void;
}

declare module 'ember-qunit' {
  // ...snip... 
  export function setupTest(hooks: QUnitModuleHooks): void;
  export function setupRenderingTest(hooks: QUnitModuleHooks): void;
}
</code></pre>
<h3 id="setuptest"><a class="header" href="#setuptest"><code>setupTest</code></a></h3>
<p>This function will:</p>
<ul>
<li>invoke <code>ember-test-helper</code>s <code>setContext</code> with the tests context</li>
<li>create an owner object and set it on the test context (e.g. <code>this.owner</code>)</li>
<li>setup <code>this.set</code>, <code>this.setProperties</code>, <code>this.get</code>, and <code>this.getProperties</code> to
the test context</li>
<li>setup <code>this.pauseTest</code> and <code>this.resumeTest</code> methods to allow easy pausing/resuming
of tests</li>
</ul>
<h3 id="setuprenderingtest"><a class="header" href="#setuprenderingtest"><code>setupRenderingTest</code></a></h3>
<p>This function will:</p>
<ul>
<li>run the <code>setupTest</code> implementation</li>
<li>setup <code>this.$</code> method to run jQuery selectors rooted to the testing container </li>
<li>setup a getter for <code>this.element</code> which returns the DOM element representing
the element that was rendered via <code>this.render</code></li>
<li>setup Ember's renderer and create a <code>this.render</code> method which accepts a 
compiled template to render and returns a promise which resolves once rendering
is completed</li>
<li>setup <code>this.clearRender</code> method which clears any previously rendered DOM (
also used during cleanup)</li>
</ul>
<p>When invoked, <code>this.render</code> will render the provided template and return a
promise that resolves when rendering is completed.</p>
<h2 id="changes-from-current-system"><a class="header" href="#changes-from-current-system">Changes from Current System</a></h2>
<p>Here is a brief list of the more important but possibly understated changes
being proposed here:</p>
<ul>
<li>the various setup methods no longer need to know the name of the object under test</li>
<li><code>this.subject</code> is removed in favor of using the standard public API for looking up
and creating instances (<code>this.owner.lookup</code> and <code>this.owner.factoryFor</code>)</li>
<li><code>this.inject</code> is removed in favor of using <code>this.owner.lookup</code> directly</li>
<li><code>this.register</code> is removed in favor of using <code>this.owner.register</code> directly</li>
<li><code>this.render</code> will begin being asynchronous to allow for further iteration in the
underlying rendering engines ability to speed up render times (by yielding back
to the browser and not blocking the main thread)</li>
<li><code>this.pauseTest</code> and <code>this.resumeTest</code> are being added</li>
<li><code>this.element</code> is being introduced as a public API for DOM assertions in a jQuery-less
environment</li>
<li>QUnit nested modules are required</li>
</ul>
<p>These changes generally do not affect our ability to write a codemod to aide in the migration.</p>
<h2 id="migration-examples"><a class="header" href="#migration-examples">Migration Examples</a></h2>
<p>The migration can likely be largely automated (following the 
<a href="https://github.com/Turbo87/ember-mocha-codemods">excellent codemod</a> that 
<a href="https://github.com/turbo87">Tobias Bieniek</a> wrote for a similar <code>ember-mocha</code>
the transition), but it is still useful to review concrete scenarios
of tests before and after this RFC is implemented.</p>
<h3 id="component--helper-integration-test"><a class="header" href="#component--helper-integration-test">Component / Helper Integration Test</a></h3>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('x-foo', {
  integration: true
});

test('renders', function(assert) {
  assert.expect(1);

  this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

  assert.equal(this.$('.color-name').text(), 'red');
});

// **** after ****

import { module, test } from 'qunit';
import { setupRenderingTest } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

module('x-foo', function(hooks) {
  setupRenderingTest(hooks);

  test('renders', async function(assert) {
    assert.expect(1);

    await this.render(hbs`{{pretty-color name=&quot;red&quot;}}`);

    assert.equal(this.$('.color-name').text(), 'red');
  });
});
</code></pre>
<h3 id="component-unit-test"><a class="header" href="#component-unit-test">Component Unit Test</a></h3>
<pre><code class="language-js">// **** before ****

import { moduleForComponent, test } from 'ember-qunit';

moduleForComponent('x-foo', {
  unit: true
});

test('computes properly', function(assert) {
  assert.expect(1);

  let subject = this.subject({
    name: 'something'
  });

  let result = subject.get('someCP');
  assert.equal(result, 'expected value');
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('x-foo', function(hooks) {
  setupTest(hooks);

  test('computed properly', function(assert) {
    assert.expect(1);

    let Factory = this.owner.factoryFor('component:x-foo');
    let subject = Factory.create({
      name: 'something'
    });

    let result = subject.get('someCP');
    assert.equal(result, 'expected value');
  });
});
</code></pre>
<h3 id="serviceroutecontroller-test"><a class="header" href="#serviceroutecontroller-test">Service/Route/Controller Test</a></h3>
<pre><code class="language-js">// **** before ****

import { moduleFor, test } from 'ember-qunit';

moduleFor('service:flash', 'Unit | Service | Flash', {
  unit: true
});

test('should allow messages to be queued', function (assert) {
  assert.expect(4);
  
  let subject = this.subject();
  
  subject.show('some message here');
  
  let messages = subject.messages;
  
  assert.deepEqual(messages, [
    'some message here'
  ]);
});

// **** after ****

import { module, test } from 'qunit';
import { setupTest } from 'ember-qunit';

module('Unit | Service | Flash', function(hooks) {
  setupTest(hooks);
  
  test('should allow messages to be queued', function (assert) {
    assert.expect(4);
  
    let subject = this.owner.lookup('service:flash');
  
    subject.show('some message here');
  
    let messages = subject.messages;
  
    assert.deepEqual(messages, [
      'some message here'
    ]);
  });
});

</code></pre>
<h2 id="ecosystem-updates-1"><a class="header" href="#ecosystem-updates-1">Ecosystem Updates</a></h2>
<p>The blueprints in all official projects (and any provided by popular addons) 
will need to be updated to detect <code>ember-qunit</code> version and emit the correct
output.</p>
<p>This includes:</p>
<ul>
<li>ember-source</li>
<li>ember-data</li>
<li>ember-cli-legacy-blueprints</li>
<li>others?</li>
</ul>
<p>This exact process was done for <code>ember-mocha</code>'s migration, making this a well
trodden path.</p>
<h2 id="update-guides"><a class="header" href="#update-guides">Update Guides</a></h2>
<p>The guides includes a section for testing, this section needs to be reviewed
and revamped to match the proposal here.</p>
<h2 id="deprecate-older-apis"><a class="header" href="#deprecate-older-apis">Deprecate older APIs</a></h2>
<p>Once this RFC is implemented, the older APIs will be deprecated and retained 
for a full LTS cycle (assuming speedy landing, this would mean the older APIs 
would be deprecated around Ember 2.20). After that timeframe, the older APIs
will be removed from <code>ember-qunit</code> and <code>ember-test-helpers</code> and they will
release with SemVer major version bumps.</p>
<p>Note that while the older <code>moduleFor</code> and <code>moduleForComponent</code> APIs will be
deprecated, they will still be possible to use since the host application can
pin to a version of <code>ember-qunit</code> / <code>ember-test-helpers</code> that support its own
usage. This is a large benefit of migrating these testing features away from 
<code>Ember</code>'s internals, and into the addon space.</p>
<h2 id="relationship-to-grand-testing-unification"><a class="header" href="#relationship-to-grand-testing-unification">Relationship to &quot;Grand Testing Unification&quot;</a></h2>
<p>This RFC is a small stepping stone towards the future where all types of tests
share a similar API. The API proposed here is much easier to extend to provide
the functionality that is required for <a href="https://github.com/emberjs/rfcs/pull/119">emberjs/rfcs#119</a>.</p>
<h1 id="how-we-teach-this-29"><a class="header" href="#how-we-teach-this-29">How We Teach This</a></h1>
<p>This change requires updates to the API documentation of <code>ember-qunit</code> and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.</p>
<h1 id="drawbacks-53"><a class="header" href="#drawbacks-53">Drawbacks</a></h1>
<h2 id="churn-1"><a class="header" href="#churn-1">Churn</a></h2>
<p>As mentioned in <a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a>, test
related churn is quite painful and annoying. In order to maintain the general
goodwill of folks, we must ensure that we avoid needless churn. </p>
<p>This RFC should be implemented in conjunction with 
<a href="https://github.com/emberjs/rfcs/pull/229">emberjs/rfcs#229</a> so that we can avoid
multiple back to back changes in the blueprints.</p>
<h2 id="qunitjsqunit977"><a class="header" href="#qunitjsqunit977"><a href="https://github.com/qunitjs/qunit/issues/977">qunitjs/qunit#977</a></a></h2>
<p>Until very recently, the QUnit nested module API was only able to allow a single
callback for each of the hooks per-nesting level. This means that the proposal in
this RFC (which requires the hooks to be setup by <code>ember-qunit</code>) would disallow
user-land <code>beforeEach</code>/<code>afterEach</code> hooks to be setup.</p>
<p>The work around is &quot;simple&quot; (if somewhat annoying), which is to &quot;just nest another
level&quot;. The good news is that <a href="https://github.com/trentwillis">Trent Willis</a> fixed
the underlying problem in <a href="https://github.com/qunitjs/qunit/pull/1188">qunitjs/qunit#1188</a>,
which should be released as 2.3.4 well before this RFC is merged.</p>
<h1 id="alternatives-53"><a class="header" href="#alternatives-53">Alternatives</a></h1>
<p>The simplest alternative is to do nothing. This would loose all of the positive
benefits mentioned in this RFC, but should still be considered a possibility...</p>
<h1 id="unanswered-questions"><a class="header" href="#unanswered-questions">Unanswered Questions</a></h1>
<h2 id="hooks-argument"><a class="header" href="#hooks-argument"><code>hooks</code> argument</a></h2>
<p>A few folks (e.g. <a href="https://github.com/ebryn">@ebryn</a> and <a href="https://github.com/stefanpenner">@stefanpenner</a>)
have approached me with concerns around the <code>hooks</code> argument I have mentioned/used here. The concerns
are generally an initial reaction to the QUnit nested modules API in general and not directly related
to this RFC (other than it highlighting a new feature that they haven't used before).</p>
<p>The main concerns are:</p>
<ul>
<li>Teaching folks what <code>hooks</code> means is a bit more difficult because it does not represent the &quot;test
environment&quot;, but rather just a way to invoke the callbacks for <code>before</code> / <code>beforeEach</code> / <code>after</code> /
<code>afterEach</code>.</li>
<li>Passing only <code>hooks</code> to the helper functions proposed in the RFC means that if we ever need to thread
more information through, we either have to use <code>hooks</code> as a transport or change our API to add more
arguments.</li>
<li>It seems somewhat impossible to communicate across multiple helpers (again without using <code>hooks</code>
as a state/transport mechanism).</li>
</ul>
<p>I've kicked off a conversation over with the QUnit folks in https://github.com/qunitjs/qunit/issues/1200.
If that PR were merged this proposal would be modified to the following syntax:</p>
<pre><code class="language-js">// current proposal
module('x-foo', function(hooks) {
  setupRenderingTest(hooks);
  // ....snip....
});

// after qunitjs/qunit#1200
module('x-foo', function(hooks) {
  setupRenderingTest(this);
  // ....snip....
});
</code></pre>
<p>Another possible solution is to rename the argument (here and in the blueprints) to <code>module</code>.
This is more in line with what the QUnit folks view it as: the &quot;module context&quot; that
is being created for that specific <code>QUnit.module</code> invocation.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-07-14
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/236
Tracking: https://github.com/emberjs/rfc-tracking/issues/26</p>
<hr />
<h1 id="summary-55"><a class="header" href="#summary-55">Summary</a></h1>
<p>This RFC proposes to deprecate the prototype extensions done by <code>Ember.String</code>, deprecate the <code>loc</code> method, and moving <code>htmlSafe</code> and <code>isHTMLSafe</code> to <code>@ember/template</code>.</p>
<h1 id="motivation-56"><a class="header" href="#motivation-56">Motivation</a></h1>
<p>Much of the public API of Ember was designed and published some time ago, when the client-side landscape looked much different. It was a time without many utilities and methods that have been introduced to JavaScript since, without the current rich npm ecosystem, and without ES6 modules. On the Ember side, Ember CLI and the subsequent addons were still to be introduced. Global mode was the way to go, and extending native prototypes like Ember does for <code>String</code>, <code>Array</code> and <code>Function</code> was a common practice.</p>
<p>With the introduction of <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md">RFC #176</a>, an opportunity to reduce and reorganize the API that is shipped by default with an Ember application appears. A lot of nice-to-have functionality that was added at that time can now be moved to optional packages and addons, where they can be maintained and evolved without being tied to the core of the framework.</p>
<p>In the specific case of <code>Ember.String</code>, our goal is that users that need these utility functions will include <code>@ember/string</code> in their dependencies, or rely on common utility packages like <a href="https://lodash.com/docs/#camelCase"><code>lodash.camelcase</code></a>.</p>
<p>To achieve the above goal we will move the <code>isHTMLSafe</code>/<code>htmlSafe</code> pair into a new package, deprecate <code>String.prototype</code> extensions, and deprecate the utility functions under the <code>Ember.String</code> namespace.</p>
<p>The <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#organize-by-mental-model">&quot;Organize by Mental Model&quot;</a> section of RFC #176 mentions the concept of chunking. In the current setup, <code>isHTMLSafe</code>/<code>htmlSafe</code> make sense in the <code>Ember.String</code> namespace because they operate on strings, and they are available on the prototype, <code>&quot;myString&quot;.htmlSafe()</code>.
However, once prototype extensions are removed it becomes clearer that while this pair operates on strings, they don't transform them in the same way as <code>capitalize</code> or <code>dasherize</code>. They are instead a way for the user to communicate to the templating engine that this string should be safe to render. For this reason, moving to <code>@ember/template</code> seems appropriate.</p>
<p>Extending native prototypes, like we do for <code>String</code> with <code>&quot;myString&quot;.dasherize()</code> and the rest of the API, has been falling out of favour more as time goes by.
While the tradeoff might have been positive at the beginning, as it allowed users access to a richer API, prototype extensions blur the line between what is the framework and what is the language in a way that is not benefitial in the current module-driven and package-rich ecosystem.</p>
<p>Relatedly, deprecating <code>Ember.String</code> and requiring <code>@ember/string</code> as a dependency allows Ember to provide a leaner default core to all users, as well as iterate faster on the <code>@ember/string</code> package if desired.
Doing this will also open a path to extract more packages in the future.</p>
<h1 id="transition-path-4"><a class="header" href="#transition-path-4">Transition Path</a></h1>
<p>It is important to understand that the transition path will be done in the context of the new modules API defined in RFC #176, which is scheduled to land in 2.16.
As this will likely be first of many packages to be extracted from the Ember source, the transition path arrived on needs to be clear and user-friendly.</p>
<h2 id="what-is-happening-for-framework-developers"><a class="header" href="#what-is-happening-for-framework-developers">What is happening for framework developers?</a></h2>
<p>The order of operations will be as follows:</p>
<ol>
<li>Move <code>htmlSafe</code> and <code>isHTMLSafe</code> to <code>@ember/template</code>
<ul>
<li>Update https://github.com/ember-cli/ember-rfc176-data</li>
</ul>
</li>
<li>Create an <code>@ember/string</code> package with the remaining public API</li>
<li>Create an <code>ember-string-prototype-extensions</code> package that introduces <code>String</code> prototype extensions to aid in transitioning</li>
<li>Make <code>ember-cli-babel</code> aware of the <code>@ember/string</code> package so it tells <code>babel-plugin-ember-modules-api-polyfill</code> not to convert those imports to the global <code>Ember</code> namespace</li>
<li>Update usages in Ember and Ember Data codebases so that the projects do not trigger deprecations</li>
<li>Deprecate <code>Ember.String</code>
<ul>
<li>Write deprecation guide which mentions minimum version of <code>ember-cli-babel</code>, and how/when to use <code>@ember/string</code> and <code>ember-string-prototype-extensions</code> packages</li>
</ul>
</li>
<li>Deprecate <code>loc</code> in <code>@ember/string</code></li>
</ol>
<h2 id="what-is-happening-for-framework-users"><a class="header" href="#what-is-happening-for-framework-users">What is happening for framework users?</a></h2>
<p>If you are using <code>Ember.String.loc</code>, you will be instructed to move to a dedicated localization solution, as this method will be completely deprecated.</p>
<p>If you are using <code>Ember.String.htmlSafe</code> or <code>Ember.String.isHTMLSafe</code>, you will be instructed to run the <a href="https://github.com/ember-cli/ember-modules-codemod"><code>ember-modules-codemod</code></a> and it will update to the correct imports from the <code>@ember/template</code> package.</p>
<p>If you are using one of the other <code>Ember.String</code> methods, like <code>Ember.String.dasherize</code>, you will receive a deprecation warning to inform you that you should run the <a href="https://github.com/ember-cli/ember-modules-codemod"><code>ember-modules-codemod</code></a>, update <code>ember-cli-babel</code> to a specific minor version, and add <code>@ember/string</code> to your application's or addon's dependencies.</p>
<p>If you are using the <code>String</code> prototype extensions, like <code>'myString'.dasherize()</code>, on top of the previous instructions you will be instructed to install <code>ember-string-prototype-extensions</code> in case updating the code to <code>dasherize('myString')</code> is not trivial.</p>
<h2 id="timeline-1"><a class="header" href="#timeline-1">Timeline</a></h2>
<ul>
<li>Deprecations are introduced - Ember 2.x
<ul>
<li><code>String</code> protoype extensions are deprecated</li>
<li><code>Ember.String</code> functions are deprecated</li>
<li><code>loc</code> is completely deprecated</li>
<li><code>isHTMLSafe</code> and <code>htmlSafe</code> are moved to <code>@ember/template</code></li>
</ul>
</li>
<li>Transition packages are introduced - Ember 2.x
<ul>
<li><code>@ember/string</code>, which replaced <code>Ember.String</code></li>
<li><code>ember-string-prototype-extensions</code>, which brings <code>String</code> prototype extensions back</li>
</ul>
</li>
<li>Deprecations are removed - Ember 3.x, <code>@ember/string</code> 2.x
<ul>
<li>New major version of Ember is released</li>
<li>New major version of <code>@ember/string</code> is released</li>
</ul>
</li>
</ul>
<h1 id="how-we-teach-this-30"><a class="header" href="#how-we-teach-this-30">How We Teach This</a></h1>
<h2 id="official-code-bases-and-documentation"><a class="header" href="#official-code-bases-and-documentation">Official code bases and documentation</a></h2>
<p>The official documentation –website, Guides, API documentation– should be updated not to use <code>String</code> prototype extensions.
This documentation should already use the new modules API from an effort to update it for Ember 2.16.</p>
<p>The Guides section on <em>disabling prototype extension</em> will need to be updated when <code>String</code> prototype extensions are removed from Ember.</p>
<p>Resources owned by the Ember teams, such and Ember and Ember Data code bases, the Super Rentals repository, or the builds app for the website, will be updated accordingly.</p>
<h2 id="emberstringhtmlsafe-and-emberstringishtmlsafe"><a class="header" href="#emberstringhtmlsafe-and-emberstringishtmlsafe"><code>Ember.String.htmlSafe</code> and <code>Ember.String.isHTMLSafe</code></a></h2>
<p>The move of <code>htmlSafe</code> and <code>isHTMLSafe</code> from <code>Ember.String</code> to <code>@ember/template</code> should be documented as part of the <a href="https://github.com/ember-cli/ember-rfc176-data">ember-rfc176-data</a> and related codemods efforts, as that project is the source of truth for the mappings between the <code>Ember</code> global namespace and <code>@ember</code>-scoped modules.</p>
<h2 id="emberstringloc-and-import--loc--from-emberstring-emberstring-to-emberstring-string-prototype-extensions"><a class="header" href="#emberstringloc-and-import--loc--from-emberstring-emberstring-to-emberstring-string-prototype-extensions"><code>Ember.String.loc</code> and <code>import { loc } from '@ember/string';</code>, <code>Ember.String</code> to <code>@ember/string</code>, <code>String</code> prototype extensions</a></h2>
<p>An entry to the <a href="https://emberjs.com/deprecations/">Deprecation Guides</a> will be added outlining the different recommended transition strategies.</p>
<h3 id="emberstringloc-import--loc--from-emberstring"><a class="header" href="#emberstringloc-import--loc--from-emberstring"><code>Ember.String.loc</code>, <code>import { loc } from '@ember/string';</code></a></h3>
<p>As this function is deprecated, users will be recommended to use a <a href="https://emberobserver.com/categories/internationalization">dedicated localization solution</a>.</p>
<h3 id="emberstring-to-emberstring"><a class="header" href="#emberstring-to-emberstring"><code>Ember.String</code> to <code>@ember/string</code></a></h3>
<p>The way that <code>@ember</code>-scoped modules will work in 2.16 is that <code>ember-cli-babel</code> will convert something like <code>import { dasherize } from '@ember/string';</code> to <code>import Ember from 'Ember'; const dasherize = Ember.String.dasherize;</code>.
What this means is that <code>import { dasherize } from '@ember/string';</code> will trigger a deprecation if you do not have the <code>@ember/string</code> package in your dependencies.</p>
<p>To address the above deprecation you will need to update <code>ember-cli-babel</code> to a a specific minor version or higher, to make sure it has the logic to detect <code>@ember/string</code>. The specific minor version will be known at the time the deprecation guide is written.
You will also need to add <code>@ember/string</code> to your application's development dependencies, or your addon's dependencies.</p>
<h3 id="string-prototype-extensions"><a class="header" href="#string-prototype-extensions"><code>String</code> prototype extensions</a></h3>
<p>If you are using <code>'myString'.dasherize()</code> or one of the other functions added to <code>String</code>, you will be instructed to replace that usage with <code>import { dasherize } from '@ember/string'; dasherize('myString')</code>, in addition to the changes on the previous section.</p>
<p>In case your code base is complicated enough that migrating all these usages at the same time is not convenient, you will be able to add <code>ember-string-prototype-extensions</code> to your dependencies, which will bring back extensions, without deprecations.</p>
<h1 id="drawbacks-54"><a class="header" href="#drawbacks-54">Drawbacks</a></h1>
<p>A lot of addons that deal with names depend on this behaviour, so they will need to install the addon. Also, Ember Data and some external serializers require these functions.</p>
<p><code>htmlSafe</code> and <code>isHTMLSafe</code> would need to change packages, thus the reason to try and provide an Ember Watson recipe.</p>
<p>Another side-effect of this change is that certain users might be shipping duplicated code between <code>Ember.String</code> and <code>@ember/string</code>, but it is a necessary stepping stone and might be able to be addressed via svelting.</p>
<h1 id="alternatives-54"><a class="header" href="#alternatives-54">Alternatives</a></h1>
<p>Leave things as they are.</p>
<h1 id="unresolved-questions-43"><a class="header" href="#unresolved-questions-43">Unresolved questions</a></h1>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-07-20
RFC PR: https://github.com/emberjs/rfcs/pull/237</p>
<hr />
<h1 id="summary-56"><a class="header" href="#summary-56">Summary</a></h1>
<p>This RFC proposes the deprecation of the following classes:</p>
<ul>
<li><code>Ember.OrderedSet</code></li>
<li><code>Ember.Map</code></li>
<li><code>Ember.MapWithDefault</code></li>
</ul>
<p>These classes need to be moved to an external addon given they are private classes and unused in Ember.js itself.</p>
<h1 id="motivation-57"><a class="header" href="#motivation-57">Motivation</a></h1>
<p>These classes have not been used in Ember itself for a while now. They have always been private but they are used in a few addons, and in particular Ember Data is using them.</p>
<h1 id="transition-path-5"><a class="header" href="#transition-path-5">Transition Path</a></h1>
<p><code>Ember.Map</code> and <code>Ember.MapWithDefault</code> will be deprecated and not extracted, but not before the fix mentioned in the following paragraph is landed in Ember Data. There is already an addon with <code>Ember.OrderedSet</code> extracted (<a href="https://github.com/emberjs/ember-ordered-set">@ember/ordered-set</a>).</p>
<p>Ember Data is quite likely the biggest project using these classes. There is already a PR that needs merging before deprecating <code>Ember.Map</code> and <code>Ember.MapWithDefault</code> https://github.com/emberjs/data/pull/5255. Ember Data still needs to migrate to <code>@ember/ordered-set</code> to its relationship logic.</p>
<p>Once Ember Data is updated to not use the classes from Ember, and that fix is released, the <code>Ember.Map</code> and <code>Ember.MapWithDefault</code> can be deprecated in Ember itself.</p>
<h1 id="how-we-teach-this-31"><a class="header" href="#how-we-teach-this-31">How We Teach This</a></h1>
<p>These classes being private would make this simple than other deprecations. People were not supposed to be using a private API and the few that were, would just need to use a new addon.</p>
<p>This should not impact many codebases.</p>
<h1 id="drawbacks-55"><a class="header" href="#drawbacks-55">Drawbacks</a></h1>
<p>This requires cooperation with Ember Data, the main user of these classes. It would be nice to have moved Ember Data to using the addon before releasing Ember with the deprecation so the average user does not see any deprecation warning.</p>
<h1 id="alternatives-55"><a class="header" href="#alternatives-55">Alternatives</a></h1>
<p>Other option would be moving these classes to Ember Data itself or leaving things as they are now.</p>
<h1 id="unresolved-questions-44"><a class="header" href="#unresolved-questions-44">Unresolved questions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-07-28
RFC PR: https://github.com/emberjs/rfcs/pull/240</p>
<hr />
<h1 id="summary-57"><a class="header" href="#summary-57">Summary</a></h1>
<p>This RFC aims to solidify the usage of ES2015 Classes as a public API of Ember so
that users can begin building on them, and projects like <code>ember-decorators</code> can
continue to push forward with experimental Javascript features. This includes:</p>
<ul>
<li>Making the class <code>constructor</code> function a public API</li>
<li>Modifying some of the internals of <code>Ember.Object</code> to support existing features
and make the usage of ES Classes cross-compatible with <code>Ember.Object</code></li>
</ul>
<p>It does <em>not</em> propose additions in the form of helpers or decorators, which should
continue to be iterated on in the community as the spec itself is finalized. It also
does not propose deprecating or removing existing functionality in <code>Ember.Object</code>.</p>
<h1 id="motivation-58"><a class="header" href="#motivation-58">Motivation</a></h1>
<p>The Ember Object model has served its purpose well over the years, but now that
ES Classes are becoming prevalent throughout the wider Javascript community
it is beginning to show its age. With class properties at stage 3 and decorators at
stage 2 in the TC39 process, classes are finally at a point where we can start
integrating them into Ember.</p>
<p>The <a href="https://github.com/rwjblue/ember-decorators">ember-decorators</a> project has been
experimenting with using ES Classes and filling out the Ember feature-set,
allowing us to write Ember classes like so:</p>
<pre><code class="language-javascript">export default class MyComponent extends Ember.Component {
  didInsertElement() {
    // do stuff
  }

  @computed
  get foo() {
    // do stuff
  }

  @action
  bar() {
    // do stuff
  }
}
</code></pre>
<p>Using classes makes Ember easier to teach and understand by normalizing it with
standard Javascript coding practices, and allows us to share code and solutions
with other frameworks and libraries. It also brings with it all the benefits of
ES Class syntax:</p>
<ul>
<li>More aligned with the greater Javascript community</li>
<li>Ability to share code more easily with other libraries and frameworks</li>
<li>Easier to statically analyze</li>
<li>Cleaner and easier to read (subjective)</li>
</ul>
<p>The Ember Object model already works extremely well with ES classes, as
demonstrated above, but there several failure scenarios. Furthermore, because
they are not officially supported as a public API, there is no guarantee
that they will continue to work well. Thus, this RFC seeks to solidify the
behavior of ES Classes so that the community can continue to experiment with
new Javascript features and build on a stable API.</p>
<h1 id="detailed-design-52"><a class="header" href="#detailed-design-52">Detailed Design</a></h1>
<p>Many of the standard features of Ember classes work out of the box today, either with
vanilla ES Classes or through <code>ember-decorators</code>, including:</p>
<ul>
<li>Inheritance</li>
<li>Lifecycle hooks</li>
<li>Computeds</li>
<li>Injections</li>
<li>Actions</li>
</ul>
<p>However, the following features either do not exist or do not work as a
user familiar with <code>Ember.Object</code> would expect:</p>
<ul>
<li>Extending from ES Classes using <code>extend</code></li>
<li>Class properties</li>
<li>Mixins</li>
<li>Observers and events</li>
<li>Merged and concatenated properties</li>
</ul>
<p>These features will require changes to <code>Ember.Object</code></p>
<h2 id="extend"><a class="header" href="#extend">Extend</a></h2>
<p>Currently, once a class is defined using ES Classes it is not possible for users
to extend it using the previous CoreObject style of writing and extending classes.
This can limit the rate of adoption because ES Classes would become a trapdoor -
once you begin using them, you must continue to use them. It would be a particularly
thorny issue for addon developers, who may design components which their users
expect to be able to extend and modify.</p>
<p>This RFC proposes that <code>extend</code> be fixed on ES Classes to make them fully
cross-compatible with the existing syntax. There are two general approaches to
making this work:</p>
<ol>
<li>
<p>Modify CoreObject to use prototypes/ES Classes internally. This would bring
CoreObject more inline with ES Classes, but would be a significant internal change.</p>
</li>
<li>
<p>Modify CoreObject to have different behavior if it is extending an ES Class
using <code>extend</code>.</p>
</li>
</ol>
<p>Both approaches should be explored and benchmarked to determine if there are an
significant advantages to one over the other.</p>
<h2 id="class-properties"><a class="header" href="#class-properties">Class Properties</a></h2>
<p>When using <code>Ember.Object.extend</code>, properties that are passed in on the object
are assigned to the prototype of the class:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({ bar: 'baz' });
const foo = Foo.create();

console.log(Foo.prototype.bar) // 'baz'
foo.hasOwnProperty('bar') // false
</code></pre>
<p>This differs from the behavior of ES Class properties, which initialize their
value on the instance of the class.</p>
<pre><code class="language-javascript">class Foo {
  bar = 'baz'
}

const foo = new Foo();

console.log(Foo.prototype.bar) // undefined
foo.hasOwnProperty('bar') // true
</code></pre>
<p>The above is essentially currently compiled down by Babel to the following:</p>
<pre><code class="language-javascript">class Foo {
  constructor() {
    this.bar = 'baz';
  }
}
</code></pre>
<p>Property assignments like this are always done at the end of the constructor,
and given the requirement that <code>super</code> must always be called before properties
are assigned it is unlikely that this will change as the spec progresses.</p>
<p>While one might intuitively expect class properties to function the same in
ES Classes as they do with Ember Objects, this difference in behavior means that
class properties will always be assigned after properties passed into <code>create</code>
are initialized on the object, and thus will always win:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({ testProp: 'default value' });

class Bar extends Ember.Object {
  testProp = 'default value'
}

const foo = Foo.create({ testProp: 'new value' });
const bar = Bar.create({ testProp: 'new value' });

console.log(foo.get('testProp')); // 'new value'
console.log(bar.get('testProp')); // 'default value'
</code></pre>
<p>This behavior makes sense when you consider that it is equivalent to assigning
values in <code>init</code> rather than on the object when it is defined. Rather than modify
<code>Ember.Object</code> to treat class properties as default values, this RFC proposes that
we accept the difference in behavior and utilize the constructor to allow users
to set default values, as in the following example:</p>
<pre><code class="language-javascript">class Foo extends Ember.Object {
  constructor(props) {
    props.testProp = props.testProp || 'default value';

    super(props);
  }
}
</code></pre>
<p>This enforces a public API rather than allowing <code>create</code> to override values as
it pleases, and is more inline with the behavior of components in Glimmer today -
args that are passed into the class are distinguished from properties that are
defined on the class.</p>
<h2 id="mixins"><a class="header" href="#mixins">Mixins</a></h2>
<p>Mixins are a contentious part of both the Ember Object model and the wider
Javascript community - some swear by the pattern, and others believe it fundamentally
flawed. While Ember mixins are at the core of Ember Object, the fact is that
no standard solution for them has arisen in the wider Javascript community as
of yet.</p>
<p>Additionally, while concepts like computed properties, actions, and
service injection are either unique to Ember or highly dependent on implementation,
mixins can be implemented in a generic way which could be used across all of
Javascript, independent of one's framework or library of choice. With that in
mind, this RFC considers mixins out of scope and suggests that in the future Ember
users can choose to use a mixin library if it suits their needs.</p>
<p>It should also be noted that existing classes which have used mixins can still be
extended using ES Class syntax:</p>
<pre><code class="language-javascript">const Mix = Ember.Mixin.create({ bar: 'baz' });
const Foo = Ember.Object.extend(Mix, { /* ... */ });

class Bar extends Foo { /* ... */ }

const bar = Bar.create();

console.log(bar.get('bar')); // 'baz'
</code></pre>
<h2 id="observers-and-events"><a class="header" href="#observers-and-events">Observers and Events</a></h2>
<p>Observers and events both fail to work properly when using ES Class syntax. The root
of the issue here is how <code>Ember.Object</code> works at a fundamental level, and will require
some refactoring to fix.</p>
<p>Currently, each time <code>Ember.Object.extend</code> is used, it stores the list of mixins and
objects passed in on a list which also contains the superclass's properties and mixins,
and so on. A class is then returned which has access to a closure variable, <code>wasApplied</code>:</p>
<pre><code class="language-javascript">makeCtor = function() {
  wasApplied = false;

  return class {
    constructor() {
      if (!wasApplied) {
        this.proto();
      }
    }
  }
}
</code></pre>
<p>The <code>proto</code> function walks the chain of stored mixins, collapsing them into a single object
prototype the first time the class is created. It is during this walk that observers and
events listeners are applied and finalized, as well as merged and concatenated properties
applied (this will be touched on more in the next section).</p>
<p>Unfortunately, due to the nature of how observers and event listeners work, they cannot be
applied at class definition time without a class decorator. For example:</p>
<pre><code class="language-javascript">const Foo = Ember.Object.extend({
  fooObserver: Ember.observer('foo', function() { /* ... */m })
});

class Bar extends Foo {
  fooObserver() { /* ... */ }
}
</code></pre>
<p>When <code>proto</code> walks the mixin chain for Foo, it will add an observer that triggers the
<code>fooObserver</code> function whenever <code>foo</code> changes. Bar, however, overloads the <code>fooObserver</code>
function with a function that is <em>not</em> observed, and thus should not trigger (this is
analagous to how Ember Object's work today). Currently there is no time at which
Bar can inspect undecorated properties to determine if the superclass has already defined
them and if they are observed and thus should have the observer removed.</p>
<p>To fix this, the <code>wasApplied</code> state should be moved to the ember meta object on the
class itself, so that both Ember Objects and ES Classes can track if they have had it
applied. Additional logic will also need to be added to allow the current &quot;squashing&quot;
behavior of <code>proto</code> to work with Prototypes instead of a list of mixins as well.</p>
<h2 id="merged-and-concatenated-properties"><a class="header" href="#merged-and-concatenated-properties">Merged and Concatenated Properties</a></h2>
<p>Ember Objects currently have the ability to define special properties which are
merged or concatenated with their superclass when extended. This is most commonly
seen with <code>actions</code> and <code>classNames</code> among others.</p>
<p>As mentioned in the last section, merged and concatenated properties are also
combined during the <code>proto</code> &quot;squash&quot; phase, and so it is also broken in ES Classes
currently. This RFC proposes that their behavior also be fixed as part of the refactors
to Ember.Object.</p>
<h1 id="how-we-teach-this-32"><a class="header" href="#how-we-teach-this-32">How We Teach This</a></h1>
<p>The sole purpose of this RFC is to make the behavior of ES Classes within Ember a
public API so that projects like <code>ember-decorators</code> can continue to build and experiment
with confidence that the underlying behavior will not change. The Ember Object model
will remain exactly the same as today, and will continue to be the recommended path
for Ember users. Thus, we will not need to add new documentation for the time being.</p>
<h1 id="drawbacks-56"><a class="header" href="#drawbacks-56">Drawbacks</a></h1>
<ul>
<li>Making <code>constructor</code> a public API means we are solidifying the lifecycle of
objects, locking us into a particular sequence of events (<code>init</code> occurs within
the <code>super()</code> portion of the constructor).</li>
<li>Lack of mixin support may make it difficult for mixin heavy codebases to utilize
ES Classes.</li>
<li>ES Class features/usage such as getters and setters may confuse users in general
(getter functions will <em>appear</em> to work, but without a <code>computed</code> decorator will
not update, etc.)</li>
</ul>
<h1 id="alternatives-56"><a class="header" href="#alternatives-56">Alternatives</a></h1>
<ul>
<li>Class property initialization can be changed such that properties are initialized
after the constructor runs entirely, allowing them to be overwritten by values
passed to <code>create</code></li>
</ul>
<h1 id="topics-for-future-rfcs-1"><a class="header" href="#topics-for-future-rfcs-1">Topics for Future RFCs</a></h1>
<p>While working on this RFC, some issues were brought into focus regarding existing
features in CoreObject that are seen as problematic or unintuitive. In order to
avoid bikeshedding these have been slated for discussion in future RFCs, but the
discussion points have been included below.</p>
<h2 id="merged-and-concatenated-properties-1"><a class="header" href="#merged-and-concatenated-properties-1">Merged and Concatenated Properties</a></h2>
<p>Merged and concatenated properties are pain points for new Ember developers,
specifically because they give no lexical hint that they are special in any way.
Developers must know that these particular properties will be merged with the
superclass, and there is no way to opt out of this behavior.</p>
<p>With decorators, this same behavior can be accomplished in a much clearer and
more straightforward way:</p>
<pre><code class="language-javascript">class FooComponent extends Ember.Component {
  @concatenated classNameBindings = ['foo']

  @computed
  get foo() { /* ... */ }

  @merged actions = {
    bar() { /* ... */ }
  }
}
</code></pre>
<p>They could also be accomplished more ergonomically with specialized decorators:</p>
<pre><code class="language-javascript">class FooComponent extends Ember.Component {
  @className
  @computed
  get foo() { /* ... */ }

  @action
  bar() { /* ... */ }
}
</code></pre>
<p>This approach has two distinct advantages over the existing behavior:</p>
<ol>
<li>It is less magical. The decorators indicate to new users that the properties are
special in some way, and ultimately they are just plain decorators, which are
compatible with ES Classes as a whole and can be reused anywhere.</li>
<li>It provides a way to opt out of the behavior. Currently, there is no easy
way to prevent properties which were marked to be merged from being merged,
meaning subclasses are stuck with the values that their superclass provided.</li>
</ol>
<h2 id="observers-and-listeners"><a class="header" href="#observers-and-listeners">Observers and Listeners</a></h2>
<p>Observers and event listeners are a powerful pattern that saw a lot of usage in Ember 1.
However, it is now widely accepted that they are problematic when overused, and using
computed properties and lifecycle hooks are better patterns in most cases.</p>
<p>As such, rather than having events and observers turned on by default it may make
more sense to have them be opt-in APIs. This could be accomplished by making new
class decorators like so:</p>
<pre><code class="language-javascript">@evented
class Foo extends Ember.Object {
  @on('init')
  onInit() {
    // do something
  }
}
</code></pre>
<p>Or it could be accomplished with new base classes that include the functionality:</p>
<pre><code class="language-javascript">class Foo extends EventedObject {
  @on('init')
  onInit() {
    // do something
  }
}
</code></pre>
<h1 id="unresolved-questions-45"><a class="header" href="#unresolved-questions-45">Unresolved questions</a></h1>
<p>None currently</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-09-25
RFC PR: https://github.com/emberjs/rfcs/pull/252</p>
<hr />
<h1 id="summary-58"><a class="header" href="#summary-58">Summary</a></h1>
<p>Solicit feedback on dropping support for IE9, IE10, and PhantomJS.</p>
<h1 id="motivation-59"><a class="header" href="#motivation-59">Motivation</a></h1>
<p>As Ember heads towards version 3.0, it is a good time to evaluate our browser support matrix. Ember follows Semantic Versioning, and we consider browser compatibility to be under the umbrella of those guarantees. In other words, we will continue to support whatever browsers we officially support in Ember 3.0 until Ember 4.0.</p>
<p>We want to make this decision on the basis of the browsers that our community still needs to support, while weighing that against the costs we bear as a community to support older browsers. This RFC will lay out some of those costs, so we can decide what tradeoff is most appropriate.
Members of the core team maintain many different kinds of apps across many different kinds of companies. Some of us work on applications with small, agile teams, while others work inside of large corporations with many engineers. When this topic came up amongst the team, we discovered that, across all these different companies and Ember apps, we did not generally support IE9, IE10, and PhantomJS.</p>
<p>Because of this, the core team's impression is that the costs support now far exceed the benefits, and we are considering dropping support for them in Ember 3.0. Before we make the decision, we want to hear from the rest of the community. Supporting IE9, IE10, and PhantomJS incurs significant cost, both in terms of features and maintenance, and we want the community to help us think through the cost-benefit analysis.</p>
<p>Ember is more than just the framework's code. When people use Ember, they expect to be able to use Ember's tooling, read Ember's documentation, find solutions to problems on Stack Overflow, and read tutorials produced by community members. <strong>All of these, including addons that follow Ember’s lead, are shackled to the limitations of these legacy browsers.</strong> By dropping support for them, people can begin to rely on the improved baseline of features.</p>
<p>Some of the features (unavailable in IE9, IE10, or PhantomJS) that addons will be able to freely take advantage of include:</p>
<ul>
<li>requestAnimationFrame (<a href="http://caniuse.com/#feat=requestanimationframe">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">MDN</a>)</li>
<li>CSS flexbox (<a href="http://caniuse.com/#search=flexbox">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes">MDN</a>)</li>
<li>Websockets (<a href="http://caniuse.com/#feat=websockets">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">MDN</a>)</li>
<li>let (<a href="http://caniuse.com/#feat=let">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">MDN</a>)</li>
<li>const (<a href="http://caniuse.com/#feat=const">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">MDN</a>)</li>
<li>TypedArray (<a href="http://caniuse.com/#feat=typedarrays">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">MDN</a>)</li>
<li>Geolocation API (<a href="https://caniuse.com/#search=Geolocation">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation">MDN</a>)</li>
<li>Online/offline API (<a href="http://caniuse.com/#feat=online-status">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Online_and_offline_events">MDN</a>)</li>
<li>XHR advanced features (<a href="https://caniuse.com/#feat=xhr2">caniuse</a>, <a href="https://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/">specification</a>)</li>
<li>HTTP2 (<a href="http://caniuse.com/#feat=http2">caniuse</a>, <a href="https://en.wikipedia.org/wiki/HTTP/2">wikipedia</a>)</li>
<li>Web Workers (<a href="http://caniuse.com/#feat=webworkers">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">MDN</a>)</li>
<li>IndexedDB (<a href="http://caniuse.com/#feat=indexeddb">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">MDN</a>) </li>
<li>WebGL (<a href="http://caniuse.com/#feat=webgl">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">MDN</a>)</li>
<li>File API (<a href="http://caniuse.com/#feat=fileapi">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/File">MDN</a>)</li>
<li>PageTransitionEvent (<a href="http://caniuse.com/#feat=page-transition-events">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/PageTransitionEvent">MDN</a>)</li>
<li>SVG filters (<a href="http://caniuse.com/#feat=svg-filters">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Filters_Tutorial">MDN</a>)</li>
<li>MutationObserver (<a href="http://caniuse.com/#feat=mutationobserver">caniuse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MDN</a>)</li>
</ul>
<p>Below, we’ve outlined several specific features we’re interested in using to improve the Ember framework itself. We’ve also included some other supporting arguments for this decision.</p>
<h2 id="vendor-support"><a class="header" href="#vendor-support">Vendor Support</a></h2>
<p>Microsoft dropped most support and maintenance for IE9 and IE10 on 2016-01-16 (IE9 on Vista SP2 <a href="http://www.allyncs.com/docs/lifecyclesupport.html">expired in April 2017</a>).</p>
<p>With the advent of headless Chrome and Firefox, PhantomJS is now <a href="https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE">effectively unmaintained</a>. The default testing boilerplate for Ember CLI-generated applications was changed to headless Chrome in Ember CLI 2.15.</p>
<h2 id="weakmap-map-set"><a class="header" href="#weakmap-map-set">WeakMap, Map, Set</a></h2>
<p>From a framework perspective, being able to rely on native <code>WeakMap</code> support will allow us to remove a significant number of fallback paths that are used in browsers without <code>WeakMap</code>. Using <code>WeakMap</code> results in better developer ergonomics as it allows us to remove many of the random properties that we currently have to assign to an object which makes interacting with your objects in the devtools much less noisy. Minimal support for WeakMap was <a href="http://kangax.github.io/compat-table/es6/#test-WeakMap">introduced in IE11</a>.</p>
<h2 id="better-es-class-support"><a class="header" href="#better-es-class-support">Better ES Class Support</a></h2>
<p>In order to support static class methods (with inheritance) transpilers (e.g. Babel) need to leverage the <code>Object.setPrototypeOf</code> / <code>Object.getPrototypeOf</code> APIs. Without the ability to rely on <code>Object.setPrototypeOf</code> we will not be able to continue iterating slowly towards leveraging ES classes as a replacement for the custom object model functionality that we have known and loved for so many years. Specifically, there is no replacement / capability to support proper inheritance with <code>.reopenClass</code>. There are several lower-fidelity hacks you might opt into, but none that we think satisfy the needs of the Ember community.</p>
<p>Generally this means IE11 is the oldest browser we can reliably transpile ES classes for reliably.</p>
<h2 id="typed-arrays"><a class="header" href="#typed-arrays">Typed Arrays</a></h2>
<p>Typed arrays are not currently used in Ember, but experimentation is underway deep in the internals of Glimmer VM to be able to further reduce template size <em>and</em> the costs associated with expanding the wire format (currently a JSON structure) into a runnable program. Leveraging typed arrays would allow Ember and Glimmer apps to completely avoid the wire format to opcode compilation that currently happens before initial render. It also significantly reduces the resulting memory footprint for the same runnable program.</p>
<h2 id="dom-api-improvements"><a class="header" href="#dom-api-improvements">DOM API Improvements</a></h2>
<p>Although IE9 introduced JavaScript engine with support for much of ES5, it was not until IE10 that the browser began to support much of what developers consider modern web platform APIs. Littered throughout the Ember and Glimmer VM codebase are <a href="https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L54">many</a> <a href="https://github.com/glimmerjs/glimmer-vm/blob/9ecc88504c81469ba20dba3ed3f37d373a998355/packages/%40glimmer/test-helpers/lib/helpers.ts#L170">examples</a> <a href="https://github.com/glimmerjs/glimmer-vm/blob/bfed16af6a5ecce4fbe9f27783245fe0f8b03480/build/broccoli/transpile-to-es5.js#L25">of</a> IE9 workarounds (and <a href="https://github.com/glimmerjs/glimmer-vm/blob/1759c16defc546b034b97e37141187652ed93859/packages/%40glimmer/runtime/lib/dom/props.ts#L49">PhantomJS workarounds</a>, in fact). We’ve worked hard to make these fixes free at runtime for modern browsers, but some cost is unavoidable.</p>
<p>PhantomJS in particular is a weird environment. Users must often fix Phantom-specific browser bugs, which is wasted effort since real users never run your app in Phantom. And &quot;how to debug in Phantom&quot; is an entire extra skill people are forced to learn. Testing your app in PhantomJS is generally a form of “testing theater”, since it fails to execute your code in a realistic environment.</p>
<h2 id="requestanimationframe"><a class="header" href="#requestanimationframe"><code>requestAnimationFrame</code></a></h2>
<p>IE10 introduced support for <code>requestAnimationFrame</code>, an efficient way to schedule work in the browser environment. We’re interested in using this API to explore incremental rendering strategies, and as a way to improve Ember’s coordination with the browser when native promises are used in application code.</p>
<h1 id="detailed-design-53"><a class="header" href="#detailed-design-53">Detailed Design</a></h1>
<p>When using Ember applications in IE9, IE10, or PhantomJS, Ember will cause an appropriate deprecation to be issued. The deprecation will be “until 3.0” and will reference an entry in the deprecation guide. The guide entry will describe For example:</p>
<blockquote>
<p>Using Ember.js in IE9, IE10, or PhantomJS is deprecated and will be unsupported in Ember.js 3.0. We recommend using Ember’s 2.x LTS releases if your applications must support those browsers.</p>
<p>PhantomJS is often used for continuous integration testing. We strongly suggest adopting headless Chrome or Firefox to run CI tests.</p>
</blockquote>
<h1 id="drawbacks-57"><a class="header" href="#drawbacks-57">Drawbacks</a></h1>
<p>Many users have told us that they chose Ember because of the community's commitment to backwards compatibility. There will always be organizations using Ember that exist on the tail-end of browser adoption patterns. We risk alienating or upsetting those users by dropping support for a browser that, while on the way out, is not yet completely gone.</p>
<p>However, in many cases, the requirement for supporting these legacy browsers is driven by non-technical management who do not have a strong sense of the experience of using apps in IE9/IE10. In practice, many applications are not rigorously tested in older browsers, and the performance is so bad that applications written using any framework perform poorly. Techniques that framework and application developers use to make Chrome fast quite often have pathological characteristics on browsers with legacy DOM and JavaScript engines.</p>
<p>Still, some people make it work, and dropping support may prevent those teams from staying with the community as it migrates to Ember 3.0.</p>
<p>As a mitigation for these concerns, the final release of Ember 2.x will itself be made an LTS release. This will ensure a 2.x platform supporting IE9+ with critical bugfix for roughly 8 months following the 3.0 release and security fixes for roughly 14 months after 3.0 release.</p>
<h1 id="alternatives-57"><a class="header" href="#alternatives-57">Alternatives</a></h1>
<h2 id="bring-your-own-compatibility-1"><a class="header" href="#bring-your-own-compatibility-1">Bring Your Own Compatibility</a></h2>
<p>Some libraries attempt to thread the needle of compatibility by asking users to bring their own compatibility libraries. They write the internals of their framework as if these older browsers did not exist, and require end users to use polyfills to make the environment look equivalent to newer browsers.</p>
<p>We have spent considerable effort on first-class support in Ember 2.x, and we feel that users who require IE9 and IE10 support will have a better experience using Ember 2.x. (with the subset of the ecosystem that supports 2.x) than trying to cobble together a solution that works reliably in a version of Ember with second-class, bring-your-own-compatibility support.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-11-05
RFC PR: https://github.com/emberjs/rfcs/pull/268</p>
<hr />
<h1 id="summary-59"><a class="header" href="#summary-59">Summary</a></h1>
<p>The testing story in Ember today is better than it ever has been. It is now
possible to test individual component/template combos, register your own mock
components/services/etc, build complex acceptance tests, and almost anything else
you would like.</p>
<p>Unfortunately, there is a massive disparity between different types of tests.
In acceptance tests, you use well designed global helpers to deal with async
related interactions; whereas in integration and unit tests you are forced to
manually deal with this asynchrony.
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
introduced us to QUnit's nested modules API, made integration and unit testing
modular, and greatly simplified the concepts needed to learn how to write unit
and integration tests. The goal of this RFC is to leverage what we have learned
in prior RFCs and apply that knowledge to acceptance testing. Once this RFC has
been implemented all test types in Ember will have a unified cohesive structure.</p>
<h1 id="motivation-60"><a class="header" href="#motivation-60">Motivation</a></h1>
<p>Usage of rendering tests is becoming more and more common, but these tests
often include manual event delegation (<code>this.$('.foo').click()</code> for
example), and assumes most (if not all) interactions are synchronous.  This is
a major issue due to the fact that the vast majority of interactions will
actually be asynchronous. There have been a few recent additions to
<code>@ember/test-helpers</code> that have made dealing with asynchrony better (namely
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>)
but forcing users to manually manage all interaction based async is a recipe
for disaster.</p>
<p>Acceptance tests allow users to handle asynchrony with ease, but they rely on
global helpers that automatically wrap a single global promise which makes
testing of interleaved asynchronous things more difficult. There are a number
of limitations in acceptance tests as compared to integration tests (cannot
mock and/or stub services, cannot look up services to setup test context, etc).</p>
<p>We need a single unified way to teach and understand testing in Ember that
leverages all the things we learned with the original acceptance testing
helpers that were introduced in Ember 1.0.0.  Instead of inventing our own
syntax for dealing with the async (<code>andThen</code>) we should use new language
features such as <code>async</code> / <code>await</code>.</p>
<h1 id="detailed-design-54"><a class="header" href="#detailed-design-54">Detailed design</a></h1>
<p>The goal of this RFC is to introduce new system for acceptance tests that follows in the footsteps of
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
and continues to enhance the system created in that RFC to share the same structure and helper system.</p>
<p>This new system for acceptance tests will be implemented in the
<a href="https://github.com/emberjs/ember-test-helpers/">@ember/test-helpers</a> library so
that we can iterate faster while supporting multiple Ember versions
independently and easily support multiple testing frameworks build on top of
the primitives in <code>@ember/test-helpers</code>. Ultimately, the existing <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-testing">ember-testing</a> system
will be deprecated but that deprecation will be added well after the new system has been
released and adopted by the community. </p>
<p>Lets take a look at a basic example (lifted from <a href="https://guides.emberjs.com/v2.16.0/testing/acceptance/">the guides</a>):</p>
<pre><code class="language-js">// **** before ****
import { test } from 'qunit';
import moduleForAcceptance from '../helpers/module-for-acceptance';

moduleForAcceptance('Acceptance | posts');

test('should add new post', function(assert) {
  visit('/posts/new');
  fillIn('input.title', 'My new post');
  click('button.submit');
  andThen(() =&gt; assert.equal(find('ul.posts li:first').text(), 'My new post'));
});

// **** after ****
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { visit, fillIn, click } from '@ember/test-helpers';

module('Acceptance | login', function(hooks) {
  setupApplicationTest(hooks);

  test('should add new post', async function(assert) {
    await visit('/posts/new');
    await fillIn('input.title', 'My new post');
    await click('button.submit');

    assert.equal(this.element.querySelectorAll('ul.posts li')[0].textContent, 'My new post');
  });
});
</code></pre>
<p>As you can see, this proposal unifies on Qunit's nested module syntax following
in emberjs/rfcs#232's footsteps.</p>
<h2 id="new-apis-proposed"><a class="header" href="#new-apis-proposed">New APIs Proposed</a></h2>
<p>The following new methods will be exposed from <code>ember-qunit</code>:</p>
<pre><code class="language-ts">declare module 'ember-qunit' {
  // ...snip... 
  export function setupApplicationTest(hooks: QUnitModuleHooks): void;
}
</code></pre>
<h3 id="dom-interaction-helpers"><a class="header" href="#dom-interaction-helpers">DOM Interaction Helpers</a></h3>
<p>New native DOM interaction helpers will be added to both <code>setupRenderingTest</code>
and (proposed below) <code>setupApplicationTest</code>. The implementation for these
helpers has been iterated on and is quite stable in the
<a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>
addon.</p>
<p>The helpers will be migrated to <code>@ember/test-helpers</code> and eventually
(once &quot;the dust settles&quot;) <code>ember-native-dom-helpers</code> will be able to reexport
the versions from <code>@ember/test-helpers</code> directly (which means apps that have
already adopted will have very minimal changes to make).</p>
<p>The specific DOM helpers to be added to the <code>@ember/test-helpers</code> module are:</p>
<pre><code class="language-ts">/**
  Clicks on the specified selector.
*/
export function click(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Taps on the specified selector.
*/
export function tap(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Triggers a keyboad event on the specified selector.
*/
export function triggerKeyEvent(
  selector: string | HTMLElement,
  eventType: 'keydown' | 'keypress' | 'keyup',
  keyCode: string,
  modifiers?: {
    ctrlKey: false,
    altKey: false,
    shiftKey: false,
    metaKey: false
  }
): Promise&lt;void&gt;;

/**
  Triggers an event on the specified selector.
*/
export function triggerEvent(
  selector: string | HTMLElement,
  eventType: string,
  eventOptions: any
): Promise&lt;void&gt;;

/**
  Fill in the specified selector's `value` property with the provided text.
*/
export function fillIn(selector: string | HTMLElement, text: string): Promise&lt;void&gt;;

/**
  Focus the specified selector.
*/
export function focus(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Unfocus the specified selector.
*/
export function blur(selector: string | HTMLElement): Promise&lt;void&gt;;

/**
  Returns a promise which resolves when the provided callback returns a truthy value.
*/
export function waitUntil&lt;T&gt;(Function: Promise&lt;T&gt;, { timeout = 1000 }): Promise&lt;T&gt;;

/**
  Returns a promise which resolves when the provided selector (and count) becomes present.
*/
export function waitFor(selector: string, { count?: number, timeout = 1000 }): Promise&lt;HTMLElement | HTMLElement[]&gt;;
</code></pre>
<h3 id="setupapplicationtest"><a class="header" href="#setupapplicationtest"><code>setupApplicationTest</code></a></h3>
<p>This function will:</p>
<ul>
<li>invoke <code>ember-test-helper</code>s <code>setupContext</code> with the tests context (which does the following):
<ul>
<li>create an owner object and set it on the test context (e.g. <code>this.owner</code>)</li>
<li>setup <code>this.pauseTest</code> and <code>this.resumeTest</code> methods to allow easy pausing/resuming
of tests</li>
</ul>
</li>
<li>add routing related helpers
<ul>
<li>setup importable <code>visit</code> method to visit the given url</li>
<li>setup importable <code>currentRouteName</code> method which returns the current route name</li>
<li>setup importable <code>currentURL</code> method which returns the current URL</li>
</ul>
</li>
<li>add DOM interaction helpers (heavily influenced by @cibernox's lovely addon <a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>)
<ul>
<li>setup a getter for <code>this.element</code> which returns the DOM element representing
the applications root element</li>
<li>setup importable <code>click</code> helper method</li>
<li>setup importable <code>tap</code> helper method</li>
<li>setup importable <code>triggerKeyEvent</code> helper method</li>
<li>setup importable <code>triggerEvent</code> helper method</li>
<li>setup importable <code>fillIn</code> helper method</li>
<li>setup importable <code>focus</code> helper method</li>
<li>setup importable <code>blur</code> helper method</li>
<li>setup importable <code>waitUntil</code> helper method</li>
<li>setup importable <code>waitFor</code> helper method</li>
</ul>
</li>
</ul>
<h3 id="setuprenderingtest-1"><a class="header" href="#setuprenderingtest-1"><code>setupRenderingTest</code></a></h3>
<p>The <code>setupRenderingTest</code> function proposed in
<a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">emberjs/rfcs#232</a>
(and implemented in
<a href="https://github.com/emberjs/ember-qunit">ember-qunit</a>@3.0.0) will be modified to add the same DOM interaction helpers mentioned above:</p>
<ul>
<li>setup importable <code>click</code> helper method</li>
<li>setup importable <code>tap</code> helper method</li>
<li>setup importable <code>triggerKeyEvent</code> helper method</li>
<li>setup importable <code>triggerEvent</code> helper method</li>
<li>setup importable <code>fillIn</code> helper method</li>
<li>setup importable <code>focus</code> helper method</li>
<li>setup importable <code>blur</code> helper method</li>
<li>setup importable <code>waitUntil</code> helper method</li>
<li>setup importable <code>waitFor</code> helper method</li>
</ul>
<p>Once implemented, <code>setupRenderingTest</code> and <code>setupApplicationTest</code> will diverge from each other in very few ways.</p>
<h2 id="changes-from-current-system-1"><a class="header" href="#changes-from-current-system-1">Changes from Current System</a></h2>
<p>Here is a brief list of the more important but possibly understated changes
being proposed here:</p>
<ul>
<li>The global test helpers that exist now, will no longer be present (e.g.
<code>click</code>, <code>visit</code>, etc) and instead will be available on the test context as
well as importable helpers.</li>
<li><code>this.owner</code> will now be present and allow (for the first time 🎉) overriding
items in the container/registry.</li>
<li>The new system will leverage the <code>Ember.Application</code> /
<code>Ember.ApplicationInstance</code> split so that we can avoid creating an
<code>Ember.Application</code> instance per-test, and instead leverage the same system
that FastBoot itself uses to avoid running initializers for each acceptance
test.</li>
<li>Implicit promise chaining will no longer be present. If your test needs to
wait for a given promise, it should use <code>await</code> (which will wait for the
system to &quot;settle&quot; in similar semantics to today's <code>wait()</code> helper).</li>
<li>The test helpers that are included by a new default ember-cli app will be no
longer needed and will be removed from the new application blueprint. This
includes:
<ul>
<li><code>tests/helpers/resolver.js</code></li>
<li><code>tests/helpers/start-app.js</code></li>
<li><code>tests/helpers/destroy-app.js</code></li>
<li><code>tests/helpers/module-for-acceptance.js</code></li>
</ul>
</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="test-helper"><a class="header" href="#test-helper">Test Helper</a></h3>
<p>Assuming the following input:</p>
<pre><code class="language-js">import Ember from 'ember';

export function withFeature(app, featureName) {
  let featuresService = app.__container__.lookup('service:features');
  featuresService.enable(featureName);
}

Ember.Test.registerHelper('withFeature', withFeature);
</code></pre>
<p>In order for an addon to support both the existing acceptance testing system, and the new system it could replace that helper with the following:</p>
<pre><code class="language-js">import { registerAsyncHelper } from '@ember/test';

export function enableFeature(owner, featureName) {
  let featuresService = owner.lookup('service:features');
  featuresService.enable(featureName);
}

registerAsyncHelper('withFeature', function(app, featureName) {
  enableFeature(app.__container__, featureName);
});
</code></pre>
<p>This allows both the prior API (without modification) and the following:</p>
<pre><code class="language-js">// Option 2:
import { module, test } from 'qunit';
import { setupApplicationTest } from 'ember-qunit';
import { enableFeature } from 'addon-name-here/test-support';

module('asdf', function(hooks) {
  setupApplicationTest(hooks);

  test('awesome test title here', function(assert) {
    enableFeature(this.owner, 'feature-name-here');

    // ...snip...
  });
});
</code></pre>
<h3 id="registering-factory-overrides"><a class="header" href="#registering-factory-overrides">Registering Factory Overrides</a></h3>
<p>Overriding a factory is generally done to allow the test to have more control
over the thing being tested. This is sometimes used to prevent side effects
that are not related to the test (i.e. to prevent network calls), other times
it is used to allow the test to inject some known state to make asserting the
results much easier.</p>
<p>It is currently possible to register custom factories in integration and unit
tests, but not in acceptance tests (without using private API's that is).</p>
<p>As of <a href="https://github.com/emberjs/rfcs/pull/232">emberjs/rfcs#232</a> the
integration/unit test API for this registration is:</p>
<pre><code class="language-js">this.owner.register('service:stripe', MockService);
</code></pre>
<p>This RFC will allow this invocation syntax to work in all test types
(acceptance, integration, and unit).</p>
<h2 id="migration-2"><a class="header" href="#migration-2">Migration</a></h2>
<p>It is important that both the existing acceptance testing system, and the
newly proposed system can co-exist together. This means that new tests can be generated
in the new style while existing tests remain untouched.</p>
<p>However, it is likely that
<a href="https://github.com/rwjblue/ember-qunit-codemod">ember-qunit-codemod</a> will be
able to accurately rewrite acceptance tests into the new format.</p>
<h1 id="how-we-teach-this-33"><a class="header" href="#how-we-teach-this-33">How We Teach This</a></h1>
<p>This change requires updates to the API documentation of <code>ember-qunit</code> and the
main Ember guides' testing section. The changes are largely intended to reduce
confusion, making it easier to teach and understand testing in Ember.</p>
<h1 id="drawbacks-58"><a class="header" href="#drawbacks-58">Drawbacks</a></h1>
<ul>
<li>This is a relatively large set of changes that are arguably not needed (things mostly work today).</li>
<li>One of the major hurdles in upgrading larger applications to newer Ember versions, is updating their tests to follow &quot;new&quot; patterns.  This RFC introduces yet another &quot;new&quot; thing (and proposes to deprecate the old thing), and could therefore be considered &quot;just more churn&quot;.</li>
</ul>
<h1 id="alternatives-58"><a class="header" href="#alternatives-58">Alternatives</a></h1>
<ul>
<li>Do nothing?</li>
<li>Make <code>ember-native-dom-helpers</code> a default addon (removing the need for DOM interaction helpers proposed here).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-11-20
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/272
Tracking: https://github.com/emberjs/rfc-tracking/issues/12</p>
<hr />
<h1 id="deprecate-functionprototypeon-functionprototypeobserves-and-functionprototypeproperty"><a class="header" href="#deprecate-functionprototypeon-functionprototypeobserves-and-functionprototypeproperty">Deprecate Function.prototype.on, Function.prototype.observes and Function.prototype.property</a></h1>
<h2 id="summary-60"><a class="header" href="#summary-60">Summary</a></h2>
<p>This RFC proposes to deprecate <code>Function.prototype.on</code>,
<code>Function.prototype.observes</code> and <code>Function.prototype.property</code></p>
<h2 id="motivation-61"><a class="header" href="#motivation-61">Motivation</a></h2>
<p>Ember has been moving away from extending native prototypes due to the confusion
that this causes users: is it specifically part of Ember, or JavaScript?</p>
<p>Continuing in that direction, we should consider recommending the usage of
<a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject%2Fevented/methods/on?anchor=on"><code>on</code> (<code>@ember/object/evented</code>)</a>, <a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject/methods/observer?anchor=observer"><code>observer</code> (<code>@ember/object</code>)</a> and <a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fobject/methods/computed?anchor=computed"><code>computed</code> (<code>@ember/object</code>)</a> as opposed to their native
prototype extension equivalents.
We go from two ways to do something, to one.</p>
<p><a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-function-prototype-extensions.md"><code>eslint-plugin-ember</code> already provides this as a rule</a>.</p>
<h2 id="transition-path-6"><a class="header" href="#transition-path-6">Transition Path</a></h2>
<p>The replacement functionality already exists in the form of <code>on</code>, <code>observer</code>, and <code>computed</code>.</p>
<p>We don't need to build anything new specifically, however, the bulk of the transition will be
focused on deprecating the native prototype extensions.</p>
<p>A codemod for this deprecation has to take into consideration that while <code>foo: function() { /* custom logic */ }.property('bar')</code> is a <code>Function.prototype</code> extension, <code>foo: observer(function () { /* some custom logic */ }).on('customEvent')</code> is not.</p>
<h2 id="how-we-teach-this-34"><a class="header" href="#how-we-teach-this-34">How We Teach This</a></h2>
<p>On the deprecation guide, we can showcase the same example as above. We can explain why
the proposal was necessary, followed by a set of examples highlighting the deprecated
vs current style.</p>
<p>Borrowing from the <a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-function-prototype-extensions.md">ESLint plugin example</a>:</p>
<pre><code class="language-js">import { computed, observer } from '@ember/object';
import { on } from '@ember/object/evented';

export default Component.extend({
  // deprecated
  abc: function() { /* custom logic */ }.property('xyz'),
  def: function() { /* custom logic */ }.observe('xyz'),
  ghi: function() { /* custom logic */ }.on('didInsertElement'),
  jkl: function() { /* custom logic */ }.on('customEvent'),

  // current
  abc: computed('xyz', function() { /* custom logic */ }),
  def: observer('xyz', function() { /* custom logic */ }),
  didInsertElement() { /* custom logic */ }),
  jkl: on('customEvent', function() { /* custom logic */ }),
});
</code></pre>
<p>The official Guides currently <a href="https://guides.emberjs.com/v2.17.0/configuring-ember/disabling-prototype-extensions/">discourage the use of <code>Function.prototype</code> extensions</a>:</p>
<blockquote>
<p>Function is extended with methods to annotate functions as computed properties,
via the property() method, and as observers, via the observes() method. Use of
these methods is now discouraged and not covered in recent versions of the Guides.</p>
</blockquote>
<p>After the deprecated code is removed from Ember, we need to remove the section
about <code>Function</code> prototypes altogether.</p>
<h2 id="alternatives-59"><a class="header" href="#alternatives-59">Alternatives</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-12-10
RFC PR: https://github.com/emberjs/rfcs/pull/276
Ember Issue: https://github.com/emberjs/ember.js/pull/15968</p>
<hr />
<h1 id="summary-61"><a class="header" href="#summary-61">Summary</a></h1>
<p>Introduce <code>{{@foo}}</code> in as a dedicated syntax for a component's template to
refer to named arguments passed in by the caller.</p>
<p>For example, given the invocation <code>{{hello-world name=&quot;Godfrey&quot;}}</code> and this
component template in <code>app/templates/components/hello-world.hbs</code>:</p>
<pre><code class="language-hbs">Hello, {{@name}}
</code></pre>
<p>Ember will render &quot;Hello, Godfrey&quot;.</p>
<h1 id="motivation-62"><a class="header" href="#motivation-62">Motivation</a></h1>
<p>Currently, the way to access named arguments passed in from the caller is to
reference <code>{{name}}</code> in the template. This works because when Ember creates
the component instance, it automatically <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">assigns</a>
all named arguments as properties on the component instance.</p>
<p>The first problem with this approach is that the <code>{{name}}</code> syntax is highly
ambigious, as it could be referring to a local variable (block param), a
helper or a named argument from the caller (which actually works by accessing
auto-reflected <code>{{this.name}}</code>) or a property on the component class (such as
a computed property).</p>
<p>This can often lead to confusion for readers of the template. Upon encountering
<code>{{foo}}</code> in a component's template, the reader has to check all of
these places: first you need to scan the surrounding lines for block
params with that name; next you check in the helpers folder to see if there
is a helper with that name (it could also be coming from an addon!); then you
check if it is an argument provided by the caller; finally, you check the
component's JavaScript class to look for a (computed) property. If you <em>still</em>
did not find it, maybe it is a named arguments that is passed only sometimes,
or perhaps it is just a leftover reference from a previous refactor?</p>
<p>Providing a dedicated syntax for referring to named arguments will resolve the
ambiguity and greatly improve clarity, especially in big projects with a lot
of files (and uses a lot of addons). (The existing <code>{{this.name}}</code> syntax can
already be used to disambiguate component properties from helpers.)</p>
<p>As an aside, the ambiguity that causes confusion for human readers is also a
problem for the compiler. While it is not the main goal of this proposal,
resolving this ambiguity also helps the rendering system. Currently, the
&quot;runtime&quot; template compiler has to perform a helper lookup for every <code>{{name}}</code>
in each template. It will be able to skip this resolution process and perform
other optimizations (such as reusing the internal <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>
object and caches) with this addition.</p>
<p>Another problem with the current approach of automatically &quot;reflecting&quot; named
arguments on the instance is that they can unexpectedly overwrite other
properties defined on the component's class. It also defeats performance
optimizations in JavaScript engines as this approach creates many different
polymorphic &quot;shapes&quot; for instances that otherwise belong to the same
component class.</p>
<p>While this proposal does not directly solve this problem (we are not proposing
that we deprecate or remove the &quot;auto-reflection&quot; on <code>Ember.Component</code>), it
paves the way for a future world where components can work without them.</p>
<p>Notably, the current iteration of the <a href="https://glimmerjs.com/guides/templates-and-helpers">Glimmer Components</a>
have adopted this design for over a year now and the experience has been very
positive. This would be one of the first pieces (admittedly, only a tiny piece)
of the Glimmer.js experiment to make its way into Ember. We think this feature
is small, self-contained but useful enough to be the ideal candidate to kick
off this process.</p>
<h1 id="detailed-design-55"><a class="header" href="#detailed-design-55">Detailed design</a></h1>
<p>This feature was baked into the Glimmer VM very early on. In fact, the
only thing that is stopping them from working in Ember is <a href="https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/assert-reserved-named-arguments.js">an AST transform</a>
that specifically disallows them. Therefore, &quot;implementing&quot; this feature is
just a matter of deleting that file.</p>
<p>Additionally, the legacy <code>{{attrs.foo}}</code> syntax (which more or less tries to
accomplish the same thing) has actually been <a href="https://github.com/emberjs/ember.js/blob/87be17d8e69f83b2abed8c0695f8fa5e4bcae473/packages/ember-template-compiler/lib/plugins/transform-attrs-into-args.js">implemented using <code>{{@foo}}</code></a>
under-the-hood since Ember 2.10.</p>
<h2 id="reserved-names"><a class="header" href="#reserved-names">Reserved Names</a></h2>
<p>We will reserve <code>{{@args}}</code>, <code>{{@arguments}}</code> and anything that does not
start with a lowercase letter (such as <code>@Foo</code>, <code>@0</code>, <code>@!</code> etc) in the first
version. This is purely speculative and the goal is to carve out some space
for future features. If we don't end up needing them, we can always relax
the restrictions down the road.</p>
<h1 id="how-we-teach-this-35"><a class="header" href="#how-we-teach-this-35">How We Teach This</a></h1>
<p><code>{{@foo}}</code> is the way to access the named arguments passed from the caller.</p>
<p>Since the <code>{{foo}}</code> syntax still works on <code>Ember.Component</code> (which is the
only kind of components available today) via the auto-reflection mechanism,
we are not really in a rush to migrate the community (and the guides, etc)
to using the new syntax. In the meantime, this could be viewed as a tool to
improve clarity in templates, similar to how the optional &quot;explicit <code>this</code>&quot;
syntax (<code>{{this.foo}}</code>).</p>
<p>While we think writing <code>{{@foo}}</code> would be a best practice for new code
going forward, the community can migrate at its own pace one component at a
time.</p>
<p>We can also encourage the community to supplement this effort by wiring
linting tools and code mods.</p>
<h1 id="drawbacks-59"><a class="header" href="#drawbacks-59">Drawbacks</a></h1>
<p>This introduces a new piece of syntax that one would need to learn in order to
understand Ember templates.</p>
<p>This mostly affects &quot;casual&quot; readers (as this should be very easy for an Ember
developer to learn, understand and remember after encounting/learning it for
the first time). However, since these casual readers are also among those
who are most acutely affected by the ambiguity, we believe this is still a
net improvement over the status-quo.</p>
<h1 id="alternatives-60"><a class="header" href="#alternatives-60">Alternatives</a></h1>
<p>We have <code>{{attrs.foo}}</code> today. In React, there is <code>this.props.foo</code>.</p>
<p>Given how common this is, we think it deserves its own dedicated, succinct
syntax. The other alternatives that involve reflecting them on the component
instances also would not allow for the internal optimizations in the Glimmer
VM.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-12-11
RFC PR: https://github.com/emberjs/rfcs/pull/278
Ember Issue: https://github.com/emberjs/ember.js/pull/15974</p>
<hr />
<h1 id="summary-62"><a class="header" href="#summary-62">Summary</a></h1>
<p>Introduce a low-level &quot;flag&quot; to remove the automatic wrapper <code>&lt;div&gt;</code> for
template-only components (templates in the <code>components</code> folder that do not
have a corresponding <code>.js</code> file).</p>
<p>In other words, given there is NO <code>app/components/hello-world.js</code> and there
exists <code>app/templates/components/hello-world.hbs</code> which contains the
following markup:</p>
<pre><code class="language-hbs">Hello world!
</code></pre>
<p>When this template-only component is invoked as <code>{{hello-world}}</code> with the
flag unset or disabled (i.e. today's semantics), Ember will render:</p>
<pre><code class="language-html">&lt;div id=&quot;ember123&quot; class=&quot;ember-view&quot;&gt;Hello world!&lt;/div&gt;
</code></pre>
<p>When the flag is enabled, the same invocation will render:</p>
<pre><code class="language-html">Hello world!
</code></pre>
<h1 id="motivation-63"><a class="header" href="#motivation-63">Motivation</a></h1>
<p>With today's component system (i.e. <code>Ember.Component</code>), a wrapper element (a
<code>div</code> by default, along with an ID like <code>ember123</code> and the <code>ember-view</code> class)
is automatically added for every component.</p>
<p>Customizing this wrapper element (such as changing the tag name – or removing
it altogether) requires making changes to the component's JavaScript class,
such as:</p>
<pre><code class="language-js">import Component from &quot;@ember/component&quot;;

export Component.extend({
  tagName: &quot;footer&quot;,
  classNames: [&quot;legalese&quot;]
});
</code></pre>
<p>While we acknowledge this API is quite cumbersome, it is sufficient to &quot;get
things done&quot; for regular components, and Glimmer Components will address
the usability aspect once they land.</p>
<p>However, this API does not work for template-only components, as they do
not have a component JavaScript class by definition. Therefore, in practice,
template-only components always come with a <code>&lt;div&gt;</code> wrapper, along with the
default <code>id</code> and <code>class</code> attributes, with no obvious ways to customize it.</p>
<p>This is quite problematic, as it is often desirable to use a template-only
component to organize content that requires a certain markup structure. The
most common workaround for this problem is to use a partial instead, which
comes with <a href="https://github.com/emberjs/rfcs/pull/262">a host of issues</a>. I
will discuss other workarounds in the section below.</p>
<p>This RFC proposes to add a global flag to remove this wrapper element around
template-only components. This will allow the component author to specify the
wrapper element in the component template, offering direct control over the
tag name and other attributes. It would also allow the component to have more
than one top-level element, or none at all.</p>
<p>In other words, this flag changes template-only components in the app to have
&quot;Outer HTML&quot; semantics. <em>What you type is what you get.</em></p>
<p>Notably, <a href="https://glimmerjs.com/guides/templates-and-helpers">Glimmer Components</a>
have adopted the &quot;Outer HTML&quot; semantics long ago and the experience has been
very positive. This would be one of the first pieces of the Glimmer.js experiment
to make its way into Ember. We think this feature is small, self-contained but
useful enough to be integrated back into Ember at this point.</p>
<p>If accepted, this RFC will fully subsume the <a href="https://github.com/emberjs/rfcs/pull/262">Non-context-shifting partials</a>
RFC. We can therefore (at a later time, in a separate RFC) explore deprecating
partials in favor of wrapper-free template-only components.</p>
<h1 id="detailed-design-56"><a class="header" href="#detailed-design-56">Detailed design</a></h1>
<h2 id="api-surface"><a class="header" href="#api-surface">API Surface</a></h2>
<p>We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a &quot;privileged addon&quot; whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the <em>addon</em> that provides this functionality. The
flag is simply an internal implementation detail.</p>
<p>We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.</p>
<p>When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that <em>disables</em> the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is <em>not set</em>, with
a message that directs the user to install one of the two addons.</p>
<h2 id="single-global-flag"><a class="header" href="#single-global-flag">Single Global &quot;Flag&quot;</a></h2>
<p>The proposed flag will be truly global in scope. That is, setting this flag
will change the semantics of all template-only components in the entire app,
even for components that were included by addons.</p>
<p>However, we believe this would not affect any addon components in practice,
as the predominant pattern for addons to expose components currently
necessitates a JavaScript class. Addon authors would create the component
(with or without a JavaScript class) in the <code>/addon</code> folder, but exposing
it for consumption in apps requires creating a corresponding JavaScript class
in the <code>/app</code> folder to &quot;re-export&quot; the component. Therefore, in practice,
it is not actually possible for addons to have a truly template-only
component today (something to address in a future RFC).</p>
<h2 id="leakage-of-embercomponent-semantics"><a class="header" href="#leakage-of-embercomponent-semantics">Leakage Of <code>Ember.Component</code> Semantics</a></h2>
<p>While the primary purpose of this flag is to remove the wrapper element from
template-only components, there are a few other observable semantics changes
that comes with it as well.</p>
<p>Currently, template-only components are &quot;backed&quot; by an instance of <code>Ember.Component</code>.
That is, Ember will create an instance of <code>Ember.Component</code> and set it as the
<code>{{this}}</code> context for the template.</p>
<p>With the flag enabled, there will be <em>no</em> component instance for the template
and <code>{{this}}</code> will be set to <code>undefined</code> (or <code>null</code>, perhaps). This would
improve performance for template-only components significantly.</p>
<p>Since there is no JavaScript file for the component, this is only observable
in a few limited ways:</p>
<ol>
<li>
<p>The most noticable artifact is the component's arguments will not be
auto-reflected on the component instance (as there is no component
instance at all). Therefore, the only way to access the component's
arguments is to use the <code>{{@foo}}</code> syntax proposed in <a href="https://github.com/emberjs/rfcs/pull/276">RFC #276</a>.</p>
</li>
<li>
<p>Because of the named arguments auto-reflection, it is actually possible
to configure the <code>tagName</code> and classes on the &quot;hidden&quot; component
instance on the invocation (e.g. <code>{{foo-bar tagName=&quot;footer&quot; class=&quot;legalese&quot;}}</code>).
This will obviously stop working, but it is also not necessary anymore
as the component author can simply include the tag in the template.
Alternatively, the component author can choose to leave out the tag
and let the caller wrap it in their template.</p>
</li>
<li>
<p>It is possible (but very rare) to configure global injections on the
component type. Since no component is being instantiated here, those
properties will not be accessible in the template. </p>
<p>More broadly, <code>{{this.foo}}</code> or the shorthand <code>{{foo}}</code> (where it
would have resolved into a <code>this</code> lookup) will always be <code>undefined</code>
(or <code>null</code>, perhaps).</p>
</li>
</ol>
<h2 id="migration-path"><a class="header" href="#migration-path">Migration Path</a></h2>
<p>Given the subtle semantics differences enumerated above, it is
not necessarily safe to simply turn on the flag in bigger applications
as it is quite likely that some of the template-only components might be
relying on one or more of these features. Further, removing the wrapper
element might break the layout.</p>
<p>Therefore, the only safe, mechanical transformation is to generate a
JavaScript file for each template-only component (turning them into non-
template only components). We should supplement the change by providing
a codemod that does this for you.</p>
<p>While this would mean that apps would not be able to immediately take
advantage of the feature, it will open the door for new template-only
components to be written in the new semantics.</p>
<p>The user can also audit the components we identified and decide to
delete the JavaScript and migrate them on a case-by-case basis.</p>
<p>The codemod can also come with a more aggressive (and unsound) mode that
simply wraps each template in a <code>&lt;div&gt;</code> (to avoid breaking layout in most
cases). This might be acceptable for smaller apps.</p>
<p>For what it's worth, the Ember CLI component blueprint always generate a
JavaScript and a template file, so it might not be that common to find
existing template-only components in an average app.</p>
<h2 id="implementation-plan"><a class="header" href="#implementation-plan">Implementation Plan</a></h2>
<p>Finally, for the actual implementation, this would be implemented using
the internal Component Manager API that has already been available for a long
time (and how Curly Components, outlets etc are implemented internally).</p>
<p>It should be very straightforward implementation – essentially just a
Component Manager that requires no capabilities and returns <code>null</code> in
<code>getSelf</code>.</p>
<h1 id="how-we-teach-this-36"><a class="header" href="#how-we-teach-this-36">How We Teach This</a></h1>
<p>Going forward, the &quot;Outer HTML&quot; semantics will be the default for
template-only components, Glimmer Components and other custom component
types (when the Component Manager API is available), so over time it
should feel quite natural. The experience from the Glimmer experiment
has also proven that this is the more natural programming model for
components.</p>
<p>In the mean time, we still have to deal with the consequence that
existing <code>Ember.Component</code> comes with a wrapper element by default. The
mental model for users to understand this is that the <code>Ember.Component</code>
class is what is giving you the wrapper element (therefore, template-only
components, which is not an <code>Ember.Component</code> does not get one of those).</p>
<p>This should feel quite natual, as the component class is where you
configure the wrapper element (and where you would lookup the API
documentation). You could imagine that the <code>Ember.Component</code> is doing
something like this under-the-hood as a convenience feature (which turned
out to be not very convenient after all, but that's a different story):</p>
<pre><code class="language-js">export const Component = Object.extend({
  tagName: &quot;div&quot;,
  classNames: [&quot;ember-view&quot;],

  // This is not real code that exists in the implementation
  render(buffer, template) {
    buffer.append(`&lt;${this.tagName} class=&quot;${this.classNames.join(' ')}&quot;&gt;`);
    buffer.append(template(this));
    buffer.append(`&lt;/${this.tagName}&gt;`);
  }
});
</code></pre>
<h1 id="drawbacks-60"><a class="header" href="#drawbacks-60">Drawbacks</a></h1>
<p>In general, we avoid flags that puts Ember into very different &quot;modes&quot; as
they causes complication across the whole addon ecosystem. However, as
mentioned above, we don't believe this would be the case here.</p>
<h1 id="alternatives-61"><a class="header" href="#alternatives-61">Alternatives</a></h1>
<p>We could keep the current semantics for template-only components. However,
this is usually undesirable, and would only grow to feel more unnatural
as Glimmer Components and friends adopt the &quot;Outer HTML&quot; semantics.</p>
<p>Alternatively, we can make this opt-in per template using a pragma or magic
comment. However, this would be needed for a lot of templates and become
very noisy, and the alternative strategy proposed here (by keeping around
the <code>Ember.Component</code> JavaScript file as needed) would be able to accomplish
the same goal with less noise.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-12-11
RFC PR: https://github.com/emberjs/rfcs/pull/280
Ember Issue: https://github.com/emberjs/ember.js/pull/15981</p>
<hr />
<h1 id="summary-63"><a class="header" href="#summary-63">Summary</a></h1>
<p>Introduce a low-level &quot;flag&quot; to remove the automatic wrapper <code>&lt;div&gt;</code> around
Ember apps and tests.</p>
<h1 id="motivation-64"><a class="header" href="#motivation-64">Motivation</a></h1>
<p>In Ember applications today, applications are anchored to some existing HTML
element in the page. Usually, this element is the <code>&lt;body&gt;</code> of the document, but it
can be configured to be a different one when the application is defined,
passing a CSS selector to the <code>rootElement</code> property:</p>
<pre><code class="language-js">export default Ember.Application.extend({
  rootElement: '#app'
});
</code></pre>
<p>However, whatever the root is, the application adds another <code>&lt;div&gt;</code> wrapper
that is not required anymore. It's a vestigial remainder of some implementation
detail of how views worked in Ember 1.x. Some sort of wisdom tooth of the original
rendering system that serves no purpose today.</p>
<p>Furthermore, much like a wisdom tooth, it can give us problems. In the past, this element
was configurable using the <code>ApplicationView</code>, but when views were removed we lost that
ability. Right now we are stuck with a wrapper element we can't remove nor customize,
which is why some apps target the selector <code>body &gt; .ember-view</code> to style this element.</p>
<p>Similarly, in testing there is another <code>.ember-view</code> wrapper inside the
<code>#ember-testing</code> container for no good reason.</p>
<p>This RFC proposes to add a global flag to remove those wrapper elements,
effectively making the <code>application.hbs</code> template have &quot;Outer HTML&quot; semantics, which aligns
well with <a href="https://github.com/emberjs/rfcs/pull/278">the changes recently proposed</a>
for template-only components, as well as the way Glimmer apps work.</p>
<p>The same flag will also remove the unnecessary extra wrapper inside the testing
container.</p>
<h1 id="detailed-design-57"><a class="header" href="#detailed-design-57">Detailed design</a></h1>
<h2 id="api-surface-1"><a class="header" href="#api-surface-1">API Surface</a></h2>
<p>The proposed approach is identical to the one proposed in #278, quoted below:</p>
<blockquote>
<p>We should not expose the flag directly as a public API. Instead, we should
abstract the flag with a &quot;privileged addon&quot; whose only purpose is to enable
the flag. Applications will enable the flag by installing this addon. This
will allow for more flexibility in changing the flag's implementation (the
location, naming, value, or even the existence of it) in the future. From the
user's perspective, it is the addon that provides this functionality. The
flag is simply an internal implementation detail.</p>
</blockquote>
<blockquote>
<p>We have done this before in other cases (such as the legacy view addon during
the 2.0 transition period), and it has generally worked well.</p>
</blockquote>
<blockquote>
<p>When landing this feature, it will be entirely opt-in for existing apps, but
the Ember CLI application blueprint should be updated to include the addon by
default. At a later time, we should provide another addon that <em>disables</em> the
flag explicitly (installing both addons would be an install-time error). At
that time, we will issue a deprecation warning if the flag is <em>not set</em>, with
a message that directs the user to install one of the two addons.</p>
</blockquote>
<h2 id="migration-path-1"><a class="header" href="#migration-path-1">Migration Path</a></h2>
<p>Given that this change only affects one single point in your application,
I do not believe we need any specific strategy. If the users want to bring
back the wrapper because it breaks their styles or some other reason,
they can just add it manually on the <code>application.hbs</code> template, with
any class or id they want.</p>
<h1 id="how-we-teach-this-37"><a class="header" href="#how-we-teach-this-37">How We Teach This</a></h1>
<p>This addon will be opt-in, but at some point it will become part of
the default blueprint. This change, rather than introducing a new concept, <em>removes</em>
an old one. Users won't have to google what is the way to remove or customize
the implicit application wrapper of the app (to sadly discover that is not
even possible), but instead they will add a wrapper only if they want,
and in the same way they would add a wrapper in any other point of their application,
with regular Handlebars.</p>
<h1 id="drawbacks-61"><a class="header" href="#drawbacks-61">Drawbacks</a></h1>
<p>There is a possibility that removing the wrapper can break styles for some apps,
but since adding the wrapper back is just editing the <code>application.hbs</code> template,
that is probably a minor drawback.</p>
<p>There is also a non-zero chance that some testing addon is relying on the <code>#ember-testing &gt; .ember-view</code>
HTML hierarchy for some reason, and those addons would have to be updated.</p>
<h1 id="alternatives-62"><a class="header" href="#alternatives-62">Alternatives</a></h1>
<p>Leave things as they are today.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-12-12
RFC PR: https://github.com/emberjs/rfcs/pull/281</p>
<hr />
<h1 id="summary-64"><a class="header" href="#summary-64">Summary</a></h1>
<p>Install ES5 getters for computed properties on object prototypes, thus
eliminating the need to use <code>this.get()</code> or <code>Ember.get()</code> to access them.</p>
<p>Before:</p>
<pre><code class="language-js">import Object, { computed } from '@ember/object';

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.get('firstName')} ${this.get('lastName')}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.get('fullName'); // =&gt; 'Godfrey Chan'

chancancode.set('firstName', 'ʎǝɹɟpo⅁');

chancancode.get('fullName'); // =&gt; 'ʎǝɹɟpo⅁ Chan'

let { firstName, lastName, fullName } = chancancode.getProperties('firstName', 'lastName', 'fullName');
</code></pre>
<p>After:</p>
<pre><code class="language-js">import Object, { computed } from &quot;@ember/object&quot;;

const Person = Object.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});

let chancancode = Person.create({ firstName: 'Godfrey', lastName: 'Chan' });

chancancode.fullName; // =&gt; 'Godfrey Chan'

chancancode.set('firstName', 'ʎǝɹɟpo⅁');

chancancode.fullName; // =&gt; 'ʎǝɹɟpo⅁ Chan'

let { firstName, lastName, fullName } = chancancode; // No problem!
</code></pre>
<h1 id="motivation-65"><a class="header" href="#motivation-65">Motivation</a></h1>
<p>Ember inherited its computed properties functionality from <a href="http://guides.sproutcore.com/core_concepts_kvo.html">SproutCore</a>.
The feature was designed at a time before <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">ES5 getters</a>
were widely available. This necessitated using a special function such as
<code>this.get()</code> or <code>Ember.get()</code> to access the values of computed properties.</p>
<p>Since all of our <a href="https://github.com/emberjs/rfcs/pull/252">target browsers</a>
support ES5 getters now, we can drop the need of this special function,
improving developer ergonomics and interoperability between other libraries
and tooling (such as TypeScript).</p>
<p>Note that at present, using <code>this.set()</code> or <code>Ember.set()</code> is still mandatory
for the property to recompute properly. In the future, we might be able to
loosen this requirement, perhaps with the help of ES5 setters. However, that
would require more design and is out-of-scope for this RFC.</p>
<p><code>this.get()</code> and <code>Ember.get()</code> will still work. This RFC does not propose
removing or deprecating them in the near term. They support other use cases
that ES5 getters do not, such as &quot;safe&quot; path chaining (<code>get('foo.bar.baz')</code>)
and <code>unknownProperty</code> (and Proxies by extension), so any future plans to
deprecate them would have to take these features into account.</p>
<p>Addon authors would likely need to continue using <code>Ember.get()</code> for at least
another two LTS cycles (8 releases) to support older versions of Ember (and
possibly longer to support proxies). It is, however, very unlikely that the
everyday user would need to use this.</p>
<h1 id="detailed-design-58"><a class="header" href="#detailed-design-58">Detailed design</a></h1>
<p>The computed property function, along with any caches, can be stored in the
object's &quot;meta&quot;. We will then define a getter on the object's prototype to
compute the value.</p>
<p>One caveat is that the computed property function is currently stored on the
instances for implementation reasons that are no longer relevant. However,
it is possible that some developers have observed their existance and have
accidentally relied on these private semantics (e.g. <code>chancancode.fullName.get()</code>
or <code>chancancode.fullName.isDescriptor</code>).</p>
<p>Before landing this change, we should turn the property into an assertion
so that in these unlikely scenarios, developers will at least receive
some warning.</p>
<p>Another thing to consider is that there is this Little Known Trick™ to add
Computed Properties to POJOs:</p>
<pre><code class="language-js">import { computed, get } from &quot;@ember/object&quot;;

let foo = {
  bar: computed(function() { return 'bar'; })
};

get(foo, 'bar'); // =&gt; 'bar'
</code></pre>
<p>In this case, there is no opportunity for us to install an ES5 getter, and
<code>Ember.get</code> is the only solution. This is very rare in practice and is more
or less just a party trick. We should deprecate this use case (in <code>Ember.get</code>)
and suggest the alternative:</p>
<pre><code class="language-js">import Object, { computed } from &quot;@ember/object&quot;;

let foo = Object.extend({
  bar: computed(function() { return 'bar'; })
}).create();

foo.bar; // =&gt; 'bar'
</code></pre>
<p>Or simply...</p>
<pre><code class="language-js">let foo = {
  get bar() {
    return 'bar';
  }
};

foo.bar; // =&gt; 'bar'
</code></pre>
<h1 id="how-we-teach-this-38"><a class="header" href="#how-we-teach-this-38">How We Teach This</a></h1>
<p>For the most part, this RFC <em>removes</em> a thing that we need to teach new
users.</p>
<p>It might, however, come across as slightly strange that <code>set()</code> is still
required. However, many other libraries share the same model, and
empricially, this does not appear to be an issue. For example, in React,
you can freely access <code>this.state.foo</code> but must use <code>this.setState('foo', ...)</code>
to update it. Even Vue has <a href="https://vuejs.org/v2/api/#Vue-set">the same API</a>
for some cases.</p>
<p>The mental model for this is that you must use the <code>set()</code> in order for
Ember to notice your mutations, so that it can update the caches, rerender
things on the screen, etc.</p>
<p>As for users who already learned to use <code>get()</code> everywhere, that would
continue to work. Ideally, this would be a Cool Trick™ they pick up some day
(as in &quot;Oh, I don't have to do <em>that</em> anymore? Cool.&quot;), at which point the
old habit would quickly die. If this turned out to be too confusing, we
could always explore deprecating <code>this.get()</code>; we will just have to weigh
the cost-benefits of the confusion (if any) versus churn.</p>
<h1 id="drawbacks-62"><a class="header" href="#drawbacks-62">Drawbacks</a></h1>
<p>As mentioned, not removing <code>set()</code> at the same time might be a source of
confusion. However, removing <code>set()</code> would require significantly more
upfront design work, and it <a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">might not even be possible</a>
to completely remove the need of <code>set()</code> (as the system is designed today)
in all cases (see <code>Vue.set()</code>).</p>
<p>Since removing <code>get()</code> would unlock so many benefits, and since there are
plenty of other libraries that uses the same model, the case for decoupling
the two seems overwhemlingly positive.</p>
<h1 id="alternatives-63"><a class="header" href="#alternatives-63">Alternatives</a></h1>
<ul>
<li>Hold off until we also remove <code>set</code></li>
<li>Hold off until we transition to something like <a href="https://glimmerjs.com/guides/tracked-properties">Glimmer's <code>@tracked</code></a></li>
</ul>
<p>In my opinion, these alternatives do not make a lot of sense, as neither
of these hypothetical systems appear to require (or would benefit from)
having a user-land getter system.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-12-21
RFC PR: https://github.com/emberjs/rfcs/pull/286
Ember Issue: https://github.com/emberjs/ember.js/pull/16076</p>
<hr />
<h1 id="block-let-template-helper"><a class="header" href="#block-let-template-helper">Block <code>let</code> template helper</a></h1>
<h2 id="summary-65"><a class="header" href="#summary-65">Summary</a></h2>
<p>Introduce the <code>let</code> template helper in block form.</p>
<h2 id="motivation-66"><a class="header" href="#motivation-66">Motivation</a></h2>
<p>The goal of this RFC is to introduce a <code>let</code> template helper that allows to create new bindings in templates.
The design of this helper is similar to <code>with</code>,
but without the conditional rendering of the block depending on the values passed into the helper.</p>
<p>While the conditional semantics of <code>with</code> are coherent with the other built-in helpers like <code>each</code> and <code>if</code>,
users often find this unexpected.
The fact that only the first positional parameter of <code>with</code> controls whether the block is rendered might also add to the confusion.</p>
<p>Taking an example from <a href="https://github.com/emberjs/rfcs/pull/200">RFC #200</a>,
let's consider we have the following template:</p>
<pre><code class="language-handlebars">Welcome back {{concat (capitalize person.firstName) ' ' (capitalize person.lastName)}}

Account Details:
First Name: {{capitalize person.firstName}}
Last Name: {{capitalize person.lastName}}
</code></pre>
<p>Because you have to know to capitalize every time you want to display a name,
errors might be introduced if we forget to do it when adding the name somewhere else in the template.
Using the <code>let</code> helper, this could be done like so:</p>
<pre><code class="language-handlebars">{{#let (capitalize person.firstName) (capitalize person.lastName)
  as |firstName lastName|
}}
  Welcome back {{concat firstName ' ' lastName}}

  Account Details:
  First Name: {{firstName}}
  Last Name: {{lastName}}
{{/let}}
</code></pre>
<p>Now you can use <code>firstName</code> and <code>lastName</code> inside the <code>let</code> block with the knowledge that that logic is in a single place.</p>
<p>With the introduction of template-only components in <a href="https://github.com/emberjs/rfcs/pull/278">RFC #278</a>,
having the capability to create additional bindings in the template would prove useful.
Another aspect to consider is related to the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">Named Blocks RFC</a>.
In both the case of named blocks and block let, you can achieve most of the same functionality by using components.
The components approach has its own drawbacks, which are explored in Alternatives below.</p>
<h2 id="detailed-design-59"><a class="header" href="#detailed-design-59">Detailed design</a></h2>
<p>The <code>let</code> helper should be implemented as a built-in helper, with the following semantics:</p>
<ul>
<li><strong>Only</strong> the block form is available</li>
<li>The block is always rendered</li>
<li>It should support however many positional arguments are passed to the helper</li>
<li>Positional arguments passed to the helper should be yielded back out in the same order</li>
<li>Inline form issues an error, linking users to documentation</li>
</ul>
<p>There already exists <a href="https://github.com/emberjs/ember.js/blob/9536e137b9e1a39411b7fd4e8ca0e7fbb341ef17/packages/ember-glimmer/tests/integration/syntax/experimental-syntax-test.js#L6-L37">an implementation in the codebase</a> that can be used as a basis.</p>
<h2 id="how-we-teach-this-39"><a class="header" href="#how-we-teach-this-39">How We Teach This</a></h2>
<p>The introduction of the <code>let</code> helper brings no new concepts.
It touches on the concepts of block helpers, how to pass arguments to them,
and how to use block parameters (<code>as |foo|</code>), which should already be introduced in the literature.</p>
<p>Current Ember developers should find it familiar to use <code>let</code>, as it is very similar to <code>with</code>.</p>
<p>JavaScript developers should also be familiar with <code>let</code> bindings,
as recent specifications of the language introduced that keyword.</p>
<p>The Guides already possess a section dedicated to Templates, with multiple mentions of helpers.
<code>let</code> would likely be documented in the <a href="https://guides.emberjs.com/v2.17.0/templates/built-in-helpers/">Built-in Helpers</a> guide alongside the others.</p>
<p>If this RFC is approved, the <code>let</code> will initially only support the block form.
This means that only the following form is available for users:</p>
<pre><code class="language-handlebars">{{#let 1 2 3 as |one two three|}}
  A, B, C, easy as {{one}}, {{two}}, {{three}}
{{/let}}
</code></pre>
<p>This could also be enforced by issuing a helpful error when <code>let</code> is used in the inline form.</p>
<h2 id="drawbacks-63"><a class="header" href="#drawbacks-63">Drawbacks</a></h2>
<p>As is the case when adding any sort of API, we will be increasing the cognitive load of learners and users,
as it is one more piece of information to obtain and retain.</p>
<p>The cost of learning this API is mitigated by the fact that its effects are very localized.
It is a template helper, so it will only affect templates.
It is not required for general usage of Ember, unlike something like <code>link-to</code>,
so you can learn the helper at your own pace.</p>
<p>And lastly, if you do use it or encounter it in code, only the markup inside the <code>{{#let}}{{/let}}</code> block is affected,
making it easier to reason about.</p>
<h2 id="alternatives-64"><a class="header" href="#alternatives-64">Alternatives</a></h2>
<h3 id="inline-form"><a class="header" href="#inline-form">Inline form</a></h3>
<p>At the moment, the only way to introduce a new binding in a template is through block params.
For example, if you are iterating over an array with <code>each</code>, you
introduce a binding named <code>item</code> for the item currently being iterated:</p>
<pre><code class="language-handlebars">{{#each myArray as |item|}}
  I am item {{item}}.
{{/each}}
</code></pre>
<p>The inline form of <code>let</code> would be an additional way of introducing bindings in templates.
Using the names example from the RFC, it would look like the following in inline form:</p>
<pre><code class="language-handlebars">{{let
  firstName=(capitalize person.firstName)
  lastName=(capitalize person.lastName)
}}

Welcome back {{concat firstName ' ' lastName}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
</code></pre>
<p>This syntax raises questions about the semantics of the inline form,
such as what is the scope of the binding, that are better left to a subsequent RFC.</p>
<h3 id="using-components"><a class="header" href="#using-components">Using components</a></h3>
<p>In a similar situation to <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">Named Blocks RFC</a>,
it is also possible to replicate some of the behavior of the proposed <code>let</code> helper using components.
However, using components also presents some drawbacks.</p>
<p>You can extract the template and do:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
Welcome back {{concat firstName ' ' lastName)}}

Account Details:
First Name: {{firstName}}
Last Name: {{lastName}}
</code></pre>
<pre><code class="language-handlebars">{{person-tile firstName=(capitalize person.firstName) lastName=(capitalize person.lastName)}}
</code></pre>
<p>This addresses not having to repeat <code>capitalize</code> wherever the names are used,
but splits the content into multiple files for the sake of it.
While <a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">module unification</a> mitigates the locality problem by putting related files in the same folder,
there is still the overhead of having to consult multiple files.</p>
<p>You can instead use a block version of the component as a wrapper to the content.
Some variations are possible: you can pass data into the component as either positional or named arguments;
you can export either an object with the arguments as keys, or export multiple block parameters.</p>
<p>Passing positional arguments to components is onerous,
and necessitates having a JavaScript file to define which positional arguments it accepts.</p>
<p>Passing named arguments to components would be the closest to <code>let</code>,
but it would still require a componente template file which would yield them as block parameters.</p>
<p>Yielding out the values is where it gets tricky in components,
regardless of returning a hash or multiple block parameters,
due to the lack of a &quot;splat&quot; operator in Handlebars.</p>
<p>Since you cannot do something like this at the moment:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield ...arguments}}
</code></pre>
<p>You would have to explicitly encode all of the arguments:</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield firstName lastName}}
</code></pre>
<p>Or</p>
<pre><code class="language-handlebars">// app/templates/components/person-tile.hbs
{{yield args=(hash firstName=firstName lastName=lastName)}}
</code></pre>
<p>Leading to some repetition of names.</p>
<p>This makes the solution of using components brittle to changes,
as typos or ordering mistakes can introduce silent errors in your application.</p>
<h3 id="adding-named-arguments-to-with"><a class="header" href="#adding-named-arguments-to-with">Adding named arguments to <code>with</code></a></h3>
<p><a href="https://github.com/emberjs/rfcs/pull/202">RFC #202</a> proposes to add named arguments to <code>with</code>.</p>
<p>I feel it is less practical to add a new mode to the helper where it always renders,
when its semantics are already confusing to users.
The RFC #202 proposal also presents the problem of bringing back context-switching helpers,
as it proposes omitting block arguments (<code>as |bar|</code> in <code>{{#with foo as |bar|}}</code>).</p>
<h3 id="remove-the-conditional-behavior-of-with"><a class="header" href="#remove-the-conditional-behavior-of-with">Remove the conditional behavior of <code>with</code></a></h3>
<p>Making the <code>with</code> helper unconditionally render the block would be a major breaking change of its semantics,
and would likely affect existing applications in insidious ways.
For this reason, I reject this alternative out of the gate.</p>
<h3 id="support-let-via-the-ember-let-addon"><a class="header" href="#support-let-via-the-ember-let-addon">Support <code>let</code> via the <code>ember-let</code> addon</a></h3>
<p>There is an <a href="https://github.com/thefrontside/ember-let"><code>ember-let</code></a> addon which implements both the block and the inline forms of <code>let</code>.
To implement the necessary functionality, the addon had to resort to private API usage, which is brittle and subject to breakage.</p>
<p>Having <code>let</code> available from Ember itself would make sure that it would not be subject to breakage the same way,
and the end user would not have to worry about version compatibility.</p>
<h2 id="unresolved-questions-46"><a class="header" href="#unresolved-questions-46">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<h3 id="deprecating-with"><a class="header" href="#deprecating-with">Deprecating <code>with</code></a></h3>
<p>With the introduction of the <code>let</code> helper, <code>with</code> should likely be deprecated.</p>
<h3 id="if-let-let-and-others"><a class="header" href="#if-let-let-and-others"><code>if-let</code>, <code>let*</code> and others</a></h3>
<p>RFC #200 also proposes the <code>if-let</code> and <code>let*</code> helpers.</p>
<p><code>if-let</code> mimics the behaviour of <code>with</code>,
enabling the user to introduce bindings and conditionally rendering the block.
The advantage of introducing <code>if-let</code> over using <code>with</code> would be to define its semantics without worrying about making breaking changes to <code>with</code>.</p>
<p><code>let*</code> would allow bindings to happen sequentially, that is,
<code>let</code> (<code>{{let* a=1 b=(sum a 5)}}</code> would be valid instead of throwing an error about <code>a</code> in <code>(sum a 5)</code>.</p>
<p>These could also be addressed in subsequent RFCs, focused on the specificities of each proposal.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2017-12-22
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/287
Tracking: https://github.com/emberjs/rfc-tracking/issues/25</p>
<hr />
<h1 id="summary-66"><a class="header" href="#summary-66">Summary</a></h1>
<p>Promote the private API <code>{{-in-element}}</code> to public API as <code>{{in-element}}</code>.</p>
<h1 id="motivation-67"><a class="header" href="#motivation-67">Motivation</a></h1>
<p>Sometimes developers need to render content out of the regular HTML flow. This concept is often also
called &quot;portals&quot;. Some components like dropdowns and modals use this technique to render stuff close
to the root of the page to bypass CSS overflow rules. Some apps that are embedded into static pages
even use this technique to update parts of the page <strong>outside</strong> the app itself.</p>
<p>This need need has been covered by solutions developed in the user space but it was so common that
glimmer baked it into the VM in the form of <code>{{-in-element}}</code>, but it remains private (or <em>intimate</em>) API.
People is usually wary of using private APIs (and for good reason) as they may get removed at any time.</p>
<p>If the core team and the community is happy with the current behavior of <code>{{-in-element}}</code> it's
time to make it public.</p>
<h1 id="detailed-design-60"><a class="header" href="#detailed-design-60">Detailed design</a></h1>
<p>The existing API of <code>{{-in-element}}</code> is very simple:</p>
<ul>
<li>It takes a single positional param <code>destinationElement</code> that is a DOM element, and a block.</li>
<li>The given block is rendered not where it is located, but inside the given <code>destination</code> element, at
the end of it if there is any other content on the destination element.</li>
<li>If <code>destinationElement</code> is null/undefined then it doesn't render anything but it doesn't error.</li>
<li>If <code>destinationElement</code> is false/0/&quot;&quot; it raises an assertion in development but fails silently in production.</li>
<li>If <code>destinationElement</code> changes the block is removed from the previous destination and added to the new one. This
process tears down the rendered content on the initial destination and renders it again on the new one, meaning
that any component withing the block will be destroyed and instantiated again (calling the appropiate lifecycle hooks),
so transient HTML state like the value of an input will be lost unless manually preserved somewhere else, like a service.</li>
<li>If the destination element is an invalid value (a string, a number ...) it throws an <code>parent.insertBefore is not a function</code> error. I think
that throwing an error is correct but the error message could be improved.</li>
<li>If the destination element has a different context (like SVG) the content will be appended normally by the glimmer VM,
which doesn't try to validate the correctness of the generated HTML. This is normal behavior in Glimmer, not
an exception, and users must be aware that rendering invalid markup might be interpreted or auto-corrected in
unexpected ways by the browser when in SSR mode.</li>
<li>Rendering into a foreign object (an element within an <code>&lt;iframe&gt;</code>) should be disallowed initially. If someone
asks for this feature it would require an RFC to explore the consequences.</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-hbs">{{#-in-element destinationElement}}
  &lt;div&gt;Some content&lt;/div&gt;
{{/-in-element}}
</code></pre>
<p>The current implementation only suggests creating a new <code>{{in-element}}</code> construct that is a simple
alias of <code>{{-in-element}}</code> with the exact same params and behavior, and then, after a while, remove
the private one.</p>
<p>Although <code>{{-in-element}}</code> is technically private, there there is enough people using it to deserve
a deprecation. I suggest keeping the deprecated private API will until the first LTS release of the
3.X cycle (3.4) to be finally removed in the next one (3.5).</p>
<h3 id="small-proposed-changes"><a class="header" href="#small-proposed-changes">Small proposed changes</a></h3>
<p>There is however one part of the behavior that the core team wants to make explicit before promoting
the private API to public, and that is how the content is added to the destination when there is other
content already there.</p>
<p>The desired behavior is that, by default, the rendered content will <strong>replace all the content of the destination</strong>,
effectively becoming the its <code>innerHTML</code>.
In the current behaviour the rendered content is appended as the end of any existing content. This will still
be supported by passing <code>insertBefore=null</code>, but it will not be the default anymore.
Any other value passed to <code>insertBefore</code> must produce an error.</p>
<h1 id="how-we-teach-this-40"><a class="header" href="#how-we-teach-this-40">How We Teach This</a></h1>
<p>This will be a new build-in helper and must be added to the guides and the API.
For most usages, it will replace some community solution created with the same goal, like
<a href="https://github.com/yapplabs/ember-wormhole">ember-wormhole</a> or <a href="https://github.com/ef4/ember-elsewhere">ember-elsewhere</a>.
It would be for the best to let the authors of those addons know about this feature so they can
deprecate their packages if they feel there is no longer a need for them, or at least update their
Readme files to let their users know that there is a built-in solution in Ember that might cover
their needs.</p>
<h1 id="drawbacks-64"><a class="header" href="#drawbacks-64">Drawbacks</a></h1>
<p>By augmenting the public API of the framework, the framework is committing to support it for the lifespan
of an entire mayor version (Ember 4.0).</p>
<h1 id="alternatives-65"><a class="header" href="#alternatives-65">Alternatives</a></h1>
<p>We can decide that the framework does not want to make public and support this feature, and continue
to rely on community-built addons like we've done until today.</p>
<h1 id="unresolved-questions-47"><a class="header" href="#unresolved-questions-47">Unresolved questions</a></h1>
<p>Do we want to make any improvement to <code>{{-in-element}}</code> before making it public API?</p>
<p>Some possible ideas:</p>
<ul>
<li>Allow to <em>conditionally</em> render the block in place. See https://github.com/DockYard/ember-maybe-in-element</li>
<li>Allow to receive not only DOM elements as first argument, but also strings, representing the ID of
other CSS selector.</li>
<li>Modify or improve the way it behaves during SSR using ember-fastboot.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-01-10
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/293
Tracking: https://github.com/emberjs/rfc-tracking/issues/24</p>
<hr />
<h3 id="summary-67"><a class="header" href="#summary-67">Summary</a></h3>
<p>Currently, incrementally experimenting with Ember Data internals is hard both for addon authors
and Ember Data contributors. This RFC rationalizes the internals and establishes clear boundaries
for record data storage and manipulation allowing us to expose a public api for addon authors to experiment with. </p>
<h3 id="motivation-68"><a class="header" href="#motivation-68">Motivation</a></h3>
<p>Externally, addons can customize how apps communicate with the server by implementing the Adapter/Serializer APIs but changing how ED deals with relationships, attribute buckets, rollbacks, dirtyness
and similar issues is extremely challenging and impossible without extremely internal hacks. One can look at popular addons like EmberDataModelFragments
and see how many private APIs they had to override and hack to implement their funcionality.</p>
<p>Internally, while ED is reasonably well factored between data coming into the system through
Adapter/Serializers/IdentityMap/Store and data going out through DS.Model/Snapshots/Adapters/Serializers
, internal handling of the data including relationships and attributes has extremely fuzzy and unclear boundaries.</p>
<p>Data currently lives in internalModels, relationship state objects, computed property caches, relationship
payload caches, etc.</p>
<h4 id="before"><a class="header" href="#before">before</a></h4>
<p><img src="https://user-images.githubusercontent.com/715175/33340994-6380c66a-d432-11e7-9f00-ed905e78915a.png" alt="image" /></p>
<p>This RFC proposes rationalizing and extracting ED's core record data handling layer into a RecordData class.</p>
<h4 id="after"><a class="header" href="#after">after</a></h4>
<p><img src="https://user-images.githubusercontent.com/715175/33341155-e5f170c2-d432-11e7-9c50-4a3e977331fe.png" alt="image" /></p>
<p>This will allow us to rationalize internal ED APIs, establish clearer internal boundaries, 
allow experimentation by addon authors, and create a path for internal ED experimentation.</p>
<p>You can think of Record Data as a layer that can receive JSON api payloads for a record,
apply local changes to it, and can be queried for the current state of the data.</p>
<p>Examples of things this would enable:</p>
<ol>
<li>
<p>By shipping a custom RecordData, EmberDataModelFragments can implement a large part of their 
funcionality without relying on private apis. Spike at <a href="https://github.com/igorT/ember-data.model-fragments/tree/igor/model-data">model fragments</a></p>
</li>
<li>
<p>A spike of Ember Data backed by Orbit, can be implemented as an addon, where most of the work
is in implementing a Record Data backed by Orbit. Spike at <a href="https://github.com/igorT/data-orbit/tree/orbit-model-data">data-orbit</a></p>
</li>
<li>
<p>By using an ES6 class for Record Data implementation, this brings us closer to an Emberless 
Ember Data running.</p>
</li>
<li>
<p>If you needed to implement a GraphQL like projection API, Adapters and Serializers would be enough
for the loading data, but currently there is no good place to handle client side data interactions.
RecordData would make it much easier to have a GraphQL ED addon</p>
</li>
<li>
<p>Certain apps and models have a large amount of read only data, which is currently very performance heavy
to implement in ED. They could use a read only fast record data addon, which would enable a large perf win.</p>
</li>
<li>
<p>Experimenting with schemaless approaches is currently very hard in ED, because internal
models encode assumptions of how attributes and relationships work. Having a swappable RecordData would
make it easier for us to implement schemaless approaches in addons.</p>
</li>
<li>
<p>By having Record Data fully expressed in JSON API apis, the current state of the store becomes serializable.</p>
</li>
</ol>
<p>By designing a public interface for RecordData that dosen't rely on any other part of EDs current system,
we can use RecordData as the main building block around which we can refactor the rest of ED.</p>
<h3 id="detailed-design-61"><a class="header" href="#detailed-design-61">Detailed design</a></h3>
<h4 id="high-level-design"><a class="header" href="#high-level-design">High level design</a></h4>
<p>Ember Data would define a RecordData interface, and ship a default implementation. Addons would
be able to swap their own implementation of the RecordData interface.</p>
<p>RecordData is an interface defining the api for how the store and DS.Models 
store and apply changes to data. RecordDatas hold
the backing data for each record, and act as a bridge between the Store, DS.Model, and Snapshots.
It is per record, and defines apis that respond to 
store api calls like <code>pushData</code>, <code>adapterDidCommit</code> and DS.Model updates like <code>setAttribute</code>.
RecordData represents the bucket of state that is backing a particular DS.Model.</p>
<p>The store instantiates the RecordData, feeds it JSON API data coming from the server and
tells it about state changes. DS.Model queries the RecordData for the attribute
and relationship values and sends back the updates the user has made.</p>
<p>Other than the <code>storeApisWrapper</code> passed to it, RecordData does not assume existence of
any other Ember or Ember Data object. It is a fully self contained system, that might serve
as a basic building block of non Ember/ED data libraries and could be extracted into a separate
library.</p>
<h4 id="interface"><a class="header" href="#interface">Interface</a></h4>
<p>The interface for RecordData is:</p>
<pre><code class="language-js">export default class RecordData {
  constructor(modelName: string, clientId?: string, id?: string, storeApisWrapper: StoreApisWrapper) {
    /*
      Exposing the entire store api to the RecordData seems very risky and would 
      limit the kind of refactors we can do in the future. We would provide a wrapper
      to the RecordData that would enable funcionality MD absolutely needs 
    */
  }


  /*
    Hooks through which the store tells the Record Data about the data
    changes. They all take JSON API and return a list of keys that the 
    record will need to update
  */

  pushData(data: JsonApi, shouldCalculateChanges: boolean/* if false, don't need to return changed keys*/) {
  }

  adapterDidCommit(data: JsonApi) {
  }

  didCreateLocally(properties) {
  }

  /*
    Hooks through which the store tells RecordData about the lifecycle of the data,
    allowing it to keep track of dirtyness
  */

  adapterWillCommit(modelName: string, id?: string, clientId?: string) {
  }

  saveWasRejected(modelName: string, id?: string, clientId?: string) {
  }

  adapterDidDelete(modelName: string, id?: string, clientId?: string) {
  }

  recordUnloaded(modelName: string, id?: string, clientId?: string) {
  }


  /*
   Rollback handling
  */

  rollbackAttributes(modelName: string, id?: string, clientId?: string) {
  }

  rollbackAttribute(modelName: string, id?: string, clientId?: string, attribute: string) {
  }

  changedAttributes(modelName: string, id?: string, clientId?: string) {
  }

  hasChangedAttributes(modelName: string, id?: string, clientId?: string) {
  }


  /*
    Methods through which DS.Model interacts with RecordData, by setting and getting local state
  */

  setAttr(modelName: string, id?: string, clientId?: string, key: string, value: string) {
  }

  getAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  hasAttr(modelName: string, id?: string, clientId?: string, key: string) {
  }

  /*
    Relationships take and return json api resource objects
    The store takes those references and decides whether it needs to load them, or
    it can serve them from the cache
  */

  getHasMany(modelName: string, id?: string, clientId?: string, key: string) {
  }
  
  addToHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources, idx: number) {
  }

  removeFromHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  setHasMany(modelName: string, id?: string, clientId?: string, key: string, jsonApiResources) {
  }

  getBelongsTo(modelName: string, id?: string, clientId?: string, key: string) {
  }

  setBelongsTo(modelName: string, id?: string, clientId?: string, key: string, jsonApiResource) {
  }

</code></pre>
<pre><code class="language-js">
export default class StoreApiWrapper {
  /* clientId is used as a fallback in the case of client side creation */
  createRecordDataFor(modelName, id, clientId)
  notifyPropertyChanges(modelName, id, clientId, keys)
  /* 
  in order to not expose ModelClasses to RecordData, we need to supply it with
  model schema information. Because a schema design is out of scope for this RFC,
  for now we expose these two methods we intend to deprecate once we have a schema
  interpretation
   */
  attributesDefinitionFor(modelName, id)
  relationshipsDefinitionFor(modelName, id)

}
</code></pre>
<h4 id="eds-usage-of-recorddata"><a class="header" href="#eds-usage-of-recorddata">ED's usage of RecordData</a></h4>
<p>We would refactor internal models, DS.Models and Snapshots to use RecordData's apis.</p>
<p>Reimplementation of ED current internals on top of RecordData apis would consist of the store
pushing the json api payload to the backing record data and the record data setting up internal
data tracking, as well as storing relationship data on any additional needed recordDatas.</p>
<pre><code class="language-js">let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};

store.push(data);

// internal store method
_internalMethod() {
  let recordData = store.recordDataFor('user', 1, this._storeWrapperApi)
  recordData.pushData(data, false)
}

-&gt;

// model-data.js
pushData(data, shouldCalculateChanges) {
  this._data = this.data.attributes;
  this._setupRelationships(data);
}
-&gt;
// model-data.js
_setupRelationships(data) {
  this.storeWrapperApi.recordDataFor('house', 1);
  ....
}
</code></pre>
<p>The DS.Model interactions would look like:</p>
<pre><code class="language-js">let user = store.peekRecord('user', 1);
user.get('name');
-&gt;
// DS.Model
get(key) {
  let recordData = _internalMethodForGettingTheCorrespondingRecordData(this);
  return recordData.getAttr('name');
}
</code></pre>
<h4 id="relationships"><a class="header" href="#relationships">Relationships</a></h4>
<h5 id="basic-loading-of-relationships"><a class="header" href="#basic-loading-of-relationships">Basic loading of relationships</a></h5>
<p>RecordData's relationship hooks would receive and return json api relationship objects with
additional metadata meaningful to Ember Data.</p>
<p>Lets say that we started off with the same user data as above</p>
<pre><code class="language-js">let data = {
  data: {
    id:1,
    type: 'user',
    attributes: { name: 'Clemens' },
    relationships: { houses: { data: [{ id: 5, type: 'house' }], links: { related: '/houses' } } }
  }
};
let clemens = store.push(data);
</code></pre>
<p>Getting a relationships from Clemens would trace a path from the DS.Model to backing record data,
which would then give the store a json api object, and the store would instantiate a ManyArray
with the records</p>
<pre><code class="language-js">clemens.get('houses');
// DS.Model
get() {
  let clemensRecordData = _internalApiGetsUsTheRecordDataFromIDMMAP();
  return clemens.getHasMany('houses');
}
-&gt;
// Record Data returns
{[ 
  data: { id: 5, type: 'house'},
  links: { related: '/houses' },
  meta: { realMetaFromServer: 'hi', _ED: { hasAllIds: true, needToLoadLink: false } }
}
-&gt; //store takes the above, figures out that it needs to fetch house with id 5
  // and returns a promise which resolves into a ManyArray

</code></pre>
<p>ED extends the relationship payload with a custom meta, which gives the store information 
about whether we have information about the entire relationship (we couldn't be sure we
have all the ids if we loaded from the belongsTo side) and whether the link should be refetched
(we might need to refetch the link in the case it potentially changed)</p>
<h5 id="setting-relationship-data-locally"><a class="header" href="#setting-relationship-data-locally">Setting relationship data locally</a></h5>
<p>Similarly to the attributes, changing relationships locally tells record data to update
the backing data store</p>
<pre><code class="language-js">let anotherHouse = store.push({data: { type: 'house', id: '5' }});
clemens.get('houses').then((houses) =&gt; {
  houses.pushObject(anotherHouse);
  -&gt; 
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: '5' } })
});
</code></pre>
<h5 id="dealing-with-newly-created-records-in-relationships"><a class="header" href="#dealing-with-newly-created-records-in-relationships">Dealing with newly created records in relationships</a></h5>
<p>Unfortunately, because ED does not have first class clientId support, we need a special case
for handling locally created records, and pushing them to relationships.</p>
<p>We extend JSON API resource object with a <code>clientId</code> meta field.
A locally created record, will also have a ED specific internal client id, which will take preference;</p>
<pre><code class="language-js">let newHouse = store.createRecord('house');
clemens.get('houses').then((houses) =&gt; {
  houses.pushObject(newHouse);
  -&gt;
  // internally
  clemensRecordData.addToHasMany('houses', { data: { type: 'house', id: null, { meta: _ED: { clientId: 1}} } })
});
clemens.get('houses') -&gt;
{ data: 
  [ { id: 5, type: 'house'}, 
    { id: null, type: 'house', meta: { _ED: { clientId: 1 } } }],
  links: { related: '/hi' },
  meta: { realMetaFromServer: 'hi', _ED: { loaded: true, needToLoadLink: false } }
}
</code></pre>
<p>ED internals would keep a separate cache of client ID and resolve the correct record</p>
<h4 id="addon-usage"><a class="header" href="#addon-usage">Addon usage</a></h4>
<p>The Store provides a public api for looking up a recordData which the store has not seen before.</p>
<pre><code>recordDataFor(modelName, id, options) {

}
</code></pre>
<p>If an Addon wanted to implement custom data handling functionality, it would subclass the store
and implement their own RecordData handler.</p>
<p>There are three main reasons to do this.</p>
<ol>
<li>Full replacement of Ember Data's data handling mechanisms</li>
</ol>
<p>Best example would be the Ember Data backed by Orbit.js experiment. EmberDataOrbit Addon replaces
Ember Data's backing data implementation with Orbit.js. Most of this work can be done by EmberDataOrbit
replacing ED's Record Data implementation</p>
<pre><code>recordDataFor(modelName, id, options, storeWrapper) {
  return new OrbitRecordData(modelName, id, storeApisWrapper) 
}
</code></pre>
<ol start="2">
<li>Per Model replacement of Ember Data's data handling</li>
</ol>
<p>If a large app was loading thousands of instances of a particular record type, which was read-only,
it could use a read only ED addon, which implemented a simplified RecordData without any change tracking.</p>
<p>The addon would implement a <code>recordDataFor</code> on the store as </p>
<pre><code>recordDataFor(modelName, id, options, storeWrapper) {
  if (addonDecidesIfReadOnly(modelName))  {
    return new ReadOnlyRecordData(modelName, id, storeApisWrapper) 
  }
  return this._super(modelName, id, options, storeWrapper);
}
</code></pre>
<ol start="3">
<li>Adding common funcionality to all ED models</li>
</ol>
<p>Ember Data Model Fragments Addon adds support for handling of embedded data fragments.
In order to manage the handling of fragments, Model Fragments would compose ED's default
RecordData with it's own for handling fragments.</p>
<pre><code class="language-js">recordDataFor(modelName, id, options, storeWrapper) {
  let EDRecordData = this._super(modelName, id, options, storeWrapper);
  return new ModelFragmentsRecordData(modelName, id, options, storeWrapper, EDRecordData);
}
</code></pre>
<p>When receiving a payload, ModelFragments would handle the fragment part and delegate the rest
to ED's implementation</p>
<pre><code class="language-js">pushData(data, shouldCalculateChanges) {
  let keysThatChanged = this.extractAndHandleFragments(data);
  return keysThatChanged.concat(this.EDRecordData.pushData(data, shouldCalculateChanges))
}
</code></pre>
<h3 id="how-we-teach-this-41"><a class="header" href="#how-we-teach-this-41">How we teach this</a></h3>
<p>These APIs are not meant to be used by most users, or app level code, and should be hidden away and
described in an api/guides section meant for ED addon authors. Currently there are a few widely used
addons which would greatly benefit from this, so we can also reach out in person. I have already implemented
a spike of ModelFragments using RecordData. Having couple addons implement different RecordDatas would be
a great way to teach new addon authors about the purpose and implementation of the API.</p>
<h3 id="drawbacks-65"><a class="header" href="#drawbacks-65">Drawbacks</a></h3>
<h4 id="defines-a-bigger-api-surface-area"><a class="header" href="#defines-a-bigger-api-surface-area">Defines a bigger API surface area</a></h4>
<p>This change would increase the public API surface area, in a codebase that is already pretty complex.
However, this would codify and simplifyA APIs addon authors have already had to interact with, while
creating a path for future simplification of the codebase. </p>
<h4 id="it-allows-people-to-do-very-non-standard-changes-that-will-complexify-their-app-needlessly"><a class="header" href="#it-allows-people-to-do-very-non-standard-changes-that-will-complexify-their-app-needlessly">It allows people to do very non-standard changes that will complexify their app needlessly</a></h4>
<p>The main mitigation, is only giving RecordData access to a small amount of knowledge of the external world,
and keeping most APIs pull only thus discouraging trying to do innapropriate work in the RecordData layer</p>
<h4 id="the-new-json-api-interaction-might-preclude-performance-improvements-or-reduce-current-performance"><a class="header" href="#the-new-json-api-interaction-might-preclude-performance-improvements-or-reduce-current-performance">The new JSON api interaction might preclude performance improvements, or reduce current performance</a></h4>
<h3 id="alternatives-66"><a class="header" href="#alternatives-66">Alternatives</a></h3>
<h4 id="we-could-do-this-work-as-an-internal-refactor-and-not-expose-it-to-public"><a class="header" href="#we-could-do-this-work-as-an-internal-refactor-and-not-expose-it-to-public">We could do this work as an internal refactor, and not expose it to public.</a></h4>
<p>I believe that this approach is valid as an internal architecture, so would like to do it even if
we did not expose any of it to addons/apps.</p>
<h4 id="make-recorddatas-looked-up-from-the-resolver"><a class="header" href="#make-recorddatas-looked-up-from-the-resolver">Make RecordData's looked up from the resolver</a></h4>
<p>Currently RecordData is a dumb ES6 class and does not live in the Ember resolver system, for performance
and simplicity reasons. We could alternatively look it up from the resolver, allowing people
to mock it and inject into it easier.</p>
<h4 id="dont-expect-a-per-record-record-data"><a class="header" href="#dont-expect-a-per-record-record-data">Don't expect a per record Record Data</a></h4>
<p>Currently, the MD layer semantics mimics current ED's data storage, where data is stored per record in
internalModels. You could alternatively do this using an app wide cache, like Orbit.js does, or
using any number of other approaches. This approach while valid, would be harder to implement and
it's apis would not map as well to ED behavior.</p>
<h3 id="open-questions"><a class="header" href="#open-questions">Open Questions</a></h3>
<h4 id="versioning-and-stability"><a class="header" href="#versioning-and-stability">Versioning and stability</a></h4>
<p>Our current implementation of <code>internalModel</code> is deeply monkeypatched by at least few addons. I think
we have to consider it as an semi-intimate api, even though it literally has <code>internal</code> in the name(I've been told adding couple undescores to the name would have helped).
Because the number of addons monkeypatching it is limited, we can manually migrate them onto the new
apis. However this requires us to make the new apis public from the get go, and doesn't allow for a long period of api evolution. </p>
<p>The following options are available, none of them great:</p>
<ol>
<li>
<p>Feature flag RecordData work. The scope of this refactor is large enough, that doing a full feature
flagging would be an enourmous burden to bear, and I would advise against it. We can proxy some basic
things, to allow for simpler changes and as a way of warning/deprecating</p>
</li>
<li>
<p>Move from the internals to public RecordData in a single release cycle, and hope public apis we created
make sense, and will not be performance issues in the future. I am reasonably confident having implemented
several addons using RecordData that the basic design works, but things can always come up.</p>
</li>
<li>
<p>Move from private internals to private RecordData, and then feature flag the public apis over couple
versions. In this case the addons monkeypatching the internals, would monkeypatch the new nicer apis
for a while, and then easily switch to the public api. This feel a bit like SemVer cheating.</p>
</li>
</ol>
<h4 id="clientid-passing-to-store-api-methods"><a class="header" href="#clientid-passing-to-store-api-methods">ClientID passing to store api methods</a></h4>
<p>We use <code>recordDataFor(modelName, id, clientId)</code> as the api to look up recordDatas. Passing an often
null clientId seems annoying. Orbit.js uses an identity object instead, and if we did the api would look like <code>recordDataFor(identityObject)</code>, where <code>identityObject</code> would look like <code>{ type, id, meta: { _ED: { clientId }}}</code>. This seem a bit more correct, but doesn't look like any existing ED api, and could create
a lot of allocations.</p>
<h4 id="recorddatas-might-need-to-do-some-global-setupcommunication-how-does-that-work"><a class="header" href="#recorddatas-might-need-to-do-some-global-setupcommunication-how-does-that-work">RecordDatas might need to do some global setup/communication, how does that work?</a></h4>
<p>Normally you would do this in an initializer, but becasue MDs aren't resolved, the only way would be
to do it in RecordDataFor or by using a singleton import. Some ceremony being required to using RecordData
isn't super bad, because it will discourage app authors from customizing it for trivial/innapropriate
things.</p>
<h4 id="what-do-we-do-with-the-record-state-management"><a class="header" href="#what-do-we-do-with-the-record-state-management">What do we do with the record state management?</a></h4>
<p>Currently RecordData has no interaction with the state machine. I think we should punt on this
for now. </p>
<h4 id="-meta--_ed--props-here----alternatives"><a class="header" href="#-meta--_ed--props-here----alternatives">{ meta: { _ED: { props here } } } alternatives?</a></h4>
<p>We could put the ED internal data outside of meta, and keep meta only for actual meta that comes from
the server.</p>
<h4 id="naming-of-everything"><a class="header" href="#naming-of-everything">Naming of everything</a></h4>
<p>Please help with better names for things if you have ideas</p>
<h4 id="snapshot-interface"><a class="header" href="#snapshot-interface">Snapshot interface</a></h4>
<p>How does a Snapshot ask Record Data for it's attributes</p>
<h4 id="real-life-perf-impact"><a class="header" href="#real-life-perf-impact">Real life perf impact</a></h4>
<p>Need benchmarks</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-01-11
RFC PR: https://github.com/emberjs/rfcs/pull/294</p>
<hr />
<h1 id="make-jquery-optional"><a class="header" href="#make-jquery-optional">Make jQuery optional</a></h1>
<h2 id="summary-68"><a class="header" href="#summary-68">Summary</a></h2>
<p>For the past Ember has been relying and depending on jQuery. This RFC proposes making jQuery optional and having a well 
defined way for users to opt-out of bundling jQuery. </p>
<h2 id="motivation-69"><a class="header" href="#motivation-69">Motivation</a></h2>
<h3 id="why-we-dont-need-jquery-any-more"><a class="header" href="#why-we-dont-need-jquery-any-more">Why we don't need jQuery any more</a></h3>
<p>One of the early goals of jQuery was cross-browser normalization, at a time where browser support for web standards was 
incomplete and inconsistent, and Internet Explorer 6 was the dominating browser. It provided a useful and convenient
API for DOM traversal and manipulation as well as event handling, that hid the various browser differences and bugs from
the user. For example <code>document.querySelector</code> wasn't a thing at that time, and browsers were using very different event 
models (<a href="https://en.wikipedia.org/wiki/DOM_events#Event_handling_models">DOM Level 0, DOM Level 2 and IE's own proprietary model</a>). </p>
<p>But this level of browser normalization is not required anymore, as today's browsers all support the basic DOM APIs well
enough. Even more so that the upcoming Ember 3.0 will drop support for all versions of Internet Explorer except 11.</p>
<p>Furthermore Ember users will need to directly traverse and modify the DOM or manually attach event listeners in very 
special cases only. Most of these low level interactions are taken care of by Ember's templates and its underlying 
Glimmer rendering engine, as well as action helpers or the component's event handler methods.</p>
<p>So having jQuery included by default does not provide that much value to users most of the time, and Ember itself is
expected to be fully functional and tested without jQuery, presumably for the upcoming 3.0 stable release.</p>
<h3 id="what-are-the-drawbacks-of-bundling-jquery"><a class="header" href="#what-are-the-drawbacks-of-bundling-jquery">What are the drawbacks of bundling jQuery</a></h3>
<p>The major drawback is the increased bundle size, which amounts to <a href="https://mathiasbynens.be/demo/jquery-size">~29KB</a> 
(minified and gzipped). This not only increases the loading time, but also parse and compile times, thus increasing the 
total time to interactive. This is especially true for mobile devices, where slow connectivity and weak CPU performance 
is not uncommon.</p>
<p>Having jQuery not included will improve the suitability of Ember for mobile applications considerably. Even
if the raw number is not that huge, it all adds up. And it plays together with other efforts to make leaner Ember builds
possible, like enabling tree shaking with the new <a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md">Module API</a>,
moving code from core to addons (e.g. the <a href="https://github.com/emberjs/rfcs/blob/master/text/0236-deprecation-ember-string.md"><code>Ember.String</code> deprecation</a>)
or the <a href="https://github.com/emberjs/rfcs/blob/explode/text/0000-explode.md">&quot;Explode RFC&quot;</a>. In that regard removing the 
dependency on jQuery is a rather low hanging fruit with an high impact.</p>
<h3 id="but-this-is-already-possible-why-this-rfc"><a class="header" href="#but-this-is-already-possible-why-this-rfc">But this is already possible, why this RFC?</a></h3>
<p>There is indeed a somewhat quirky way to build an <a href="https://github.com/rwjblue/no-jquery-app">app without jQuery</a> even
today.
Although this <em>happens</em> to work, it is not sufficient to consider this officially supported for these reasons:</p>
<ul>
<li>Ember itself must be fully tested to work without jQuery</li>
<li>the public APIs that depend on and/or expose jQuery need to have some well defined behavior when jQuery is not 
available</li>
<li>there should be a way to technically opt-out (other than fiddling with <a href="https://github.com/rwjblue/no-jquery-app/commit/34c40fc2cfc5e2ce0c39e5e906448c46af699d26"><code>vendorFiles</code></a>)
that is easier to use, understand and maintain</li>
<li>addons should mostly default to not use jQuery, to make removing jQuery practically possible for their consuming
apps</li>
</ul>
<h2 id="detailed-design-62"><a class="header" href="#detailed-design-62">Detailed design</a></h2>
<h3 id="remove-internal-jquery-usage"><a class="header" href="#remove-internal-jquery-usage">Remove internal jQuery usage</a></h3>
<p>As of writing this, there are <a href="https://github.com/emberjs/ember.js/issues/16058">major efforts</a> underway to remove and 
cleanup the Ember codebase and especially its tests from jQuery usage. Having a way to fully test Ember without jQuery 
is a prerequisite to officially support jQuery being optional. When this is done, it will enable a &quot;no jQuery&quot; mode, 
that will make it not use jQuery anymore, but only native DOM APIs.</p>
<h3 id="add-an-opt-out-flag"><a class="header" href="#add-an-opt-out-flag">Add an opt-out flag</a></h3>
<p>There should be a global flag that will toggle the optional jQuery integration (true by default). When this is disabled,
it will make Ember CLI's build process <em>not</em> include jQuery into the <code>vendor.js</code> bundle, <em>and</em> it will explicitly put 
Ember itself into its &quot;no jQuery&quot; mode.</p>
<p>The flag itself will not be made a public API. Rather it will be handled by a privileged addon, that will allow to 
disable the integration flag, thus to opt out from jQuery integration. This approach is in line with 
<a href="https://github.com/emberjs/rfcs/pull/278">RFC 278</a> and <a href="https://github.com/emberjs/rfcs/pull/280">RFC 280</a>, to allow 
for some better implementation flexibility.</p>
<h3 id="introduce-emberjquery-package"><a class="header" href="#introduce-emberjquery-package">Introduce <code>@ember/jquery</code> package</a></h3>
<p>Currently Ember CLI itself is importing jQuery into the app's <code>vendor.js</code> file. To decouple it from this task, and
to allow for some better flexibility in the future, the responsibility for importing jQuery is moved to a dedicated 
<code>@ember/jquery</code> addon.</p>
<p>To not create any breaking changes, Ember CLI will have to check the app's dependencies for the presence of this addon. 
If it is not present, it will continue importing jQuery <em>unless</em> the jQuery integration flag is disabled.
If it is present, it will stop importing jQuery at all, and delegate this responsibility to the addon.</p>
<p>To nudge users to install <code>@ember/jquery</code> when they need jQuery, some warning/deprecation messages should be issued when
the addon is <em>not</em> installed and the integration flag is either not specified or is set to true. To ease 
migration the addon should be placed in the default blueprint (until an eventual more aggressive deprecation of 
jQuery). Only in the case the app is actively opting out of jQuery integration the addon is not needed.</p>
<p>The addon itself has to make sure the Ember CLI version in use is at least the one that introduced the above mentioned
logic, to prevent importing jQuery twice.</p>
<h3 id="assertions-for-jquery-based-apis"><a class="header" href="#assertions-for-jquery-based-apis">Assertions for jQuery based APIs</a></h3>
<p>Apart from testing (see below), Ember features some APIs that directly expose jQuery, which naturally cannot continue 
to work without it. For these APIs some assertions have to be added when running in &quot;no jQuery&quot; mode (and not in 
production), that provide some useful error messages for the developer:</p>
<ul>
<li><code>Ember.$()</code>
should throw an assertion stating that jQuery is not available.</li>
<li><code>this.$()</code> in components
should throw an assertion stating that jQuery is not available and that <code>this.element</code> and native DOM APIs should be
used instead.</li>
</ul>
<h3 id="introducing-ember-jquery-legacy-and-deprecating-jqueryevent-usage"><a class="header" href="#introducing-ember-jquery-legacy-and-deprecating-jqueryevent-usage">Introducing <code>ember-jquery-legacy</code> and deprecating <code>jQuery.Event</code> usage</a></h3>
<p>Event handler methods in components will usually receive an instance of <a href="http://api.jquery.com/category/events/event-object/"><code>jquery.Event</code></a> as an argument, which is very
similar to native event objects, but not exactly the same. To name a few differences, not all properties of the native 
event are mapped to the jQuery event, on the other hand a jquery event has a <code>originalEvent</code> property referencing the
native event. </p>
<p>The updated event dispatcher in Ember 3.0 is capable of working without jQuery (similar to what 
<code>ember-native-dom-event-dispatcher</code> provided for Ember 2.x). When jQuery is not available, it will naturally not be 
able to pass a <code>jquery.Event</code> instance but a native event instead. This creates some ambiguity for addons, as they 
cannot know in advance how the consuming app is built (with or without jQuery).</p>
<p>For code that does not rely on any <code>jQuery.Event</code> specific API, there is no need to change anything as it will continue
to work with native DOM events. </p>
<p>But there are cases where jQuery specific properties have to be used (when jQuery events are passed). This is especially
true for the <code>originalEvent</code> property, for example to access <code>TouchEvent</code> properties that are not exposed on the 
<code>jQuery.Event</code> instance itself. So there has to be a way to make the code work with either jQuery events or native 
events being passed to the event handler (especially important for addons). Moreover this should be done in a way that 
uses native DOM APIs only, to support the migration away from jQuery coupled code.</p>
<p>To solve this issue another addon <code>ember-jquery-legacy</code> will be introduced, which for now will only expose a single
<code>normalizeEvent</code> function. This function will accept a native event as well as a jQuery event (possibly distinguishing
between those two modes at build time, based on the jQuery integration flag), but will always return a native event 
only. </p>
<p>This will allow addon authors to work with both event types, but start to only use native DOM APIs:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { normalizeEvent } from 'ember-jquery-legacy';

export default Component.extend({
  click(event) {
    let nativeEvent = normalizeEvent(event);
    // from here on use only native DOM APIs...
  }
})
</code></pre>
<p>To encourage addon authors to refactor their jQuery coupled event code, the use of <code>jQuery.Event</code> specific APIs used for
jQuery events passed to component event handlers should be deprecated and a deprecation message be shown when accessing 
them (e.g. <code>event.originalEvent</code>). Care must be taken though that this warning will not be issued when <code>normalizeEvent</code> 
has to access <code>originalEvent</code>. </p>
<p>Also for apps that do not want to transition away from jQuery and would be overloaded with unnecessary warnings, the 
deprecations should be silenced when the jQuery integration flag is explicitly set to true (and not just true by 
default). By doing so users effectively state their desire to continue using jQuery, thus any needless churn should
be avoided for them.</p>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<p>Ember's test harness has been based on jQuery for a long time. Most global acceptance test helpers like <code>find</code> or 
<code>click</code> rely on jQuery. For integration tests the direct use of jQuery like <code>this.$('button').click()</code> to trigger 
events or assert the state of the DOM is still the standard, based on <code>this.$()</code> returning a jQuery object representing
the rendered result of the tests <code>render</code> call.</p>
<p>To be able to reliably run tests in a jQuery-less world, we need to run our tests without jQuery being included,
so our test harness has to work without jQuery as well.</p>
<p>Fortunately this is well underway already. <a href="https://github.com/cibernox/ember-native-dom-helpers">ember-native-dom-helpers</a>
introduced native DOM test helpers for integration and acceptance tests as an user space addon. The recent acceptance 
testing <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a> provides 
similar test helpers, implemented in the <code>@ember/test-helpers</code> package, and envisages deprecating the global test 
helpers.</p>
<p>However while the existing jQuery based APIs are still available, when these are used without jQuery they have to throw
an assertion with some meaningful error message:</p>
<ul>
<li>
<p>global acceptance test helpers that expect jQuery selectors (which are a potentially incompatible superset of standard
CSS selectors)</p>
</li>
<li>
<p><code>this.$()</code> in component tests, provided currently by <code>@ember/test-helpers</code> in <code>moduleForComponent</code> and 
<code>setupRenderingTest</code></p>
</li>
</ul>
<p>In both cases the error message should state that jQuery is not available and that the native DOM based test helpers
of the <code>@ember/test-helpers</code> package should be used instead.</p>
<p>The transitioning to these new test helpers can be eased through a codemod. For <code>ember-native-dom-helpers</code> there already
exists  <a href="https://github.com/simonihmig/ember-native-dom-helpers-codemod">ember-native-dom-helpers-codemod</a>, which 
could be adapted to the very similar RFC 268 based interaction helpers in <code>@ember/test-helpers</code>.</p>
<h3 id="implementation-outline"><a class="header" href="#implementation-outline">Implementation outline</a></h3>
<p>The following outlines how a possible implementation of the jQuery integration flag <em>could</em> look like. This
is just to provide some additional context, but is <em>intentionally not</em> meant to be normative, to allow some flexibility 
for the actual implementation.</p>
<p>The addon that will handle the flag is expected to be <a href="https://github.com/emberjs/ember-optional-features">ember-optional-features</a>,
which will read from and write to a <code>config/optional-features.{js,json}</code> file. This will hold the <code>jquery-integration</code> 
flag (amongst others). This flag in turn will be added to the <code>EmberENV</code> hash, which will make Ember go into its 
&quot;no jQuery&quot; mode when set to <code>false</code>. </p>
<p>Ember CLI and the <code>@ember/jquery</code> addon will also look for <code>jquery-integration</code> in this configuration file, and will 
opt-out of importing jQuery when this file is present and the flag is set to <code>false</code>.</p>
<h2 id="how-we-teach-this-42"><a class="header" href="#how-we-teach-this-42">How we teach this</a></h2>
<h3 id="guides"><a class="header" href="#guides">Guides</a></h3>
<p>The existing &quot;Managing Dependencies&quot; chapters in the Ember Guides as well as on ember-cli.com provide a good place to 
explain users how to set the jQuery integration flag by means of the mentioned <a href="0294-optional-jquery.html#add-an-opt-out-flag">privileged addon</a> 
that handles this flag. </p>
<p>The section on components should be updated to remove any eventually remaining references to <code>this.$</code>, to not let users 
fall into the trap of creating an implicit dependency on jQuery by &quot;accidental&quot; use of it. These should be changed to 
refer to their native DOM counterparts like <code>this.element</code> or <code>this.element.querySelector()</code>.</p>
<p>The section on acceptance tests will have been updated as per <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a>
to use the new <code>@ember/test-helpers</code> based test helpers instead of the jQuery based global helpers.</p>
<p>The section on component tests should not use <code>this.$()</code> anymore as well, and instead also according to <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a> 
use <code>this.element</code> to refer to the component's root element, and use the new DOM interaction helpers instead of jQuery 
events triggered through <code>this.$()</code>. </p>
<h3 id="deprecation-guide"><a class="header" href="#deprecation-guide">Deprecation guide</a></h3>
<p>The deprecation warnings introduced for using <code>jQuery.Event</code> specific APIs should explain the use of the 
<code>normalizeEvent</code> helper function to migrate towards native DOM APIs on the one side, and on the other side the effect of 
setting the jQuery integration flag to explicitly opt into jQuery usage thus suppressing the warnings.</p>
<h3 id="addon-migration"><a class="header" href="#addon-migration">Addon migration</a></h3>
<p>One of the biggest problems to easily opt-out of jQuery is that many addons still depend on it. Many of these usages 
seem to be rather &quot;accidental&quot;, in that the full power of jQuery is not really needed for the given task, and could 
be fairly easily refactored to use only native DOM APIs.</p>
<p>For this reason this RFC encourages addon authors to not use jQuery anymore and to refactor existing usages whenever 
possible! This certainly does not apply categorically to all addons, e.g. those that wrap jQuery plugins as 
components and as such cannot drop this dependency.</p>
<h4 id="ember-try"><a class="header" href="#ember-try">ember-try</a></h4>
<p><code>ember-try</code>, which is used to test addons in different scenarios with different dependencies, should provide some means
to define scenarios without jQuery, based on the jQuery integration flag introduced in this RFC.</p>
<p>Furthermore the Ember CLI blueprint for addons should be extended to include no-jQuery scenarios by default, to make
sure addons don't cause errors when jQuery is not present.</p>
<h4 id="emberobservercom"><a class="header" href="#emberobservercom">emberobserver.com</a></h4>
<p>It would be very helpful to have a clear indication on <a href="https://emberobserver.com/">emberobserver.com</a> which 
addons depend on jQuery and which not. This would benefit users as to know which addons they can use without 
jQuery, but also serve as an incentive for authors to make their addons work without it.</p>
<p>Given the jQuery integration flag introduced in this RFC, this paves the way to automatically detect addons that are 
basically declaring their independence from jQuery by having this flag set to <code>false</code>  (in their own repository).</p>
<h2 id="drawbacks-66"><a class="header" href="#drawbacks-66">Drawbacks</a></h2>
<h3 id="churn-2"><a class="header" href="#churn-2">Churn</a></h3>
<p>A vast amount of addons still depend on jQuery. While as far as this RFC is concerned no jQuery based APIs will be
deprecated and the default will still be to include jQuery, addons are nevertheless encouraged to remove their 
dependency on jQuery, which will add some considerable churn to the addon ecosystem. As of writing this, there are:</p>
<ul>
<li><a href="https://emberobserver.com/code-search?codeQuery=Ember.%24">475 addons</a> using <code>Ember.$</code></li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=addon%2Fcomponents">479 addons</a> using <code>this.$</code> in
components</li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=tests">994 addons</a> using <code>this.$</code> in tests</li>
</ul>
<p>Among these are still some very essential addons like <code>ember-data</code>, which still relies on <code>$.ajax</code>, see 
<a href="https://github.com/emberjs/data/issues/5320">#5320</a>.</p>
<p>A good amount of that churn can be mitigated by having a codemod that migrates tests (see &quot;Testing&quot; above).</p>
<h2 id="alternatives-67"><a class="header" href="#alternatives-67">Alternatives</a></h2>
<p>Continue to depend on jQuery.</p>
<h2 id="unresolved-questions-48"><a class="header" href="#unresolved-questions-48">Unresolved questions</a></h2>
<p>None so far.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-01-17 
RFC PR: https://github.com/emberjs/rfcs/pull/297
Ember Issue: https://github.com/emberjs/ember.js/issues/16231</p>
<hr />
<h1 id="deprecation-of-emberlogger"><a class="header" href="#deprecation-of-emberlogger">Deprecation of Ember.Logger</a></h1>
<h2 id="summary-69"><a class="header" href="#summary-69">Summary</a></h2>
<p>This RFC recommends the deprecation and eventual removal of <code>Ember.Logger</code>.</p>
<h2 id="motivation-70"><a class="header" href="#motivation-70">Motivation</a></h2>
<p>There are a variety of features of Ember designed to support old browsers,
features that are no longer needed. <code>Ember.Logger</code> came into being because
the browser support for the console was inconsistent. In some browsers,
like Internet Explorer 9, the console only existed when the developer tools
panel was open, which caused null references and program crashes when run
with the console closed. <code>Ember.Logger</code> provided methods that would route to 
the console when it was available.</p>
<p>With Ember 3.x, Ember no longer supports these older browsers, and hence this
feature no longer serves a purpose. Removing it will make Ember smaller and 
lighter.</p>
<h2 id="detailed-design-63"><a class="header" href="#detailed-design-63">Detailed design</a></h2>
<p>For the most part, this is a 1:1 substitution of the global <code>console</code> object 
for <code>Ember.Logger</code>.</p>
<p>Node only added support for <code>console.debug</code> in Node version 9. Where we wish
to support earlier versions of Node, we will need to use <code>console.log</code>, rather than
<code>console.debug</code>, as the replacement for <code>Logger.debug</code>. Apps and addons
which don't care about Node or are specifying Node version 9 as their minimum can
use <code>console.debug</code>.</p>
<p>Internet Explorer 11 and Edge both require console methods to be bound to the
console object when the developer tools are not showing. This diverges from the
expectations of other browsers. Direct calls to console methods will work correctly,
but constructs which involve explicitly or implicitly binding the console methods to
other objects or using them unbound will fail. This is straightforward to work around.</p>
<p>You can address the issue by binding the method to the console object:</p>
<pre><code class="language-javascript">// Before - assigning raw method to a variable for later use
var print = Logger.log; // assigning method to variable
print('Message');

// After - assigning console-bound method to variable for later use
var print = console.log.bind(console);
print('Message');
</code></pre>
<p>In some cases, you can use rest parameter syntax to avoid the issue entirely:</p>
<pre><code class="language-javascript">// Before
Logger.info.apply(undefined, arguments); // or
Logger.info.apply(null, arguments); // or
Logger.info.apply(this, arguments); // or

// After
console.info(...arguments);
</code></pre>
<h3 id="within-the-framework"><a class="header" href="#within-the-framework">Within the framework</a></h3>
<p>Remove the following direct uses of <code>Ember.Logger</code> from the ember.js and 
ember-data projects: </p>
<ul>
<li><code>ember-debug</code>:
<ul>
<li>deprecate (<code>ember-debug\lib\deprecate.js</code>) - <code>Logger.warn</code></li>
<li>debug (<code>ember-debug\lib\index.js</code>) - <code>Logger.info</code></li>
<li>warn (<code>ember-debug\lib\warn.js</code>) - <code>Logger.warn</code></li>
</ul>
</li>
<li><code>ember-routing</code> (<code>ember-routing\lib\system\router.js</code>):
<ul>
<li>transitioned to - <code>Logger.log</code></li>
<li>preparing to transition to - <code>Logger.log</code></li>
<li>intermediate-transitioned to - <code>Logger.log</code></li>
</ul>
</li>
<li><code>ember-testing</code>:
<ul>
<li>Testing paused (<code>ember-testing\lib\helpers\pause_test.js</code>) - <code>Logger.info</code></li>
<li>Catch-all handler (<code>ember-testing\lib\test\adapter.js</code>) - <code>Logger.error</code></li>
</ul>
</li>
<li><code>ember-data</code>:
<ul>
<li><code>tests\test-helper.js</code>- <code>Logger.log</code></li>
</ul>
</li>
</ul>
<p>Adjust all test code that redirects logging and sets it back:</p>
<ul>
<li><code>ember\tests\routing\basic_test.js</code> (adjust)</li>
<li><code>ember-application\tests\system\dependency_injection\default_resolver_test.js</code> (adjust)</li>
<li><code>ember-application\tests\system\logging_test.js</code> (remove?)</li>
<li><code>ember-glimmer\tests\integration\helpers\log-test.js</code> (remove?)</li>
</ul>
<p>Note: None of the uses of <code>Ember.Logger</code> in <code>ember.js</code> or <code>ember-data</code> involve
<code>Ember.debug</code>, so that issue doesn't affect the Ember.js code directly.</p>
<p>Add deprecation warnings to the implementation: <code>ember-console\lib\index.js</code>.
Bear in mind that <code>Ember.deprecate</code> in <code>ember-debug</code> currently calls 
<code>Logger.warn</code>, so the <code>ember-debug</code> code should be changed <em>first</em> or adding 
the deprecation warning will create a deep recursion.</p>
<p>The <code>Ember.assert</code>, <code>Ember.warn</code>, <code>Ember.info</code>, <code>Ember.debug</code>, and 
<code>Ember.deprecate</code> methods suppress their output on production builds. 
However, they are suppressing them in the <code>ember-debug</code> module, which 
currently consumes <code>Ember.Logger</code>, <em>not</em> by <code>Ember.Logger</code> itself. Hence, 
replacing calls to <code>Ember.Logger</code> with direct calls to the console will not 
affect this behavior. </p>
<h3 id="add-on-developers"><a class="header" href="#add-on-developers">Add-On Developers</a></h3>
<p>The following high-impact add-ons (9 or 10 or a * on EmberObserver) use 
<code>Ember.Logger</code> and should probably be given an early heads-up to adjust 
their code to use <code>console</code> before this RFC is implemented. This will limit 
the level of pain that their users experience when the deprecation is released.</p>
<p>Add-ons that need to also support Ember 2.x will need to make their console
references conditional on console being &quot;truthy&quot;, of course, to support Internet
Explorer 9.</p>
<p>In the order of their number of references to <code>Ember.Logger</code>:</p>
<ul>
<li><code>ember-concurrency</code> (15)</li>
<li><code>ember-cli-deprecation-workflow</code> (9)</li>
<li><code>ember-stripe-service</code> (9)</li>
<li><code>semantic-ui-ember</code> (7)</li>
<li><code>ember-resolver</code> (6)</li>
<li><code>ember-cli-page-object</code> (4) </li>
<li><code>ember-cli-sentry</code> (3)</li>
<li><code>ember-islands</code> (3)</li>
<li><code>ember-states</code> (3)</li>
<li><code>ember-cli-pagination</code> (2)</li>
<li><code>ember-cli-clipboard</code> (1)</li>
<li><code>ember-cli-fastboot</code> (1)</li>
<li><code>ember-elsewhere</code> (1)</li>
<li><code>ember-i18n</code> (1)</li>
<li><code>ember-simple-auth-token</code> (1)</li>
<li><code>ember-svg-jar</code> (1)</li>
<li><code>liquid-fire</code> (1)</li>
</ul>
<p>For details, see https://emberobserver.com/code-search?codeQuery=Ember.Logger.</p>
<h2 id="how-we-teach-this-43"><a class="header" href="#how-we-teach-this-43">How we teach this</a></h2>
<h3 id="communication-of-change"><a class="header" href="#communication-of-change">Communication of change</a></h3>
<p>We need to inform users that <code>Ember.Logger</code> will be deprecated and in what 
release it will occur. </p>
<h3 id="official-code-bases-and-documentation-1"><a class="header" href="#official-code-bases-and-documentation-1">Official code bases and documentation</a></h3>
<p>We do not currently actively teach the use of <code>Ember.Logger</code>. We will need to 
remove any passing references to <code>Ember.Logger</code> from the Ember guides 
from the Super Rentals tutorial, and anywhere else it appears on the website.</p>
<p>Once it is gone from the code, we also need to verify it no longer appears in 
the API listings. </p>
<p>We must provide an entry in the deprecation guide for this change:</p>
<ul>
<li>describing relevant divergences remaining in the handling of the console in
Internet Explorer 11 and Edge browsers.</li>
<li>describing the issue with using console.debug on node versions
earlier than Node 9.</li>
<li>describing alternative ways of dealing with eslint's <code>no-console</code> messages.</li>
</ul>
<h2 id="drawbacks-67"><a class="header" href="#drawbacks-67">Drawbacks</a></h2>
<p>191 add-ons in Ember Inspector are using <code>Ember.Logger</code>. It has been there and 
documented for a long time. So this deprecation will cause some level of change 
on many projects. </p>
<p>This, of course, can be said for almost any deprecation, and Ember's 
disciplined approach to deprecation has been repeatedly shown to ease things. 
These particular changes are proving easy to locate and replace by hand. Also,
only twenty of those add-ons have more than six references to <code>Ember.Logger</code>.
If this is characteristic of the user base, the level of effort to make 
the change, even by hand, should be very small for most users.</p>
<p>Those using <code>Logger.debug</code> as something different from <code>Logger.log</code> may have 
at least a theoretical concern. Under the covers <code>Logger.debug</code> only calls 
<code>console.debug</code> if it exists, calling <code>console.log</code> otherwise. The only 
platform where the difference between the two is visible in the console is on 
Safari. We can encourage folks with a tangible, practical concern about this to
speak up during the comment period, but I don't anticipate this will have much 
impact.</p>
<h2 id="alternatives-68"><a class="header" href="#alternatives-68">Alternatives</a></h2>
<ol>
<li>
<p>Leave things as they are, perhaps providing an <code>@ember/console</code> module 
interface.</p>
</li>
<li>
<p>Extract <code>Ember.Logger</code> into its own (tiny) <code>@ember/console</code> package as 
a shim for users.</p>
</li>
</ol>
<h2 id="unresolved-questions-49"><a class="header" href="#unresolved-questions-49">Unresolved questions</a></h2>
<p>None at this point. The answers from prior drafts have been promoted into the text. </p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-02-04
Relevant Team(s): Steering
RFC PR: https://github.com/emberjs/rfcs/pull/300
Tracking: https://github.com/emberjs/rfc-tracking/issues/1</p>
<hr />
<h1 id="rfc-request-for-comments-process-update"><a class="header" href="#rfc-request-for-comments-process-update">RFC (Request for Comments) Process Update</a></h1>
<h2 id="summary-70"><a class="header" href="#summary-70">Summary</a></h2>
<p>Refine the Ember RFC process and have it apply to all Ember teams. </p>
<h2 id="motivation-71"><a class="header" href="#motivation-71">Motivation</a></h2>
<p>The Ember community has been using the RFC process to great effect over the last few years.
Proposals by both Core and community members are discussed and refined
with the result coming out much stronger.</p>
<p>During this time, the community and the core teams have identified shortcomings 
of the RFC process as well as new requirements, which this RFC intends to address:</p>
<h3 id="confusion-between-emberjsrfcs-and-ember-clirfcs"><a class="header" href="#confusion-between-emberjsrfcs-and-ember-clirfcs">Confusion between emberjs/rfcs and ember-cli/rfcs</a></h3>
<p>The Ember project currently has two separate RFC processes for Ember.js and Ember CLI.</p>
<p>This leads to confusion because the community needs to keep track of two different repositories.
For contributors there is the overhead of having to decide where to file their RFC if the proposal involves both projects,
as well as being aware of the differences in the processes.</p>
<h3 id="the-process-does-not-cover-the-entire-project"><a class="header" href="#the-process-does-not-cover-the-entire-project">The process does not cover the entire project</a></h3>
<p>RFCs to emberjs/rfcs and ember-cli/rfcs have traditionally concerned themselves with features or deprecations to Ember.js and Ember CLI respectfully, with some Ember Data proposals in emberjs/rfcs.</p>
<p>We have already begun to use emberjs/rfcs for other initiatives, such as the project-wide Ember.js 2018 Roadmap but have not codified or updated the process to make it clear that it should be used for efforts such as a website redesign,
information architecture suggestions, SEO suggestions, and the like.</p>
<h3 id="lingering-rfcs"><a class="header" href="#lingering-rfcs">Lingering RFCs</a></h3>
<p>Both the emberjs/rfcs and the ember-cli/rfcs repositories have many open issues and pull-requests.
A percentage of these have not been active in the recent past.</p>
<p>We have kept PRs and issues open so people could more easily find the discussions,
but this has instead given a negative impression of staleness, as RFCs linger open without new feedback.</p>
<h3 id="the-process-for-an-rfc-after-it-has-been-accepted"><a class="header" href="#the-process-for-an-rfc-after-it-has-been-accepted">The process for an RFC after it has been accepted</a></h3>
<p>At the moment the process does not specify what happens when an RFC is accepted and merged. This has led to many questions about the status of merged RFCs.</p>
<h2 id="detailed-design-64"><a class="header" href="#detailed-design-64">Detailed design</a></h2>
<h3 id="one-rfc-process-for-all-of-ember"><a class="header" href="#one-rfc-process-for-all-of-ember">One RFC Process for all of Ember</a></h3>
<p>Ember is <a href="https://emberjs.com/team/">organized into teams</a>, with each team being responsible for certain projects. 
The RFC process will be a useful tool for all of those projects. 
The header of the RFC template will be updated to include a spot to specify the relevant team(s). The header will have &quot;Ember Issue:&quot; removed.</p>
<p>A list of the teams and respective projects will be added to the instructions, 
possibly with the addition of per-team instructions on specifics of the project.
Additional templates might be created as well, such a design work template.</p>
<p>Each team will be responsible for reviewing new RFCs and, if an RFC requires work from their team, ensuring that the RFC reflects that. 
As it is with the wider community, the RFC process is the time for teams and team members to push back on, encourage, refine, or otherwise comment on proposals.</p>
<h3 id="require-a-core-champion"><a class="header" href="#require-a-core-champion">Require a Core Champion</a></h3>
<p>To make sure that RFCs receive adequate support from the team, Ember CLI has implemented the idea of a champion associated with each RFC.
One goal is that in seeking a champion from the team,
the RFC author starts a dialogue with the team and gets some early feedback.
That champion is then responsible for representing the RFC in team meetings, and for shepherding its progress. We will import a version of this process to emberjs/rfcs:</p>
<p>Each RFC will require a champion from the primary core team to which the RFC has been marked relevant. 
The champion must be found by the opener of the RFC or other community member. They are not assigned by the core teams.
The champion will assign themselves on the RFC on Github. 
The champion will be responsible for:</p>
<ul>
<li>achieving consensus from the team(s) to move the RFC through the stages of the RFC process.</li>
<li>ensuring the RFC follows the RFC process. </li>
<li>shepherding the planning and implementation of the RFC.
Before the RFC is accepted, the champion may remove themselves.
The champion may find a replacement champion at any time. </li>
</ul>
<p>A section on 'Finding a champion' will be added to the instructions on proposing an RFC. </p>
<h3 id="introduce-the-concept-of-fcp-to-close"><a class="header" href="#introduce-the-concept-of-fcp-to-close">Introduce the concept of &quot;FCP to close&quot;</a></h3>
<p>To address the problem of RFC triage and inactivity, this RFC introduces the concept of FCP to close.</p>
<p>Closing an RFC should be viewed as another triage tool, not as a rejection of the RFC.
Sometimes a rewrite of an RFC would be so fundamental that it would benefit of a fresh discussion in a new thread.
Sometimes the original author is no longer active (Champions should help here as well),
and someone else might want to take over the work in a new RFC.
Sometimes the timing might not be right, or the feature might have been addressed some other way, and yes,
sometimes it might be something that is not aligned with the team's values for the project.</p>
<p>A good example of this is the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md#motivation">Named Blocks RFC</a>,
which lists in the motivation section previous attempts at similar ideas.</p>
<p>Like the FCP to merge process, once an RFC is marked as FCP to close there will be a period of one week where people can raise new concerns.
After that period of one week, the respective team will review and close the RFC or extend the period for another week.</p>
<h3 id="merge-ember-clirfcs-into-emberjsrfcs"><a class="header" href="#merge-ember-clirfcs-into-emberjsrfcs">Merge ember-cli/rfcs into emberjs/rfcs</a></h3>
<p>We will have a single repository for all Ember Project RFCs.</p>
<p>To achieve merging ember-cli/rfcs into emberjs/rfcs the following will be done:</p>
<ul>
<li>Add to the RFC header to indicate it applies to ember-cli</li>
<li>Copy both active and completed RFC files into <code>text</code> of emberjs/rfcs</li>
<li>Transfer active PRs and Issues to emberjs/rfcs</li>
<li>Archive ember-cli/rfcs</li>
</ul>
<p>There are some concerns about links breaking when we move the files to emberjs/rfcs,
but given the fact that ember-cli/rfcs had the concept of active/completed by moving the files into different folders,
links were already being broken.</p>
<p>The ember-cli/rfcs do not need name or numbering changes, as there is currently no duplicated name.
Going forward, the numbering should be unified by virtue of having a single repository.</p>
<h3 id="track-rfcs-after-they-are-accepted"><a class="header" href="#track-rfcs-after-they-are-accepted">Track RFCs after they are accepted</a></h3>
<p>At the moment it is not clear what happens to an RFC after it has been merged. </p>
<p>This RFC proposes that after an RFC is merged, the relevant teams, guided by the champion, 
will plan implementation by creating tracking issues in the relevant projects.</p>
<p>This RFC proposes having a single place to track the implementation of each RFC. 
Each RFC will have a header <code>Tracking:</code> that will be filled out with a link. At that link all issues related to that RFC, across all projects and organizations, will be enumerated.</p>
<h2 id="how-we-teach-this-44"><a class="header" href="#how-we-teach-this-44">How We Teach This</a></h2>
<p>To ensure that contributors are updated on the RFC process and the process is clear,
the documentation should be improved in a couple of ways.</p>
<p>The README will be updated to reflect process changes described in this RFC. 
We will add checklists to the instructions for each stage of the RFC process to make it very clear what needs to happen.</p>
<h2 id="drawbacks-68"><a class="header" href="#drawbacks-68">Drawbacks</a></h2>
<h3 id="adjustment-period"><a class="header" href="#adjustment-period">Adjustment period</a></h3>
<p>There are active RFCs in ember-cli/rfcs. Moving these discussions would be onerous, so they should be kept there until completion, and no new RFCs accepted.</p>
<h3 id="permalinks-to-ember-clirfcs-proposals"><a class="header" href="#permalinks-to-ember-clirfcs-proposals">Permalinks to ember-cli/rfcs proposals</a></h3>
<p>Moving the RFC files from ember-cli/rfcs (active or completed) to emberjs/rfcs can be seen as a breaking change, and could lead to someone linking to ember-cli/rfcs and then the RFC being updated in emberjs/rfcs. However, ember-cli/rfcs already suffers from a linking problem due to the active/completed folders, as RFCs need to be moved from one to the other even after being accepted.
This could be mitigated by introducing a warning in the RFC text directing people to the new source.</p>
<h2 id="alternatives-69"><a class="header" href="#alternatives-69">Alternatives</a></h2>
<p>None at the moment.</p>
<h2 id="unresolved-questions-50"><a class="header" href="#unresolved-questions-50">Unresolved questions</a></h2>
<p>None at the moment.</p>
<hr />
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li><strong>RFC</strong>: Request For Comments. The process by which a proposal is discussed by the community and then approved by an Ember team.</li>
<li><strong>FCP</strong>: Final Comment Period. Period of one week at the end of which an RFC is to be accepted or rejected by an Ember team. Extended in periods of one week if new concerns are raised.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-02-15
RFC PR: https://github.com/emberjs/rfcs/pull/308</p>
<hr />
<h1 id="summary-71"><a class="header" href="#summary-71">Summary</a></h1>
<p>Beginning the transition to deprecate the fallback behavior of resolving <code>{{foo}}</code> by requiring the usage of <code>{{this.foo}}</code> as syntax to refer to properties of the templates' backing component. This would be the default behavior in Glimmer Components.</p>
<p>For example, given the following component class:</p>
<pre><code class="language-js">import Component from '@ember/component';
export default Component.extends({
  init() {
    super(...arguments);
    this.set('greeting', 'Hello');
  }
});
</code></pre>
<p>One would refer to the <code>greeting</code> property as such:</p>
<pre><code class="language-hbs">&lt;h1&gt;{{this.greeting}}, Chad&lt;/h1&gt;
</code></pre>
<p>Ember will render &quot;Hello, Chad&quot;.</p>
<p>To make this deprecation tractable, we will provide a codemod for migrating templates.</p>
<h1 id="motivation-72"><a class="header" href="#motivation-72">Motivation</a></h1>
<p>Currently, the way to access properties on a components class is <code>{{greeting}}</code> from a template. This works because the component class is one of the objects we resolve against during the evaluation of the expression.</p>
<p>The first problem with this approach is that the <code>{{greeting}}</code> syntax is ambiguous, as it could be referring to a local variable (block param), a helper with no arguments, a closed over component, or a property on the component class.</p>
<h2 id="exemplar"><a class="header" href="#exemplar">Exemplar</a></h2>
<p>Consider the following example where the ambiguity can cause issues:</p>
<p>You have a component class that looks like the following component and template:</p>
<pre><code class="language-js">import Component from '@ember/component';
import computed from '@ember/computed';

export default Component.extend({
  formatName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
});
</code></pre>
<pre><code class="language-hbs">&lt;h1&gt;Hello {{formatName}}!&lt;/h1&gt;
</code></pre>
<p>Given <code>{ firstName: 'Chad', lastName: 'Hietala' }</code>, Ember will render the following:</p>
<pre><code class="language-html">&lt;h1&gt;Hello Chad Hietala!&lt;/h1&gt;
</code></pre>
<p>Now some time goes on and someone adds a <code>formatName</code> helper at <code>app/helpers/fortmatName.js</code> that looks like the following:</p>
<pre><code class="language-js">export default function formatName([firstName, lastName]) {
  return `${firstName} ${lastName}`;
}
</code></pre>
<p>Due to the fact that helpers take precedence over property lookups, our <code>{{formatName}}</code> now resolves to a helper. When the helper runs it doesn't have any arguments so our template now renders the following:</p>
<pre><code class="language-html">&lt;h1&gt;Hello !&lt;/h1&gt;
</code></pre>
<p>This can be a refactoring hazard and can often lead to confusion for readers of the template. Upon encountering <code>{{greeting}}</code> in a component's template, the reader has to check all of these places: first, you need to scan the surrounding lines for block params with that name; next, you check in the helpers folder to see if there is a helper with that name (it could also be coming from an addon!); finally, you check the component's JavaScript class to look for a (computed) property.</p>
<p>Like <a href="https://github.com/emberjs/rfcs/blob/68812bf2d439c6bb77ad491e0159b371b68c5c35/text/0276-named-args.md">RFC#0276</a> made argument usage explicit through the <code>@</code> prefix, the <code>this</code> prefix will resolve the ambiguity and greatly improve clarity, especially in big projects with a lot of files (and uses a lot of addons).</p>
<p>As an aside, the ambiguity that causes confusion for human readers is also a problem for the compiler. While it is not the main goal of this proposal, resolving this ambiguity also helps the rendering system. Currently, the &quot;runtime&quot; template compiler has to perform a helper lookup for every <code>{{greeting}}</code> in each template. It will be able to skip this resolution process and perform other optimizations (such as reusing the internal <a href="https://github.com/glimmerjs/glimmer-vm/blob/master/guides/04-references.md">reference</a>
object and caches) with this addition.</p>
<p>Furthermore, by enforcing the <code>this</code> prefix, tooling like the <a href="https://github.com/emberwatch/ember-language-server">Ember Language Server</a> does not need to know about fallback resolution rules. This makes common features like <a href="https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition">&quot;Go To Definition&quot;</a> much easier to implement since we have semantics that mean &quot;property on class&quot;.</p>
<h1 id="transition-path-7"><a class="header" href="#transition-path-7">Transition Path</a></h1>
<p>We intend this to be a <em>very slow</em> process as we understand it is a large change. Because of this we will be doing a phased rollout to help guide people in transtion. Below is an outline of how we plan to roll this change out.</p>
<p><strong>Phase 1:</strong></p>
<ul>
<li>Add <a href="https://github.com/ember-template-lint/ember-template-lint/pull/392">template lint rule</a> to <a href="https://github.com/ember-template-lint/ember-template-lint">ember-template-lint</a> as an <strong>opt-in</strong> rule</li>
<li>Document the <a href="https://github.com/dyfactor/dyfactor">codemod infrastructure</a> and <a href="https://github.com/dyfactor/dyfactor-plugin-disambiguate-locals">codemod</a>. Make it available for early adopters</li>
<li>Start updating docs to use <code>this.</code></li>
</ul>
<p><strong>Phase 2:</strong></p>
<ul>
<li>Add the lint rule by default <em>in the apps</em> <code>.template-lintrc.js</code></li>
<li>Complete doc migration to use <code>this.</code></li>
</ul>
<p><strong>Phase 3:</strong></p>
<ul>
<li>Enable the lint rule by default in the <code>recommended</code> config</li>
</ul>
<p><strong>Phase 4:</strong></p>
<ul>
<li>Introduce deprecation <strong>app only</strong> fallbacks</li>
</ul>
<p><strong>Phase 5:</strong></p>
<ul>
<li>Introduce deprecation for <strong>any</strong> fallbacks</li>
</ul>
<p><strong>Phase 6:</strong></p>
<ul>
<li>Rev major to 4.0.0</li>
<li>Add assert for fallback behavior</li>
</ul>
<p><strong>Phase 7:</strong></p>
<ul>
<li>Remove fallback functionality in 4.5, post 4.4.0 LTS</li>
</ul>
<h1 id="how-we-teach-this-45"><a class="header" href="#how-we-teach-this-45">How We Teach This</a></h1>
<p><code>{{this.foo}}</code> is the way to access the properties on the component class. This also aligns with property access in JavaScript.</p>
<p>Since the <code>{{this.foo}}</code> syntax has worked in Ember.Component (which is the only kind of component available today) since the 1.0 series, we are not really in a rush to migrate the community (and the guides, etc) to using the new syntax. In the meantime, this could be viewed as a tool to improve clarity in templates.</p>
<p>While we think writing <code>{{this.foo}}</code> would be a best practice for new code going forward, the community can migrate at its own pace one component at a time. However, once the fallback functionality is eventually removed this will result in a &quot;Helper not found&quot; error.</p>
<h2 id="syntax-breakdown"><a class="header" href="#syntax-breakdown">Syntax Breakdown</a></h2>
<p>The follow is a breakdown of the different forms and what they mean:</p>
<ul>
<li><code>{{@foo}}</code> is an argument passed to the component</li>
<li><code>{{this.foo}}</code> is a property on the component class</li>
<li><code>{{#with this.foo as |foo|}} {{foo}} {{/with}}</code> the <code>{{foo}}</code> is a local</li>
<li><code>{{foo}}</code> is a helper</li>
</ul>
<h1 id="drawbacks-69"><a class="header" href="#drawbacks-69">Drawbacks</a></h1>
<p>The largest downside of this proposal is that it makes templates more verbose, causing developers to type a bit more. This will also create a decent amount of deprecation noise, although we feel like tools like <a href="https://github.com/mixonic/ember-cli-deprecation-workflow">ember-cli-deprecation-workflow</a> can help mitigate this.</p>
<h1 id="alternatives-70"><a class="header" href="#alternatives-70">Alternatives</a></h1>
<p>This pattern of having programming model constructs to distinguish between the backing class and arguments passed to the component is not unique to Ember.</p>
<h2 id="what-other-frameworks-do"><a class="header" href="#what-other-frameworks-do">What Other Frameworks Do</a></h2>
<p>React has used <code>this.props</code> to talk about values passed to you and <code>this.state</code> to mean data owned by the backing component class since it was released. However, this approach of creating a specific object on the component class to mean &quot;properties available to the template&quot;, would likely be even more an invasive change and goes against the mental model that the context for the template is the class.</p>
<p>Vue requires enumeration of <code>props</code> passed to a component, but the values in the template suffer from the ambiguity that we are trying to solve.</p>
<p>Angular relies heavily on the dependency injection e.g. <code>@Input</code> to enumerate the bindings that were passed to the component and relies heavily on TypeScript to hide or expose values to templating layer with <code>public</code> and <code>private</code> fields. Like Vue, Angular does not disambiguate.</p>
<h2 id="introduce-yet-another-sigil"><a class="header" href="#introduce-yet-another-sigil">Introduce Yet Another Sigil</a></h2>
<p>We could introduce another sigil to remove ambiguity. This would address the concern about verbosity, however it is now another thing we would have to teach.</p>
<h2 id="change-resolution-order"><a class="header" href="#change-resolution-order">Change Resolution Order</a></h2>
<p>The other option is to reverse the resolution order to prefer properties over helpers. However this has the reverse problem as described in the exemplar.</p>
<h2 id="do-nothing"><a class="header" href="#do-nothing">Do Nothing</a></h2>
<p>I personally don't think this is an option, since the goal is to provide clarity for applications as they evolve over time and to provide a more concise mental model.</p>
<h1 id="unresolved-questions-51"><a class="header" href="#unresolved-questions-51">Unresolved questions</a></h1>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-03-09
RFC PR: https://github.com/emberjs/rfcs/pull/311</p>
<hr />
<h1 id="angle-bracket-invocation"><a class="header" href="#angle-bracket-invocation">Angle Bracket Invocation</a></h1>
<h2 id="summary-72"><a class="header" href="#summary-72">Summary</a></h2>
<p>This RFC introduces an alternative syntax to invoke components in templates.</p>
<p>Examples using the classic invocation syntax:</p>
<pre><code class="language-hbs">{{site-header user=this.user class=(if this.user.isAdmin &quot;admin&quot;)}}

{{#super-select selected=this.user.country as |s|}}
  {{#each this.availableCountries as |country|}}
    {{#s.option value=country}}{{country.name}}{{/s.option}}
  {{/each}}
{{/super-select}}
</code></pre>
<p>Examples using the angle bracket invocation syntax:</p>
<pre><code class="language-hbs">&lt;SiteHeader @user={{this.user}} class={{if this.user.isAdmin &quot;admin&quot;}} /&gt;

&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<h2 id="motivation-73"><a class="header" href="#motivation-73">Motivation</a></h2>
<p>The original <a href="https://github.com/emberjs/rfcs/pull/60">angle bracket components</a>
RFC focused on capitalizing on the opportunity of switching to the new syntax
as an opt-in to the &quot;new-world&quot; components programming model.</p>
<p>Since then, we have switched to a more iterative approach, favoring smaller
RFCs focusing on one area of improvement at a time. Collectively, these RFCs
have largely accomplished the goals in the original RFC without the angle
bracket opt-in.</p>
<p>Still, separate from other programming model improvements, there is still a
strong desire from the Ember community for the previously proposed angle
bracket invocation syntax.</p>
<p>The main advantage of the angle bracket syntax is clarity. Because component
invocation are often encapsulating important pieces of UI, a dedicated syntax
would help visually distinguish them from other handlebars constructs, such as
control flow and dynamic values. This can be seen in the example shown above –
the angle bracket syntax made it very easy to see the component invocations as
well as the <code>{{#each}}</code> loop, especially with syntax highlight:</p>
<pre><code class="language-hbs">&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<p>This RFC proposes that we adopt the angle bracket invocation syntax to Ember as
an alternative to the classic (&quot;curlies&quot;) invocation syntax.</p>
<p>Unlike the original RFC, the angle bracket invocation syntax proposed here is
purely syntactical and does not affect the semantics. The invocation style is
largely transparent to the invokee and can be used to invoke both classic
components as well as <a href="https://github.com/emberjs/rfcs/pull/213">custom components</a>.</p>
<p>Since the original angle bracket RFC, we have worked on a few experimental
implementation of the feature, both and in Ember and Glimmer. These experiments
allowed us to attempt using the feature in real apps, and we have learned some
valuable insights throughout these usage.</p>
<p>The original RFC proposed using the <code>&lt;foo-bar ...&gt;</code> syntax, which is the same
syntax used by web components (custom elements). While Ember components and web
components share a few similarities, in practice, we find that there are enough
differences that causes the overload to be quite confusing for developers.</p>
<p>In addition, the code needed to render Ember components is quite different
from what is needed to render web components. If they share the same syntax,
the Glimmer template compiler will not be able to differentiate between the two
at build time, thus requiring a lot of extra runtime code to support the
&quot;fallback&quot; scenario.</p>
<p>In conclusion, the ideal syntax should be similar to HTML syntax so it doesn't
feel out of place, but different enough that developers and the compiler can
easier tell that they are not just regular HTML elements at a glance.</p>
<h2 id="detailed-design-65"><a class="header" href="#detailed-design-65">Detailed design</a></h2>
<h3 id="tag-name"><a class="header" href="#tag-name">Tag Name</a></h3>
<p>The first part of the angle bracket invocation syntax is the tag name. While
web components use the &quot;dash rule&quot; to distinguish from regular HTML elements,
we propose to use capital letters to distinguish Ember components from regular
HTML elements and web components.</p>
<p>The invocation <code>&lt;FooBar /&gt;</code> is equivalent to <code>{{foo-bar}}</code>. The tag name will
be normalized using the <code>dasherize</code> function, which is the same rules used by
existing use cases, such as service injections. This allows existing components
to be invoked by the new syntax.</p>
<p>Another benefit of the capital letter rule is that we can now support component
names with a single word, such as <code>&lt;Button&gt;</code>, <code>&lt;Modal&gt;</code> and <code>&lt;Tab&gt;</code>.</p>
<blockquote>
<p>Note: Some day, we may want to explore a file system migration to remove the
need for the normalization rule (i.e. also use capital case in filenames).
However, that is out-of-scope for this RFC, as it would require taking into
consideration existing code (like services), transition paths and codemods.</p>
</blockquote>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p>The next part of the invocation is passing arguments to the invoked component.
We propose to use the <code>@</code> syntax for this purpose. For example, the invocation
<code>&lt;FooBar @foo=... @bar=... /&gt;</code> is equivalent to <code>{{foo-bar foo=... bar=...}}</code>.
This matches the <a href="https://github.com/emberjs/rfcs/pull/276">named arguments syntax</a>
in the component template.</p>
<p>If the argument value is a constant string, it can appear verbatim after the
equal sign, i.e. <code>&lt;FooBar @foo=&quot;some constant string&quot; /&gt;</code>. Other values should
be enclosed in curlies, i.e. <code>&lt;FooBar @foo={{123}} @bar={{this.bar}} /&gt;</code>.
Helpers can also be used, as in <code>&lt;FooBar @foo={{capitalize this.bar}} /&gt;</code>.</p>
<h4 id="reserved-names-1"><a class="header" href="#reserved-names-1">Reserved Names</a></h4>
<p><code>@args</code>, <code>@arguments</code> and anything that does not start with a lowercase letter
(such as <code>@Foo</code>, <code>@0</code>, <code>@!</code> etc) are reserved names and cannot be used. These
restrictions may be relaxed in the future.</p>
<h4 id="positional-arguments"><a class="header" href="#positional-arguments">Positional Arguments</a></h4>
<p>Positional arguments (<code>{{foo-bar &quot;first&quot; &quot;second&quot;}}</code>) are not supported.</p>
<h3 id="html-attributes"><a class="header" href="#html-attributes">HTML Attributes</a></h3>
<p>HTML attributes can be passed to the component using the regular HTML syntax.
For example, <code>&lt;FooBar class=&quot;btn btn-large&quot; role=&quot;button&quot; /&gt;</code>. HTML attributes
can be interleaved with named arguments (it does not make any difference). This
is a new feature that is not available in the classic invocation style.</p>
<p>These attributes can be accessed from the component template with the new
<code>...attributes</code> syntax, which is available only in element positions, e.g.
<code>&lt;div ...attributes /&gt;</code>. Using <code>...attributes</code> in any other positions, e.g.
<code>&lt;div&gt;{{...attributes}}&lt;/div&gt;</code>, would be a syntax error. It can also be used on
multiple elements in the same template. If attributes are passed but the
component template does not contain <code>...attributes</code> (i.e. the invoker passed
some attributes, but the invokee does not take them), it will be a development
mode error.</p>
<p>It could be thought of that the attributes in the invocation side is stored in
an internal block, and <code>...attributes</code> is the syntax for yielding to this
internal block. Since the <code>yield</code> keyword is not available in element position,
a dedicated syntax is needed.</p>
<p>Classic components (<code>Ember.Component</code>) will implicitly have an <code>...attributes</code>
added to the end of the wrapper element (if <code>tagName</code> is not an empty string),
after any attributes added by the component itself (using <code>attributeBindings</code>,
<code>classNames</code> etc). This means that attributes provided by the caller will
override (replace) those added by the component (except for <code>class</code>, which is
merged).</p>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<p>A block can be passed to the invokee using the angle bracket invocation syntax.
For example, the invocation <code>&lt;FooBar&gt;some content&lt;/FooBar&gt;</code> is equivalent to
<code>{{#foo-bar}}some content{{/foo-bar}}</code>. As with the classic invocation style,
this block will be accessible using the <code>{{yield}}</code> keyword, or the <code>@main</code>
named argument per the <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">named blocks RFC</a>.</p>
<p>Block params are supported as well, i.e. <code>&lt;FooBar as |foo bar|&gt;...&lt;/FooBar&gt;</code>.</p>
<p>There is no dedicated syntax for passing an &quot;else&quot; block directly. If needed,
that can be passed using the named blocks syntax.</p>
<h3 id="closing-tag"><a class="header" href="#closing-tag">Closing Tag</a></h3>
<p>The last piece of the angle bracket invocation syntax is the closing tag, which
is mandatory. The closing tag should match the tag name portion of the opening
tag exactly. If no block is passed, the self-closing tag syntax <code>&lt;FooBar /&gt;</code>
can also be used (in which case <code>{{has-block}}</code> will be false).</p>
<h3 id="dynamic-invocations"><a class="header" href="#dynamic-invocations">Dynamic Invocations</a></h3>
<p>In additional to the static invocation described above (where the tag name is a
statically known component name), it is also possible to use the angle bracket
invocation syntax for dynamic invocations.</p>
<p>The most common use case is for invoking &quot;contextual components&quot;, as shown in
the first example:</p>
<pre><code class="language-hbs">&lt;SuperSelect @selected={{this.user.country}} as |Option|&gt;
  {{#each this.availableCountries as |country|}}
    &lt;Option @value={{country}}&gt;{{country.name}}&lt;/Option&gt;
  {{/each}}
&lt;/SuperSelect&gt;
</code></pre>
<p>Because <code>Option</code> is the name of a local variable (block param), the <code>&lt;Option&gt;</code>
invocation will invoke the yielded value instead of looking for a component
named &quot;option&quot;.</p>
<p>Similar to curly invocations, most valid Handlebars path expressions are
invokable in this manner:</p>
<pre><code class="language-hbs">{{!-- LOCAL VARIABLES --}}

{{#form-for model=user as |f|}}
  {{f.fieldset}}
    {{f.input name=&quot;username&quot; type=&quot;text&quot;}}
    {{f.input name=&quot;password&quot; type=&quot;password&quot; }}
  {{/f.fieldset}}

  {{!-- is equivilant to --}}

  &lt;f.fieldset&gt;
    &lt;f.input @name=&quot;username&quot; @type=&quot;text&quot; /&gt;
    &lt;f.input @name=&quot;password&quot; @type=&quot;text&quot; /&gt;
  &lt;/f.fieldset&gt;
{{/form-for}}

{{!-- NAMED BLOCKS OR CURRIED COMPONENTS --}}

{{@content}}

{{!-- is equivilant to --}}

&lt;@content /&gt;

{{!-- THIS LOOKUP --}}

{{#this.container}}
  {{this.child}}
{{/this.container}}

&lt;this.container&gt;
  &lt;this.child /&gt;
&lt;/this.container&gt;
</code></pre>
<blockquote>
<p>Note: The <a href="https://github.com/emberjs/rfcs/blob/master/text/0226-named-blocks.md">named blocks RFC</a>
proposed to use the <code>&lt;@foo&gt;...&lt;/@foo&gt;</code> syntax on the invocation side to mean
providing a block named <code>@foo</code>, which creates a conflict with this proposal.
<a href="https://github.com/emberjs/rfcs/pull/317">RFC #317</a> propose to change the
block-passing syntax to <code>&lt;@foo=&gt;...&lt;/@foo&gt;</code> to avoid this conflict.</p>
</blockquote>
<p>Notably, based on the rules laid out above, the following is perfectly legal:</p>
<pre><code class="language-hbs">{{!-- DON'T DO THIS --}}

{{#let (component &quot;my-div&quot;) as |div|}}
  {{!-- here, &lt;div /&gt; referes to the local variable, not the HTML tag! --}}
  &lt;div id=&quot;my-div&quot; class=&quot;lol&quot; /&gt;
{{/let}}
</code></pre>
<p>From a programming language's perspective, the semantics here is quite clear. A
local variable is allowed to override (&quot;shadow&quot;) another variable on the outer
scope (the &quot;global&quot; scope, in this case), similar to what is possible in
JavaScript:</p>
<pre><code class="language-js">let console = {
  log() {
    alert(&quot;I win!&quot;);
  }
};

console.log(&quot;Hello!&quot;); // shows alert dialog instead of logging to the console
</code></pre>
<p>While this is semantically unambiguous, it is obviously very confusing to the
human reader, and we don't recommend anyone actually doing this.</p>
<p>A previous version of this RFC recommended statically disallowing these cases.
However, after giving it more thoughts, we realized it should not be the
programming language's job to dictate what are considered &quot;good&quot; programming
patterns. By statically disallowing arbitrary expressions, it actually makes it
more difficult to learn and understand the underlying programming model.</p>
<p>Instead, we recommend <a href="https://github.com/ember-cli/rfcs/pull/114">including a template linter</a>
in the default stack and defer to the linter to make such recommendations. At
minimum, we recommend linting against invoking local variables with lowercase
names without a path segment, regardless of whether the name actually collide
with a known HTML tag – human readers of an Ember template should be able to
safely assume lowercase tags refer to HTML.</p>
<p>Eventually, we might want to provide stronger guidance with via the linter. For
example, we may want to recommend capitalizing invokable local variables, as in
<code>&lt;F.Input /&gt;</code>. We will let the community experiment and coalesce around these
conventions before recommending them by default.</p>
<p>Finally, there are two exceptions to the general rule where certain technically
valid Handlebars path expressions are not supported for dynamic invocations:</p>
<ul>
<li>Implicit <code>this</code> lookups (a.k.a. &quot;property fallback&quot; in <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a></li>
<li>Slash lookups</li>
</ul>
<p>First, while <code>{{foo}}</code> or <code>{{Foo}}</code> can normally refer to <code>{{this.foo}}</code> or
<code>{{this.Foo}}</code> normally, allowing this implicitly lookup will mean <em>any</em> tag
in the template (i.e. <code>&lt;foo /&gt;</code> or <code>&lt;Foo /&gt;</code>) can possibly refer to a property
on the current <code>this</code> context.</p>
<p>This ambiguity is highly undesirable for both human readers and the compiler,
therefore implicitly <code>this</code> lookup is not allowed in angle bracket invocations.
This explicit form, <code>&lt;this.foo /&gt;</code> and <code>&lt;this.Foo /&gt;</code> is required.</p>
<p>This requirement aligns well with <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a>
and the current curly invocation semantics, due to the <a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#component-helper-shorthand">&quot;dot rule&quot;</a>
that requires a dot in the path. Note that this is actually more restrictive
than the proposed angle bracket invocation semantics, since it is not possible
to invoke a local variable without a dot:</p>
<pre><code class="language-hbs">{{#super-select selected={{this.user.country}} as |option|&gt;
  {{#each this.availableCountries as |country|}}
    {{!-- this is not legal today, since `option` does not contain a dot --}}
    {{#option value=country}}{{country.name}}{{/option}}
  {{/each}}
{{/super-select}}
</code></pre>
<p>We propose to relax that rule to match the proposed angle bracket invocation
semantics (i.e. allowing local variables without a dot, as well as <code>@names</code>,
but disallowing implicit <code>this</code> lookup).</p>
<p>Second, while Handlebars technically allows <code>{{foo/bar}}</code> as an equivalent
alternative to the <code>{{foo.bar}}</code> path lookup (and therefore <code>foo/bar</code> is
technically a valid Handlebars path expression), it will not be supported in
angle bracket invocation. This is both because the <code>/</code> conflicts with the HTML
closing tag syntax, and the fact that Ember overrides that syntax with a
different semantic.</p>
<p>In today's semantics, <code>{{foo/bar}}</code> does not try to lookup <code>this.foo.bar</code> and
invoke it as a component. Instead, it is used as a filesystem scoping syntax.
Since this feature will be rendered unnecessary with <a href="https://github.com/emberjs/rfcs/blob/master/text/0143-module-unification.md">Module Unification</a>,
we recommend apps using &quot;slash components&quot; to migrate to alternatives provided
by Module Unification (or, alternatively, keep using curly invocations for this
purpose).</p>
<h2 id="how-we-teach-this-46"><a class="header" href="#how-we-teach-this-46">How we teach this</a></h2>
<p>Over time, we will switch to teaching angle bracket invocation as the primary
invocation style for components. The HTML-like syntax should make them feel
more familiar for new developers.</p>
<p>Classic invocation is here to stay – the ability to accept positional arguments
and &quot;else&quot; blocks makes them ideal for control-flow like components such as
<code>{{liquid-if}}</code>.</p>
<h2 id="drawbacks-70"><a class="header" href="#drawbacks-70">Drawbacks</a></h2>
<p>Because angle bracket invocation is designed for the future in mind, allowing
angle bracket invocations on classic components might introduce some temporary
incoherence (such as the interaction between the attributes passing feature and
the &quot;inner HTML&quot; semantics). However, in our opinion, the upside of allowing
incremental migration outweighs the cons.</p>
<h2 id="alternatives-71"><a class="header" href="#alternatives-71">Alternatives</a></h2>
<p>We could just stick with the classic invocation syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-03-24
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/318
Tracking: https://github.com/emberjs/rfc-tracking/issues/23</p>
<hr />
<h1 id="array-helper"><a class="header" href="#array-helper"><code>array</code> helper</a></h1>
<h2 id="summary-73"><a class="header" href="#summary-73">Summary</a></h2>
<p>This RFC proposes to add an <code>array</code> template helper for creating arrays in templates.</p>
<p>The helper would be invoked as <code>(array arg1 ... argN)</code> and return the value <code>[arg1, ..., argN]</code>. For example, <code>(array 'a' 'b' 'c')</code> would return the value <code>['a', 'b', 'c']</code>.</p>
<h2 id="motivation-74"><a class="header" href="#motivation-74">Motivation</a></h2>
<p>Objects (or hashes) and arrays are the two main data structures in JavaScript. Ember already has a <code>hash</code> helper for building objects, so it makes sense to also include an <code>array</code> helper for building arrays.</p>
<h2 id="detailed-design-66"><a class="header" href="#detailed-design-66">Detailed design</a></h2>
<p>The design is straightforward and mirrors the design of the <code>hash</code> helper. In particular, the important thing to note is that if any of the arguments to the <code>array</code> helper change then an entirely new array will be returned, rather than updating the existing array in place.</p>
<p>The implementation would also mirror the <a href="https://github.com/emberjs/ember.js/blob/ec9f4e5e5f4099a77a73bc5a9aa41916f0d15d6d/packages/ember-glimmer/lib/helpers/hash.ts#L49-L51">implementation of the <code>hash</code> helper</a> and would simply capture the positional arguments instead.</p>
<h2 id="how-we-teach-this-47"><a class="header" href="#how-we-teach-this-47">How we teach this</a></h2>
<p>This helper is not an important part of the programming model and can just be mentioned in the <a href="https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers">API docs</a> like its sibling the <code>hash</code> helper.</p>
<h2 id="drawbacks-71"><a class="header" href="#drawbacks-71">Drawbacks</a></h2>
<p>As usual, adding new helpers increases the surface area of the API and file size but in this case it is justified because the file size change is extremely small and its actually filling an existing hole in the API.</p>
<h2 id="alternatives-72"><a class="header" href="#alternatives-72">Alternatives</a></h2>
<p>This helper could be left to addons, and indeed there are addons that include this helper. It's also trivial to generate
your own <code>array</code> helper with <code>ember generate helper array</code>. Humorously, the default helper blueprint generates a helper that already acts like the <code>array</code> helper ;)</p>
<p>Nevertheless, I believe it's preferable to include this helper in Ember to fill the hole in Ember's API.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-03-24 
RFC PR: https://github.com/emberjs/rfcs/pull/322</p>
<hr />
<h1 id="deprecation-of-embercopy-and-embercopyable"><a class="header" href="#deprecation-of-embercopy-and-embercopyable">Deprecation of Ember.copy and Ember.Copyable</a></h1>
<h2 id="summary-74"><a class="header" href="#summary-74">Summary</a></h2>
<p>This RFC recommends the deprecation and eventual removal of <code>Ember.copy</code> and the <code>Ember.Copyable</code> mixin.</p>
<h2 id="motivation-75"><a class="header" href="#motivation-75">Motivation</a></h2>
<p>A deep-copy mechanism is certainly useful, but it is a general JavaScript problem. Ember itself doesn't need to offer one, especially one that Ember itself isn't using internally. This function and its accompanying mixin arrived with SproutCore, a long time ago, and are not used by Ember itself, even though they currently reside in <code>@ember/object/internals</code>.</p>
<p><code>ember-data</code> uses <code>Ember.copy</code> to do deep-copies. However, the <code>ember-data</code> team finds its needs would be better served by a private deep-copy mechanism that doesn't flow inadvertently through external interfaces into the <code>Ember.copy</code> methods of user-supplied objects. These interfaces are not designed to support deep copies of user-supplied data, and it can raise havoc in the form of hard-to-diagnose bugs, especially in test scenarios.</p>
<p>Since <code>ember</code> and <code>ember-data</code> do not intend to use this mechanism going forward, it would be better to remove it from the Ember codebase and extract it into an add-on for those who wish to continue to use it.</p>
<h2 id="detailed-design-67"><a class="header" href="#detailed-design-67">Detailed design</a></h2>
<p>There are four steps to deprecating any function:</p>
<ul>
<li>logging the deprecation in the call</li>
<li>removal of calls to the function from ember and any add-ons that ship with ember-cli</li>
<li>extraction to an add-on</li>
<li>eventual removal of the feature in the stated release (in this case 4.0.0).</li>
</ul>
<p>This RFC deprecates the <code>copy</code> function and <code>Copyable</code> mixin of <code>@ember/object/internals</code>.</p>
<p>Shallow copies of the form  <code>copy(x)</code>  or <code>copy(x, false)</code> can be replaced mechanically with <code>Object.assign({}, x)</code>. The simplest way to deal with deep copies in any situation depends upon the nature of the data involved.</p>
<h3 id="current-internal-uses"><a class="header" href="#current-internal-uses">Current internal uses</a></h3>
<h4 id="ember-source"><a class="header" href="#ember-source"><code>ember-source</code></a></h4>
<p>This following modules in <code>packages/ember-runtime/lib</code> implement the code being deprecated:</p>
<ul>
<li><code>copy.js</code> contains the <code>copy()</code> function that will log the deprecation before executing,</li>
<li><code>mixins/copyable.js</code> provides the <code>Copyable</code> mixin, but it contains no executable code to deprecate.</li>
<li><code>mixins/array.js</code> - The <code>NativeArray</code> mixin extends the <code>Copyable</code> mixin and implements <code>copy()</code>.</li>
</ul>
<p>The following tests in <code>packages/ember-runtime/tests</code> use the implementation above:</p>
<ul>
<li><code>core/copy_test.js</code> tests the <code>copy()</code> method itself.</li>
<li><code>copyable-array/copy-test.js</code> tests the <code>copy()</code> method of a <code>NativeArray</code> for identical results.</li>
<li><code>helpers/array.js</code> provides the arrays used by the <code>NativeArray</code> test above.</li>
<li><code>system/native_array/copyable_suite_test.js</code> tests the independence of the results of deep copying a <code>NativeArray</code></li>
</ul>
<p>The route  <code>packages/ember-routing/lib/system/route.js</code> has one shallow copy, but the test  <code>packages/ember/tests/routing/decoupled_basic_test</code> is using deep copy.</p>
<p>The <code>copy()</code> methods in <code>packages/ember-metal/lib/map.js</code> and  <code>chains.js</code> and their use in <code>meta.js</code>, and  <code>map_test.js</code> are unrelated.</p>
<p>At present, the handling of arrays in <code>Ember.copy</code> is inconsistent. <code>NativeArray</code> uses the <code>Copyable</code> mixin and implements a <code>copy</code> method. When calling <code>Ember.copy</code>, passing a <code>NativeArray</code>, it will note that the passed parameter uses <code>Copyable</code> and call the copy method inside  <code>NativeArray</code>. However, the recursive <code>_copy</code> method that <code>Ember.copy</code> calls for other objects has its own generic mechanism for copying arrays. If <code>copy</code> is passed a non-<code>Copyable</code> object that contains a <code>NativeArray</code> as a member, when the recursion gets to that member, it will use the generic mechanism rather than delegating to the <code>copy</code> method within the  <code>NativeArray</code>.</p>
<p>The recursive  <code>_copy</code> method also has an assertion that will fail if it is called with any <code>EmberObject</code> that is not also <code>Copyable</code>. This assertion occurs before (and hence affects) the code which handles arrays, even though, for arrays, the object's <code>copy</code> method isn't then used.</p>
<p>During the deprecation period, the <code>Ember.copy</code> method and the <code>NativeArray.copy</code> methods will carry a deprecation warning. We will remove <code>Copyable</code> from <code>NativeArray</code> and change  <code>Ember.copy</code> to consistently use the common array copy mechanism to copy arrays rather than sometimes delegating. We will move the assertion that an <code>EmberObject</code> must be  <code>Copyable</code> to the clause that handles non-array objects.</p>
<p>We need a way to deprecate use of the <code>Copyable</code> mixin. If the penalty for adding code in such a common place isn't too high, we could have <code>core_object.extend()</code>  check for <code>Copyable</code> and deprecate accordingly. We will also supply a new eslint warning that flags the deprecated use of <code>Copyable</code>. (This may be our first eslint check for deprecations. We may want to consider adding others at the same time.)</p>
<p>Those using the add-on will need to mechanically adjust any uses of  <code>myArray.copy(deep)</code> to  <code>copy(myArray, deep)</code> in order to avoid the deprecation message.</p>
<p>At the end of this period, we will remove the deprecated copy() method, the Copyable mixin, and the deprecated NativeArray.copy() method.</p>
<h4 id="ember-data"><a class="header" href="#ember-data"><code>ember-data</code></a></h4>
<p>The following code in <code>ember-data</code> uses <code>copy()</code>, but only for shallow copies:</p>
<ul>
<li><code>addon/-private/system/model/internal-model.js</code> - one use</li>
<li><code>addon/-private/system/snapshot.js</code> - two uses</li>
<li><code>addon/-private/system/store.js</code> - one use</li>
</ul>
<p>All of the following uses in tests perform deep copies:</p>
<ul>
<li><code>tests/integration/adapter/build-url-mixin-test.js</code> - two uses</li>
<li><code>tests/integration/adapter/rest-adapter-test.js</code> - two uses</li>
<li><code>tests/integration/store-test.js</code> - two uses</li>
<li><code>tests/unit/system/relationships/polymorphic-relationship-payloads-test.js</code> - four uses</li>
</ul>
<p>The <code>copy()</code> methods referenced in <code>addon/-private/system.map.js</code> and  <code>addon/-private/system/relationships/state/relationship.js</code> are unrelated.</p>
<p>It would appear that deep copy is used within these packages only during testing, and generally to ensure fresh test data without side-effects.</p>
<h3 id="current-external-uses"><a class="header" href="#current-external-uses">Current external uses</a></h3>
<p>The key considerations for add-ons or apps looking for an alternative to copy() and Copyable are:</p>
<ul>
<li>Do they call <code>copy()</code> to do shallow copies or deep copies?</li>
<li>If deep copies are being performed, are the objects involved POJOs or are they derived from <code>EmberObject</code>?</li>
<li>Do they provide objects that use the <code>Copyable</code> mixin with <code>copy()</code> methods intended for use in deep copies by other classes?</li>
<li>Is the data you are copying the sort of thing where you can do the copy in its behalf, or does it require collaboration from the object itself? Or are the contents so open-ended that you can't possibly know?</li>
</ul>
<p>Shallow copies are directly supported by ES6. It's easy to perform recursive deep copies for most simple POJOs without delegating work to the object you are copying. For more complex data, you may need some kind of recursive delegation. <code>Copyable</code> is a delegation mechanism, and apps and add-ons that require delegation will probably want to use the proposed add-on.</p>
<p>The Code Search capabilities of emberobserver are a wonderful way to get a glimpse of how code in the wild is using particular features.</p>
<p>A quick search of the top-scoring add-on packages revealed that most, but by no means all, of the uses of <code>copy()</code> in the modules were for shallow copies that can be accomplished using Object.assign, so a lot of the code affected by this deprecation can rely on a simple substitution.</p>
<p>Very few packages used <code>Copyable</code> - only 9 across the whole set - and most used the feature for only one class.   <code>ember-data-copyable</code> is probably most wedded to the mechanism: it delivers a  <code>Copyable</code>-based mixin for asynchronous copying.  <code>ember-data-model-fragments</code> has pretty open-ended properties. These add-ons would be likely to use the proposed add-on moving forward.   <code>ember-restless</code>, and <code>ember-calendar</code> appear more bounded. Any deep copy mechanism for POJOs may meet their needs.</p>
<h3 id="add-on"><a class="header" href="#add-on">Add-on</a></h3>
<p>The add-on will supply the <code>copy()</code> function and the <code>Copyable</code> mixin based on the existing code, modified as indicated above for handling of arrays.</p>
<p>We could treat the add-on as the extraction of a feature from the monolithic <code>ember-source</code>, as was recently done for strings. If we choose to frame it in that way, the naming should follow the conventions set out for extracting elements of Ember into their own packages. If we choose not to frame it that way, then naming is one of the things this section should specify clearly.</p>
<h2 id="how-we-teach-this-48"><a class="header" href="#how-we-teach-this-48">How we teach this</a></h2>
<h3 id="communication-of-change-1"><a class="header" href="#communication-of-change-1">Communication of change</a></h3>
<p>We need to inform users that <code>Ember.copy</code> and <code>Ember.Copyable</code> will be dprecated and in what release it will occur. This notification should also point them to the add-on for those who need it.</p>
<h3 id="official-code-bases-and-documentation-2"><a class="header" href="#official-code-bases-and-documentation-2">Official code bases and documentation</a></h3>
<p>We do not actively teach the use of <code>Ember.copy</code>. It doesn't appear anywhere in our guides, website, or tutorial. Once it is gone from the code, we also need to verify it no longer appears in the API listings.</p>
<p>We must provide an entry in the deprecation guide for this change:</p>
<ul>
<li>describing the use of <code>to = Object.assign({},from)</code> for shallow copies.</li>
<li>pointing out viable alternatives for deep copies.</li>
<li>directing heavy users of deep copies to the addon.</li>
</ul>
<h2 id="drawbacks-72"><a class="header" href="#drawbacks-72">Drawbacks</a></h2>
<p>The primary drawback is the API churn of people pulling it out of their code. However, for most uses, the change will be straightforward, and the add-on will be available for the foreseeable future for those who want to continue with the implementation.</p>
<h2 id="alternatives-73"><a class="header" href="#alternatives-73">Alternatives</a></h2>
<p>We could simply leave it in place as a utility for others to use. Even then, it would make sense to split it out into its own module, as has already been done for strings, so the work would be much the same.</p>
<h2 id="unresolved-questions-52"><a class="header" href="#unresolved-questions-52">Unresolved questions</a></h2>
<p>None at the moment...</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-03-28
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/324
Tracking: https://github.com/emberjs/rfc-tracking/issues/22</p>
<hr />
<h1 id="summary-75"><a class="header" href="#summary-75">Summary</a></h1>
<p>The aim of this RFC is to deprecate the component's <code>isVisible</code> property. 
It is not used by Ember internally and left undefined unless manually set.
It's poorly documented and component visibility it better managed in 
template space rather than JS.</p>
<h1 id="motivation-76"><a class="header" href="#motivation-76">Motivation</a></h1>
<p>Setting the isVisible property on a component instance as a way to toggle
the visibility of the component is confusing. The majority of its usage
predates even Ember 1.0.0, and modern Ember applications already completely
avoid using isVisible in favor of simpler conditionals in the template
space.</p>
<p>In addition, when <code>isVisible</code> is used today it often introduces subtle (and
difficult to track down) bugs due to its interaction with the <code>style</code>
attribute (toggling <code>isVisible</code> clobbers any existing content in <code>style</code>).</p>
<p>Simply put, removing <code>isVisible</code> will reduce confusion amongst users.</p>
<h1 id="transition-path-8"><a class="header" href="#transition-path-8">Transition Path</a></h1>
<p>Whenever <code>isVisible</code> is used a deprecation will be issued with a link to 
the deprecation guide explaining the deprecation and how to refactor in order
to avoid it.</p>
<p>Given that <code>Component#isVisible</code> is a public API, deprecating now would
schedule for removal in the next major version release (4.0).</p>
<p>There are several options available to hiding elements 
such as <code>&lt;div hidden={{boolean}}&gt;&lt;/div&gt;</code>(hidden is valid for all elements
and is semantically correct) or wrapping the component in a template
conditional <code>{{#if}}</code> statement. Components <code>classNames</code> and <code>classNameBindings</code>
could also be used to add hidden classes.</p>
<h1 id="how-we-teach-this-49"><a class="header" href="#how-we-teach-this-49">How We Teach This</a></h1>
<p>The <code>isVisible</code> property is rarely used, the deprecation along with a mention
in a future blog post would be sufficient.</p>
<p>We should consider adding documentation on hiding components to the Ember
guides with the conditional handlebar helper or via the widely supported <code>hidden</code>
attribute.</p>
<pre><code class="language-hbs">{{#if showComponent}}
  {{component}}
{{/if}}

{{! or }}
&lt;div hidden={{isHidden}}&gt;&lt;/div&gt;
</code></pre>
<h1 id="alternatives-74"><a class="header" href="#alternatives-74">Alternatives</a></h1>
<p>An alternative option would be to to keep <code>isVisible</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-04-18
RFC PR: https://github.com/emberjs/rfcs/pull/326</p>
<hr />
<h1 id="ember-data-filter-deprecation"><a class="header" href="#ember-data-filter-deprecation">Ember Data Filter Deprecation</a></h1>
<h2 id="summary-76"><a class="header" href="#summary-76">Summary</a></h2>
<p>Deprecate the <code>store.filter</code> API. This API was previously gated
behind a private <code>ENV</code> variable that was enabled by the addon
<a href="https://github.com/ember-data/ember-data-filter/tree/b62c992186c00dce8cc81f1fb0cf5e2e6fee0f6b#ember-data-filter"><code>ember-data-filter</code></a>.</p>
<h2 id="motivation-77"><a class="header" href="#motivation-77">Motivation</a></h2>
<p>The <code>filter</code> API was a &quot;memory leak by design&quot;. <a href="https://github.com/ember-data/ember-data-filter#recommended-refactor-guide">Patterns exist</a>
with no-worse ergonomics that have better performance and do not incur memory leak penalties.</p>
<p>While the change in ergonomics for end consumers in minimal, the change to <code>ember-data</code> is substantial.
The code for this feature required significant amounts of confusing internal plumbing to ensure that
filters were rerun every time any form of mutation (update, addition, deletion) occurred to any record.</p>
<p>In addition to maintenance costs, this plumbing negatively affects the performance of all <code>RecordArray</code>s,
and slow any operations that count as mutations (such as pushing new records into the store).</p>
<p>By removing this feature, we significantly simplify and streamline the core of <code>Ember Data</code>.</p>
<h2 id="detailed-design-68"><a class="header" href="#detailed-design-68">Detailed design</a></h2>
<p>We will provide 3 new deprecations with links to a <a href="https://github.com/ember-data/ember-data-filter#recommended-refactor-guide">guide on how to refactor</a>.
These deprecations will target <code>3.5</code>, meaning that the <code>ember-data-filter</code> addon will continue to
work and be supported through the release of ember-data <code>3.4</code>.</p>
<p><strong>Deprecation: ember-data-filter:filter</strong></p>
<p>Deprecate the primary case (<code>store.filter('posts', filterFn)</code>).
Instead, users can combine <code>store.peekAll</code> with a computed property.</p>
<p><strong>Deprecation: ember-data-filter:query-for-filter</strong></p>
<p>This deprecation is specific to folks providing a <code>query</code> to be requested the
first time a filter is run. To do this better, users can separate their usage
of <code>filter</code> from their usage of <code>query</code>.</p>
<p><strong>Deprecation: ember-data-filter:empty-filter</strong></p>
<p>In the case that users were creating a <code>filter</code> with no method for filtering by,
a deprecation is printed letting them know that the easiest path forward is to
use <code>peekAll</code>, which would return the same record result set.</p>
<h2 id="how-we-teach-this-50"><a class="header" href="#how-we-teach-this-50">How we teach this</a></h2>
<p>The <code>filter</code> API is rarely used, having been discouraged for many years. A simple post
alerting users to it's deprecation should be sufficient. The refactoring guide is
sufficiently simple that teaching folks a better way should not be much of a hurdle.</p>
<h2 id="drawbacks-73"><a class="header" href="#drawbacks-73">Drawbacks</a></h2>
<p>Minor churn for folks that did use this API; however, the end result will improve the
performance of apps using filters more so than anyone else.</p>
<h2 id="alternatives-75"><a class="header" href="#alternatives-75">Alternatives</a></h2>
<p>There's been some talk of an API for local querying; however, said alternative RFC
would only result in deprecating this API as well.</p>
<h2 id="unresolved-questions-53"><a class="header" href="#unresolved-questions-53">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-05-01
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/329
Tracking: https://github.com/emberjs/rfc-tracking/issues/21</p>
<hr />
<h1 id="deprecate-usage-of-ember-evented-in-ember-data"><a class="header" href="#deprecate-usage-of-ember-evented-in-ember-data">Deprecate Usage of Ember Evented in Ember Data</a></h1>
<h2 id="summary-77"><a class="header" href="#summary-77">Summary</a></h2>
<p><code>Ember.Evented</code> functionality on <code>DS.Model</code>, <code>DS.ManyArray</code>,
<code>DS.Errors</code>, <code>DS.RecordArray</code>, and <code>DS.PromiseManyArray</code> will be
deprecated and eventually removed in a future release. This includes
the following methods from the
<a href="https://www.emberjs.com/api/ember/2.15/classes/Ember.Evented/methods/on?anchor=off">Ember.Evented</a>
class: <code>has</code>, <code>off</code>, <code>on</code>, <code>one</code>, and <code>trigger</code>. Additionally the
following lifecycle methods on <code>DS.Model</code> will also be deprecated:
<code>becameError</code>, <code>becameInvalid</code>, <code>didCreate</code>, <code>didDelete</code>, <code>didLoad</code>,
<code>didUpdate</code>, <code>ready</code>, <code>rolledBack</code>.</p>
<h2 id="motivation-78"><a class="header" href="#motivation-78">Motivation</a></h2>
<p>The use of <code>Ember.Evented</code> is mostly a legacy from the pre 1.0 days of
Ember Data when events were a core part of the Ember Data programming
model. Today there are better ways to do everything that once needed
events. Removing the usage of the <code>Ember.Evented</code> mixin will make it
easier for Ember Data to eventually transition to using native ES2015
JavaScript classes and will reduce the surface area of APIs that Ember
Data must support in the long term.</p>
<h2 id="detailed-design-69"><a class="header" href="#detailed-design-69">Detailed design</a></h2>
<p><code>Ember.Evented</code> mixin will be scheduled to be removed from the
following classes in a future Ember Data release: <code>DS.Model</code>,
<code>DS.ManyArray</code>, <code>DS.Errors</code>, <code>DS.RecordArray</code>, and
<code>DS.PromiseManyArray</code>.</p>
<p>The <code>has</code>, <code>off</code>, <code>on</code>, <code>one</code>, and <code>trigger</code> methods will be trigger a
deprecation warning when called and will be completly in a future
Ember Data release.</p>
<p>A special deprecation will be logged when users of a
<code>DS.adapterPopulatedRecordArray</code> attempt to listen to the <code>didLoad</code>
event. This depecations will prompt users to use a computed property
instead of the <code>didLoad</code> event.</p>
<p><code>DS.Model</code> will also recieve deprecation warnings when a model is
defined with the following methods: <code>becameError</code>, <code>becameInvalid</code>,
<code>didCreate</code>, <code>didDelete</code>, <code>didLoad</code>, <code>didUpdate</code>, <code>ready</code>,
<code>rolledBack</code>.</p>
<p>When a model is instantiated for the first time with any of these
methods a deprecation warning will be logged notifiying the user that
this method will be deprecated and the user should use an computed or
overide the model's init method instead.</p>
<h2 id="how-we-teach-this-51"><a class="header" href="#how-we-teach-this-51">How we teach this</a></h2>
<p>Today we do not teach the use of any of the Ember Data lifecycle
events in the guides. They are referenced in the API docs but they
will be updated to mark the APIs as deprecated and show alternative
examples of how to achieve the same functionality using a non event
pattern.</p>
<p>The deprecation guide app will be updated with examples showing how to
migrate away from an evented pattern to using a computed or imperative
method to achieve the same results.</p>
<h2 id="drawbacks-74"><a class="header" href="#drawbacks-74">Drawbacks</a></h2>
<p>The drawback to making this change is existing code that takes
advantage of the Ember Data lifecycle events will need to be updated
to use a different pattern.</p>
<h2 id="alternatives-76"><a class="header" href="#alternatives-76">Alternatives</a></h2>
<p>We could leave the <code>Ember.Evented</code> mixin on all of the Ember Data
objects that currently support it and continue to support this
interface for the foreseeable future. However, Ember Data itself
doesn't require these events internally. There is only one place in
the <code>DS.Error</code> code that takes advantage of the <code>Ember.Evented</code> system
and that code can be easilly re-written to avoid <code>Ember.Evented</code> APIs.</p>
<h2 id="unresolved-questions-54"><a class="header" href="#unresolved-questions-54">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-05-08
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/331
Tracking: https://github.com/emberjs/rfc-tracking/issues/20</p>
<hr />
<h1 id="summary-78"><a class="header" href="#summary-78">Summary</a></h1>
<p>Deprecate all use of:</p>
<ul>
<li>Ember Globals Resolver (looks up a class via a global namespace such as &quot;App&quot;)</li>
<li>Creation of a Global Namespace (<code>var App = Ember.Namespace.create();</code>)</li>
<li>Ember.TEMPLATES array</li>
<li>&lt;script type=&quot;text/handlebars&quot; data-template-name=&quot;path/to/template&quot;&gt;</li>
</ul>
<p>Use of any of the above should trigger a deprecation warning, with a target
of version 4.0</p>
<h1 id="motivation-79"><a class="header" href="#motivation-79">Motivation</a></h1>
<p>Over the past years we have transitioned to using Ember-CLI as the main way
to compile Ember apps. The globals resolver is a holdover and primarily
facilitates use of Ember without Ember-CLI.</p>
<h1 id="the-globals-resolver"><a class="header" href="#the-globals-resolver">The Globals Resolver</a></h1>
<p>For those who are not aware, the globals resolver is available via <code>@ember/globals-resolver</code> or
<code>Ember.DefaultResolver</code>. For more information, see the
<a href="https://www.emberjs.com/api/ember/release/classes/GlobalsResolver/properties">api</a>.
Using it looks like the following:</p>
<pre><code class="language-js">// app.js
var App = Ember.Application.create();

App.Router.map(function() {
  this.route('about');
});

App.AboutRoute = Ember.Route.extend({
  model: function() {
    return ['red', 'yellow', 'blue'];
  }
});
</code></pre>
<pre><code class="language-html">// index.html
&lt;script type=&quot;text/x-handlebars&quot; data-template-name=&quot;about&quot;&gt;
  &lt;ul&gt;
    {{#each model as |item|}}
      &lt;li&gt;{{item}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/script&gt;
</code></pre>
<h1 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h1>
<p>One small detail required to implement this RFC: ember-cli's own default resolver,
<a href="https://github.com/ember-cli/ember-resolver">ember-resolver</a>
currently still extends from the globals resolver.
In order to implement this RFC, the ember-cli resolver will need to be changed
so that it does <em>not</em> extend from the globals resolver, or otherwise ember-cli users
will get a deprecation warning as well.
However, changing the base class of the ember cli classic resolver is a breaking change,
so prior to ember/ember-cli version 4.0 we need to take another step.
In the ember-cli classic resolver, deprecate any runtime calls where there is fallback to the globals mode resolver. This would be a deprecation in ember-cli's resolver. We could bump a major version of ember-cli-resolver removing the base class and release it in ember-cli after an LTS of ember-cli.</p>
<h1 id="transition-path-9"><a class="header" href="#transition-path-9">Transition Path</a></h1>
<p>Primarily, the transition path is to recommend using Ember-CLI.</p>
<p>During the 3.x timeframe, it MAY become increasingly difficult to use this old functionality.
For example, with the release of 3.0, we already stopped publishing builds that support
globals mode. Here are some of the changes that have impacted or may soon impact users of globals mode:</p>
<h2 id="impact-of-es6-modules"><a class="header" href="#impact-of-es6-modules">Impact of ES6 modules</a></h2>
<p>Users of ES6 modules must use their own build tooling to convert them to named AMD modules via Babel.
No support is provided for &lt;script type=&quot;module&quot;&gt; at this time, although that may change.</p>
<h2 id="impact-of-new-module-imports"><a class="header" href="#impact-of-new-module-imports">Impact of New Module Imports</a></h2>
<p>Globals based apps are only able to use new module imports via the polyfill available at
https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill No build support for this is provided.</p>
<h2 id="impact-of-not-publishing-globals-builds"><a class="header" href="#impact-of-not-publishing-globals-builds">Impact of not publishing globals builds</a></h2>
<p>It is necessary to get a globals build of Ember.js from the npm package now that globals builds
are no longer published to S3, builds.emberjs.com, and CDNs.</p>
<h2 id="impact-of-not-generating-a-globals-build-in-emberjs-package"><a class="header" href="#impact-of-not-generating-a-globals-build-in-emberjs-package">Impact of not Generating a Globals Build in Ember.js Package</a></h2>
<p>At some point during the 3.x cycle, it may be that we no longer publish a globals build in the
npm package. At that point, it may become necessary to use Ember-CLI to generate a globals build
of Ember.js</p>
<h2 id="impact-of-package-splitting"><a class="header" href="#impact-of-package-splitting">Impact of Package Splitting</a></h2>
<p>Work has started on package splitting. It is likely that the globals resolver may not be included
in a default partial build of Ember.js and may be moved to its own package for easy removal.</p>
<h2 id="impact-of-tree-shaking"><a class="header" href="#impact-of-tree-shaking">Impact of Tree Shaking</a></h2>
<p>If the globals resolver is moved to a separate package, it will likely not be included in a build
of Ember.js by default unless tree shaking is turned off.</p>
<h1 id="how-we-teach-this-52"><a class="header" href="#how-we-teach-this-52">How We Teach This</a></h1>
<p>We already do teach this and don't teach the globals resolver. No changes required here.</p>
<h2 id="deprecation-guide-1"><a class="header" href="#deprecation-guide-1">Deprecation Guide</a></h2>
<p>A draft deprecation guide has been pull requested at https://github.com/ember-learn/deprecation-app/pull/155</p>
<h1 id="drawbacks-75"><a class="header" href="#drawbacks-75">Drawbacks</a></h1>
<p>A drawback is that people may want alternate build tooling to Ember-CLI.
We have mitigated this by openly publishing the ember-cli resolver and all parts of the
ember-cli ecosystem under the MIT license.
Alternate build tooling may simply use this open source code to build a competing
infrastructure to ember-cli.</p>
<h1 id="alternatives-77"><a class="header" href="#alternatives-77">Alternatives</a></h1>
<p>Without doing this, we will have to continue to ship and maintain this rarely used functionality.
We don't believe this is a reasonable alternative.</p>
<h1 id="unresolved-questions-55"><a class="header" href="#unresolved-questions-55">Unresolved questions</a></h1>
<p>There has never been a transition guide for transitioning an old codebase to Ember-CLI.
Do we want to create one at this late date?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-24
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/332
Tracking: https://github.com/emberjs/rfc-tracking/issues/19</p>
<hr />
<h1 id="ember-data-record-links--meta"><a class="header" href="#ember-data-record-links--meta">Ember Data Record Links &amp; Meta</a></h1>
<h2 id="summary-79"><a class="header" href="#summary-79">Summary</a></h2>
<p>Enable users to associate <code>links</code> and <code>meta</code> information with individual records
in a manner accessible via the template.</p>
<h2 id="motivation-80"><a class="header" href="#motivation-80">Motivation</a></h2>
<p>Sometimes users have meta or links information to associate with a specific record.
Users of the <code>json-api</code> specification will commonly understand this information as
belonging to an individual <code>resource</code>.</p>
<p>While <code>ember-data</code> allows for this information to exist on relationships, it does
not allow for it to exist on records, which has to this point been a glaring omission
for users of <code>json-api</code> and similar specifications.</p>
<h2 id="detailed-design-70"><a class="header" href="#detailed-design-70">Detailed design</a></h2>
<p>In keeping with the current design of the <code>store.push</code> API which expects the <code>json-api</code> format,
users would include optional <code>meta</code> and <code>links</code> information as member properties of a resource.</p>
<pre><code class="language-js">store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {},
    meta: {
      // ... &lt;any&gt;
    },
    links: {
      self: './person/1', // ... &lt;String&gt;
    }
  }
});
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> will be accepted anywhere a <code>resource</code> may be encountered in a payload.</p>
<pre><code class="language-js">store.push({
  data: [
    {
      type: 'contributor',
      id: '1',
      attributes: {},
      relationships: {
        projects: {
          data: [
            { type: 'project', id: '1' }
          ]
        }
      },
      meta: {
        // ... &lt;any&gt;
      },
      links: {
        self: './person/1', // ... &lt;String&gt;
      }
    }
  ],
  included: [
    {
      type: 'project',
      id: '1',
      attributes: {},
      relationships: {
        contributors: {
          data: [
            { type: 'contributor', id: '1' }
          ]
        }
      },
      meta: {
        // ... &lt;any&gt;
      },
      links: {
        self: './github-projects/1', // ... &lt;String&gt;
      }
    }
  ]
})
</code></pre>
<hr />
<p>Links &amp; Meta on objects used as <code>ResourceIdentifiers</code> (e.g. to link to another resource within a relationship)
will not be used for the associated resource and will be silently ignored.</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',         
            meta: {}, // ignored
            links: {} // ignored
          }
        ]
      }
    },
  }
});
</code></pre>
<hr />
<p>Links &amp; Meta on objects provided for <code>Relationships</code> will continue to work (as they do today).</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'contributor',
    id: '1',
    attributes: {},
    relationships: {
      projects: {
        data: [
          {
            type: 'project',
            id: '1',         
          }
        ],
        meta: {}, // available on the Record's hasMany relationship
        links: {} // available on the Record's hasMany relationship
      }
    },
  }
});
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> properties will be exposed as getters on instances of <code>DS.Model</code> and will default to <code>null</code> if
no <code>meta</code> or <code>links</code> have been provided.</p>
<pre><code class="language-js">let record = store.push({
  data: {
    type: 'person',
    id: '1',
    attributes: { name: '@runspired' },
    meta: {
      expiresDate: '2018-05-10'
    },
    links: {
      self: './people/runspired'
    }
  }
});

record.meta.expiresDate; // '2018-05-10'
record.links.self; // './people/runspired'
</code></pre>
<hr />
<p><code>links</code> and <code>meta</code> will similarly be exposed as on instances of <code>Snapshot</code> given to
adapter and serializer methods. In keeping with <code>Snapshot#attributes()</code>, they will
be exposed as methods.  Should users desire to reload a record via link, they could
achieve such by utilizing the <code>links()</code> method to check for a link when making a request.</p>
<pre><code class="language-js">class Snapshot {
  links() {}
  meta() {}
}
</code></pre>
<hr />
<h4 id="the-shared-namespace-problem-and-interop-with-existing-workaround-for-links-and-meta"><a class="header" href="#the-shared-namespace-problem-and-interop-with-existing-workaround-for-links-and-meta">The shared namespace problem and interop with existing workaround for <code>links</code> and <code>meta</code>.</a></h4>
<p>The <code>json-api</code> spec places <code>type</code>, <code>id</code>, and all members of <code>attributes</code> and <code>relationships</code> into
a single shared flattened namespace.  This flattened namespace is what <code>records</code> expose.</p>
<p>The spec does not put <code>links</code> and <code>meta</code> into this namespace, and it is valid to have <code>links</code> and <code>meta</code>
as member names of either <code>attributes</code> or <code>relationships</code>.</p>
<p>Some apps have taken advantage of this to move <code>links</code> and <code>meta</code> into <code>attributes</code> on their serializer
and to expose them via <code>DS.attr</code> on their records.</p>
<p>The <code>getter</code> we are proposing adding to <code>DS.Model</code> would be overwriteable. In the case that there is a
conflict, the version defined by the end user model would win. It would be up to consuming apps to
decide whether they wish to avoid this conflict by renaming the non-resource <code>links</code> and <code>meta</code> either
in their serializer or in their API responses.</p>
<h2 id="how-we-teach-this-53"><a class="header" href="#how-we-teach-this-53">How we teach this</a></h2>
<p>Documentation for <code>DS.Model</code> should be updated to reflect these properties, the potential conflict
(and the default conflict resolution) explained in said documentation, and guides on working with
Models should reflect this capability.</p>
<h2 id="drawbacks-76"><a class="header" href="#drawbacks-76">Drawbacks</a></h2>
<p>Users may sometimes encounter confusion when <code>links</code> or <code>meta</code> is a member of attributes or
relationships.</p>
<h2 id="alternatives-78"><a class="header" href="#alternatives-78">Alternatives</a></h2>
<ul>
<li>
<p>Rename <code>links</code> and <code>meta</code> to a name less likely to collide and which we fully reserve, such as
<code>recordLinks</code> and <code>recordMeta</code>. We felt this would be confusing.</p>
</li>
<li>
<p>Enforce accessing <code>links</code> and <code>meta</code> via some other object such as the <code>Reference</code> API. In addition
to being cumbersome and confusing, this would lack discoverability and be unergonomic in templates.</p>
</li>
<li>
<p>Enforce accessing <code>links</code> and <code>meta</code> via some imported helper, e.g. <code>recordMetaFor(record)</code> or <code>recordLinksFor(record)</code>.
We felt this would be confusing and unergonomic for templates.</p>
</li>
</ul>
<h2 id="unresolved-questions-56"><a class="header" href="#unresolved-questions-56">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-05-29
RFC PR: https://github.com/emberjs/rfcs/pull/335</p>
<hr />
<h1 id="deprecate-sendaction"><a class="header" href="#deprecate-sendaction">Deprecate <code>.sendAction</code></a></h1>
<h2 id="summary-80"><a class="header" href="#summary-80">Summary</a></h2>
<p>In old versions of Ember (&lt; 1.13) <code>component#sendAction</code> was the only way for a component to call an
action on a parent scope. In 1.13 with the so called <em>closure actions</em> a more intuitive and flexible
way of calling actions was introduced, yielding the old way redundant.</p>
<h2 id="motivation-81"><a class="header" href="#motivation-81">Motivation</a></h2>
<p>With the new <em>closure actions</em> being the recommended way, <code>component#sendAction</code> is not even
mentioned in the guides.
With the goal of simplifying the framework I think we should remove what is not considered the
current best practice.
<em>Closure actions</em> have been available since 1.13. That is 3 years ago, so deprecating <code>sendAction</code>
should not cause too much pain and yet addons can support still support the last version of the 1.X
cycle if they really want to.</p>
<p>It is out of the scope of this RFC to enumerate the reasons why <em>closure actions</em> are preferred over
<em>sendAction</em> but you can find an in depth explanation of <em>closure actions</em> in <a href="http://miguelcamba.com/blog/2016/01/24/ember-closure-actions-in-depth">this blog post from 2016</a>.</p>
<h2 id="detailed-design-71"><a class="header" href="#detailed-design-71">Detailed design</a></h2>
<p>A deprecation message will appear when <code>sendAction</code> is invoked. The feature will be removed in
Ember 4.0. The deprecation message will use the arguments passed to <code>sendAction</code> to generate a dynamic
explanation that will make super-easy for developers to migrate to closure actions.</p>
<p>As it is mandatory with new deprecations, a new entry in the deprecation guides will be added
explaining the migration path in depth.</p>
<p>To refresh what the migration path would look like in the typical use case.</p>
<p><strong>BEFORE</strong></p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=&quot;sayHi&quot;}}
</code></pre>
<pre><code class="language-js">// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.sendAction('salute');
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button {{action &quot;sendSalute&quot;}}&gt;Send salute&lt;/button&gt;
</code></pre>
<p><strong>AFTER</strong></p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=(action &quot;sayHi&quot;)}}
</code></pre>
<pre><code class="language-js">// child-component.js
export default Component.extend({
  actions: {
    sendSalute() {
      this.salute();
      // if the salute action is optional you'll have to guard in case it's undefined:
      // if (this.salute) {
      //   this.salute()
      // }
      // 
      // Alternatively, you can also define a noop salute function:
      // salute() {}
      //
      // This allows you to remove the guard while provinding an obvious place to add
      // docs for that action.
    }
  }
});
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button {{action &quot;sendSalute&quot;}}&gt;Send salute&lt;/button&gt;
</code></pre>
<p>However <em>closure actions</em> allow to be less verbose, so the same behavior could be attained using
less intermediate calls</p>
<pre><code class="language-js">// parent-component.js
export default Component.extend({
  actions: {
    sayHi() {
      alert('Hello user!');
    }
  }
})
</code></pre>
<pre><code class="language-hbs">{{!-- parent-component.hbs --}}
{{child-component salute=(action &quot;sayHi&quot;)}}
</code></pre>
<pre><code class="language-hbs">{{!-- child-component.hbs --}}
&lt;button onclick={{@salute}}&gt;Send salute&lt;/button&gt;
</code></pre>
<h2 id="how-we-teach-this-54"><a class="header" href="#how-we-teach-this-54">How we teach this</a></h2>
<p>There are no new concepts to teach, but the removal of an old concept now considered outdated.</p>
<h2 id="drawbacks-77"><a class="header" href="#drawbacks-77">Drawbacks</a></h2>
<p>There might be some churn following the deprecation, specially comming from addons that haven't been
updated in a while.
Addons that want to support the latest versions of Ember without deprecation messages and still work
past Ember 1.13 will have to do some gymnastics to do so.</p>
<h2 id="alternatives-79"><a class="header" href="#alternatives-79">Alternatives</a></h2>
<p>Wait longer to deprecate it and keep <code>sendAction</code> undocumented until it's usage is yet more minoritary
than it is today, to lower the churn.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-06-14
RFC PR: https://github.com/emberjs/rfcs/pull/337
Ember Issue: https://github.com/emberjs/ember.js/pull/16795</p>
<hr />
<h1 id="native-class-constructor-update"><a class="header" href="#native-class-constructor-update">Native Class Constructor Update</a></h1>
<h2 id="summary-81"><a class="header" href="#summary-81">Summary</a></h2>
<p>Update the behavior of EmberObject's constructor to defer object
initialization.</p>
<h2 id="motivation-82"><a class="header" href="#motivation-82">Motivation</a></h2>
<p>Using native class syntax with EmberObject has almost reached full feature
parity, meaning soon we'll be able to ship native classes and begin recommending
them. This will do wonders for the Ember learning story, and will bring us in
line with the wider Javascript community.</p>
<p>However, early adopters of native classes have experienced some serious
ergonomic issues due to the current behavior of the class constructor. The issue
is caused by the fact that properties passed to <code>EmberObject.create</code> are
assigned to the instance in the root class <code>constructor</code>. Due to the way that
native class fields work, this means that they are assigned <em>before</em> any
subclasses' fields are assigned, causing subclass fields to overwrite any value
passed to <code>create</code>:</p>
<pre><code class="language-js">class Foo extends EmberObject {
  bar = 'baz';
}

let foo = Foo.create({ bar: 'something different' });

console.log(foo.bar); // 'baz'
</code></pre>
<p>This has made adoption very difficult, and is a consistent stumbling block for
new users of native class syntax in Ember. Worse yet, it makes writing a codemod
for converting to native class syntax very difficult because we don't have a
clear target.</p>
<p>For instance, given the above class, how would we convert the class field? Let's
go through the various options:</p>
<pre><code class="language-js">class Foo extends EmberObject {
  // Does not work, for the reasons described above
  bar = 'baz';

  // Does not cover all cases. If we did `Foo.create({ bar: false })` it would
  // still assign the default.
  bar = this.bar || 'baz';

  // This works, but is very verbose and not ideal
  bar = this.hasOwnProperty('bar') ? this.bar : 'baz';

  // This is one of the community accepted solutions, but it requires lodash
  bar = _.defaultTo(this.bar, 'baz');

  // This is another community accepted solution, but it requires
  // @ember-decorators/argument, which is a separate library
  @argument foo = 'bar';
}
</code></pre>
<p>None of these is ideal. Instead, we can change the behavior of the constructor
and the <code>create</code> method to circumvent this issue.</p>
<p>This change <em>would</em> be a breaking change to the behavior of native classes
today, and a change from the previous class RFC. This will impact early adopters
and should be made with that in mind. It would <em>not</em> be a change that breaks the
behavior of the community solutions to class fields mentioned above, and all
other changes would be relatively easy to create a safe codemod for (essentially
converting <code>constructor</code> -&gt; <code>init</code> in affected classes), so the impact <em>should</em>
be minimal.</p>
<p>Because native classes never officially shipped as part of Ember's public API
(an announcement was not made, docs have not been written, etc), this RFC
proposes that the change would <em>not</em> be considered a breaking change <em>for the
purposes of semver</em>. This would allow us to ship the change during the Ember v3
release cycle, and prevent more code from being built on top of the previous
behavior.</p>
<h2 id="detailed-design-72"><a class="header" href="#detailed-design-72">Detailed design</a></h2>
<p>One very important design constraint to making this change is that we <em>cannot</em>
break the behavior of EmberObject when used <em>without</em> native classes. To do
this, we will leverage the fact that the static <code>create</code> method is the only
public way to create an instance of EmberObject.</p>
<p>Currently, the behavior of EmberObject is the following (simplified):</p>
<pre><code class="language-js">class EmberObject {
  constructor(props) {
    // ..class setup things

    Object.assign(this, props);
    this.init();
  }

  static create(props) {
    let instance = new this(props);

    return instance;
  }
}
</code></pre>
<p>We can change it to the following (simplified):</p>
<pre><code class="language-js">class EmberObject {
  constructor(props) {
    // ..class setup things
  }

  static create(props) {
    let instance = new this(props);

    Object.assign(instance, props);
    instance.init();

    return instance;
  }
}
</code></pre>
<p>This would assign the properties <em>after</em> all of the class fields for any
subclasses have been assigned. Revisiting our previous example, the following
two class declarations would effectively be equivalent:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: 'baz'
});

class Foo extends EmberObject {
  bar = 'baz';
}
</code></pre>
<p>Much easier to codemod! There are other subtle differences between native class
fields and EmberObject properties, such as the fact that class fields are
assigned each time a class is initialized, but these are easier to work around.</p>
<h3 id="injections-and-the-init-hook"><a class="header" href="#injections-and-the-init-hook">Injections and the <code>init</code> hook</a></h3>
<p>One side effect of this change is that injections will not be available on the
class instance during the <code>constructor</code> phase. This behavior is not very
commonly used - based on an informal community survey we found only a few usages
- but it <em>does</em> exist and have its use cases.</p>
<p>Figuring out the ideal behavior of injections during the constructor phase is
outside of the scope of this RFC, and is something that should be discussed in
future RFCs. For the time being, users can still rely on the <code>init</code> hook, which
will continue to be called after all injections and properties have been
assigned to the instance.</p>
<h3 id="new-emberobject"><a class="header" href="#new-emberobject"><code>new EmberObject()</code></a></h3>
<p>It was previously possible to use <code>new</code> syntax with EmberObject. While this
was not considered public API, it has technically worked and been under test
since the early days of Ember, and may fall under the category of intimate API.
Ideally, we would deprecate this usage as a private/intimate API, which would
mean supporting it through the next LTS version, and dropping support after
(currently, this would mean dropping it at <code>v3.5.0</code>).</p>
<p>We can continue to support this behavior in a backwards compatible way while
deprecating it with one final tweak to the change above:</p>
<pre><code class="language-js">const DEFER_INIT = new Symbol();

function initialize(instance, props) {
  Object.assign(instance, props);
  instance.init();
}

class EmberObject {
  constructor(props, maybeDefer) {
    // ..class setup things

    if (maybeDefer === DEFER_INIT) {
       return this;
    }

    deprecate('using `new` with EmberObject has been deprecated. Please use `create` instead.', false, {
      id: 'object.new-constructor',
      until: '3.5.0'
    });

    initialize(this, props);
  }

  static create(props) {
    let instance = new this(props, DEFER_INIT);
    initialize(instance, props);

    return instance;
  }
}
</code></pre>
<h2 id="how-we-teach-this-55"><a class="header" href="#how-we-teach-this-55">How we teach this</a></h2>
<p>If this PR is accepted, most of the major issues with classes will have been
resolved. We can begin working on a codemod to make converting easier, and move
toward officially making native classes a finalized part of the public API of
Ember. Pending decorators and class fields moving to a late enough stage in the
TC39 process, we can also begin converting the guides to use native class
syntax.</p>
<p>We can document the exact behavior of the new constructor in the API docs for
EmberObject. Most details won't have to change since this change only affects
native class syntax, which has not been documented much officially. We can also
demonstrate the behaviors of classes throughout the guides and API docs.</p>
<p>One thing we should make clear is that EmberObject will likely be deprecated
in the near future, and that ideally for non-Ember classes (things that aren't
Components, Services, etc.) users should drop EmberObject altogether and use
native classes only.</p>
<h2 id="drawbacks-78"><a class="header" href="#drawbacks-78">Drawbacks</a></h2>
<p>This would be a breaking change that could negatively affect early adopters.</p>
<h2 id="alternatives-80"><a class="header" href="#alternatives-80">Alternatives</a></h2>
<ul>
<li>
<p>We could leave the behavior as is, and choose a method for defaulting to
standardize on.</p>
</li>
<li>
<p>We could make this change behind a feature flag and require users to opt-in
to the new behavior, like optional features that currently exist. This would
have to be a build time feature flag, since the area is very performance
sensitive. Given native classes are not yet public API, if we were to do this we
should probably still default to enabling the new behavior and recommending it
as the preferred path.</p>
</li>
<li>
<p>We could not deprecate <code>new EmberObject</code> altogether, and instead only
deprecate passing properties to the constructor. While this would work as a
temporary solution, it may also encourage users to continue using EmberObject
instead of switching to native classes, which is ultimately the long term goal.</p>
</li>
</ul>
<h2 id="unresolved-questions-57"><a class="header" href="#unresolved-questions-57">Unresolved questions</a></h2>
<p>How do we handle DI during the construction phase?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-06-19
RFC PR: https://github.com/emberjs/rfcs/pull/340</p>
<hr />
<h1 id="deprecate-embermerge-in-favor-of-emberassign"><a class="header" href="#deprecate-embermerge-in-favor-of-emberassign">Deprecate Ember.merge in favor of Ember.assign</a></h1>
<h2 id="summary-82"><a class="header" href="#summary-82">Summary</a></h2>
<p>The goal of this RFC is to remove <code>Ember.merge</code> in favor of using <code>Ember.assign</code>.</p>
<h2 id="motivation-83"><a class="header" href="#motivation-83">Motivation</a></h2>
<p><code>Ember.assign</code> has been around quite awhile, and has the same functionality as <code>Ember.merge</code>.
With that in mind, we should remove the old <code>Ember.merge</code>, in favor of just having a single function.</p>
<h2 id="detailed-design-73"><a class="header" href="#detailed-design-73">Detailed design</a></h2>
<p>Ember will start logging deprecation messages that tell you to use <code>Ember.assign</code> instead of <code>Ember.merge</code>.</p>
<p>The exact deprecation message will be decided later, but something along the lines of:</p>
<pre><code>Using `Ember.merge` is deprecated. Please use `Ember.assign` instead. If you are using a version of
Ember &lt;= 2.4 you can use [ember-assign-polyfill](https://github.com/shipshapecode/ember-assign-polyfill) to make `Ember.assign`
available to you.
</code></pre>
<h2 id="how-we-teach-this-56"><a class="header" href="#how-we-teach-this-56">How we teach this</a></h2>
<p>This should be a simple 1 to 1 conversion, and the deprecation message should be clear enough for all to 
understand what they need to do, and convert all usages of <code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<h3 id="deprecation-guide-2"><a class="header" href="#deprecation-guide-2">Deprecation Guide</a></h3>
<p>An entry to the <a href="https://emberjs.com/deprecations/">Deprecation Guides</a> will be added outlining the conversion from
<code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<p><code>Ember.merge</code> predates <code>Ember.assign</code>, but since <code>Ember.assign</code> has been released, <code>Ember.merge</code> has been mostly unnecessary.
To cut down on duplication, we are now recommending using <code>Ember.assign</code> instead of <code>Ember.merge</code>. If you are using a version of
Ember &lt;= 2.4 you can use <a href="https://github.com/shipshapecode/ember-assign-polyfill">ember-assign-polyfill</a> to make <code>Ember.assign</code>
available to you.</p>
<p>Before:</p>
<pre><code class="language-js">import { merge } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
merge(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }

</code></pre>
<p>After:</p>
<pre><code class="language-js">import { assign } from '@ember/polyfills';

var a = { first: 'Yehuda' };
var b = { last: 'Katz' };
assign(a, b); // a == { first: 'Yehuda', last: 'Katz' }, b == { last: 'Katz' }
</code></pre>
<h3 id="codemod"><a class="header" href="#codemod">Codemod</a></h3>
<p>A codemod will be provided to allow automatic conversion of <code>Ember.merge</code> to <code>Ember.assign</code>.</p>
<h2 id="drawbacks-79"><a class="header" href="#drawbacks-79">Drawbacks</a></h2>
<p>The only drawback, that I can think of, is people would need to convert <code>Ember.merge</code> to 
<code>Ember.assign</code>, but this would be a very easy change and could easily be done via codemod.</p>
<h2 id="alternatives-81"><a class="header" href="#alternatives-81">Alternatives</a></h2>
<p>The impact of not doing this, is we continue to have two functions that do basically the same thing,
which we need to maintain. </p>
<p>Another alternative, could be to remove both <code>Ember.merge</code> and <code>Ember.assign</code>, in favor of <code>Object.assign</code>
or something similar.</p>
<h2 id="unresolved-questions-58"><a class="header" href="#unresolved-questions-58">Unresolved questions</a></h2>
<p>None, that I can think of.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-07-11
RFC PR: https://github.com/emberjs/rfcs/pull/345</p>
<hr />
<h1 id="rfc-to-move-the-ember-community-chat-to-discord"><a class="header" href="#rfc-to-move-the-ember-community-chat-to-discord">RFC to move the Ember community chat to Discord</a></h1>
<h2 id="summary-83"><a class="header" href="#summary-83">Summary</a></h2>
<p>Encourage the Ember community to adopt Discord for real-time chat (vs Slack or other options).</p>
<h2 id="motivation-84"><a class="header" href="#motivation-84">Motivation</a></h2>
<p>Real-time chat is essential to the function of online communities, particularly in open source. Chat fosters an informal, interactive style of communication that is important for building relationships, sharing community norms, coordinating on projects, and brainstorming ideas.</p>
<p>The Ember community predominantly uses <a href="https://ember-community-slackin.herokuapp.com/">a Slack instance</a> as the gathering place of choice. While we have benefited enormously from Slack, there are significant downsides as well.</p>
<h3 id="loss-of-history"><a class="header" href="#loss-of-history">Loss of History</a></h3>
<p>Because we use Slack's free plan, the entire instance is limited to 10,000 messages in history at any time. Because of this hard cap, the amount of time messages persist continues to shrink as the community grows.</p>
<p>It's hard to quantify exactly how painful this limitation is, as it means that new community members can't search for the answer to a question that was likely answered in the past. We can never go back to reference how or when a decision was made, which can mean decision-making feels less transparent that it should be.</p>
<p>This limit applies not just to chat messages, but direct messages between community members as well. This leads to annoyance, as people have to ask for the same information over again if they forgot to save it, or data loss, as useful things like code snippets vanish into the ether.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>The architecture of the Slack native application relies on running a separate web application per Slack instance the user is signed into. For users who need to be in multiple Slack instances, this can add up to a significant tax on computer resources, particularly as the application starts up.</p>
<p>Once Slack is up and running, most people generally find the performance reasonable, but a solution that offers better startup and runtime performance would be ideal.</p>
<h3 id="privacy-concerns"><a class="header" href="#privacy-concerns">Privacy Concerns</a></h3>
<p>Slack is very clear that their target audience is companies, who often have strict compliance rules that they must follow. Unfortunately, those needs are often at odds with concerns about privacy in an open source community.</p>
<p>In particular, Slack recently added a feature called Corporate Export that theoretically allows administrators to export all messages, including private messages, without notifying users.</p>
<p>Now, the odds of this feature being abused are extremely low. It is only available on Slack's Plus plan, which means a malicious actor would need to be granted administrator priveleges, pony up at least $150,000 to upgrade our Slack plan for that month, apply for the the Corporate Export feature, have it granted by Slack, and then perform an export without anyone noticing.</p>
<p>Because the difficulty of exploiting this feature for evil is so remote, it's not a primary concern driving this change. But all things being equal, we prefer a solution that doesn't offer export of private messages at all, so it's never a concern at the back of someone's mind.</p>
<h3 id="better-communication--transparency"><a class="header" href="#better-communication--transparency">Better Communication &amp; Transparency</a></h3>
<p>Out of frustration with Slack's disappearing messages, the Ember.js core team set up a Discord server to evaluate if it might be a better fit for open source communities.</p>
<p>While this was a public Discord server that anyone could sign up for, its existence was not widely publicized because we were unsure if Discord was the right solution.</p>
<p>Over time, the core team and many contributors gravitated towards the Discord, finding that it served our needs better. Because of how valuable the Slack instance is, no one wanted to propose a move to Discord until a plan (like, say, this RFC) could be put in place.</p>
<p>Unfortunately, this state of affairs has had several undesirable outcomes.</p>
<p>First, it has caused many of the most prolific contributors to be less active in Slack. This may give the appearance of stagnation or disinterest, when momentum on Ember has never been higher. It robs lurkers of the ability to become contributors if a good opportunity to help pops up. And it prevents some of the most experienced members of the community from being around to help answer questions they might have an off-hand answer to.</p>
<p>Second, and perhaps worst of all, it undermines the transparency and open governance that we have worked hard to create. Our bar is higher than just making it possible to contribute—we go out of our way to actively welcome and encourage everyone to participate, learn and contribute.</p>
<p>Finally, this is not intended to replace <a href="https://discuss.emberjs.com/">the forum</a>, and that should be made clear. The forum is still the preferred place for asyncronous, threaded conversations where in-depth discussion is desired. </p>
<h2 id="detailed-design-74"><a class="header" href="#detailed-design-74">Detailed design</a></h2>
<h3 id="transition-plan-8"><a class="header" href="#transition-plan-8">Transition Plan</a></h3>
<p>We will need these things to transition the community smoothly:</p>
<ul>
<li>a period of time when we use both chat platforms during the transition, put the equivalent Discord channel information in the Slack channel topic</li>
<li>a clear guide (with illustrations)</li>
<li>once all of the setup is complete, the Discord server invites can be distributed. </li>
</ul>
<p>Note: the current Discord chat will be closed while this RFC is under consideration. If the RFC is accepted, then a detailed implementation plan (mostly role/channel/server setup) &amp; invitation strategy will be carried out.</p>
<h4 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h4>
<p>Because Discord has fine-grained controls, we will be able to implement categories for chats.</p>
<p>We intend to have the &quot;welcome&quot; channel as the initial channel for everyone who joins the Discord server. This channel will be read-only and will list the rules for the Discord server.</p>
<p>We also intend to have a &quot;setup&quot; channel. This channel will give you a complete guide of how to take advantage of the personalization, privacy and security, and notification controls in Discord. </p>
<p><strong>Verification Level</strong>
Initially, we will be implementing the &quot;low&quot; verification level, which means users will need to have a verified email on their Discord account. If this proves to be too easy of a target for spammers, we will implement a higher level of verification (levels include amount of time a user has to be a verified member of the server before they can post).</p>
<p><strong>Explicit Content Filter</strong>
Since this is a public Discord server, we will be setting an explicit content filter- it will scan messages from all members without a role. Email-verified members will be given a community member role to start, and other roles may be added to users over time. </p>
<p><strong>Categories and Channels</strong>
Community members will then have the option of visiting the &quot;setup&quot; channel and learning more about fine-grained controls, such as:</p>
<ul>
<li>notifications</li>
<li>muting a channel</li>
<li>muting a category</li>
</ul>
<p>Because our goal is transparency, all of the channels that exist will be visible in the channel list. A lock icon will display if the user does not have the role necessary to join that channel. (<em>FWIW, the alternative is to not display locked channels at all, which we felt would be less ideal- it is better to know that there are channels where private conversations are necessary and see what they are.</em>)</p>
<p>The following proposed initial category and channel list was chosen based on the current channel needs and evaluation of the channels with the most members on Slack. <em>Additional channels may be requested in the Admin/community-feedback channel.</em></p>
<p><strong>Category/Channel List:</strong></p>
<ul>
<li>(No Category)
<ul>
<li>welcome (community guidelines are posted here) &lt;--readonly &amp; the server invite puts users in this channel first. </li>
<li>setup-profile (how to setup your profile) &lt;--readonly</li>
</ul>
</li>
<li>Admin
<ul>
<li>community-feedback (questions, comments, concerns, requests)</li>
<li>security</li>
<li>steering-committee 🔒 (locked to role “steering-committee”)</li>
<li>news &amp; announcements</li>
<li>ember-jobs</li>
<li>bots</li>
</ul>
</li>
<li>Core Teams
<ul>
<li>ember-js 🔒 (locked to role “core-js”)</li>
<li>ember-data 🔒 (locked to role “core-data”)</li>
<li>ember-cli 🔒 (locked to role “core-cli”)</li>
<li>ember-learning 🔒 (locked to role “core-learning”)</li>
</ul>
</li>
<li>Working on Ember
<ul>
<li>ember-cli</li>
<li>ember-data</li>
<li>ember-engines</li>
<li>ember-js</li>
<li>glimmer-vm</li>
<li>triage</li>
<li>st-* (as needed)</li>
</ul>
</li>
<li>Using Ember
<ul>
<li>general-help</li>
<li>learning-ember</li>
<li>a11y</li>
<li>backend</li>
<li>internationalization</li>
<li>jsonapi</li>
<li>mobile</li>
<li>ember-js</li>
<li>ember-data</li>
<li>ember-cli</li>
<li>ember-engines</li>
<li>fastboot</li>
<li>ember-twiddle</li>
<li>e-*</li>
</ul>
</li>
<li>Supporting Ember
<ul>
<li>documentation</li>
<li>website</li>
<li>marketing-and-advocacy</li>
<li>infrastructure</li>
</ul>
</li>
<li>Event-Chat
<ul>
<li>EmberConf</li>
<li>EmberCamps</li>
<li>EmberFest</li>
<li>Talks</li>
<li>Other Conferences</li>
<li>Meetup organizers</li>
</ul>
</li>
<li>Social
<ul>
<li>Water-cooler (random)</li>
<li>Local-*</li>
<li>Media (livestreams, videos, podcasts)</li>
<li>Pets</li>
<li>Women in Ember 🔒</li>
</ul>
</li>
</ul>
<p><strong>Integrations</strong>
Discord's integration game is strong. Discord has a <a href="https://discordapp.com/developers/docs/intro">very detailed API</a> and many integrations already exist, and with no limitation (compared to free Slack instances, that have limited numbers of integrations).</p>
<h2 id="how-do-we-teach-this"><a class="header" href="#how-do-we-teach-this">How do we teach this?</a></h2>
<p>In addition to having a setup channel available upon login (with illustrated instructions), here are some links where community members can read more: </p>
<ul>
<li><a href="https://discordapp.com/open-source">Discord Loves Open Source</a></li>
<li><a href="https://discordapp.com/guidelines">Discord Community Guidelines</a></li>
<li><a href="http://www.businessinsider.com/how-to-use-discord-the-messaging-app-for-gamers-2018-5">How to use Discord</a></li>
</ul>
<h2 id="drawbacks-80"><a class="header" href="#drawbacks-80">Drawbacks</a></h2>
<h3 id="supporting-learning-vs-supporting-development"><a class="header" href="#supporting-learning-vs-supporting-development">Supporting Learning vs Supporting Development</a></h3>
<p>There is some concern that there is already some confusion on Slack about where to get help learning/using Ember, and where to coordinate working on Ember. We need to have a clear delineation so that the folks who are spending their volunteer time to ship Ember features can continue to concentrate and do that.</p>
<h3 id="losing-community-members"><a class="header" href="#losing-community-members">Losing Community Members</a></h3>
<p>There is some concern that we may lose some community members due to this move. This could happen for a variety of reasons- the nature of OSS work means that some are not always active on the chat community, or the user doesn't want a different chat app, etc. We believe that the former is probably more likely than the latter, since many of us are on at least 2-3 chat apps already. </p>
<h2 id="alternatives-82"><a class="header" href="#alternatives-82">Alternatives</a></h2>
<p>The alternative to this would be to temporarily remain on Slack until we are able to evaluate and choose another viable option. However, we believe that staying on Slack is not desirable.</p>
<p>List of Slack alternatives:</p>
<ul>
<li>riot.io</li>
<li>mattermost.org</li>
<li>rocket.chat</li>
<li>spectrum.chat</li>
</ul>
<h2 id="unresolved-questions--faq"><a class="header" href="#unresolved-questions--faq">Unresolved questions &amp; FAQ</a></h2>
<ul>
<li>When will there be conversation threads? We have been told that it is in the works, but there is no ETA.</li>
<li>Disqus, Discord, Discuss? Which is which? For clarity, we will encourage the use of the terms <strong>chat</strong> (Discord), <strong>the forums</strong> (Discuss), and <strong>blog comments</strong> (Disqus)- mostly so no one has to try to remember.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-08-24
RFC PR: https://github.com/emberjs/rfcs/pull/364
Tracking: https://github.com/emberjs/rfc-tracking/issues/28</p>
<hr />
<h1 id="ember-2018-roadmap-rfc"><a class="header" href="#ember-2018-roadmap-rfc">Ember 2018 Roadmap RFC</a></h1>
<h1 id="summary-84"><a class="header" href="#summary-84">Summary</a></h1>
<p>This RFC sets the Ember 2018 Roadmap. This year’s goals are to:</p>
<ul>
<li>Improve communication and streamline decision-making, and empower new leaders.</li>
<li>Finish the major initiatives that we’ve already started.</li>
<li>Ship a new <em>edition</em>, Ember Octane, focused on performance and productivity.</li>
</ul>
<h1 id="motivation-85"><a class="header" href="#motivation-85">Motivation</a></h1>
<p>This document is a distillation of multiple sources:</p>
<ol>
<li>The 2018 Community Survey.</li>
<li>Community #EmberJS2018 blog posts, authored in response to our call for posts.</li>
<li>Discussion on https://discuss.emberjs.com</li>
<li>Deliberations among the Ember core teams.</li>
</ol>
<p>The goal of the RFC is to align the Ember community around a set of shared, achievable goals that balance the needs of existing users with the need to grow and support new use cases.</p>
<h1 id="detailed-design-75"><a class="header" href="#detailed-design-75">Detailed design</a></h1>
<p>This year is primarily about finishing initiatives that we’ve already started, fine-tuning our communication channels, and getting the world excited about Ember.</p>
<ul>
<li><strong>Improve communication and streamline decision-making</strong>. We will expand and refine the core team structure, to ensure decisions are made quickly, communication is clear, and users feel empowered to become contributors. We will invest in mentoring new leaders, and cross-pollinating knowledge between teams. As a community, we will share our excitement about Ember with the wider web development world.</li>
<li><strong>Finish what we started.</strong> We need to focus on stabilizing and polishing the work that we’ve already started in 2018. We will add extension points to allow popular new tools to be quickly adopted in Ember apps. We will standardize around ES modules and npm packages, better enabling the sharing of Ember tools with the wider JavaScript community.</li>
<li><strong>Ship Ember Octane</strong>. We will ship a new <em>edition</em> of Ember, emphasizing its <em>modern productivity and performance</em>. We will polish our compatibility with new JavaScript language features like native classes, decorators, and async functions. We will continue efforts like optional jQuery and treeshaking that reduce file size. We will overhaul the Ember homepage to align with Octane and tell the story of modern Ember.</li>
</ul>
<p>To help us deliver a polished, cohesive experience, we will focus on two end-to-end, real world use cases. Having concrete use cases in mind helps us improve our marketing as well as prioritize feature development. In 2018, our two use cases are:</p>
<ul>
<li><strong>Productivity apps.</strong> Ember’s historical strength: sophisticated, highly interactive apps that users spend a lot of time in, getting things done.</li>
<li><strong>Content apps</strong>, where pages are text-heavy and where the first load is critical. In performance-constrained environments, Ember’s strong conventions can help developers build faster apps by default.</li>
</ul>
<h2 id="improve-communication-and-streamline-decision-making"><a class="header" href="#improve-communication-and-streamline-decision-making">Improve communication and streamline decision-making</a></h2>
<blockquote>
<p>Silence is the only thing that cause developers to lose trust in Ember. And overcommunication is the cure to silence.
—<a href="https://embermap.com/notes/107-our-wish-for-ember-in-2018-overcommunication">Ryan Toronto and Sam Selikoff</a></p>
</blockquote>
<blockquote>
<p>Technical leadership seems to me to be about 10% technical brilliance and 90% clear communication. We have loads of technical brilliance; we need more communication!
—<a href="https://www.chriskrycho.com/2018/emberjs2018-part-3.html">Chris Krycho</a></p>
</blockquote>
<blockquote>
<p>Communication is well, not stellar. Newsletters do a great job at communicating what already happened, but future plans are largely unknown to public.
—<a href="https://medium.com/@vlascik/honest-look-at-ember-in-the-middle-of-2018-a0dc2787e506">V. Lascik</a></p>
</blockquote>
<blockquote>
<p>The Core Team is in a unique position to add external-facing commentary on the framework's vision. Our RFC process and release posts are awesome, and they have done great things internally, so I would like to encourage Core to look outwards next.
—<a href="https://gist.github.com/jenweber/a9fbea98478fc3841fb8b24f7dc961c8">Jen Weber</a></p>
</blockquote>
<blockquote>
<p>My hope is that Ember will continue to be an investment worth making. I see a growing, diverse community with lots of fresh faces as an essential part of that. 
—<a href="https://medium.com/@mattmcmanus/emberjs2018-2d28a441fadb">Matt McManus</a></p>
</blockquote>
<blockquote>
<p>Finding how and where I can help feels scattered. Issues do not receive effective labeling. This has translated into me not contributing to varying projects.
—<a href="https://www.typedspace.com/a-few-quick-thoughts-on-ember-for-2018-from-a-corporate-citizen/">Eli Flanagan</a></p>
</blockquote>
<blockquote>
<p>What I’d wish for Ember’s 2018 Roadmap though is to find ways to lower the entry barriers for newcomers to get started in their attempt to advocate Ember and to be creative on how to encourage a sense of empowerment in the wider community regarding outreach efforts.
—<a href="https://simplabs.com/blog/2018/05/30/a-little-encouragement-goes-a-long-way-in-2018.html">Jessica Jordan</a></p>
</blockquote>
<blockquote>
<p>My hope is that we will continue to hand off the baton of the community values to developers who are new to Ember.
—<a href="https://pixelhandler.com/posts/emberjs2018-a-few-suggestions">Bill Heaton</a></p>
</blockquote>
<blockquote>
<p>A good idea would be to continue creating quests for small things like documentation, code-cleaning… And maybe add a place where this quest can be found
—<a href="https://medium.com/@KamiKillertO/my-emberjs-in-2018-bc7f52739e16">Benjamin Jegard</a></p>
</blockquote>
<p>There has never been more time and energy going into Ember, but we’ve heard loud and clear that this momentum is not as visible as it needs to be. We are going to prioritize sharing work as it happens, making planning and status updates more discoverable, and making it easier for would-be contributors to get involved. </p>
<p>We also need to double down on making Ember as friendly and inclusive as possible, particularly for folks who have never participated in an open source project before. As we bring in new community members, we will make changes to ensure that individuals can have a meaningful impact, no matter what time zone they live in.</p>
<p>Lastly, we need to make sure that our core teams are not so bogged down that they become a bottleneck for decision-making. Core teams and strike teams decentralize planning, empower new contributors to take ownership of community initiatives, and help to build and strengthen relationships among community members. We will invest in improving the organization and structure of these teams this year.</p>
<p>To accomplish these goals, this year we will:</p>
<ul>
<li><strong>Expand and refine our team structure</strong>, breaking up work and delegating it to strike teams or new core teams as appropriate.</li>
<li><strong>Move to discoverable communication tools</strong>, such as our Discourse forum, which is visible to search engines, and Discord chat, which doesn't lose history.</li>
<li><strong>Invest in mentoring</strong>. This includes direct mentorship relationships, as well as written guides like quest issues that are helpful even for people in different time zones or who have difficulty with spoken English.</li>
<li><strong>Track RFC implementation via GitHub issues</strong>, so it's clear what the next steps are after an RFC is merged.</li>
<li><strong>Automate communication and status updates.</strong> For example, we will improve the <a href="https://www.emberjs.com/statusboard">Statusboard</a> to automatically pull from RFCs and RFC tracking issues.</li>
<li><strong>Document “best practices” for core teams</strong>, spreading knowledge about what works and what doesn’t for building an active community.</li>
<li><strong>Unify the RFC process</strong> to ensure a consistent experience across all of Ember's sub-projects.</li>
</ul>
<h2 id="finish-what-we-started"><a class="header" href="#finish-what-we-started">Finish what we started</a></h2>
<blockquote>
<p>The last few years have seen the Ember team do a lot of really important exploratory work, including projects like <a href="https://glimmerjs.com/">Glimmer.js</a>; and we have landed some of the initiatives we have started. But I think it’s fair to say that focus has not been our strong suit. It’s time for a year of shipping.—<a href="https://www.chriskrycho.com/2018/emberjs2018-part-1.html">Chris Krycho</a></p>
</blockquote>
<blockquote>
<p>I think the goal of being able to just npm install or yarn install any package and having it &quot;just work&quot; should be high on the TODO list.
—<a href="http://andrewcallahan.com/a-road-to-ember-4-0/">Andrew Callahan</a></p>
</blockquote>
<blockquote>
<p>When <a href="https://mobile.twitter.com/wycats">Yehuda Katz</a> <a href="https://github.com/emberjs/rfcs/pull/38#issuecomment-355800759">closed</a> that RFC, I think a bit of that dream died, but at the same time I was happy. Not because it wasn't going to happen but because there was clear communication, finally.
—<a href="https://burstcreations.com/ember-in-2018-and-beyond/">Ilya Radchenko</a></p>
</blockquote>
<blockquote>
<p>I firmly believe that Ember needs to deliver all the great new features that are currently in flight before taking more to its plate.
—<a href="https://josemarluedke.com/blog/ember-in-2018-getting-ready-for-the-next-major-release/">Josemar Luedke</a></p>
</blockquote>
<p>This year, we <strong>need a strong focus on shipping</strong>. Huge improvements to Ember have either already landed or are in the pipeline. We need to cross the finish line on these before moving on to new initiatives, however important or exciting they might seem.</p>
<p>“Done” doesn’t mean behind a feature flag on canary. Finishing what we started means ensuring that features are discoverable, on by default, and that the guides and other documentation have been revised to take them into account. It means making sure they work well with the entire Ember ecosystem so that new developers get a seamless experience.</p>
<p>This year, we are going to ship:</p>
<ul>
<li><strong>Broccoli 2.0</strong> in Ember CLI, as well as significant investment into Broccoli documentation, marketing and advocacy.</li>
<li><strong>Module Unification</strong> as the default file system layout.</li>
<li><strong>Glimmer Components</strong> as the default component API.</li>
<li><strong>Native JavaScript classes</strong> as the default object model.</li>
<li><strong>Native JavaScript modules,</strong> including:
<ul>
<li><strong>Exposing modules in the build pipeline</strong> and allowing addons to integrate tools like Parcel, Rollup or Webpack.</li>
<li><strong>Publishing Ember as npm packages</strong>.</li>
<li><strong>Importing npm packages</strong> into your Ember apps with zero additional configuration. (This was, far and away, the most-mentioned feature request in all of the #EmberJS2018 blog posts.)</li>
</ul>
</li>
</ul>
<h2 id="ember-octane"><a class="header" href="#ember-octane">Ember Octane</a></h2>
<blockquote>
<p>The homepage looks a bit outdated and does not a very compelling job at selling Ember to new users, IMHO. This needs to change.
—<a href="https://www.kaliber5.de/en/blog/ember-js-in-2018-get-better-at-marketing/">Simon Ihmig</a></p>
</blockquote>
<blockquote>
<p>When you generate a project with <code>ember new</code>, you get a project that is almost “legacy” by standards of the wider JavaScript community.
—<a href="https://medium.com/@gauravmunjal_86037/stability-without-stagnation-in-2018-ce2d4f519991">Gaurav Munjal</a></p>
</blockquote>
<blockquote>
<p>Ember's custom object model isn't hard to learn, but it's a big reason people are turned off before learning why Ember is such a great choce. I'd like to see ES classes support finished and adopted in the Guides ASAP, followed by decorators.
—<a href="https://gist.github.com/michaelrkn/ffdd67906a724362bd8f5ccc3434db0f">Michael Kaiser-Nyman</a></p>
</blockquote>
<blockquote>
<p>ES6 syntax, the new file layout, new templating etc. — the new features will land in 3.x releases as non-breaking changes, but let’s prepare to show off the sum of all those amazing parts. Sell the vision, right now! A ‘relaunch’ of Ember in the minds of those who dismiss it.
—<a href="https://medium.com/@willviles/ember-js-in-2018-lets-market-the-future-e6be9c42cf86">Will Viles</a></p>
</blockquote>
<p>Ember releases a new, stable version every six weeks. For existing users, this drumbeat of incremental improvement is easier to keep up with than splashy, big-bang releases.</p>
<p>However, for people not following Ember closely, it’s easy to miss the significant improvements that happen over time. As detailed in the forthcoming Ember Editions RFC (being worked on by <a href="https://twitter.com/davewasmer">Dave Wasmer</a>), every year or so <strong>we will release a new edition of Ember</strong>, focused on a particular theme. The set of improvements related to that theme, taken together, mark a meaningful change to how people should think about Ember.</p>
<p>In 2018, we will release the first edition of Ember, called <em>Ember Octane</em>. <strong>Octane will focus on the themes of productivity and performance.</strong> We’ll talk about how Ember excels in performance-constrained environments, particularly on mobile devices, as well as the productivity benefits of modern JavaScript features like classes, decorators, and async functions when paired with Ember’s strong conventions and community.</p>
<p>This is also a good time for us to review the new application blueprint, to ensure that it is up-to-date with the latest Ember Octane idioms and includes the right set of addons to help new users achieve our goals of productivity and performance.</p>
<p>Ember Octane is about <em>doing more with less</em>. Not only does this make Ember simpler to learn, it makes the framework smaller and faster, too. These are some of the highlights of Ember Octane:</p>
<ul>
<li><strong>No jQuery.</strong> Currently available as an optional feature, we will enable this by default.</li>
<li><strong>Svelte builds</strong>, where deprecated features are stripped out of framework code. We will get more aggressive about deprecating code that is not widely used.</li>
<li><strong>Native JavaScript classes</strong> perform better and require less code, and integrate better with tools like TypeScript and ESLint.</li>
<li><strong>Glimmer components</strong> offer a greatly simplified API and remove common slow paths.</li>
<li><strong>Incremental rendering and rehydration</strong> that keeps even low-end devices responsive as the application boots.</li>
<li><strong>Treeshaking</strong> to automatically remove code unused by the application.</li>
<li><strong>Eliminating the runloop</strong> from the programming model, replaced by <code>async</code> and <code>await</code> in tests.</li>
<li><strong>Stabilizing Ember Data</strong> by streamlining internals and providing more extension points for applications and addons to customize behavior.</li>
</ul>
<p>The final timeline and feature set of Ember Octane will be determined by the core teams and are not set in stone in this RFC.</p>
<p>In keeping with our commitment to finishing what we’ve started, these are all features that are either finished or being implemented now. We should not plan for Octane to have any features that are not already close to being done today, so that we have adequate time to make sure they all work well together as part a cohesive programming model.</p>
<p>The process of releasing a new edition also gives us an opportunity to evaluate what it’s like to use Ember end-to-end. We will overhaul the Ember homepage, focusing on Ember Octane and how it helps solve targeted use cases.</p>
<p>This is also a good time to perform a holistic review of the guides, making sure that examples use the latest idioms and set new learners on a good path.</p>
<h1 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h1>
<p>One of our most important goals this year is to focus on shipping. Focus means saying “no” to ideas that we really like.</p>
<ul>
<li><strong>Significant work on Glimmer.js</strong>. We will instead focus on our efforts on incorporating the lessons of Glimmer.js into work that enables a smaller core in Ember.</li>
<li><strong>Further Glimmer VM optimizations</strong>. Glimmer performance is industry leading and not a bottleneck in most Ember.js apps. At this point, the Ember.js payload is the primary performance bottleneck, and we should turn our attention to enabling better performance there.</li>
<li><strong>Brand new language features</strong> in either Handlebars templates or Ember’s JavaScript files. There is already a full pipeline of features, such as Glimmer components, JavaScript classes with decorators, and module unification that we need to finish before starting any new major design.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-08-30
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/369
Tracking: https://github.com/emberjs/rfc-tracking/issues/18</p>
<hr />
<h1 id="summary-85"><a class="header" href="#summary-85">Summary</a></h1>
<p>Deprecate computed overridability and <code>computed().readOnly()</code> in favor of
read-only computeds as the default.</p>
<h1 id="motivation-86"><a class="header" href="#motivation-86">Motivation</a></h1>
<p>Computed properties have existed in Ember long before class syntax and native
accessors (getters and setters) were readily available, and as such they have a
few notable behavioral differences. As we move toward adopting native class
syntax and using a decorator-based form of computeds, it makes sense to
reconcile these differences so that users can expect them to work the same as
their native counterparts.</p>
<p>The main and most notable difference this RFC seeks to deprecate is computed
overridability (colloquially known as &quot;clobbering&quot;). There are some other
notable differences, including the caching behavior of the <code>return</code> value of
setter functions, which may be addressed in future RFCs.</p>
<h2 id="overridability"><a class="header" href="#overridability">Overridability</a></h2>
<p>When defining a native getter without a setter, attempting to set the value will
throw a hard error (in strict mode):</p>
<pre><code class="language-js">function makeFoo() {
  'use strict';

  class Foo {
    get bar() {
      return this._value;
    }
  }

  let foo = new Foo();

  foo.bar; // undefined
  foo.bar = 'baz'; // throws an error in strict mode
}
</code></pre>
<p>By constrast, computed properties without setters will be overridden when they
are set, meaning the computed property is removed from the object and replaced
with the set value:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: computed('_value', {
    get() {
      return this._value;
    },
  }),
});

let foo = Foo.create();

foo.bar; // undefined
foo.set('bar', 'baz'); // Overwrites the getter
foo.bar; // 'baz'
foo.set('_value', 123);
foo.bar; // 'baz'
</code></pre>
<p>This behavior is confusing to newcomers, and oftentimes unexpected. Common best
practice is to opt-out of it by declaring the property as <code>readOnly</code>, which
prevents this overridability.</p>
<h1 id="transition-path-10"><a class="header" href="#transition-path-10">Transition Path</a></h1>
<p>This RFC proposes that <code>readOnly</code> properties become the default, and that in
order to override users must opt in by defining their own setters:</p>
<pre><code class="language-js">class Foo {
  get bar() {
    if (this._bar) {
      return this._bar;
    }

    return this._value
  }

  set bar(value) {
    this._bar = value
  }
}
</code></pre>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Most computed macros are overridable by default, the exception being <code>readOnly</code>.
This RFC proposes that all computed macros with the exception of <code>reads</code> would
become read only by default. The purpose of <code>reads</code> is to <em>be</em> overridable, so
its behavior would remain the same.</p>
<h2 id="decorator-interop"><a class="header" href="#decorator-interop">Decorator Interop</a></h2>
<p>It may be somewhat cumbersome to write overriding functionality or add proxy
properties when overriding is needed. In an ideal world, computed properties
would modify accessors transparently so that they could be composed with other
decorators, such as an <code>@overridable</code> decorator:</p>
<pre><code class="language-js">class Foo {
  @overridable
  @computed('_value')
  get bar() {
    return this._value;
  }

  @overridable
  @and('baz', 'qux')
  quux;
}
</code></pre>
<p>Currently this is not possible as computed properties store their getter/setter
functions elsewhere and replace them with a proxy getter and the mandatory
setter assertion, respectively. In the long term, making computeds more
transparent in this way would be ideal, but it is out of scope for this RFC.</p>
<h2 id="deprecation-timeline"><a class="header" href="#deprecation-timeline">Deprecation Timeline</a></h2>
<p>This change will be a breaking change, which means we will not be able to change
the behavior of <code>computed</code> until Ember v4.0.0. Additionally, users will likely
want to continue using <code>.readOnly()</code> up until overriding has been fully removed
to ensure they are using properties safely. With that in mind, the ordering of
events should be:</p>
<ol>
<li>Ember v3
<ul>
<li>Deprecate the default override-setter behavior immediately. This means that
a deprecation warning will be thrown if a user attempts to set a
non-<code>readOnly</code> property which does not have a setter. Users will still be
able to declare a property is <code>readOnly</code> without a deprecation warning.</li>
<li>Add optional feature to change the deprecation to an assertion after the
deprecation has been released, and to show a deprecation when using
the <code>.readOnly()</code> modifier.</li>
<li>After the deprecation and optional feature have been available for a
reasonable amount of time, enable the optional feature by default in new
apps and addons. The main reason we want to delay this is to give <em>addons</em>
a chance to address deprecations, since enabling this feature will affect
both apps and the addons they consume.</li>
</ul>
</li>
<li>Ember v4
<ul>
<li>Remove the override-setter entirely, making non-overrideable properties the
default.</li>
<li>Make the <code>readOnly</code> modifier a no-op, and show a deprecation warning when it
is used.</li>
</ul>
</li>
</ol>
<p>The warnings should explain the deprecation, and recommend that users do not
rely on setter behavior or opting-in to read only behavior.</p>
<h1 id="how-we-teach-this-57"><a class="header" href="#how-we-teach-this-57">How We Teach This</a></h1>
<p>In general, we can teach that computed properties are essentially cached native
getters/setters (with a few more bells and whistles). Once we have official
decorators in the framework, we can make this connection even more solid.</p>
<p>We should add notes on overridability, and we should scrub the guides of any
examples that make use of overriding directly and indirectly via <code>.readOnly()</code>.</p>
<h1 id="drawbacks-81"><a class="header" href="#drawbacks-81">Drawbacks</a></h1>
<p>Overriding is not a completely uncommonly used feature, and developers who have
become used to it may feel like it makes their code more complicated, especially
without any easy way to opt back in.</p>
<h1 id="alternatives-83"><a class="header" href="#alternatives-83">Alternatives</a></h1>
<p>We could convert <code>.readOnly()</code> into <code>.overridable()</code>, forcing users to opt-in
to overriding. Given the long timeline of this deprecation, it would likely be
better to work on making getters/setters transparent to decoration, and provide
a <code>@overridable</code> decorator either in Ember or as an independent package.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-08-31
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/370
Tracking: https://github.com/emberjs/rfc-tracking/issues/17</p>
<hr />
<h1 id="summary-86"><a class="header" href="#summary-86">Summary</a></h1>
<p>Deprecate <code>computed().volatile()</code> in favor of undecorated native getters and
setters.</p>
<h1 id="motivation-87"><a class="header" href="#motivation-87">Motivation</a></h1>
<p><code>computed().volatile()</code> is a commonly misunderstood API. On its surface,
declaring a computed as volatile causes the computed to recalculate every time
it is called. This actually works much like native, undecorated accessors do on
classes, with one key difference.</p>
<p>Volatile properties are meant to respresent fundamentally unobservable values.
This means that they swallow notification changes, and will not notify under any
circumstances, and that when setting a volatile value the user must notify
manually:</p>
<pre><code class="language-js">const Foo = EmberObject.extend({
  bar: computed({
    get() {
      return this._value;
    }

    set(key, value) {
      return this._value = value;
    }
  }).volatile(),

  baz: computed('bar', {
    get() {
      return this.bar;
    }
  }),
});

let foo = Foo.create();

foo.set('bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

foo.set('bar', 456);
foo.baz; // 123, no property changes were made so the cache was not cleared
</code></pre>
<p>This behavior is useful at times for framework code, but is generally not what
users are expecting. By constrast, when using native accessors with <code>set</code> and
<code>get</code>, Ember treats them just like any other property. From its perspective,
they <em>are</em> standard properties, so it'll continue to notify as expected.</p>
<pre><code class="language-js">class Foo {
  get bar() {
    return this._value;
  }

  set bar(value) {
    this._value = value;
  }

  @computed('bar')
  get baz() {
    return this.bar;
  }
});

let foo = new Foo();

set(foo, 'bar', 123);
foo.baz; // 123, it's the initial get so nothing cached yet

set(foo, 'bar', 456);
foo.baz; // 456, cache was cleared and value was updated
</code></pre>
<p>The most common use case for volatile computeds was when users wanted a computed
to behave like a native getter/setter. Now that we (almost) <em>have</em> those in a
easy to use form, it makes more sense to deprecate the volatile API and rely
directly on native functionality.</p>
<h1 id="transition-path-11"><a class="header" href="#transition-path-11">Transition Path</a></h1>
<p>Native getters and setters will <em>only</em> work on native classes, due to how the
internals of the old object model work. To ensure that users do not accidentally
try to replace volatile with getters/setters on non-native classes, we should
provide 2 deprecation warnings:</p>
<ol>
<li>
<p>Deprecation when users use volatile on a computed which tells them that the
API has been deprecated, and that they'll need to update native class syntax
to remove the volatile property.</p>
</li>
<li>
<p>Deprecation when users use volatile on a computed decorator (to be RFC'd)
which tells them to remove the computed decorator entirely from the getter.</p>
</li>
</ol>
<p>Volatile properties will be removed once native classes are the default.</p>
<h1 id="how-we-teach-this-58"><a class="header" href="#how-we-teach-this-58">How We Teach This</a></h1>
<p>In general documentation should be updated to use native getters and setters
wherever <code>volatile</code> was used. This will have to happen after docs are updated to
use native classes, because native getters and setters do <em>not</em> work with the
older object model.</p>
<h1 id="drawbacks-82"><a class="header" href="#drawbacks-82">Drawbacks</a></h1>
<p>Volatility is useful for framework level concerns, for instance if developing an
API or decorator that already handles notification. Addon authors may be able to
use this functionality.</p>
<p>Not having an alternative for old style classes or mixins could be problematic
for users who aren't ready to update to native class syntax.</p>
<h1 id="alternatives-84"><a class="header" href="#alternatives-84">Alternatives</a></h1>
<p>We could keep <code>volatile()</code> around for any potential addons that may want to use
it, but teach native getters/setters as the preferred path for most use cases.</p>
<p>We could provide <code>volatile</code> as a separate API/decorator to distinguish it from
computed properties, and discourage use for users.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-09-06
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/372
Tracking: https://github.com/emberjs/rfc-tracking/issues/16</p>
<hr />
<h1 id="ember-data--modelfactoryfor"><a class="header" href="#ember-data--modelfactoryfor">ember-data | modelFactoryFor</a></h1>
<h2 id="summary-87"><a class="header" href="#summary-87">Summary</a></h2>
<p>Promote the private <code>store._modelFactoryFor</code> to public API as <code>store.modelFactoryFor</code>.</p>
<h2 id="motivation-88"><a class="header" href="#motivation-88">Motivation</a></h2>
<p>This RFC is a follow-up RFC for <a href="https://github.com/emberjs/rfcs/pull/293">#293 RecordData</a>.</p>
<p>Ember differentiates between <code>klass</code> and <code>factory</code> for classes registered with the container.
At times, <code>ember-data</code> needs the <code>klass</code>, at other times, it needs the <code>factory</code>. For this reason,
<code>ember-data</code> has carried two APIs for accessing one or the other for some time. The public <code>modelFor</code>
provides access to the <code>klass</code> where schema information is stored, while the private <code>_modelFactoryFor</code>
provides access to the factory for instantiation.</p>
<p>We provide access to the class with <code>modelFor</code> roughly implemented as <code>store._modelFactoryFor(modelName).klass</code>.
We instantiate records from this class roughly implemented as <code>store._modelFactoryFor(modelName).create({ ...args })</code>.</p>
<p>For symmetry, both of these APIs should be public. Making <code>modelFactoryFor</code> public would provide a hook
that consumers can override should they desire to provide a custom <code>ModelClass</code> as an alternative
to <code>DS.Model</code>.</p>
<h2 id="detailed-design-76"><a class="header" href="#detailed-design-76">Detailed design</a></h2>
<p>Due to previous complexity in the lookup of models in <code>ember-data</code>, we previously had both <code>modelFactoryFor</code>
and <code>_modelFactoryFor</code>. Despite the naming, both of these methods were private. During a recent cleanup phase,
we unified the methods into <code>_modelFactoryFor</code> and left a deprecation in <code>modelFactoryFor</code>. This RFC proposes
un-deprecating the <code>modelFactoryFor</code> method and making it public, while deprecating the private <code>_modelFactoryFor</code>.</p>
<p>More precisely:</p>
<ul>
<li><code>store._modelFactoryFor</code> becomes deprecated and calls <code>store.modelFactoryFor</code>.</li>
<li><code>store.modelFactoryFor</code> becomes un-deprecated.</li>
</ul>
<h3 id="the-contract-for-modelfactoryfor"><a class="header" href="#the-contract-for-modelfactoryfor">The contract for <code>modelFactoryFor</code></a></h3>
<p>The return value of <code>modelFactoryFor</code> MUST be the result of a call to <a href="https://www.emberjs.com/api/ember/3.4/classes/ApplicationInstance/methods/factoryFor?anchor=factoryFor"><code>applicationInstance.factoryFor</code></a>
where <code>applicationInstance</code> is the <code>owner</code> returned by using <code>getOwner(this)</code> to access the <code>owner</code> of the <code>store</code> instance.</p>
<pre><code class="language-typescript">interface Klass {}

interface Factory {
  klass: Klass,
  create(): Klass
}

interface FactoryMap {
    [factoryName: string]: Factory
}

declare function factoryFor&lt;K extends keyof FactoryMap&gt;(factoryName: K): FactoryMap[K];

interface Store {
  modelFactoryFor(modelName: string): ReturnType&lt;typeof factoryFor&gt;;
}
</code></pre>
<p>Users interested in providing a custom class for their <code>records</code> and who override <code>modelFactoryFor</code>,
would not need to also change <code>modelFor</code>, as this would be the <code>klass</code> accessible via the <code>factory</code>.</p>
<p>Users wishing to extend the behavior of <code>modelFactoryFor</code> could do so in the following manner:</p>
<p><strong>Example 1:</strong></p>
<p><strong>services/store.js</strong></p>
<pre><code class="language-js">import { getOwner } from '@ember/application';
import Store from 'ember-data/store';

export default Store.extend({
  modelFactoryFor(modelName) {
    if (someCustomCondition) {
      return getOwner(this).factoryFor(someFactoryName);
    }
    
    return this._super(modelName);
  }
});
</code></pre>
<h4 id="modelmodelname"><a class="header" href="#modelmodelname"><code>Model.modelName</code></a></h4>
<p><code>ember-data</code> currently sets <code>modelName</code> onto the <code>klass</code> accessible via the <code>factory</code>. For classes that do not
inherit from <code>DS.Model</code> this would not be done, although end users may do so themselves in their implementations
if so desired.</p>
<h3 id="what-is-a-valid-factory"><a class="header" href="#what-is-a-valid-factory">What is a valid factory?</a></h3>
<p>The default export of a custom ModelClass <strong>MUST</strong> conform to the requirements of <code>Ember.factoryFor</code>. The requirements
of <code>factoryFor</code> are currently underspecified; however, in practice, this means that the default export is an
instantiable class with a static <code>create</code> method and an instance <code>destroy</code> method or that inherits from <code>EmberObject</code>
(which provides such methods).</p>
<p><strong>Example 2:</strong></p>
<pre><code class="language-javascript">import { assign } from '@ember/polyfills';

export default class CustomModel {
  constructor(createArgs) {
    assign(this, createArgs);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="language-javascript">import EmberObject from '@ember/object';

export default class CustomModel extends EmberObject {
  constructor(createArgs) {
    super(createArgs);
  }
}
</code></pre>
<p>Custom classes for models should expect their constructor to receive a single argument: an object with <em>at least</em>
the following.</p>
<ul>
<li>A <code>recordData</code> instance accessible via <code>getRecordData</code> (see below)</li>
<li>Any properties passed as the second arg to <code>createRecord</code></li>
<li>An <code>owner</code> accessible via <code>Ember.getOwner</code></li>
<li>Any DI injections</li>
<li>any other properties that <code>Ember</code> chooses to pass to a class instantiated via <code>factory.create</code> (currently none)</li>
</ul>
<h3 id="getrecorddata"><a class="header" href="#getrecorddata">getRecordData</a></h3>
<p>Every <code>record</code> (instance of the class returned by <code>modelFactoryFor</code>) will have an associated <a href="https://github.com/emberjs/rfcs/pull/293">RecordData</a>
which contains the backing data for the id, type, attributes and relationships of that record.</p>
<p>This backing data can be accessed by using the <code>getRecordData</code> util on the <code>record</code> (or on the <code>createArgs</code> passed to
a record). Using <code>getRecordData</code> on a <code>record</code> is only guaranteed after the record has been instantiated. During
instantiation, this call should be made on the <code>createArgs</code> object passed into the record.</p>
<p><strong>Example 4</strong></p>
<pre><code class="language-javascript">import { getRecordData } from 'ember-data';

export default class CustomModel {
  constructor(createArgs) {
    // during instantiation, `recordData` is available by calling `getRecordData` on createArgs
    let recordData = getRecordData(createArgs);
  }
  someMethod() {
    // post instantiation, `recordData` is available by calling `getRecordData` on the instance
    let recordData = getRecordData(this);
  }
  destroy() {
    // ... do teardown
  }
  static create(createArgs) {
    return new this(createArgs);
  }
}
</code></pre>
<h2 id="how-we-teach-this-59"><a class="header" href="#how-we-teach-this-59">How we teach this</a></h2>
<p>This API would be intended for addon-authors and power users. It is not expected
that most apps would implement custom models, much as it is not expected that most
apps would implement custom <code>RecordData</code>. The teaching story would be limited to
documenting the nature and purpose of <code>modelFactoryFor</code>.</p>
<h2 id="drawbacks-83"><a class="header" href="#drawbacks-83">Drawbacks</a></h2>
<ul>
<li>Users may try to use the hook to instantiate records on their own. Ultimately, the store
should still do the instantiating.</li>
</ul>
<h2 id="alternatives-85"><a class="header" href="#alternatives-85">Alternatives</a></h2>
<p>Users could define models in <code>models/*.js</code> that utilize a custom <code>ModelClass</code>.
However, such an API for custom classes would exclude the ability to dynamically
generate classes.</p>
<h2 id="unresolved-questions-59"><a class="header" href="#unresolved-questions-59">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-09-10
RFC PR: https://github.com/emberjs/rfcs/pull/373</p>
<hr />
<h1 id="element-modifier-manager"><a class="header" href="#element-modifier-manager">Element Modifier Manager</a></h1>
<h2 id="summary-88"><a class="header" href="#summary-88">Summary</a></h2>
<p>This RFC proposes a low-level primitive for defining element modifiers. It is a parent to the <a href="https://github.com/emberjs/rfcs/pull/353">Modifiers RFC</a>.</p>
<h2 id="motivation-89"><a class="header" href="#motivation-89">Motivation</a></h2>
<p>Ever since Ember 1.0 we have had the concept of element modifiers, however Ember only exposes one modifier; <code>{{action}}</code>. We also do not provide a mechanism for defining your own modifiers and managing their life cycles.</p>
<p>As <a href="https://github.com/emberjs/rfcs/pull/353#issuecomment-417769349">pointed out</a> in the <a href="https://github.com/emberjs/rfcs/pull/353">Element Modifiers RFC</a> we should expose the underlying infrastructure that makes element modifiers possible. Based on our experience, we believe it would be beneficial to open up these new primitives to the wider community. The largest benefit is that it allows the community to experiment with and iterate on APIs outside of the core framework.</p>
<p>This RFC is in the same spirit as the <a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md">custom components RFC</a>.</p>
<h2 id="detailed-design-77"><a class="header" href="#detailed-design-77">Detailed design</a></h2>
<p>This RFC introduces the concept of <em>modifier managers</em>. A modifier manager is an object that is responsible for coordinating the lifecycle events that occurs when invoking, installing and updating an element modifier.</p>
<h3 id="registering-modifier-managers"><a class="header" href="#registering-modifier-managers">Registering modifier managers</a></h3>
<p>Modifier managers are registered with the <code>modifier-manager</code> type in the
application's registry. Similar to services, modifier managers are singleton
objects (i.e. <code>{ singleton: true, instantiate: true }</code>), meaning that Ember
will create and maintain (at most) one instance of each unique modifier
manager for every application instance.</p>
<p>To register a modifier manager, an addon will put it inside its <code>app</code> tree:</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  // ...
});
</code></pre>
<p>(Typically, the convention is for addons to define classes like this in its
<code>addon</code> tree and then re-export them from the <code>app</code> tree. For brevity, we will
just inline them in the <code>app</code> tree directly for the examples in this RFC.)</p>
<p>This allows the modifier manager to participate in the DI system – receiving
injections, using services, etc. Alternatively, modifier managers can also
be registered with imperative API. This could be useful for testing or opt-ing
out of the DI system. For example:</p>
<pre><code class="language-js">// ember-basic-modifier/app/initializers/register-basic-modifier-manager.js

const MANAGER = {
  // ...
};

export function initialize(application) {
  // We want to use a POJO here, so we are opt-ing out of instantiation
  application.register('modifier-manager:basic', MANAGER, { instantiate: false });
}

export default {
  name: 'register-basic-modifier-manager',
  initialize
};
</code></pre>
<h2 id="determining-which-modifier-manager-to-use"><a class="header" href="#determining-which-modifier-manager-to-use">Determining which modifier manager to use</a></h2>
<p>When invoking the modifier <code>&lt;p {{foo baz bar=bar}} /&gt;</code>, Ember will first resolve the
modifier class (<code>modifier:foo</code>, usually the <code>default</code> export from
<code>app/modifiers/foo.js</code>). Next, it will determine the appropiate modifier
manager to use based on the resolved modifier class.</p>
<p>Ember will provide a new API to assign the modifier manager for a element modifier
class:</p>
<pre><code class="language-js">// my-app/app/modifier/foo.js

import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setModifierManager } from '@ember/modifier';

export default setModifierManager(createManager, EmberObject.extend({
  // ...
}));
</code></pre>
<pre><code class="language-js">// my-app/app/modifier/basic-manager.js

// ...

export function createManager(owner) {
  return new BasicManager(owner);
}
</code></pre>
<p><code>setModifierManager</code> takes two parameters. The first parameter is a function that takes an <code>Owner</code> and returns an instance of a manager. The second parameter is the base class that applications would extend from.</p>
<p>In reality, an app developer would never have to write this in their apps,
since the modifier manager would already be assigned on a super-class provided
by the framework or an addon. The <code>setModifierManager</code> function is essentially
a low-level API designed for addon authors and not intended to be used by app
developers. Attempting to reassign the modifier manager when one is already
assinged on a super-class will be an error. If no modifier manager is set, it
will also result in a runtime error when invoking the modifier.</p>
<h2 id="modifier-lifecycle"><a class="header" href="#modifier-lifecycle">Modifier Lifecycle</a></h2>
<p>Back to the <code>&lt;p {{foo baz bar=bar}}&gt;&lt;/p&gt;</code> example.</p>
<p>Once Ember has determined the modifier manager to use, it will be used to manage the modifiers's lifecycle.</p>
<h3 id="createmodifier"><a class="header" href="#createmodifier"><code>createModifier</code></a></h3>
<p>The first step is to create an instance of the modifier. Ember will invoke the modifier manager's <code>createModifier</code> method:</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args);
  },
});
</code></pre>
<p>The <code>createModifier</code> method on the modifier manager is responsible for taking the modifier's factory and the arguments passed to the modifier (the ... in {{foo ...}}) and return an instantiated modifier.</p>
<p>The first argument passed to <code>createModifier</code> is the result returned from the <code>factoryFor</code> API. It contains a class property, which gives you the the raw class (the default export from app/modifiers/foo.js) and a create function that can be used to instantiate the class with any registered injections, merging them with any additional properties that are passed.</p>
<p>The second argument is a snapshot of the arguments passed to the modifier in the template invocation, given in the following format:</p>
<pre><code class="language-js">{
  positional: [ ... ],
  named: { ... }
}
</code></pre>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">&lt;p {{foo baz bar=bar}}&gt;&lt;/p&gt;
</code></pre>
<p>You will get the following as the second argument:</p>
<pre><code class="language-js">{
  positional: [true],
  named: {
    &quot;bar&quot;: &quot;Another RFC by Chad&quot;
  }
}
</code></pre>
<p>The arguments object should not be mutated (e.g. args.positional.pop() is no good). In development mode, it might be sealed/frozen to help prevent these kind of mistakes.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called as discovered during DOM construction</li>
<li>called in defintion order in template</li>
</ul>
<h3 id="installmodifier"><a class="header" href="#installmodifier"><code>installModifier</code></a></h3>
<p>Once the modifier instance has been created, the next step is to install the modifier on to the underlying element.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  // ...
});
</code></pre>
<p><code>installModifer</code> is responsible for giving access to the underlying element and arguments to the modifier instance.</p>
<p>The first argument passed to <code>installModifer</code> is the result of <code>createModifier</code>. The second argument is the <code>element</code> the modifier was defined on. The third argument is the same snapshot of the arguments passed to the modifier in the template invocation that <code>createModifier</code> recieved.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after all children modifier managers <code>installModifer</code> hook are called</li>
<li>called after DOM insertion</li>
</ul>
<p><strong>May or May Not</strong></p>
<ul>
<li>be called in the same tick as DOM insertion</li>
<li>have the sibling nodes fully initialized in DOM</li>
</ul>
<h3 id="updatemodifier"><a class="header" href="#updatemodifier"><code>updateModifier</code></a></h3>
<p>Modifiers are only updated when one of its arguments is changed. In this case Ember will call the manager's <code>updateModifier</code> method to give the manager the oppurtunity to reflect those changes on the modifier instance, before re-rendering.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  updateModifier(instance, args) {
    if (instance.didUpdateArguments !== undefined) {
      instance.didUpdateArguments(args.positional, args.named);
    }
  }

  // ...
});
</code></pre>
<p><code>updateModifier</code> recieves the modifier instance and also the the updated snapshot of arguments.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after the arguments to the modifier have changed</li>
</ul>
<p><strong>Never</strong></p>
<ul>
<li>called if the arguments to the modifier are constants</li>
</ul>
<h3 id="destroymodifier"><a class="header" href="#destroymodifier"><code>destroyModifier</code></a></h3>
<p><code>destroyModifier</code> will be called when the modifier is no longer needed. This is intended for performing object-model level cleanup.</p>
<pre><code class="language-js">// ember-basic-component/app/modifier-managers/basic.js

import EmberObject from '@ember/object';

export default EmberObject.extend({
  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
</code></pre>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after all children modifier manager's <code>destroyModifier</code> hook is called</li>
</ul>
<p><strong>May or May Not</strong></p>
<ul>
<li>be called in the same tick as DOM removal</li>
</ul>
<h2 id="capabilities-1"><a class="header" href="#capabilities-1">Capabilities</a></h2>
<p>In addition to the methods specified above, modifier managers are required to
have a <code>capabilities</code> property.  This property must be set to the result of
calling the <code>capabilities</code> function provided by Ember.</p>
<h3 id="versioning-2"><a class="header" href="#versioning-2">Versioning</a></h3>
<p>The first, mandatory, argument to the <code>capabilities</code> function is the modifier
manager API, which is denoted in the <code>${major}.${minor}</code> format, matching the
minimum Ember version this manager is targeting. For example:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/modifier';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.6'),

  createModifier(factory, args) {
    return factory.create(args.named);
  },

  installModifier(instance, element, args) {
    instance.element = element;
    if (instance.wasInstalled !== undefined) {
      instance.wasInstalled(args.positional, args.named);
    }
  },

  destroyModifier(instance, args) {
    if (instance.willDestroyDOM !== undefined) {
      instance.willDestroyDOM();
    }
  }
});
</code></pre>
<p>This allows Ember to introduce new capabilities and make improvements to this
API without breaking existing code.</p>
<p>Here is a hypothical scenario for such a change:</p>
<ol>
<li>
<p>Ember 3.6 implemented and shipped the modifier manager API as described in
this RFC.</p>
</li>
<li>
<p>The <code>ember-basic-modifier</code> addon released version 1.0 with the modifier
manager shown above (notably, it declared <code>capabilities('3.6')</code>).</p>
</li>
<li>
<p>In Ember 3.8, we determined that constructing the arguments object passed to
the hooks is a major performance bottleneck, and changes the API to pass a
&quot;proxy&quot; object with getter methods instead (e.g. <code>args.getPositional(0)</code> and
<code>args.getNamed('foo')</code>).</p>
<p>However, since Ember sees that the <code>basic</code> modifier manager is written to
target the <code>3.6</code> API version, it will retain the old behavior and passes the
old (more expensive) &quot;reified&quot; arguments object instead, to avoid breakage.</p>
</li>
<li>
<p>The <code>ember-basic-modifier</code> addon author would like to take advantage of
this performance optimization, so it updates its modifier manager code to
work with the arguments proxy and changes its capabilities declaration to
<code>capabilities('3.8')</code> in version 2.0.</p>
</li>
</ol>
<p>This system allows us to rapidly improve the API and take advantage of
underlying rendering engine features as soon as they become available.</p>
<p>Note that addon authors are not <em>required</em> to update to the newer API.
Concretely, modifier manager APIs have the following support policy:</p>
<ul>
<li>
<p>API versions will continue to be supported in the same major release of
Ember. As shown in the example above, <code>ember-basic-modifier</code> 1.0 (which
targets modifier manager API version 3.6), will continue to work on
Ember 3.8. However, the reverse is not true – modifier manager API version
3.8 will (somewhat obviously) not work in Ember 3.6.</p>
</li>
<li>
<p>In addition, to ensure a smooth transition path for addon authors and app
developers across major releases, each Ember version will support (at least)
the previous LTS version as of the release was made. For example, if 3.16 is
the last LTS release of the 3.x series, the modifier manager API version
3.16 will be supported by Ember 4.0 through 4.4, at minimum.</p>
</li>
</ul>
<p>Addon authors can also choose to target multiple versions of the modifier
manager API using <a href="https://github.com/pzuraq/ember-compatibility-helpers/">ember-compatibility-helpers</a>:</p>
<pre><code class="language-js">// ember-basic-modifier/app/modifier-managers/basic.js

import { gte } from 'ember-compatibility-helpers';

let ComponentManager;

if (gte('3.5')) {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.8'),

    // ...
  });
} else {
  ComponentManager = EmberObject.extend({
    capabilities: capabilities('3.6'),

    // ...
  });
}

export default ComponentManager;
</code></pre>
<p>Since the conditionals are resolved at build time, the irrevelant code will be
stripped from production builds, avoiding any deprecation warnings.</p>
<h3 id="optional-features-1"><a class="header" href="#optional-features-1">Optional Features</a></h3>
<p>The second, optional, argument to the <code>capabilities</code> function is an object
enumerating the optional features requested by the modifier manager.</p>
<p>In the hypothical example above, while the &quot;reified&quot; arguments objects may be
a little slower, they are certainly easier to work with, and the performance
may not matter to but the most performance critical modifiers. A modifier
manager written for Ember 3.8 (again, only hypothically) and above would be
able to explicitly opt back into the old behavior like so:</p>
<pre><code class="language-js">// ember-basic-component/app/component-managers/basic.js

import { capabilities } from '@ember/component';
import EmberObject from '@ember/object';

export default EmberObject.extend({
  capabilities: capabilities('3.8', {
    reifyArguments: true
  }),

  // ...
});
</code></pre>
<p>In general, we will aim to have the defaults set to as bare-bone as possible,
and allow the component managers to opt into the features they need in a PAYGO
(pay-as-you-go) manner, which aligns with the Glimmer VM philosophy. As the
rendering engine evolves, more and more feature will become optional.</p>
<p>At this time this RFC does not specify any optional capabilties for the initial release.</p>
<h2 id="how-we-teach-this-60"><a class="header" href="#how-we-teach-this-60">How we teach this</a></h2>
<p>What is proposed in this RFC is a low-level primitive. We do not expect most users to interact with this layer directly. Instead, most users will simply benefit from this feature by subclassing these special modifiers provided by addons.</p>
<h2 id="drawbacks-84"><a class="header" href="#drawbacks-84">Drawbacks</a></h2>
<p>In the long term, there is a risk of fragmentating the Ember ecosystem with many competing modifier APIs. However, given the Ember community's strong desire for conventions, this seems unlikely. We expect this to play out similar to the data-persistence story – there will be a primary way to do things (Ember Data), but there are also plenty of other alternatives catering to niche use cases that are underserved by Ember Data.</p>
<h2 id="alternatives-86"><a class="header" href="#alternatives-86">Alternatives</a></h2>
<p>Instead of focusing on exposing enough low-level primitives we can just ship the high level API as described in <a href="https://github.com/emberjs/rfcs/pull/353">RFC#353</a>.</p>
<h2 id="unresolved-questions-60"><a class="header" href="#unresolved-questions-60">Unresolved questions</a></h2>
<p>TBD?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-09-13
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/375
Tracking: https://github.com/emberjs/rfc-tracking/issues/15</p>
<hr />
<h1 id="summary-89"><a class="header" href="#summary-89">Summary</a></h1>
<p>Deprecate the computed <code>.property()</code> modifier which can be used to add dependent
keys to computed properties.</p>
<h1 id="motivation-90"><a class="header" href="#motivation-90">Motivation</a></h1>
<p>Currently, computed properties can use the <code>.property</code> modifier to add dependent
keys to a computed <em>after</em> the computed has been declared:</p>
<pre><code class="language-js">foo: computed('strings', {
  get() {
    return this.strings.filter(s =&gt; s.includes(this.filterText));
  }
}).property('filterText')
</code></pre>
<p>In most cases, this ability is redundant, since the dependent keys can be moved
into the original computed declaration and be equivalent:</p>
<pre><code class="language-js">foo: computed('strings', 'filterText', {
  get() {
    return this.strings.filter(s =&gt; s.includes(this.filterText));
  }
})
</code></pre>
<p>The one exception is in the case of computed <em>macros</em>, specifically macros which
accept a <em>function</em> such as <code>filter()</code> and <code>map()</code>:</p>
<pre><code class="language-js">foo: filter('strings', function(s) {
  return s.includes(this.filterText);
}).property('filterText')
</code></pre>
<p>The issue stems from the fact that the inner function can access the class
instance and use dynamic properties from it, and this access is opaque to the
macro.</p>
<p>This API is confusing since it bears a strong resemblance to the older style
of computed property declarations, and at first glance appears to be invalid.
The few edge-case macros where it does legitimately apply can be rewritten to
accept more dependent keys, making it fully redundant.</p>
<h1 id="transition-path-12"><a class="header" href="#transition-path-12">Transition Path</a></h1>
<p>As mentioned above, macros which receive a callback function as an argument are
the only valid use of <code>.property()</code> in current Ember. Currently, there are two
such macros in Ember core: <code>map</code> and <code>filter</code>.</p>
<p>This RFC proposes that these macros be updated to receive additional dependent
keys via their public API directly via an optional second parameter which is an
array of the keys:</p>
<pre><code class="language-ts">function filter(filteredPropertyKey: string, callback: Function): ComputedProperty;
function filter(
  filteredPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;

function map(mappedPropertyKey: string, callback: Function): ComputedProperty;
function map(
  mappedPropertyKey: string,
  additionalDependentKeys: string[],
  callback: Function
): ComputedProperty;
</code></pre>
<h2 id="deprecation-timeline-1"><a class="header" href="#deprecation-timeline-1">Deprecation Timeline</a></h2>
<p>The deprecation should follow these steps:</p>
<ul>
<li>Update <code>filter</code> and <code>map</code> to their new APIs</li>
<li>Add a deprecation warning to uses of <code>.property</code> which add dependent keys to
computed properties.</li>
<li>Add an optional feature to turn the deprecation into an assertion</li>
<li>After enough time has passed for addons and users to update, enable the
optional feature by default in new addons and apps</li>
<li>Fully remove <code>.property()</code> in Ember v4.0.0</li>
</ul>
<h1 id="how-we-teach-this-61"><a class="header" href="#how-we-teach-this-61">How We Teach This</a></h1>
<p>In most cases, we shouldn't have to teach anything. There are already linting
rules prohibiting <code>.property()</code> usage, and the recommended path is to provide
all dependent keys in the original declaration of the computed property. For
users of <code>map</code> and <code>filter</code> we should ensure that they new documentation is
clear on how to add dependent keys to either macro.</p>
<p>For addon authors that have created their own macros which rely on callbacks and
have similar issues, we should demonstrate how they can structure their macro
API to accept additional dependent keys.</p>
<h1 id="drawbacks-85"><a class="header" href="#drawbacks-85">Drawbacks</a></h1>
<p>The new proposed APIs for <code>filter</code> and <code>map</code> may be somewhat confusing, since
only the first argument will be filtered/mapped</p>
<h1 id="alternatives-87"><a class="header" href="#alternatives-87">Alternatives</a></h1>
<p>We could allow additional dependent keys to be passed via an options argument:</p>
<pre><code class="language-ts">filter(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;

map(dependentKey: string, options: {
  additionalDependentKeys: [],
  callback: Function,
}): ComputedProperty;
</code></pre>
<p>This is more verbose, but would be very clear.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-07
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/386
Tracking: https://github.com/emberjs/rfc-tracking/issues/3</p>
<hr />
<h1 id="remove-jquery-by-default"><a class="header" href="#remove-jquery-by-default">Remove jQuery by default</a></h1>
<h2 id="summary-90"><a class="header" href="#summary-90">Summary</a></h2>
<p>This RFC proposes deprecating those public APIs that are coupled to jQuery, and to finally remove them (with an optional
backport), so Ember apps will be built <em>by default</em> without bundling jQuery. </p>
<p>While <a href="https://emberjs.github.io/rfcs/0294-optional-jquery.html">RFC294</a>, which is already implemented, provides
a way to opt out of jQuery, the intention of this RFC is to push this a step further and essentially move from the
current &quot;included by default, allow opt out&quot; strategy to &quot;excluded by default, allow opt in&quot;.</p>
<p>In that way it is not meant as a replacement of the previous RFC, but rather as a continuation and the logical next step.</p>
<h2 id="motivation-91"><a class="header" href="#motivation-91">Motivation</a></h2>
<h3 id="lean-by-default"><a class="header" href="#lean-by-default">Lean by default</a></h3>
<p>This follows the philosophy of making Ember leaner (or <em>higher octane</em> if you want), by deprecating unused or 
non-essential APIs.
New apps will be smaller and faster by default, while allowing to opt-in into using jQuery when needed.</p>
<h3 id="why-the-current-opt-out-strategy-is-not-sufficient"><a class="header" href="#why-the-current-opt-out-strategy-is-not-sufficient">Why the current opt-out strategy is not sufficient</a></h3>
<p>The biggest problem in the current opt-out strategy is that many addons still require jQuery. Many of these usages
seem to be rather &quot;accidental&quot;, in that the full power of jQuery is not really needed for the given task, and could be 
rather easily refactored to use only native DOM APIs. But as it is available anyway by default, and it is very convenient, 
authors probably tend to use it without being fully aware of the consequences, that it prohibits jQuery-less builds for 
all its consumers.</p>
<p>In that way the general availability of jQuery <em>by default</em> and Ember APIs around it like <code>this.$()</code> tend to manifest the 
status quo, the coupling of Ember to jQuery. In fact I could observe an actual <em>increase</em> of jQuery usage numbers
(see below), rather than a decrease, which was an intention of the previous RFC. So it is not only a concern of the core 
Ember library to enable jQuery-less builds, but the whole addon ecosystem has to go through that transition.</p>
<p>In that regard early deprecations will help prevent this accidental use of jQuery on the one side, and on the other side
for addons that depend on jQuery already they will provide an incentive and a long enough transition period to refactor 
their jQuery usage to use standard DOM APIs.</p>
<h3 id="jquery-might-still-be-needed"><a class="header" href="#jquery-might-still-be-needed">jQuery might still be needed</a></h3>
<p>This RFC does not propose to discourage the use of jQuery. There are legitimate cases where you still want to have it. 
And this is also true for addons, especially those that basically wrap other jQuery-based libraries like jQuery plugins
in an Ember friendly way. For those cases, there should be an <em>opt-in</em> path to continue bundling jQuery and to preserve
the existing APIs around it. This is what the <code>@ember/jquery</code> package is meant for.</p>
<h2 id="transition-path-13"><a class="header" href="#transition-path-13">Transition path</a></h2>
<h3 id="add-deprecations"><a class="header" href="#add-deprecations">Add deprecations</a></h3>
<p>All current public APIs that are coupled to jQuery should be deprecated via the usual deprecation process. 
This specifically involves:</p>
<ul>
<li>adding a (universal, non-silenceable) deprecation warning to <code>Ember.$()</code></li>
<li>adding a deprecation warning to <code>this.$()</code> in an <code>Ember.Component</code></li>
<li>adding a deprecation warning to <code>this.$()</code> in component integration tests, based on <code>setupRenderingTest()</code> </li>
</ul>
<h3 id="this-in-old-style-tests"><a class="header" href="#this-in-old-style-tests"><code>this.$()</code> in old style tests</a></h3>
<p><code>this.$()</code> in tests based on the old <code>moduleForComponent()</code> based testing APIs will not be specifically deprecated, 
as these legacy testing APIs will eventually be deprecated altogether, as already envisaged in RFC232.</p>
<h3 id="extend-emberjquery-package"><a class="header" href="#extend-emberjquery-package">Extend <code>@ember/jquery</code> package</a></h3>
<p>For apps and addons that have to or choose to still require jQuery, they can add this package to its dependencies.
This will provide a way to retain the deprecated and later removed APIs. So by adding this to your dependencies this 
would effectively be the way to <em>opt-in</em> to require jQuery.</p>
<p>RFC294 already introduced this package, being responsible to include jQuery into the JavaScript bundle. As part of this
RFC the scope of this addon will be extended to also reintroduce the deprecated APIs, but <em>without</em> triggering any 
deprecation warnings for <code>this.$()</code> in a component.</p>
<p>As the default <code>EventDispatcher</code>, which currently dispatches jQuery events when jQuery is enabled, will eventually 
support native events only (see the Timeline below), the addon also needs to replace it with one that again dispatches
jQuery events for compatibility with existing jQuery-based code. This can happen in a similar way as 
<a href="https://github.com/rwjblue/ember-native-dom-event-dispatcher">ember-native-dom-event-dispatcher</a> did it, just the other
way around.</p>
<p><strong>This effectively makes the integration of jQuery a feature of this addon, rather than Ember itself, which is freed from
the burden to care about this.</strong></p>
<p>So effectively, for the Ember 3.x release cycle, adding this package will not change the behavior in any significant way,
other than removing the mentioned deprecation warnings, as Ember will still have these APIs available. However starting 
with Ember 4.0, which will have these APIs removed and not include jQuery integration features anymore, this 
package will make sure jQuery remains included and it will add the now removed APIs back again, so any jQuery depending
code will continue to work just as before. Also see the timeline below.</p>
<p>As <code>ember-cli-babel</code> will currently transform <code>import $ from 'jquery';</code> to use <code>Ember.$</code> again, it must be made aware of
the <code>@ember/jquery</code> package so it tells <code>babel-plugin-ember-modules-api-polyfill</code> not to convert those imports to the 
global <code>Ember.$</code>. Instead the package itself should provide the necessary shim to make <code>import $ from 'jquery';</code> work.</p>
<p>Addons that continue to depend on jQuery would have to list this package as a dependency in their <code>package.json</code>, 
to make their consuming app automatically include jQuery and the related APIs in its bundle as mentioned above.
Thereby they make their dependency on jQuery explicit, which in turn helps users to make an educated choice if they 
deem this to be acceptable.</p>
<h3 id="extend-ember-fetch"><a class="header" href="#extend-ember-fetch">Extend ember-fetch</a></h3>
<p>The <code>ember-fetch</code> addon integrates the newer <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><code>Fetch API</code></a>
nicely into an Ember app, with an (optional) polyfill for older browsers. This can be used as a replacement for the
jQuery-based <code>ember-ajax</code>. </p>
<p>One piece that is missing so far when switching is a convenient way to customize all outgoing requests, e.g. to add
HTTP headers for authentication tokens. When using jQuery's AJAX implementation, this could be easily done using its
<a href="http://api.jquery.com/jquery.ajaxprefilter/"><code>prefilter</code></a> function. To facilitate something similar when using 
<code>ember-fetch</code>, the addon should be extended with an appropriate API, e.g. by adding a simple service through which 
fetch requests are issued, which provides similar features for customization. The exact API of such a service is however
out of scope for this RFC.</p>
<h3 id="make-ember-data-use-ember-fetch"><a class="header" href="#make-ember-data-use-ember-fetch">Make ember-data use ember-fetch</a></h3>
<p>It must be ensured that all parts of the core Ember experience work flawlessly without jQuery. Currently <code>ember-data</code>
is still relying on jQuery for its XHR requests. By the time this RFC is implemented (i.e. the deprecation messages are 
added), it must work out of the box without jQuery. </p>
<p>Fortunately <a href="https://github.com/emberjs/data/pull/5386">migration efforts</a> are well advanced to support the <code>fetch</code> API
through <code>ember-fetch</code>, so we can expect that to land soon enough that it does not block the transition.</p>
<h3 id="update-app-blueprint"><a class="header" href="#update-app-blueprint">Update app blueprint</a></h3>
<p>The blueprint to create a new app with <code>ember new</code> should be updated to not use jQuery by default. This involves to</p>
<ul>
<li>disable jQuery integration by default (in <code>config/optional-features.json</code>)</li>
<li>remove the <code>@ember/jquery</code> package</li>
<li>replace <code>ember-ajax</code> with <code>ember-fetch</code></li>
<li>add the <a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/docs/rules/no-jquery.md"><code>no-jquery</code></a> rule to the
default ESLint config</li>
</ul>
<h3 id="timeline-2"><a class="header" href="#timeline-2">Timeline</a></h3>
<p>During Ember 3.x:</p>
<ol>
<li>migrate the jQuery integration features to the <code>@ember/jquery</code> package</li>
<li>update the blueprints as stated above</li>
<li>add deprecation warnings as stated above</li>
</ol>
<p>Upon Ember 4.0</p>
<ul>
<li>remove deprecated functions</li>
<li>remove the jQuery specific code paths in the <code>EventDispatcher</code></li>
</ul>
<h2 id="how-we-teach-this-62"><a class="header" href="#how-we-teach-this-62">How we teach this</a></h2>
<p>As part of the efforts to make jQuery optional, the guides have already been updated to have all examples teach native 
DOM APIs instead of jQuery, and the new testing APIs. 
The <a href="https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_jquery-integration">jQuery migration guide</a>
already mentions the APIs that are not available anymore without jQuery and how to opt-out now.</p>
<p>Activating the <code>no-jquery</code> ESLint rule will warn developers about any usages of the jQuery-based APIs being deprecated
here. </p>
<p>The newly added deprecation messages should link to a deprecation guide, which will provide details on how to silence
these deprecations, either by using native DOM APIs only or by installing <code>@ember/jquery</code> to explicitly opt-in into 
jQuery. </p>
<p>For apps the tone of it should be neutral regarding jQuery itself, in the sense that using jQuery is neither
bad nor good by itself. It depends on the context of the app if using jQuery makes sense or not. It is just that <em>Ember</em> 
does no need it anymore, so it is not part of the default Ember experience anymore.</p>
<p>For addons the story is a bit different, in that they are not aware of their app's context, so they should abstain from
using jQuery if possible. See the <a href="0386-remove-jquery.html#motivation">Motivation</a> chapter above.</p>
<h2 id="drawbacks-86"><a class="header" href="#drawbacks-86">Drawbacks</a></h2>
<h3 id="churn-3"><a class="header" href="#churn-3">Churn</a></h3>
<p>A vast amount of addons still depend on jQuery, so adding the deprecations will add some considerable churn for the addon
ecosystem. As of writing this, there are:</p>
<ul>
<li><a href="https://emberobserver.com/code-search?codeQuery=Ember.%24">407 addons</a> using <code>Ember.$</code></li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=addon%2Fcomponents">546 addons</a> using <code>this.$</code> in components</li>
<li><a href="https://emberobserver.com/code-search?codeQuery=this.%24&amp;fileFilter=tests">994 addons</a> using <code>this.$</code> in tests</li>
</ul>
<p>A good amount of that churn can be mitigated by</p>
<ul>
<li>existing codemods that migrate tests</li>
<li>having an easy way, given by the <code>@ember/jquery</code> package, to opt-in to continue bundling jQuery, and to restore the 
deprecated APIs, so no further refactorings are required </li>
</ul>
<h2 id="alternatives-88"><a class="header" href="#alternatives-88">Alternatives</a></h2>
<p>Stick to the current <em>opt-out</em> process.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-14
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/389
Tracking: https://github.com/emberjs/rfc-tracking/issues/42</p>
<hr />
<h1 id="dynamic-tag-names-in-glimmer-templates"><a class="header" href="#dynamic-tag-names-in-glimmer-templates">Dynamic tag names in glimmer templates.</a></h1>
<h2 id="summary-91"><a class="header" href="#summary-91">Summary</a></h2>
<p>With the transition from inner-html semantics to outer-html semantics in components, we lost one feature: Being
able dynamically define the tag name of components.</p>
<p>I think it was an useful feature and we should find a way to bring it back.</p>
<h2 id="motivation-92"><a class="header" href="#motivation-92">Motivation</a></h2>
<p>Although not something we use every day, there is a need for some components to have a dynamic tag name.</p>
<p>This is most often used for certain low-level <em>presentational</em> components.</p>
<p>Take for instance a component named <code>&lt;Panel&gt;</code> that is used to encapsulate some presentation concerns.
The template of that component could be like this:</p>
<pre><code class="language-hbs">&lt;div class=&quot;pt-10 pb-10 ps-20 box-shadow&quot; ...attributes&gt;
  {{yield}}
&lt;/div&gt;
</code></pre>
<p>For accessibility and semantic reasons, sometimes a <code>&lt;div&gt;</code> may not be the best kind of tag.
We might want the panel to be a <code>&lt;section&gt;</code> element, or an <code>&lt;aside&gt;</code> when it's content is somewhat unrelated
with the rest of the page. Or maybe a <code>&lt;legend&gt;</code> if it's and the end of a form.</p>
<p>With the <code>element</code> helper proposed in this RFC, this can be accomplished with something like this:</p>
<pre><code class="language-hbs">{{#let (element @tagName) as |Tag|}}
  &lt;Tag class=&quot;pt-10 pb-10 ps-20 box-shadow&quot; ...attributes&gt;
    {{yield}}
  &lt;/Tag&gt;
{{/let}}
</code></pre>
<h2 id="detailed-design-78"><a class="header" href="#detailed-design-78">Detailed design</a></h2>
<p>We propose to add a new <code>element</code> helper that takes a single positional argument.</p>
<ul>
<li>When passed a non-empty string it generates a contextual component that, when invoked, renders an element with the same tag name as the passed string, along with the passed attributes (if any), modifiers (if any) and yields to given block (if any).</li>
<li>When passed an empty string, it generates a contextual compoment that, when invoked, yields to the given block without wrapping it an element and ignores any passed modifiers and attributes.</li>
<li>When passed <code>null</code> or <code>undefined</code>, it will return <code>null</code>.</li>
<li>When passed any other values (e.g. a boolean or a number), it will result in a development mode assertion.</li>
</ul>
<p>Example:</p>
<pre><code class="language-hbs">{{#let (element @htmlTag) as |Tag|}}
  &lt;Tag class=&quot;my-element&quot; {{on &quot;click&quot; this.tagClicked}}&gt;Hello&lt;/Tag&gt;
{{/let}}

{{!-- when @htmlTag=&quot;button&quot; --}}
&lt;button class=&quot;my-element&quot; {{on &quot;click&quot; this.tagClicked}}&gt;Hello&lt;/button&gt;

{{!-- when @htmlTag=&quot;&quot; --}}
Hello

{{!-- when @htmlTag=null or @htmlTag=undefined, it renders nothing --}}

{{!-- when @htmlTag=true or @htmlTag=1, it throws in development mode --}}
</code></pre>
<p>Unlike ids, classes or other attributes, the tag name of DOM element cannot be changed in runtime.</p>
<p>To help the user understand that changing the tag of an element in runtime is an expensive operation,
the syntax is intentionally chosen to express that changes in the tag name will turn down the given block
and recreate it again.</p>
<p>Having dynamic tag names can also open the door to possible XSS vulnerabilities if developers allow user-input
to become tag names (e.g. <code>xlink:</code>) . To prevent that, this helper will throw an error for any tag name containing anyting
but lowercase letters and dashes.</p>
<p>A working proof of concept of this approach has been created in https://github.com/tildeio/ember-element-helper</p>
<p>Shall this RFC me accepted, that helper would be ported to Ember.js itself, perhaps making it more efficient
on the process.</p>
<h2 id="how-we-teach-this-63"><a class="header" href="#how-we-teach-this-63">How we teach this</a></h2>
<p><em>It's vitally important that developers have awareness the negative impact that misuse of dynamic tags can have on the accessibility of an Ember application.</em></p>
<p>While dynamic tags enable a great deal of flexibility in components, it's essential to recognize that these can also negatively impact accessibility. Developers should be keenly aware of the appropriate role that should be applied per HTML element (as specified in the <a href="https://www.w3.org/WAI/PF/aria/roles">WAI-ARIA specification</a>), and ensure that the role is also updated, if necessary, as the tag name is changed. In some cases, the use of native, semantic HTML elements may eliminate the need to apply a role at all, so developers should consult the WAI-ARIA specification until they are certain of the correct use for their specific use cases.</p>
<p>This new helpers will be added to the list of <a href="https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers">built-in helpers</a> along
with its cousins <code>component</code>, <code>array</code>, <code>each</code>, etc...</p>
<p>Some meaningful example for the docs could look like this (extracted from a real use case):</p>
<pre><code class="language-hbs">{{!-- sidebar.hbs, a template-only component --}}
{{#let (element (or @htmlTag &quot;aside&quot;)) as |Tag|}}
  &lt;Tag ...&gt;...&lt;/Tag&gt;
{{/let}}
</code></pre>
<pre><code class="language-hbs">&lt;Sidebar @htmlTag=&quot;nav&quot;&gt;...&lt;/Sidebar&gt;
</code></pre>
<p>Since this feature is not very commonly used, it should not be mentioned in the more beginner-friendly portion
of the guides. However, the <em>Components &gt; Customizing a Component's Element</em> section is a perfect fit for this.</p>
<h2 id="drawbacks-87"><a class="header" href="#drawbacks-87">Drawbacks</a></h2>
<p>Admittedly this syntax is somewhat convoluted, as it involves using the <code>let</code> helper, the new <code>element</code>
helper that yields a contextual component that is then invoked using angle-bracket syntax.</p>
<p>This syntax is intentional to make clear that any change in the tag name would yield a new contextual component,
effectively tearing down the previous one before rendering the new one, but I can see perceiving this
as unnecessarily complex.</p>
<h2 id="alternatives-89"><a class="header" href="#alternatives-89">Alternatives</a></h2>
<p>We can decide not to do anything and leave this problem to be solved in user space, as it can be
solved using only public APIs.</p>
<p>We can also propose other alternative syntaxes. For instance, we could have a special built-in component for this:</p>
<pre><code class="language-hbs">&lt;DynamicElement @tagName={{@tagName}} class=&quot;some-class&quot; ...attributes&gt;
&lt;/DynamicElement&gt;
</code></pre>
<h2 id="unresolved-questions-61"><a class="header" href="#unresolved-questions-61">Unresolved questions</a></h2>
<hr />
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-22
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/391
Tracking: https://github.com/emberjs/rfc-tracking/issues/14</p>
<hr />
<h1 id="router-helpers"><a class="header" href="#router-helpers">Router Helpers</a></h1>
<h2 id="summary-92"><a class="header" href="#summary-92">Summary</a></h2>
<p>This RFC introduces new router helpers that represent a decomposition of functionality of what we commonly use <code>{{link-to}}</code> for. Below is a list of the new helpers:</p>
<pre><code class="language-hbs">{{url-for}}
{{root-url}}
{{is-active}}
{{is-loading}}
{{is-transitioning-in}}
{{is-transitioning-out}}
</code></pre>
<p>This represents a super set of the functionality provided by <a href="https://github.com/rwjblue/ember-router-helpers/">Ember Router Helpers</a> which has provided this RFC that confidence that a decomposition is possible.</p>
<p>This RFC does <strong>not</strong> deprecate <code>{{link-to}}</code> or <code>{{query-params}}</code>. These deprecations will come in the form of a deprecation RFC.</p>
<h2 id="motivation-93"><a class="header" href="#motivation-93">Motivation</a></h2>
<p><code>{{link-to}}</code> is the primary way for Ember applications to transition from route to route in your application. While this works for a lot of cases there are some use cases that are not well supported or supported at all by the framework. Below is an enumeration of cases that <code>{{link-to}}</code> does not address.</p>
<h3 id="anchor-tags"><a class="header" href="#anchor-tags">Anchor Tags</a></h3>
<p>We currently do not have a good solution for transitioning solely based on HTML anchors defined in the templating layer. For instance let say you are using <a href="https://github.com/ember-intl/ember-intl">Ember Intl</a> to do internationalization for your application. Ember Intl uses the <a href="http://userguide.icu-project.org/formatparse/messages">ICU message format</a> for the actual translation strings and supports having HTML within the string. Now lets say you want to put a link in a translation string and have it work like <code>{{link-to}}</code> works. In that case you either have to roll your own solution or use something like <a href="https://github.com/intercom/ember-href-to">Ember-href-to</a>. Another example where this would be useful is that links within markdown produced by addons like <a href="https://github.com/gcollazo/ember-cli-showdown">Ember-CLI-Showdown</a> would just work. API's like <code>RouterService#transitionTo</code> can transition an application using relative URLs and we have an opportunity to leverage this functionality to support this use case.</p>
<h3 id="extensibility-of-link-to"><a class="header" href="#extensibility-of-link-to">Extensibility Of <code>{{link-to}}</code></a></h3>
<p>In 2.11 we moved <code>LinkComponent</code> from <code>private</code> to <code>public</code> largely because there was no other way to modify the behavior of <code>{{link-to}}</code> and it had effectively become de-facto public API. That being said, it is less than desirable to <code>reopen</code> or <code>extend</code> framework objects to gain access to the functionality to create some application specific primitive. For example <a href="https://github.com/kaliber5/ember-bootstrap/">Ember Bootsrap</a> extends the <a href="https://github.com/kaliber5/ember-bootstrap/blob/master/addon/components/base/bs-dropdown/menu/link-to.js"><code>LinkComponent</code></a> and then layers more functionality on top of it. Addons would be better served if they had access to more primitive functionality.</p>
<h3 id="css-class-magic"><a class="header" href="#css-class-magic">CSS Class Magic</a></h3>
<p><code>{{link-to}}</code> adds some convienent, yet not obvious, classes to the element. These classes are:</p>
<ul>
<li><code>active</code>: applied to any <code>{{link-to}}</code> that is on the &quot;active&quot; path</li>
<li><code>disabled</code>: applied depending on the evaluation of <code>disabled=someBool</code></li>
<li><code>loading</code>: applied if one or more of the models passed are <code>undefined</code></li>
<li><code>ember-transitioning-in</code>: applied to links that are about to be <code>active</code></li>
<li><code>ember-transitioning-out</code>: applied to links that are about to be deactivated</li>
</ul>
<p>The issue with these class names is that they are not declared anywhere in your templated and are provided by the <code>LinkComponent</code> as <code>classNameBindings</code>. This effectively creates a set of reserved class names that are highly prone to colissions in your typical application.</p>
<p>Furthermore, addons like <a href="https://github.com/alexspeller/ember-cli-active-link-wrapper">ember-cli-active-link-wrapper</a> and <a href="https://github.com/zoltan-nz/ember-bootstrap-nav-link">ember-bootstarp-nav-link</a> do a ton of work arounds to get things like the <code>.active</code> class to show up on wrapping elements instead of the element directly. This is a great example that shows we are missing some primitives.</p>
<h3 id="default-query-param-serialization"><a class="header" href="#default-query-param-serialization">Default Query Param Serialization</a></h3>
<p>Lastly, <code>{{link-to}}</code> has very strange behavior when it comes to serializing query params. On a controller you declare the query params for a specific route. These query params can have defaults for them. For example if you have a controller that looks like:</p>
<pre><code class="language-js">// app/controllers/profile.js
import Controller from '@ember/controller';

export default Controller.extend({
  queryParams: ['someBool'],
  someBool: true,
})
</code></pre>
<p>and you to link to it like this:</p>
<pre><code class="language-hbs">{{#link-to 'profile'}}Profile{{/link-to}}
</code></pre>
<p>In the DOM you will have an <code>href</code> on the anchor that gets serializes as:</p>
<pre><code class="language-html">&lt;a href=&quot;/profile?someBool=true&quot; class=&quot;active ember-view&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<p>Looking at a template you would have no idea that rendering the <code>{{link-to}}</code> would result in the query params being serialized. From an implementation point of view, this is problematic as we are forced to <code>lookup</code> the <code>Route</code> and the associated <code>Controller</code> to grab the query params. This can add a non-trivial amount of overhead during rendering, especially if you have many <code>{{link-to}}</code>s on a route that link many different parts of your application. As a side-note, this is one of the things  that needs to be dealt with if we are ever to kill controllers.</p>
<h3 id="does-not-work-with-angle-bracket-invocation"><a class="header" href="#does-not-work-with-angle-bracket-invocation">Does Not Work With Angle Bracket Invocation</a></h3>
<p>Since angle bracket invocation does not support positional params, <code>{{link-to}}</code> has to adapt its public API.</p>
<h3 id="costly-api"><a class="header" href="#costly-api">Costly API</a></h3>
<p><code>{{link-to}}</code> has <a href="0391-router-helpers.html#kitchen-sink">a lot of functionality</a>, however this functionality does come at a cost for every instance of <code>{{link-to}}</code>. This is not ideal especially if you're just using <code>{{link-to}}</code> to generate a url that can be transitioned to. By providing fine grain control of the functionality, applications should see a performance boost.</p>
<h2 id="detailed-design-79"><a class="header" href="#detailed-design-79">Detailed design</a></h2>
<p>Below is a detailed design of all of the template helpers.</p>
<h3 id="url-generation-helpers"><a class="header" href="#url-generation-helpers">URL Generation Helpers</a></h3>
<p>The following helpers are to be used to construct a valid root-relative URL that will be used by the event dispatcher to perform a transition. These helpers <strong>do not</strong> pass the in memory model, meaning the model hook will always run for the route you are transitioning to.</p>
<h3 id="url-for-helper"><a class="header" href="#url-for-helper"><code>{{url-for}}</code> Helper</a></h3>
<pre><code class="language-hbs">{{url-for routeName model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{url-for routeName models=model queryParams=(hash a=a)}}
</code></pre>
<p><code>{{url-for}}</code> generates a root-relative URL as a string (which will include the application's rootUrl). When the link is clicked it will cause a transition to occur. See the <a href="0391-router-helpers.html#event-dispatcher-changes">Event Dispatcher Changes</a>. It will not serialize the default query params on the controller.</p>
<h4 id="signature-explainer"><a class="header" href="#signature-explainer">Signature Explainer</a></h4>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models or identifiers for each dynamic segment to be use for generation.</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>: Optionally pass key value pairs that will be serialized</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>String</em>: a root-relative URL as a string (which will include the application's <code>rootUrl</code>)</li>
</ul>
<h3 id="root-url-helper"><a class="header" href="#root-url-helper"><code>{{root-url}}</code> Helper</a></h3>
<p><code>{{root-url}}</code> simply returns the value from <code>Application.rootURL</code>. It can be used to prefix any <code>href</code> values you wish to hard code.</p>
<pre><code class="language-hbs">&lt;a href=&quot;{{root-url}}profile&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<p>Will result in the following for the default configuration:</p>
<pre><code class="language-html">&lt;a href=&quot;/profile&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<h4 id="signature-explainer-1"><a class="header" href="#signature-explainer-1">Signature Explainer</a></h4>
<p><code>{{root-url}}</code> does not take any parameters.</p>
<h3 id="route-state-helpers"><a class="header" href="#route-state-helpers">Route State Helpers</a></h3>
<p>The following helpers are all <em>context dependent</em>, not global. For instance you might have two copies of <code>(is-active &quot;posts&quot;)</code> in your app simultaneously where one is <code>true</code> and one is <code>false</code>, because you're in the middle of an animated transition, or because you're pre-rendering a route that hasn't been entered yet.</p>
<h3 id="is-active-helper"><a class="header" href="#is-active-helper"><code>{{is-active}}</code> Helper</a></h3>
<pre><code class="language-hbs">{{is-active 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>or</p>
<pre><code class="language-hbs">{{is-active 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p>The arguments to <code>{{is-active}}</code> have the same semantics as <code>{{url-for}}</code>, however the return value is a boolean. This should provide the same logic that determines whether to put an <code>active</code> class on a <code>{{link-to}}</code>.</p>
<h4 id="signature-explainer-2"><a class="header" href="#signature-explainer-2">Signature Explainer</a></h4>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>: Optionally pass key value pairs that will be used to determine if the route is active.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is active or not.</li>
</ul>
<h3 id="is-loading-helper"><a class="header" href="#is-loading-helper"><code>{{is-loading}}</code> Helper</a></h3>
<pre><code class="language-hbs">{{is-loading 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{is-loading 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p>The arguments to <code>{{is-loading}}</code> have the same semantics as <code>{{url-for}}</code> and <code>{{is-active}}</code>, however if any of the model(s) passed to it are unresolved e.g. evaluate to <code>undefined</code> the helper will return <code>true</code>, otherwise the helper will return <code>false</code>. This should provide the same logic that determines whether to put an <code>loading</code> class on a <code>{{link-to}}</code>.</p>
<h4 id="signature-explainer-3"><a class="header" href="#signature-explainer-3">Signature Explainer</a></h4>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>: Optionally pass key value pairs that will be used to determine if the route is loading.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is loading or not.</li>
</ul>
<h3 id="is-transitioning-in-helper"><a class="header" href="#is-transitioning-in-helper"><code>{{is-transitioning-in}}</code> Helper</a></h3>
<pre><code class="language-hbs">{{is-transitioning-in 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{is-transitioning-in 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p>The arguments to <code>{{is-transitioning-in}}</code> have the same semantics as all the other route state helpers, however <code>{{is-transitioning-in}}</code> only returns <code>true</code> when the route is going from an non-active to an active state. This should provide the same logic that determines whether to put an <code>ember-transition-in</code> class on a <code>{{link-to}}</code>.</p>
<h4 id="signature-explainer-4"><a class="header" href="#signature-explainer-4">Signature Explainer</a></h4>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>:  Optionally pass key value pairs that will be used to determine if the route is transitioning in.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is transitioning in.</li>
</ul>
<h3 id="is-transitioning-out-helper"><a class="header" href="#is-transitioning-out-helper"><code>{{is-transitioning-out}}</code> Helper</a></h3>
<pre><code class="language-hbs">{{is-transitioning-out 'people.index' model queryParams=(hash a=a)}}
</code></pre>
<p>Or</p>
<pre><code class="language-hbs">{{is-transitioning-out 'people.index' models=model queryParams=(hash a=a)}}
</code></pre>
<p><code>{{is-transitioning-out}}</code> is just the inverse of <code>{{is-transitioning-in}}</code>.</p>
<h4 id="signature-explainer-5"><a class="header" href="#signature-explainer-5">Signature Explainer</a></h4>
<p>Using the example above:</p>
<p><em>Positional Params</em></p>
<ul>
<li><strong><code>routeName</code></strong> <em>String</em>: A fully-qualified name of this route, like <code>&quot;people.index&quot;</code></li>
<li><strong><code>model</code></strong> <em>...Object|Array|Number|String</em>: Optionally pass an arbitrary amount of models to use for generation</li>
</ul>
<p><em>Named Params</em></p>
<ul>
<li><strong><code>models</code></strong> <em>Object|Array|Number|String</em>: Same as the positional parameter. It is a compiler error if the positional params and the named param is used.</li>
<li><strong><code>queryParms</code></strong> <em>Object</em>:  Optionally pass key value pairs that will be used to determine if the route is transitioning out.</li>
</ul>
<p><em>Returns</em></p>
<ul>
<li><em>Boolean</em>: Determines if the route is transitioning out.</li>
</ul>
<h3 id="event-dispatcher"><a class="header" href="#event-dispatcher">Event Dispatcher</a></h3>
<p>In the past, only <code>HTMLAnchorElement</code>s that were produced by <code>{{link-to}}</code>s would produce a transition when a user clicked on them. This RFC changes to the global <code>EventDispatcher</code> to allow for any <code>HTMLAnchorElement</code> with a valid root relative <code>href</code> to cause a transition. This will allow for us to not only allows us to support use cases like the ones described in the <a href="0391-router-helpers.html#anchor-tags">motivation</a>, it makes teaching easier since people who know HTML don't need know an Ember specific API to participate in routing transitions.</p>
<h4 id="route-globs-and-route-blacklisting"><a class="header" href="#route-globs-and-route-blacklisting">Route Globs And Route Blacklisting</a></h4>
<p>While the vast majority of the time developers want root relative URLs to cause a transition there are cases where you want root relative urls to cause a normal HTTP navigation. In the router map you can define <a href="https://guides.emberjs.com/release/routing/defining-your-routes/#toc_wildcard--globbing-routes">wildcard / globbing</a> that makes this problematic as any root relative url can be catched by a wildcard route. To solve this issue this RFC proposes expanding the route options to allow for a black list of urls that are allowed to cause a normal HTTP navigation.</p>
<pre><code class="language-js">Router.map(function() {
  this.route('not-found', { path: '/*path', blacklist: ['/contact-us', '/order/:order_id'] });
});
</code></pre>
<p>When an event comes into the <code>EventDispatcher</code> we will cross check the blacklist to see if the event should be let through to the browser or if it should be handled internally.</p>
<h3 id="transition-attribution"><a class="header" href="#transition-attribution">Transition Attribution</a></h3>
<p>This RFC introduces the notion of an <code>attribution</code> to the <code>Transition</code>. The <code>TransitionAttribution</code> is a read-only object that has 2 fields <code>event</code> and <code>source</code>.</p>
<pre><code class="language-ts">interface TransitionAttribution {
  readonly event: Maybe&lt;Event&gt;;
  readonly source: unknown
}

interface Transition {
  readonly attribution: TransitionAttribution;
}
</code></pre>
<p>On initial render <code>event</code> and <code>source</code> will be <code>null</code>. On subsequent transitions, the <code>event</code> will be the DOM event that caused the transition and <code>element</code> will be populated with <code>HTMLElement</code> that the user interacted with to cause the transition. See <a href="0391-router-helpers.html#appendix-a">Appendix A</a> for example usage. In the event that the transition occurs programmatically through an API like <code>replaceWith</code> or <code>transitionTo</code> the <code>event</code> will be <code>null</code> but can be <a href="0391-router-helpers.html#programatic-attribution">populated by the caller</a>.</p>
<h4 id="programatic-attribution"><a class="header" href="#programatic-attribution">Programatic Attribution</a></h4>
<p>In cases where you need to programatically transition with <code>transitionTo</code> or <code>replaceWith</code> we will allow for you to pass your own <code>TransitionAttribution</code>. See Appendix B for an example.</p>
<pre><code class="language-ts">interface Options {
  queryParams?: Dict&lt;string|number&gt;,
  attribution?: TransitionAttribution;
}

interface Router /* Route, RouterService */ {
  //...
  transitionTo(routeName: string, models?: string|number|object, options?: Options): Transition;
  replaceWith(routeName: string, models?: string|number|object, options?: Options): Transition;
}
</code></pre>
<h4 id="transitionattribution-integrity"><a class="header" href="#transitionattribution-integrity"><code>Transition.attribution</code> Integrity</a></h4>
<p>The <code>attribution</code> in a <code>Transition</code> is guaranteed to be carried through the completion of the route transition. This includes <code>abort</code>s, <code>redirect</code>s and <code>retry</code>s of the transition. The <code>attribution</code> field is readonlu and the <code>TransitionAttribution</code> is readonly and frozen.</p>
<h2 id="migration-path-2"><a class="header" href="#migration-path-2">Migration Path</a></h2>
<p>Since this RFC does not deprecate <code>{{link-to}}</code> you can continue to use it. That being said <code>{{link-to}}</code> has static semantics therefore we can write a codemod using <a href="https://github.com/ember-template-lint/ember-template-recast">Ember Template Recast</a> to migrate the code. Below are numerous before and after examples of how the codemod would migrate. It's important to note that the behavior of the application <a href="0391-router-helpers.html#url-generation-helpers">will change</a> if you are relying on the passing of the in-memory model. Because of this the codemod would need different levels of conversion.</p>
<h3 id="basic-link-to"><a class="header" href="#basic-link-to">Basic <code>{{link-to}}</code></a></h3>
<p><strong>Before:</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile' class=&quot;profile&quot;}}Profile{{/link-to}}
{{link-to 'About' 'about'}}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-hbs">&lt;a href={{url-for 'profile'}} class=&quot;profile&quot;&gt;Profile&lt;/a&gt;
&lt;a href={{url-for 'about'}}&gt;About&lt;/a&gt;
</code></pre>
<h3 id="with-model-link-to"><a class="header" href="#with-model-link-to">With Model <code>{{link-to}}</code></a></h3>
<p><strong>Before:</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile' this.profile class=&quot;profile&quot;}}Profile{{/link-to}}
{{link-to 'About' 'about' this.contact}}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-hbs">&lt;a class=&quot;profile&quot; href={{url-for 'profile' this.profile}}&gt;Profile&lt;/a&gt;
&lt;a href={{url-for 'about' this.contact}}&gt;About&lt;/a&gt;
</code></pre>
<h3 id="with-query-params-link-to"><a class="header" href="#with-query-params-link-to">With Query Params <code>{{link-to}}</code></a></h3>
<p><strong>Before:</strong></p>
<pre><code class="language-hbs">{{#link-to 'post' this.post (query-params order=&quot;CHRON&quot;)}}{{this.post.name}}{{/link-to}}
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-hbs">&lt;a href={{url-for 'post' this.post queryParms=(hash order=&quot;CHRON&quot;)}}&gt;{{this.post.name}}&lt;/a&gt;
</code></pre>
<p>One of the trickier parts about this migration is knowing how the autogenerated CSS classes are being used. Because of this, adding the route state helpers must explicitly be turned on in the codemod. For instance if you are making heavy use of the <code>.active</code> class, you will be suited best by turning pass the codemod the correct configuration to do a transform like the following:</p>
<p><strong>Before</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile'}}Profile{{/link-to}}
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-hbs">&lt;a href={{url-for 'profile'}} class={{if (is-active 'profile') 'active'}}&gt;Profile&lt;/a&gt;
</code></pre>
<h4 id="kitchen-sink"><a class="header" href="#kitchen-sink">Kitchen Sink</a></h4>
<p>If you were to transform all <code>{{link-to}}</code>s verbatim in terms of functionality this would be the result.</p>
<p><strong>Before</strong></p>
<pre><code class="language-hbs">{{#link-to 'profile' model (query-parmas foo=bar) replace=true}}Profile{{/link-to}}
</code></pre>
<p><strong>After</strong></p>
<pre><code class="language-hbs">&lt;a
  href={{url-for 'profile'
    model
    queryParams=(hash foo=bar)}}
  class=&quot;{{if (is-active 'profile' model queryParams=(hash foo=bar)) 'active'}} {{if (is-loading 'profile' model queryParams=(hash foo=bar)) 'loading'}} {{if (is-transitioning-in 'profile' model queryParams=(hash foo=bar)) 'ember-transitioning-in'}} {{if (is-transitioning-out 'profile' model queryParams=(hash foo=bar)) 'ember-transitioning-out'}}&quot;&gt;Profile&lt;/a&gt;
</code></pre>
<p>As the kitchen sink example shows, <code>{{link-to}}</code> is packed with functionality. While this convienent, it comes with a cost per <code>{{link-to}}</code> and is the reason why addons like <a href="https://github.com/intercom/ember-href-to">Ember-href-to</a> were created. In reality the vast majority of applications only need a subset of this functionality and only in rare cases need things like the transition and loading states.</p>
<h2 id="how-we-teach-this-64"><a class="header" href="#how-we-teach-this-64">How we teach this</a></h2>
<p>In many ways this vastly simplifies Ember's approach to linking within the app. It removes the requirement for a proprietary API and instead embraces the power of URLs.</p>
<p>In the cases where you do need to do more complicated things like pass in memory models to a route, things should feel very similar to <code>{{link-to}}</code> as they have the exact same signature. In the case of query param serialization, I believe we are actually aligning a mental model as to how URL generation should work.</p>
<h2 id="drawbacks-88"><a class="header" href="#drawbacks-88">Drawbacks</a></h2>
<p>This RFC expands the surface area of the templating layer by exposing the primitives that make up <code>{{link-to}}</code>. This may cause confusion of choosing between using simple basic anchor tags, <code>{{url-for}}</code> and <code>{{link-to}}</code>, however I believe that each one of the these APIs are solving a real problem that we have in Ember today.</p>
<p>By proxy this may cause people to encapsulate all of these primitives into a single component and thus creating a user-land version of <code>{{link-to}}</code>. This could be seen as a framework misstep if the majority of applications end up depending on the addon.</p>
<h2 id="alternatives-90"><a class="header" href="#alternatives-90">Alternatives</a></h2>
<p>We could just start deprecating and removing functionality from <code>{{link-to}}</code> itself. That being said, it is hard to understand how much of the community is reliant on certain feature of <code>{{link-to}}</code>. This also doesn't help with usecases like the i18n and markdown use cases.</p>
<h2 id="unresolved-questions-62"><a class="header" href="#unresolved-questions-62">Unresolved questions</a></h2>
<p>TBD?</p>
<h2 id="appendix-a"><a class="header" href="#appendix-a">Appendix A</a></h2>
<pre><code class="language-js">// app/utils/tracking.js
const TRACKING_DATA = new WeakMap();
export default TRACKING_DATA;
</code></pre>
<pre><code class="language-js">// app/components/track-link.js
import Component from '@ember/component';
import TRACKING_DATA from '../utils/tracking';

export default Component.extend({
  tagName: 'a',
  attributeBindings: ['href'],
  didInsertElement() {
    TRACKING_DATA.set(this.element, this.contextName);
  }
})
</code></pre>
<pre><code class="language-js">// app/routes/application.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  router: service('router'),
  init() {
    this._super(...arguments);

    this.router.on('routeDidChange', transition =&gt; {
      let { source, event } = trasition.attribution;

      let trackingInfo = {
        cause: event.type,
        contextName: null
      };

      if (TRACKING_DATA.has(trasition.source)) {
        trackingInfo.contextName = TRACKING_DATA.get(source);
      }

      ga.send('pageView', {
        from: transition.from ? transition.from.name : 'initial',
        to: transition.to.name,
        attribution: trackingInfo
      });
    });
  }
})
</code></pre>
<pre><code class="language-hbs">&lt;h1&gt;Hello {{@name}}!&lt;/h1&gt;
&lt;TrackLink href=&quot;/profile&quot; @contextName=&quot;profile.link&quot;&gt;Profile&lt;/TrackLink&gt;
&lt;TrackLink href=&quot;/about&quot; @contextName=&quot;about.link&quot;&gt;About&lt;/TrackLink&gt;
&lt;TrackLink href=&quot;/contact&quot; @contextName=&quot;contact.link&quot;&gt;Contact&lt;/TrackLink&gt;
</code></pre>
<h2 id="appendix-b"><a class="header" href="#appendix-b">Appendix B</a></h2>
<pre><code class="language-js">// app/utils/tracking.js
const TRACKING_DATA = new WeakMap();
export default TRACKING_DATA;
</code></pre>
<pre><code class="language-js">// app/routes/profile.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  store: service('store'),
  actions: {
    changeName(name) {
      this.model.set('name', name);
    },

    changeAge(age) {
      this.model.set('age', age);
    },

    submit(e) {
      if (isValid(this.model)) {
        let attribution = {
          event: e,
          source: e.target,
        };

        TRACKING_DATA.set(e.target, 'profile.submit');

        this.model.save().then(() =&gt; {
          this.transitionTo('profile.success', { attribution });
        }, () =&gt; {
          alert('Issue saving... please try again.');
        });
      } else {
        alert('Data is not valid!');
      }
    }
  }
})
</code></pre>
<pre><code class="language-hbs">&lt;input onchange={{action 'changeName' value=&quot;target.value&quot;}} /&gt;
&lt;input onchange={{action 'changeAge' value=&quot;target.value&quot;}} /&gt;
&lt;button onclick={{action 'submit' this.model}}&gt;Submit&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// app/routes/application.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import TRACKING_DATA from '../utils/tracking';

export default Route.extend({
  router: service('router'),
  init() {
    this._super(...arguments);

    this.router.on('routeDidChange', transition =&gt; {
      let { source, event } = trasition.attribution;

      let trackingInfo = {
        cause: event.type,
        contextName: null
      };

      if (TRACKING_DATA.has(trasition.source)) {
        trackingInfo.contextName = TRACKING_DATA.get(source);
      }

      ga.send('pageView', {
        from: transition.from ? transition.from.name : 'initial',
        to: transition.to.name,
        attribution: trackingInfo
      });
    });
  }
})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-23
RFC PR: https://github.com/emberjs/rfcs/pull/392</p>
<hr />
<h1 id="summary-93"><a class="header" href="#summary-93">Summary</a></h1>
<p>This deprecates the string-based lookup API for associating a custom component manager with a corresponding base class.</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { setComponentManager } from '@ember/component';

export default setComponentManager('basic', EmberObject.extend({
  //...
}))
</code></pre>
<p>Instead, you must pass a factory function that produces an instance of the custom manager:</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { createManager } from './basic-manager';
import { setComponentManager } from '@ember/modifier';

export default setComponentManager(createManager, EmberObject.extend({
  // ...
}));
</code></pre>
<p>Where <code>createManager</code> is:</p>
<pre><code class="language-js">export function createManager(owner) {
  return new BasicManager(owner);
}
</code></pre>
<h1 id="motivation-94"><a class="header" href="#motivation-94">Motivation</a></h1>
<p>There are several motivators:</p>
<ul>
<li>A string-based API is not friendly when it comes to tree shaking. It would force us into creating a compiler to turn the string into a symbol that build tools like Rollup and Webpack could analyze.</li>
<li>This API expands the namespacing problems associated with module unification. Specifically, an addon author would have to associate the package name with the string, similar to how <a href="https://github.com/mixonic/rfcs/blob/mu-packages/text/0000-module-unification-packages.md#explicit-packages-for-service-injections">RFC#367</a> proposes changes to services.</li>
<li><code>setModifierManager</code> as introduced by <a href="https://github.com/emberjs/rfcs/blob/89349d30ade24303a06448bc121b8fd810cbe58d/text/0373-Element-Modifier-Managers.md#determining-which-modifier-manager-to-use">RFC#373</a> uses a factory style API. This RFC intends to align these to function signatures.</li>
<li>We want to make sure this API is compatible with the binary AoT compilation work we did in the Glimmer-VM.</li>
</ul>
<h1 id="transition-path-14"><a class="header" href="#transition-path-14">Transition Path</a></h1>
<p>We can transition away by producing a factory function in the internals of <code>setupComponentManager</code>. The implementation would look something like:</p>
<pre><code class="language-js">export function setComponentManager(stringOrFunction, obj: any) {
  let factory;
  if (typeof stringOrFunction === 'string') {
    deprecate(
      `Passing the name of the component manager to 'setupComponentManager' is deprecated. Please pass a function that produces an instance of the manager.`,
      {
        id: 'deprecate-string-based-component-manager',
        unil: '4.0.0'
      }
    );
    factory = function(owner: Owner) {
      return owner.lookup(`component-manager:${stringOrFunction}`);
    };
  } else {
    factory = stringOrFunction;
  }

  // ...
}

</code></pre>
<h1 id="how-we-teach-this-65"><a class="header" href="#how-we-teach-this-65">How We Teach This</a></h1>
<p>From our understanding this API has very limited usage as it is a low-level API. We should update that docs accordingly.</p>
<h1 id="drawbacks-89"><a class="header" href="#drawbacks-89">Drawbacks</a></h1>
<p>Historically, Ember has given developers base classes that the developer would extend from and Ember would create instances on your behalf. This allows the framework to know that the interface of the object is complete. With this approach we are relying more on the addon author to construct the object and ensure it conforms to the correct interface.</p>
<p>Generally speaking this a good practice of OOP but due to the fact that JavaScript does not have first-class interfaces, Ember has taken the concretion approach.</p>
<h1 id="alternatives-91"><a class="header" href="#alternatives-91">Alternatives</a></h1>
<p>Instead of passing a factory function we could pass the class itself. This option does have the issue of Ember needing to know how to construct the class and does not allow for the addon author to perform any dependency injections.</p>
<h1 id="unresolved-questions-63"><a class="header" href="#unresolved-questions-63">Unresolved questions</a></h1>
<p>TBD?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-31
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/395
Tracking: https://github.com/emberjs/rfc-tracking/issues/11</p>
<hr />
<h1 id="ember-data-packages"><a class="header" href="#ember-data-packages">Ember Data Packages</a></h1>
<h2 id="summary-94"><a class="header" href="#summary-94">Summary</a></h2>
<p>This documents presents the proposed <strong>public</strong> import path changes for <code>ember-data</code>, and moving <code>ember-data</code>
into the <code>@ember-data</code> namespace.</p>
<h2 id="motivation-95"><a class="header" href="#motivation-95">Motivation</a></h2>
<p><strong>Reduce Confusion &amp; Bike Shedding</strong></p>
<p>Users of <code>ember-data</code> have often noted their confusion by the existence of both direct and &quot;god object&quot; (<code>DS.</code>) style
imports for modules from <code>ember-data</code>. The documentation currently uses primarily the <code>DS.</code> style, and users have
expressed interest and confusion over why the documentation has not been updated to reflect direct imports.</p>
<p><strong>Improve The TypeScript Experience</strong></p>
<p>Presence of multiple import locations confuses <code>Typescript</code>'s autocomplete, symbol resolution, and type hinting.</p>
<p><strong>Simplify The Mental Model</strong></p>
<p>Users of <code>ember-data</code> complain about the large API surface area; however, a large portion of this surface area is
non-essential user-land APIs that the provided adapter and serializer implementations expose. This move to packages
helps us simplify the mental model in three ways.</p>
<p>First: it gives us a natural way of dividing the documentation and learning story such that key concepts
and APIs are more discoverable.</p>
<p>Second: it allows us specifically to isolate the API surface area explosion of the provided adapter and serializer
implementations and make it clear that these are non-essential, replaceable APIs. E.G. it will help us to communicate
that these adapters and serializers are <em>an implementation</em>, <strong>not</strong> <em>the required implementation</em>.</p>
<p>Third: it clarifies the roles of several concepts within <code>ember-data</code> that are often misused today. Specifically:
the <code>embedded-records-mixin</code> should <em><em>only</em></em> be used with the <code>RESTAdapter</code>, and <code>transforms</code> are <em><em>only</em></em> a
serialization/deserialization concern and not a way of defining custom <code>attrs</code> or <code>types</code>. Furthermore, <code>transforms</code>
are only applicable to the serializer implementations that <code>ember-data</code> provides, and not to <code>custom</code> (and sometimes
not to <code>subclassed</code>) serializers.</p>
<p><strong>Improve the Contributor Experience</strong></p>
<p>Contributors to <code>ember-data</code> are faced with a large, complex project with poor code and test organization. This makes it
unduly difficult to discover what tests exist, where to add tests, where associated code lives, and even what parts of
the code base relate to the feature or bug that they are looking to address.</p>
<p>This move to packages will help us restructure the project and associated tests in a manner that is more discoverable.</p>
<p><strong>Provide a Clear Subdivision of Packages</strong></p>
<p>Today, <code>ember-data</code> is a large single package (<code>~35KB gzipped</code> in production). <code>ember-data</code> is often one of the largest
dependencies <code>emberjs</code> users have in their applications. However, not all users utilize all parts of <code>ember-data</code>, and
some users use very little. Providing these packages helps to clearly show the cost of various features, and better
allows us to enable end users to eliminate unneeded packages.</p>
<p>Users that implement their own adapter or serializers today must still carry the significant weight of the adapter and
serializer implementations that <code>ember-data</code> ships regardless. This is a weight we should enable these users to eliminate.</p>
<p>With the landing of <code>RecordData</code> and the merging of the <code>modelFactoryFor</code> RFC, it is likely that many applications
will soon require far less of <code>ember-data</code> than they do today. <code>ember-m3</code> is an example of a project that utilizes these
APIs in a way that requires significantly less of the <code>ember-data</code> experience.</p>
<p><strong>Provide Infrastructure for Additional Changes</strong></p>
<p><code>ember-data</code> is entering a period of extended evolution, of which <code>RecordData</code> and <code>modelFactoryFor</code> are only the early
pieces. For example, current thinking includes the possibility of <code>ember-data</code> evolving to provide an <code>ember-m3</code>-like
experience for <code>json-api</code> as the default out-of-the-box experience, and a rethinking of how we manage the request/response
lifecycle when fulfilling a request for data.</p>
<p>These experiences would live alongside the existing experience for a time prior to any deprecations of the current layer,
and it is possible that sometimes the current experience would never be deprecated. Subdividing <code>ember-data</code> into these
packages will enable us to provide a more seamless transition between these experiences without hoisting any package
size costs onto users that do not use either the current or the new experience.</p>
<h2 id="detailed-design-80"><a class="header" href="#detailed-design-80">Detailed design</a></h2>
<p>This RFC proposes import paths following the guidelines established in <a href="https://github.com/emberjs/rfcs/pull/176">Ember Modules RFC #176</a>,
with two addendums to account for scenarios that weren't faced by <code>ember</code>:</p>
<ul>
<li><code>Error</code> sub-classes are named exports</li>
<li><code>Mixins</code> are named exports</li>
</ul>
<p>This is done to allow for continued grouping by common usage and mental model, where otherwise users would be faced with multiple imports from length file paths.</p>
<p>The following modules would continue to live in a monorepo that (until further RFC) would continue to live at <code>github.com/ember/data</code>.</p>
<table>
  <thead>
    <tr>
      <th colspan="2">Before</th>
      <th>After</th>
    </tr>
    <tr>
        <th>import DS from 'ember-data';</th>
        <th>Direct Import</th>
        <th>New Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="3"><h3 id="ember-datamodel"><a class="header" href="#ember-datamodel">@ember-data/model</a></h3></td>
    </tr>
    <tr>
      <td>DS.Model</td>
      <td>import Model from 'ember-data/model';</td>
      <td>import Model from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.attr</td>
      <td>import attr from 'ember-data/attr';</td>
      <td>import { attr } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.belongsTo</td>
      <td>import { belongsTo } from 'ember-data/relationships';</td>
      <td>import { belongsTo } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td>DS.hasMany</td>
      <td>import { hasMany } from 'ember-data/relationships';</td>
      <td>import { hasMany } from '@ember-data/model';</td>
    </tr>
    <tr>
      <td colspan="3"><h3 id="ember-dataadapter"><a class="header" href="#ember-dataadapter">@ember-data/adapter</a></h3></td>
    </tr>
    <tr>
      <td>DS.Adapter</td>
      <td>import Adapter from 'ember-data/adapter';</td>
      <td>import Adapter from '@ember-data/adapter';</td>
    </tr>
    <tr>
      <td>DS.RESTAdapter</td>
      <td>import RESTAdapter from 'ember-data/adapters/rest';</td>
      <td>import RESTAdapter from '@ember-data/adapter/rest';</td>
    </tr>
    <tr>
      <td>DS.JSONAPIAdapter</td>
      <td>import JSONAPIAdapter from 'ember-data/adapters/json-api';</td>
      <td>import JSONAPIAdapter from '@ember-data/adapter/json-api';</td>
    </tr>
    <tr>
      <td>DS.BuildURLMixin</td>
      <td>none</td>
      <td>import { BuildURLMixin } from '@ember-data/adapter';</td>
    </tr>
    <tr>
      <td>DS.AdapterError</td>
      <td>import { AdapterError } from 'ember-data/adapters/errors';</td>
      <td>import AdapterError from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.InvalidError</td>
      <td>import { InvalidError } from 'ember-data/adapters/errors';</td>
      <td>import { InvalidError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.TimeoutError</td>
      <td>import { TimeoutError } from 'ember-data/adapters/errors';</td>
      <td>import { TimeoutError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.AbortError</td>
      <td>import { AbortError } from 'ember-data/adapters/errors';</td>
      <td>import { AbortError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.UnauthorizedError</td>
      <td>import { UnauthorizedError } from 'ember-data/adapters/errors';</td>
      <td>import { UnauthorizedError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ForbiddenError</td>
      <td>import { ForbiddenError } from 'ember-data/adapters/errors';</td>
      <td>import { ForbiddenError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.NotFoundError</td>
      <td>import { NotFoundError } from 'ember-data/adapters/errors';</td>
      <td>import { NotFoundError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ConflictError</td>
      <td>import { ConflictError } from 'ember-data/adapters/errors';</td>
      <td>import { ConflictError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.ServerError</td>
      <td>import { ServerError } from 'ember-data/adapters/errors';</td>
      <td>import { ServerError } from '@ember-data/adapter/error';</td>
    </tr>
    <tr>
      <td>DS.errorsHashToArray</td>
      <td>none</td>
      <td>import { errorsHashToArray } from '@ember-data/adapter/error';<br>
         <br>this public method should also be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td>DS.errorsArrayToHash</td>
      <td>none</td>
      <td>import { errorsArrayToHash } from '@ember-data/adapter/error';<br>
        <br>this public method should also be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td colspan="3"><h3 id="ember-dataserializer"><a class="header" href="#ember-dataserializer">@ember-data/serializer</a></h3></td>
    </tr>
    <tr>
      <td>DS.Serializer</td>
      <td>import Serializer from 'ember-data/serializer';</td>
      <td>import Serializer from '@ember-data/serializer';</td>
    </tr>
    <tr>
      <td>DS.JSONSerializer</td>
      <td>import JSONSerializer from 'ember-data/serializers/json';</td>
      <td>import JSONSerializer from '@ember-data/serializer/json';</td>
    </tr>
    <tr>
      <td>DS.RESTSerializer</td>
      <td>import RESTSerializer from 'ember-data/serializers/rest';</td>
      <td>import RESTSerializer from '@ember-data/serializer/rest';</td>
    </tr>
    <tr>
      <td>DS.JSONAPISerializer</td>
      <td>import JSONAPISerializer from 'ember-data/serializers/json-api';</td>
      <td>import JSONAPISerializer from '@ember-data/serializer/json-api';</td>
    </tr>
    <tr>
      <td>DS.EmbeddedRecordsMixin</td>
      <td>import EmbeddedRecordsMixin from 'ember-data/serializers/embedded-records-mixin';</td>
      <td>import { EmbeddedRecordsMixin } from '@ember-data/serializer/rest';</td>
    </tr>
    <tr>
      <td>DS.Transform</td>
      <td>import Transform from 'ember-data/transform';</td>
      <td>import Transform from '@ember-data/serializer/transform';</td>
    </tr>
    <tr>
      <td colspan="3"><h3 id="ember-datastore"><a class="header" href="#ember-datastore">@ember-data/store</a></h3></td>
    </tr>
    <tr>
      <td>DS.Store</td>
      <td>import Store from 'ember-data/store';</td>
      <td>import Store from '@ember-data/store';</td>
    </tr>
    <tr>
      <td>DS.Snapshot</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.PromiseArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.PromiseObject</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.RecordArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.AdapterPopulatedRecordArray</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.RecordarrayManager</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td>DS.normalizeModelName</td>
      <td>none</td>
      <td>import { normalizeModelName } from '@ember-data/store';<br>
        <br>this public method should be a candidate for deprecation
      </td>
    </tr>
    <tr>
      <td colspan="3"><h3 id="ember-datarecord-data"><a class="header" href="#ember-datarecord-data">@ember-data/record-data</a></h3></td>
    </tr>
    <tr>
      <td>none</td>
      <td>import { RecordData } from 'ember-data/-private';</td>
      <td>import RecordData from '@ember-data/record-data';</td>
    </tr>
    <tr>
      <td colspan="3"><h3 id="ember-datarelationship-layer"><a class="header" href="#ember-datarelationship-layer">@ember-data/relationship-layer</a></h3></td>
    </tr>
    <tr>
      <td>DS.Relationship</td>
      <td>none</td>
      <td>none</td>
    </tr>
    <tr>
      <td colspan="3"><h3 id="ember-datadebug"><a class="header" href="#ember-datadebug">@ember-data/debug</a></h3></td>
    </tr>
    <tr>
      <td>DS.DebugAdapter</td>
      <td>none</td>
      <td>none</td>
    </tr>
  </tbody>
</table>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<h4 id="ember-datamodel-1"><a class="header" href="#ember-datamodel-1"><code>@ember-data/model</code></a></h4>
<ol>
<li>
<p><code>InternalModel</code> and <code>RootState</code> are tightly coupled to the store and to our provided <code>Model</code>
implementation. Over time we need to uncouple this, but given their coupling to <code>Model</code> and our
desire to enable them to be eliminated from projects not using <code>Model</code>, these concepts belong in <code>@ember-data/model</code>, although they will not be given direct import paths.</p>
</li>
<li>
<p>The following belong in <code>@ember-data/model</code> and not in <code>@ember-data/relationship-layer</code> with
relationships.  While this presents a mild risk of confusion due to the presence of the
<code>relationship-layer</code> package, the argument for their presence here is they are a ui-layer concern being coupled to the current <code>Model</code> presentation layer and not related to overall state management
of relationships which could itself be used with alternative implementations.</p>
</li>
</ol>
<ul>
<li><code>belongsTo</code></li>
<li><code>hasMany</code></li>
</ul>
<ol start="3">
<li>The following have the same considerations as #2 but they will not be given direct import paths.</li>
</ol>
<ul>
<li><code>PromiseManyArray</code></li>
<li><code>ManyArray</code></li>
</ul>
<h4 id="ember-dataserializers"><a class="header" href="#ember-dataserializers"><code>@ember-data/serializers</code></a></h4>
<ol>
<li>We should move automatic registration of transforms into a more traditional
<code>app/</code> directory re-export for the package so that when the package is dropped they
cleanly drop as well.</li>
</ol>
<h4 id="ember-datarelationship-layer-1"><a class="header" href="#ember-datarelationship-layer-1"><code>@ember-data/relationship-layer</code></a></h4>
<p>This package seems thin but it's likely to hold quite a bit.
Additional private things that would be moved here:</p>
<ul>
<li>everything in <code>-private/system/relationships/state</code></li>
<li><code>BelongsToReference</code> and <code>HasManyReference</code></li>
<li>relationship logic from <code>store</code> / <code>internal-model</code> that need to be isolated and extracted</li>
</ul>
<h4 id="ember-datadebug-1"><a class="header" href="#ember-datadebug-1"><code>@ember-data/debug</code></a></h4>
<p>Moving <code>DebugAdapter</code> here would allow dropping it if not desired. Additionally we should likely
RFC dropping it for production builds where it adds persistent unnecessary overhead for a tool
meant for devs. This exists to support the ember inspector.</p>
<h3 id="documented-public-apis-without-public-import-paths"><a class="header" href="#documented-public-apis-without-public-import-paths">Documented Public APIs without public import paths</a></h3>
<p>There are a few public classes that are not exposed at all via <code>export</code> today. Those classes will not be given
public export paths, but the package containing their documentation and implementation is shown here:</p>
<ul>
<li><code>@ember-data/store</code>
<ul>
<li><code>Reference</code></li>
<li><code>RecordReference</code></li>
<li><code>StoreWrapper</code></li>
</ul>
</li>
<li><code>@ember-data/relationship-layer</code>
<ul>
<li><code>BelongsToReference</code></li>
<li><code>HasManyReference</code></li>
</ul>
</li>
<li><code>@ember-data/model</code>
<ul>
<li><code>PromiseBelongsTo</code></li>
<li><code>PromiseRecord</code></li>
</ul>
</li>
</ul>
<h2 id="migration-3"><a class="header" href="#migration-3">Migration</a></h2>
<p>Blueprints, guides, docs, and twiddle would be updated to use the new <code>@ember-data/</code> package imports.</p>
<p>A codemod would be provided to convert from the existing import locations to the new ones, as well as lint rules for encouraging their use.</p>
<p>The package <code>ember-data</code> would continue to exist, much like <code>ember-source</code>. Initially, this package would provide all of the subpackages
as dependencies as well as the respective re-exports for supporting the existing import paths. After a time, the existing paths would
be deprecated.</p>
<p>Users who have resolved the deprecations may choose to convert to consuming only the packages they still require directly,
by dropping <code>ember-data</code> from their <code>package.json</code> and adding in the individual <code>@ember-data/</code> packages as necessary.</p>
<p>Ultimately, the default <code>ember-data</code> story in <code>ember-cli</code> would change to install select packages from <code>@ember-data</code> directly.</p>
<h2 id="how-we-teach-this-66"><a class="header" href="#how-we-teach-this-66">How we teach this</a></h2>
<p>This RFC should be seen as a continuation of the <code>javascript-modules</code> RFC that defined explicit import paths for <code>emberjs</code>.</p>
<p>Codemods and lint rules would be provided to convert existing imports to the new syntax. Existing import locations
would continue to exist for a time but would at some point in the future be made to print build-time deprecations.</p>
<p>End users would need to run the codemod at some point, but no other changes will be required.</p>
<p>Ember documentation and guides would be updated to reflect these new import paths as well as to utilize the new package
divisions to improve the teaching story.</p>
<h2 id="drawbacks-90"><a class="header" href="#drawbacks-90">Drawbacks</a></h2>
<ul>
<li>A Tiny amount of churn</li>
<li>Sub-packages will require sprinkling significant numbers of excess package.json files throughout our repo.</li>
<li>Our import paths may not align with the expected mental model for addon import paths going forward (no <code>/src/</code> in path)</li>
</ul>
<h2 id="alternatives-92"><a class="header" href="#alternatives-92">Alternatives</a></h2>
<ol>
<li>Divide into packages without exposing the new division publicly</li>
</ol>
<ul>
<li><em>argument for:</em> Don't expose churn to end users without a clear win, we aren't 100% sure what belongs in a vague
&quot;future ember-data&quot;, so wait until we are sure.</li>
<li><em>rebuttal:</em> The churn is minimal and mostly automated (codemod). There are clear wins here for many users. We
should not hold up progress now on an uncertain future. Dividing into packages now gives us more options for how to
manage future evolution. Regardless of when we become certain of what belongs in &quot;future ember-data&quot;, these packages
would need to exist alongside at least for a time.</li>
</ul>
<ol start="2">
<li>Don't divide into packages until nebulous future RFCs have landed</li>
</ol>
<ul>
<li><em>argument for:</em> This argument is an extension of <em>alternative 1</em> in which we wait for specific concepts to mature and
materialize that we have discussed internally, including a significant rework of how we manage the <code>request/response</code>
lifecycle. These new feature RFCs would come with corresponding deprecation RFCs for parts of the system they either
fully replace or make vestigial.</li>
<li><em>rebuttal:</em> The argument here is a variation of the argument in <em>alternative 1</em> and the rebuttal merely extends
that rebuttal as well. These future deprecations would necessarily be long-tail, if we deprecate at all. There is
the option to have both old and new experiences live side-by-side. Additionally, if we deprecate and then land
<code>@ember-data/packages</code> there is both an equal amount of churn and fewer options for how to manage those deprecations.</li>
</ul>
<ol start="3">
<li>Use the <code>@ember</code> namespace.</li>
</ol>
<ul>
<li>
<p><em>argument for:</em> <code>ember-data</code> is an official package and we wish to position it centrally within the <code>ember</code>
ecosystem. This <a href="https://github.com/emberjs/rfcs/pull/238#issuecomment-318745236">argument has been presented</a>
by other core teams in response to previous attempts to move forward with a packages RFC for <code>ember-data</code>.</p>
</li>
<li>
<p><em>rebuttal:</em> <code>ember-cli</code> and <code>glimmer</code> are also official packages, but with their own namespaces. Additionally
re-using the <code>@ember</code> namespace would only further confusion that many folks already have regarding:</p>
<ul>
<li>where <code>ember</code> ends and <code>ember-data</code> begins.</li>
<li>whether <code>ember-data</code> is required or optional</li>
<li>whether other data layers are seen as &quot;bad practices&quot; (they are not)</li>
<li>what packages are provided by <code>ember-data</code> vs <code>ember</code>
<code>ember-data</code>'s status as a team, in the guides and in release blog posts on <code>emberjs.com</code>, as well as presence in
the default blueprint provided by <code>ember-cli</code> make clear it's status as an official offering. Using the <code>@ember</code>
namespace is not required for this.</li>
</ul>
<p>This argument also necessarily foments an untrue presupposition: that <code>ember-data</code> is the right choice for every app.
While we strive to make this the case, it would be very difficult to claim this today, and may never be true,
as every app presents unique concerns and needs.</p>
<p>Finally, using the <code>@ember</code> namespace would leave us in the unfortunate position of either always scoping all of our
packages to <code>@ember/data/</code> or of fighting with <code>emberjs</code> for package names.</p>
</li>
</ul>
<ol start="4">
<li>This RFC but with Adapters and Serializers broken out into the packages <code>@ember-data/json</code> <code>@ember-data/rest</code> <code>@ember-data/json-api</code>.</li>
</ol>
<ul>
<li>
<p><em>argument for:</em> grouping the adapter / serializer &quot;by API spec&quot; feels more natural and would allow for users to drop only the versions of adapters / serializer they don't require.</p>
</li>
<li>
<p><em>rebuttal:</em> Even without considering future changes to <code>ember-data</code>'s API surface, there are several issues with this approach.</p>
<ol>
<li>
<p>The implementations inherit each other:</p>
<ul>
<li><code>JSONAPISerializer extends RESTSerializer extends JSONSerializer extends Serializer</code></li>
<li><code>JSONAPIAdapter extends RESTAdapter extends Adapter</code></li>
</ul>
</li>
<li>
<p>The adapter / serializer pairings aren't coupled</p>
<ul>
<li>It is fairly common to use the <code>JSONAPIAdapter</code> with the <code>RESTSerializer</code> or
with a custom serializer that extends the <code>RESTSerializer</code> and vice-verse.</li>
<li>Even when using a consistent spec (<code>json-api</code> or <code>rest</code>) it is common to need
a fully custom serializer. The division of needs is at least equally between
adapter/serializer as it is between specs.</li>
</ul>
</li>
<li>
<p>Transforms are an implementation detail for all the provided serializers</p>
<ul>
<li>But they  are not required and likely not even used by custom serializers.</li>
</ul>
</li>
<li>
<p>Packages for automatically registered fallbacks would fit poorly.</p>
<ul>
<li>Serializers: <code>&quot;-default&quot;</code> <code>&quot;-rest&quot;</code> <code>&quot;-json-api&quot;</code></li>
<li>Adapters: <code>&quot;-rest&quot;</code> <code>&quot;-json-api&quot;</code></li>
</ul>
</li>
<li>
<p>Today, we use multiple serializers for a single type based on entry-point</p>
<ul>
<li><code>Model.serialize</code> (per-type) / <code>Model.toJSON</code> (<code>&quot;-json&quot;</code>) / <code>Adapter.serialize</code> (per-adapter)</li>
</ul>
</li>
</ol>
<p>That said, this organization is also one of the only-nods
to future RFCs this RFC concedes. The existing provided implementations all follow roughly the same interface for their implementations, and that interface is something we strongly wish to change. For this reason, it seems advantageous to keep the existing implementations together such that the delineation between a new experience and this experience can be kept clear.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-11-02
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/398
Tracking: https://github.com/emberjs/rfc-tracking/issues/10</p>
<hr />
<h1 id="routeinfo-metadata"><a class="header" href="#routeinfo-metadata">RouteInfo MetaData</a></h1>
<h2 id="summary-95"><a class="header" href="#summary-95">Summary</a></h2>
<p>The RFC introduces the ability to associate application specific metadata with its corresponding <code>RouteInfo</code> object. This also adds a <code>metadata</code> field to <code>RouteInfo</code>, which will be the return value of <code>buildRouteInfoMetadata</code> for its corresponding <code>Route</code>.</p>
<pre><code class="language-js">// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';

export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      trackingKey: 'page_profile',
      user: {
        id: this.user.id,
        type: this.user.type
      }
    }
  }
  // ...
});
</code></pre>
<pre><code class="language-js">// app/services/analytics.js
import Service, { inject } from '@ember/service';

export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromMeta,
        to: toMeta,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<h2 id="motivation-96"><a class="header" href="#motivation-96">Motivation</a></h2>
<p>While the <code>RouteInfo</code> object is sufficient in providing developers metadata about the <code>Route</code> itself, it is not sufficient in layering on application specific metadata about the <code>Route</code>. This metadata could be anything from a more domain-specific name for a <code>Route</code>, e.g. <code>profile_page</code> vs <code>profile.index</code>, all the way to providing contextual data when the <code>Route</code> was visited.</p>
<p>This metadata could be used for more pratical things like updating the <code>document.title</code>.
Currently, addons like <a href="https://github.com/ronco/ember-cli-head">Ember CLI Head</a> and <a href="https://github.com/kimroen/ember-cli-document-title">Ember CLI Document Title</a> require the user to supply special metadata fields on your <code>Route</code> that will be used to update the title. This API would be a formalized place to place that metadata.</p>
<p>See the <a href="0398-RouteInfo-Metadata.html#appendix-a">appendix</a> for examples.</p>
<h2 id="detailed-design-81"><a class="header" href="#detailed-design-81">Detailed design</a></h2>
<h3 id="buildrouteinfometadata"><a class="header" href="#buildrouteinfometadata"><code>buildRouteInfoMetadata</code></a></h3>
<p>This optional hook is intended to be used as a way of letting the routing system know about any metadata associated with the route.</p>
<h4 id="route-interface-extension"><a class="header" href="#route-interface-extension"><code>Route</code> Interface Extension</a></h4>
<pre><code class="language-ts">interface Route {
  // ... existing public API
  buildRouteInfoMetadata(): unknown
}
</code></pre>
<h4 id="runtime-semantics"><a class="header" href="#runtime-semantics">Runtime Semantics</a></h4>
<ul>
<li><strong>Always</strong> called before the <code>beforeModel</code> hook is called</li>
<li><strong>Maybe</strong> called more than once during a transition e.g. aborts, redirects.</li>
</ul>
<h3 id="routeinfometadata"><a class="header" href="#routeinfometadata"><code>RouteInfo.metadata</code></a></h3>
<p>The <code>metadata</code> optional field on <code>RouteInfo</code> will be populated with the return value of <code>buildRouteInfoMetadata</code>. If there is no metadata associated with the <code>Route</code>, the <code>metadata</code> field will be <code>null</code>.</p>
<pre><code class="language-ts">interface RouteInfo {
  // ... existing public API
  metadata: Maybe&lt;unknown&gt;;
}
</code></pre>
<p>This field will also be added to <code>RouteInfoWithAttributes</code> as it is just a super-set of <code>RouteInfo</code>.</p>
<h2 id="how-we-teach-this-67"><a class="header" href="#how-we-teach-this-67">How we teach this</a></h2>
<p>We feel that this a low-level primitive that will allow existing tracking addons to encapsulate. That being said the concept here is pretty simple: What gets returned from <code>buildRouteInfoMetadata</code> becomes the value of <code>RouteInfo.metadata</code> for that <code>Route</code>.</p>
<p>The guides and tutorial should be updated to incorporate an example on how these APIs could integrate with services like Google Analytics.</p>
<h2 id="drawbacks-91"><a class="header" href="#drawbacks-91">Drawbacks</a></h2>
<p>This adds an additional hook that is called during route activation, expanding the surface area of the <code>Route</code> class.
While this is true, there is currently no good way to associate application-specific metadata with a route transition.</p>
<h2 id="alternatives-93"><a class="header" href="#alternatives-93">Alternatives</a></h2>
<p>There are numerous alternative to the proposal:</p>
<h3 id="setroutemetadata"><a class="header" href="#setroutemetadata"><code>setRouteMetadata</code></a></h3>
<p>This API would be similar to <code>setComponentManager</code> and <code>setModifierManager</code>. For example:</p>
<pre><code class="language-js">// app/route/profile.js
import Route, { setRouteMetadata } from '@ember/routing/route';

export default Route.extend({

  init() {
    this._super(...arguments);
    setRouteMetadata(this, {
      trackingKey: 'page_profile',
      profile: {
        viewing: this.userId,
        locale: this.userLocale
      }
    });
  }
  // ...
});
</code></pre>
<p>You would then use the a <code>RouteInfo</code> to lookup the value:</p>
<pre><code class="language-js">// app/services/analytics.js
import { getRouteMetadata } from '@ember/routing/route';
import Service, { inject } from '@ember/service';
 export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let { trackingKey: fromKey } = getRouteMetadata(from);
      let { trackingKey: toKey } = getRouteMetadata(to);
      ga.sendEvent('pageView', {
        from: fromKey,
        to: toKey,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<p>This could work but there are two things that are confusing here:</p>
<ol>
<li>What happens if you call <code>setRouteMetadata</code> mutliple times. Do you clobber the existing metadata? Do you merge it?</li>
<li>It is very odd that you would use a <code>RouteInfo</code> to access the metadata when you set it on the <code>Route</code>.</li>
</ol>
<h3 id="routemetadata"><a class="header" href="#routemetadata"><code>Route.metadata</code></a></h3>
<p>This would add a special field to the <code>Route</code> class that would be copied off on to the <code>RouteInfo</code>. For example:</p>
<pre><code class="language-js">// app/route/profile.js
import Route, { setRouteMetadata } from '@ember/routing/route';

export default Route.extend({
  metadata: {
    trackingKey: 'page_profile',
    profile: {
      viewing: this.userId,
      locale: this.userLocale
    }
  }
  // ...
});
</code></pre>
<p>The value would then be populated on <code>RouteInfo.metadata</code>.</p>
<pre><code class="language-js">// app/services/analytics.js
import { getRouteMetadata } from '@ember/routing/route';
import Service, { inject } from '@ember/service';
 export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromKey,
        to: toKey,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<p>This could work but there are two things that are problematic here:</p>
<ol>
<li>What happens to the this data if you subclass it? Do you merge or clobber the field?</li>
<li>This is a generic property name and may conflict in existing applications</li>
</ol>
<h3 id="return-metadata-from-activate"><a class="header" href="#return-metadata-from-activate">Return Metadata From <code>activate</code></a></h3>
<p>Today <code>activate</code> does not get called when the dynamic segments of the <code>Route</code> change, making it not well fit for this use case.</p>
<h2 id="unresolved-questions-64"><a class="header" href="#unresolved-questions-64">Unresolved questions</a></h2>
<p>TBD?</p>
<h3 id="apendix-a"><a class="header" href="#apendix-a">Apendix A</a></h3>
<p>Tracking example</p>
<pre><code class="language-js">// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';
export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      trackingKey: 'page_profile',
      user: {
        id: this.user.id,
        type: this.user.type
      }
    }
  }
  // ...
});
</code></pre>
<pre><code class="language-js">// app/services/analytics.js
import Service, { inject } from '@ember/service';

export default Service.extend({
  router: inject('router'),
  init() {
    this._super(...arguments);
    this.router.on('routeDidUpdate', (transition) =&gt; {
      let { to, from } = transition;
      let fromMeta = from.metadata;
      let toMeta = to.metadata;
      ga.sendEvent('pageView', {
        from: fromMeta,
        to: toMeta,
        timestamp: Date.now(),
      })
    })
  },
  // ...
});
</code></pre>
<h3 id="appendix-b-1"><a class="header" href="#appendix-b-1">Appendix B</a></h3>
<p>Updating document.title</p>
<pre><code class="language-js">// app/route/profile.js
import Route from '@ember/routing/route';
import { inject } from '@ember/service';
export default Route.extend({
  user: inject('user'),
  buildRouteInfoMetadata() {
    return {
      title: 'My Cool WebPage'
    }
  }
  // ...
});
</code></pre>
<pre><code class="language-js">// app/router.js
import Router from '@ember/routing/router';

// ...
export default Router.extend({
  init() {
    this._super(...arguments);
    this.on('routeDidUpdate', (transition) =&gt; {
      let { title } = transition.metadata;
      document.title = title;
    });
  },
  // ...
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-11-25
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/403
Tracking: https://github.com/emberjs/rfc-tracking/issues/31</p>
<hr />
<h1 id="ember-data--identifiers"><a class="header" href="#ember-data--identifiers">Ember Data | Identifiers</a></h1>
<h2 id="summary-96"><a class="header" href="#summary-96">Summary</a></h2>
<p><code>Identifiers</code> provides infrastructure for handling <code>identity</code> within <code>ember-data</code> to
satisfy requirements around improved caching, serializability, replication, and handling
of remote data.</p>
<p>This concept would parallel a similar structure proposed for <code>json-api</code> resource identifier
<code>lid</code> property <a href="https://github.com/json-api/json-api/pull/1244">drafted for version <code>1.2</code> of the <code>json-api</code> spec</a>.</p>
<p>In doing so we provide a framework for future RFCs and/or addons to address many common
feature requests.</p>
<hr />
<h2 id="motivation-97"><a class="header" href="#motivation-97">Motivation</a></h2>
<p>This groundwork RFC represents the union of a diverse set of motivations, each of which 
is discussed below in no particular order of importance, outside of the first. <strong>This 
RFC is not seeking to immediately address each of the motivations below, we are adding
infrastructure to make future RFCs possible in these spaces</strong></p>
<h3 id="unified-concept-of-identity"><a class="header" href="#unified-concept-of-identity">Unified concept of Identity</a></h3>
<p>Identity is a core concept to managing a cache and guaranteeing <a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">atomicity, consistency,
isolation, and durability</a>. 
Currently, <code>ember-data</code> has no unified mechanism for Identity. This missing mechanism 
introduces errors in application code, makes <code>ember-data</code> internals needlessly complex, 
and complicates the method signatures of many public APIs.</p>
<p>Creating a unified <code>Identity</code> concept will allow <code>ember-data</code> to expose <code>identity</code> as a 
first-class primitive to our users, improving the mental model, improving application 
resiliance to errors, and providing a clear language of communication between <code>ember-data</code>'s 
various primitives.</p>
<p>Today, we handle <code>identity</code> in a myriad of ad-hoc ways:</p>
<ul>
<li><code>InternalModel</code> instances as keys for most internal methods and the relationship layer.</li>
<li><code>type+id</code> for serializing/deserializing a <code>record</code> or <a href="https://jsonapi.org/format/#document-resource-object-identification"><code>resource</code></a></li>
<li><code>type+clientId</code> for caching newly created records on the client and communicating 
about them with <code>RecordData</code>.</li>
<li>Various other non-serializable forms of identity for tracking requests, relationship 
membership and state.</li>
<li>In some cases we have no concept at all where one is needed (for instance, caching 
queries)</li>
</ul>
<p>We wish to simplify and codify our handling of identity.</p>
<h3 id="simplify-storewrapper-and-recorddata-apis"><a class="header" href="#simplify-storewrapper-and-recorddata-apis">Simplify StoreWrapper and RecordData APIs</a></h3>
<p>Today, to deal with the lack of a unified <code>identifier</code> concept, we overload many 
<code>StoreWrapper</code> and <code>RecordData</code> API method signatures with <code>modelName</code>, <code>id</code>, <code>clientId</code>
as arguments. This leads to method signatures being long and needlessly unwieldy.</p>
<p>Note: We had initially intended to overload all of these classes method signatures in 
this way, to ensure that <code>RecordData</code> implementations could be <code>singleton</code>s, but we failed
to correctly implement the <code>RecordData</code> RFC in this regard and a near future RFC will look
at rectifying this using the <code>Identity</code> APIs introduced here.</p>
<p>Moving to a unified concept of <code>identity</code> opens up a path to clean up these method
signatures.</p>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>Operations are a foundational concept for <code>acid</code> transactions. Without the ability to 
describe an operation and a clear mental model of what operations exist and achieve, it
is difficult to understand how an action affects state. Granularity and clarity is key.</p>
<p>While <code>ember-data</code> does not yet have concepts of operations or transactions, mutations and
updates are applied directly, there are many areas we could improve upon by introducing
them. As with data, operations upon data should be serializable so that local state can 
be accurately cached on local clients.</p>
<h3 id="nested-saves--api-transactions--websocket-support"><a class="header" href="#nested-saves--api-transactions--websocket-support">Nested Saves / API Transactions / Websocket Support</a></h3>
<p>Many applications wish to create or update and save multiple records together. Achieving
this in <code>ember-data</code> today is unweildy and has many difficult edge cases: one of which
is correctly matching data received back from the API to the newly created records already
on the client.</p>
<p>A similar edge case occurs when a newly created record is saved for the first time and 
prior to receiving the request response the same record is recieved via another means
(background polling, websocket subscription, etc.). We have no means of matching the record
returned by the alternative means to that of the request, leading to a second cache entry 
being created and an error once the initial request completes.</p>
<p>One solution has been to generate and assign <code>id</code>s for records on the client, but this is
not always desireable. These scenarios are a major motivation for <code>lid</code> in the <code>json-api</code>
spec. Users wishing to solve these cases would be able to serialize the <code>lid</code> of the 
<code>Identifier</code> for a newly created record and reflect that <code>lid</code> back in any payloads send 
from their API for the session to correctly match the payloads to the record.</p>
<h3 id="better-cache-serialization--improved-infra-for-offline-support"><a class="header" href="#better-cache-serialization--improved-infra-for-offline-support">Better Cache Serialization &amp; Improved Infra for Offline Support</a></h3>
<p>In order to enable users to achieve full offline support, or to serialize the store 
or transport across the wire (for example as an advanced fastboot rehydration mode)
the entire state of the store needs to be serializable. This RFC introduces the 
foundation for mechanisms through which this can be later achieved.</p>
<hr />
<h2 id="detailed-design-82"><a class="header" href="#detailed-design-82">Detailed design</a></h2>
<pre><code class="language-typescript">export interface Identifier {
  lid: string;
}

export interface RecordIdentifier extends Identifier {
  id?: string | null;
  type: string;
}
</code></pre>
<p>Note: the referential stability (object reference) of all identifiers created by the
<code>store</code> is guaranteed. E.g. any data that results in the lookup of an identifier 
producing the same <code>lid</code> token will return the same <code>Identifier</code> instance. This is 
useful for being able to use identifiers for either <code>Map</code> or <code>WeakMap</code> cache solutions.</p>
<h3 id="buckets"><a class="header" href="#buckets">Buckets</a></h3>
<p>In an ideal world, the <code>lid</code> of each <code>Identifier</code> would be a <code>v4</code> <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">uuid</a>,
making it practically unique in all contexts. However, due to requirements around design
flexibility and performance we are only requiring that <code>Identifiers</code> be unique <em>within 
their bucket</em> for the data they are intended to reference.</p>
<p>Each underlying primitive will have its own bucket, as new primitives are formalized, new
buckets will emerge. Initially we expect only a <code>record</code> bucket which aligns with today's
<code>IdentityMap</code> cache for <code>Record</code>s. Examples of future buckets may include a cache for 
<code>queries</code>, <code>documents</code>, <code>transactions</code>, <code>operations</code>, <code>errors</code>, <code>meta</code> or any number of other
concepts that represent state required to be serializable.</p>
<p>In our ideal world, the <code>lid</code> would then be a <code>uuid-v4</code> that is practically unique across
buckets and not just within. While we  will ship a minimal <code>uuid-v4</code> generator to be used
for generating identifiers when needed on the client, generating large quantities of <code>uuid</code>s
is cost prohibitive.  An early performance analysis suggests that a few thousand identifiers
would bring a cost in the tens of milliseconds on powerful machines. When generating
identifiers for data returned by an API, this cost would impede optimizations around
rendering.</p>
<p>This cost is primarily due to the need to generate large quantities of random bytes: a cost
that is necessarily cpu intensive. Additionally, many forms of data (such as <code>json-api</code> 
resources) come with unique or nearly unique identifying information already (<code>type</code> + <code>id</code>,
<code>href</code> etc.).  Some APIs already make use of <code>v4</code> <code>uuid</code>s as IDs, and for these APIs it would
make the most sense to implement a custom generation method to reuise these <code>id</code>s as <code>lid</code>s
when present.</p>
<p>To balance performance with the requirements of <code>identity</code>, we are choosing what we feel is a
<em>sensible default</em>.  Users for whom this default does not meet their requirements may override
the appropriate hooks to generate identifiers that do.</p>
<h3 id="customizing-identifiers"><a class="header" href="#customizing-identifiers">Customizing Identifiers</a></h3>
<p>For users wishing to provide increased guarantees around uniqueness and serializability
of identifiers we provide the ability to configure how we generate and manage identifiers.</p>
<p>Given the guarantees around uniqueness and serializability that are required, this configuration
applies to all <code>IdentifierCache</code> instances and meaning that it is shared across all buckets,
store instances. Ideally the configuration does not change between application instances but
for encapsulation purposes for fastboot and tests we allow and encourage repeated setup/teardown.
Specifically, this recommendation is that in order to provide a strong guarantee of uniqueness
and serializability, <em>identifiers generated by separate store or application instances but which
represent the same data should result in the generation of the same <code>lid</code></em>.</p>
<p>Indeed in this vein, we have not provided a mechanism for distinguishing what instance of a <code>store</code>
has asked for an <code>Identifier</code> when multiple stores are present, but the <code>initializer</code> pattern
recommended below does offer the ability to distinguish <em>per-application</em>. We do not recommend
using this availability to affect your generation method.</p>
<p>Supplying custom <code>lid</code> generation can be done using <code>setIdentifierGenerationMethod</code>. Currently
there is only one bucket (<code>record</code>) as discussed above, but we reserve the ability to add 
additional buckets in the future.</p>
<p>Users should do any identifier customization within an instance-initialize prior to making use
of the store. Given the more universal nature of this customization, we recommend ensuring that
you consider the mechanics of multiple applications in fastboot or test application instance
scenarios when instantiating and populating any secondary lookup tables or caches for identifiers.
Weakmapping these lookup tables and caches to the application instance will accomplish this.
An example is provided below.</p>
<pre><code class="language-typescript">/*
  A method which can expect to receive various data as its first argument
  and the name of a bucket as its second argument. Currently the second
  argument will always be `record` data should conform to a `json-api`
  `Resource` interface, but will be the normalized json data for a single
  resource that has been given to the store.

  The method must return a unique (to at-least the given bucket) string identifier
  for the given data as a string to be used as the `lid` of an `Identifier` token.

  This method will only be called by either `getOrCreateIdentifier` or 
  `createIdentifierForNewRecord` when an identifier for the supplied data
  is not already known via `lid` or `type + id` combo and one needs to be
  generated or retrieved from a proprietary cache.

  `data` will be the same data argument provided to `getOrCreateIdentifier`
  and in the `createIdentifierForNewRecord` case will be an object with
  only `type` as a key.
*/
type GenerationMethod = (data: Object, bucket: string) =&gt; string;

/*
 A method which can expect to receive an existing `Identifier` alongside
 some new data to consider as a second argument. This is an opportunity
 for secondary lookup tables and caches associated with the identifier
 to be amended.

 This method is called everytime `updateRecordIdentifier` is called and
  with the same arguments. It provides the opportunity to update secondary
  lookup tables for existing identifiers.
  
 It will always be called after an identifier created with `createIdentifierForNewRecord`
  has been committed, or after an update to the `record` a `RecordIdentifier`
  is assigned to has been committed. Committed here meaning that the server
  has acknowledged the update (for instance after a call to `.save()`)

 If `id` has not previously existed, it will be assigned to the `Identifier`
  prior to this `UpdateMethod` being called; however, calls to the parent method
  `updateRecordIdentifier` that attempt to change the `id` or calling update
  without providing an `id` when one is missing will throw an error.
*/
type UpdateMethod = (identifier: StableIdentifier, newData: Object, bucket: string) =&gt; void;

/*
A method which can expect to receive an existing `Identifier` that should be eliminated
 from any secondary lookup tables or caches that the user has populated for it.
*/
type ForgetMethod = (identifier: StableIdentifier) =&gt; void;

/*
 A method which can expect to be called when the parent application is destroyed.

 If you have properly used a WeakMap to encapsulate the state of your customization
 to the application instance, you may not need to implement the `resetMethod`.
*/
type ResetMethod = () =&gt; void;

export function setIdentifierGenerationMethod(method: GenerationMethod): void {}

export function setIdentifierUpdateMethod(method: UpdateMethod): void {}

export function setIdentifierForgetMethod(method: ForgetMethod): void {}

export function setIdentifierResetMethod(method: ResetMethod): void {}
</code></pre>
<p>A simple custom generation method might be an increasing counter like below:</p>
<pre><code class="language-typescript">import { setIdentifierGenerationMethod } form '@ember-data/store';

export function initialize(applicationInstance) {
  // note how `count` here is now scoped to the application instance
  // for our generation method by being inside the closure provided
  // by the initialize function
  let count = 0;

  setIdentifierGenerationMethod((resource: Resource) =&gt; {
    return resource.lid || `my-key-${count++}`;
  });
}

export default {
  name: 'configure-ember-data-identifiers',
  initialize
};
</code></pre>
<h3 id="identifiers-for-records"><a class="header" href="#identifiers-for-records">Identifiers for Records</a></h3>
<p>When discussing identifiers for records it is useful to be familiar with <code>json-api</code> 
interfaces for <a href="https://jsonapi.org/format/#document-resource-objects">ResourceObjects</a> 
and <a href="https://jsonapi.org/format/#document-resource-identifier-objects">ResourceIdentifierObjects</a>.</p>
<p>Below, we expose a rough approximation of these interfaces as <code>Resource</code> including the
potential presence of <code>lid</code>.</p>
<pre><code class="language-typescript">import { Value as JSONValue } from 'json-typescript';

type JSONDict = { [k: string]: JSONValue };

export interface Resource {
  id: string;
  type: string;
  lid?: string;
  attributes?: JSONDict;
  relationships?: JSONDict;
  meta?: JSONDict;
}
</code></pre>
<p>We can access and generate identifiers for records using the following APIs available
via the <code>identifierCache</code> on the <code>Store</code> and <code>StoreWrapper</code> classes.</p>
<pre><code class="language-typescript">import Service from '@ember/service';

export interface Store {
  identifierCache: IdentifierCache
}

export interface StoreWrapper {
  identifierCache: IdentifierCache
}

export default class IdentifierCache extends Service {
  /*
   Returns the Identifier for the given Resource, creates one if it does not yet exist.

   Specifically this means that we:

   - validate the `id` `type` and `lid` combo against known identifiers
   - return an object with an `lid` that is stable (repeated calls with the same
    `id` + `type` or `lid` will return the same `lid` value)
   - this referential stability of the object itself is guaranteed
  */
  getOrCreateRecordIdentifier(resource: Resource): RecordIdentifier {}

  /*
   Returns a new Identifier for the supplied data. Call this method to generate
   an identifier when  a new resource is being created local to the client and
   potentially does not have an `id`.
  */
  createIdentifierForNewRecord({ type: string, id: string | null }): RecordIdentifier {}

  /*
   Provides the opportunity to update secondary lookup tables for existing identifiers
   
   Called with the attributes provided to createRecord after an identifier created with
   `createIdentifierForNewRecord` has been instantiated.

   Called again after an identifier created with `createIdentifierForNewRecord` has been
   committed, or a resource has received an update from the API.

   Assigns `id` to an `Identifier` if `id` has not previously existed; however,
   attempting to change the `id` or calling update without providing an `id` when
   one is missing will throw an error.
  */
  updateRecordIdentifier(identifier: RecordIdentifier, data: Resource): void;

  /*
   Provides the opportunity to eliminate an identifier from secondary lookup tables
   as well as eliminates it from ember-data's own lookup tables and book keeping.

   Useful when a record has been deleted and the deletion has been persisted and
   we do not care about the record anymore. Especially useful when an `id` of a
   deleted record might be reused later for a new record.
  */
  forgetRecordIdentifier(identifier: RecordIdentifier): void
}

// -- example uses

// ... for existing resources
let identifierA = identifierCache.getOrCreateRecordIdentifier({
  type: 'foo',
  id: '1'
}); // =&gt; { lid: 'some-unique-key-1324' }
let identifierB = identifierCache.getOrCreateRecordIdentifier({
  type: 'foo',
  id: '2',
  lid: '123a' 
}); // =&gt; { lid: '123a' }
let identifierC = identifierCache.getOrCreateRecordIdentifier({ 
  type: 'foo', 
  lid: '123b' 
}); // =&gt; { lid: '123b' }
let identifierD = identifierCache.getOrCreateRecordIdentifier({ 
  lid: '123c' 
}); // =&gt; { lid: '123c' }

// ... generating identifiers for newly created resources
// (this is something that likely only store.createRecord() should do)
let identifier1 = identifierCache.createIdentifierForNewRecord('foo'); // =&gt; { lid: 'some-random-unique-key-123a' }
let identifier2 = identifierCache.createIdentifierForNewRecord('foo'); // =&gt; { lid: 'some-random-unique-key-123b' }
let identifier3 = identifierCache.createIdentifierForNewRecord('bar'); // =&gt; { lid: 'some-random-unique-key-123c' }
</code></pre>
<h3 id="updating-new-record-identifiers-with-more-complete-information"><a class="header" href="#updating-new-record-identifiers-with-more-complete-information">Updating new record Identifiers with more complete information</a></h3>
<p>Called when an identifier has been generated for resource data prior to <code>id</code> being
available for that resource and complete resource data is now available. <code>ember-data</code> 
will automatically call this with the resolved payload after save for any newly created
records. An <code>identifier</code> can only be updated once, and only when transitioning the 
associated resource from a never-before-persisted to persisted state.</p>
<p>Udating provides the opportunity to update the primary and secondary lookup tables for the
identifier. In the case of a RecordIdentifier that was created locally, it provides the
ability to do a &quot;one time only&quot; upgrade of the identifier to assign an id.</p>
<pre><code class="language-ts">IdentifierCache {
  updateRecordIdentifier(identifier: RecordIdentifier, data: Resource): void;
}
</code></pre>
<h3 id="refreshing-an-identifier-when-recycling-an-id"><a class="header" href="#refreshing-an-identifier-when-recycling-an-id">Refreshing an <code>Identifier</code> When recycling an <code>id</code></a></h3>
<p>Occasionally some APIs re-use the same <code>id</code> for different <code>data</code>. Common scenarios for
this include reusing the <code>id</code> of a previously deleted record for a new record, and less
commonly a stable <code>id</code> to reference the &quot;currently logged in user&quot;.</p>
<p>When this occurs, the existing <code>lid</code> needs the chance to be forgotten and a new <code>lid</code>
generated. This method eliminates the identifier from our internal cache only. Caches
associated with custom identifiier generation methods must be cleared by the implementors
of those custom methods. Any data associated with the original <code>lid</code> should be purged from
caches prior to calling this method. We leave it to follow up RFCs to provide
infrastructure for safely and correctly eliminating records from caches.</p>
<pre><code class="language-ts">IdentifierCache {
  forgetRecordIdentifier(identifier: RecordIdentifier): void
}
</code></pre>
<h3 id="access-from-record-instances"><a class="header" href="#access-from-record-instances">Access from <code>record</code> instances</a></h3>
<pre><code class="language-typescript">export function recordIdentifierFor(record: object): RecordIdentifier {}
</code></pre>
<pre><code class="language-ts">import { recordIdentifierFor } from '@ember-data/store';

// ...

// when you have a record instance
let identifier = recordIdentifierFor(record);

// from inside a record class after instantiation
class MyRecord {
  getIdentifier() {
    return recordIdentifierFor(this);
  }
}
</code></pre>
<p>Whether and how to access an identifier during instantiation of a record will be left
for discussion as part of a different RFC for custom record classes.</p>
<h3 id="polymorphism--the-username-problem"><a class="header" href="#polymorphism--the-username-problem">Polymorphism &amp; &quot;The Username Problem&quot;</a></h3>
<p>A common edge case that <code>Identifiers</code> enables end users to solve is when multiple pieces
of identifying information should reference the same data.</p>
<p>For instance, when using single-table polymorphism (in which <code>ferrari</code> and <code>bmw</code> extend
<code>car</code> and share a common <code>id</code> space) then <code>ferrari:1</code> and <code>bmw:2</code> are the same vehicles
as <code>car:1</code> and <code>car:2</code>.</p>
<p>A similar problem presents for the scenario in which we know that we wish to reference a
<code>user</code> with a given <code>username</code>, but do not yet have access to the <code>id</code> for that user. In
this case, <code>user:@jackson5</code> and <code>user:abc123</code> are the same user.</p>
<p>Today in these situations many users will encounter bugs resulting from there being two 
records present in the cache instead of one. This problem can be solved with a custom 
identifier generation method that is aware of an application's polymorphic associations
or additional indexing requirements.</p>
<p>For example, to solve the username problem we might do the following:</p>
<pre><code class="language-typescript">import { setIdentifierGenerationMethod } from '@ember-data/store';

export const SECONDARY_IDENTIFIER_CACHE = new WeakMap();

export function initialize(applicationInstance) {
 let count = 0;
 const typeid_cache = {};
 const username_cache = {};

 /*
   Note: if you needed to share access to these caches elsewhere
   in the same applicationInstance, we could use a WeakMap to add
   them. Shown here for a more complete example.
 */
 SECONDARY_IDENTIFIER_CACHE.set(applicationInstance, {
   typeid: typeid_cache,
   username: username_cache
 });

 setIdentifierGenerationMethod((resource: Resource) =&gt; {
   let { type, id, lid } = resource;
   let username = (resource.type === 'user' 
     &amp;&amp; resource.attributes
     &amp;&amp; resource.attributes.username);
   let cacheKey, altCacheKey;

   if (lid) {
     // probably ensure username and id cache are populated first IRL
     return lid;
   }

   // handle the case where we do know the ID and have set the `lid` previously
   if (id) {
     cacheKey = `${type}:${id}`;

     if (lid = typeid_cache[cacheKey]) {
       return lid;
     }
   }

   // handle the cases where we have a username but we didn't know the ID yet
   if (username) {
     lid = username_cache[username];

     if (!lid) {
       lid =  `my-key-${count++}`;
       username_cache[username] = lid;
     }

     if (id) {
       typeid_cache[cacheKey] = lid;
     }
     return lid;
   }

   // handle everything else
   lid =  `my-key-${count++}`;
   typeid_cache[cacheKey] = lid;

   return lid;
 });
}

export default {
 name: 'configure-ember-data-identifiers',
 initialize
};
</code></pre>
<h4 id="handling-updates-to-alternative-cache-keys"><a class="header" href="#handling-updates-to-alternative-cache-keys">Handling Updates to Alternative Cache Keys</a></h4>
<p>Note that in our above example we treat <code>username</code> a stable, immutable alternative 
primary-key. Some APIs allow users to change the value of such &quot;unique keys&quot; (<code>email</code>
<code>phone</code> <code>username</code> being common examples).</p>
<p>If your application enables such behavior, and these updates are not handled by the
call to <code>updateRecordIdentifier</code> that occurs after a record is saved, in addition
to manually calling <code>identifierCache.updateRecordIdentifier</code> with the desired patch
you could also provide your own explicit method for doing so. An explicit method is
great for ensuring the correct context for the granularity of this change. The timing
of this update would be up to you (whether pre- or post- the mutation having been
persisted to the server)</p>
<p>Extending the example above:</p>
<pre><code class="language-ts">import { SECONDARY_IDENTIFIER_CACHE } from './initializers/configure-identifiers';

export function updateUsernameForIdentifier(
  // application instance is the result of `getOwner`
  // on something like the `store` or a `component`
  owner: Owner, 
  identifier: Identifier,
  oldUsername: string,
  newUsername: string
  ) {
   const caches = SECONDARY_IDENTIFIER_CACHE.get(applicationInstance);
   const typeid_cache = caches.typeid;
   const username_cache = caches.username;

   if (username_cache[oldUsername] !== identifier.lid) {
     throw new Error('invalid update');
   }

   // you might want to continue mapping both old an new username
   //  here we decided not to.
   delete username_cache[oldUsername];

   username_cache[newUsername] = identifier.lid;
 }
</code></pre>
<h3 id="identifier-stability"><a class="header" href="#identifier-stability">Identifier Stability</a></h3>
<p>Identifiers handed to public APIs by <code>ember-data</code> will <strong>always</strong> be <em>referentially stable</em>
Public <code>ember-data</code> APIs that <strong>expect</strong> an <code>Identifier</code> will normalize the object they 
are given into the stable <code>Identifier</code> if it is not one already. This is done to allow
for serialized identifiers and identifying information from the API to more easily be worked
with without extra normalization effort.</p>
<p>Specifically, this means that as regards this RFC, <code>identifiers</code> that are structurally the same
(meaning an object with the same <code>lid</code>) are treated as any other <code>identifier</code> regardless of
whether the object is an identical reference to the object generated by the store previously.</p>
<p>Additionally, only the objects generated by the store will have additional debug information
attached to them, as shown in the interfaces below.</p>
<pre><code class="language-typescript">const IS_IDENTIFIER = Symbol('is-identifier');

// provided for additional debuggability
const DEBUG_CLIENT_ORIGINATED = Symbol('record-originated-on-client');
const DEBUG_IDENTIFIER_BUCKET = Symbol('identifier-bucket');

export interface StableIdentifier {
  lid: string;
  [IS_IDENTIFIER]: true;
  [DEBUG_IDENTIFIER_BUCKET]: string;
}

export interface StableRecordIdentifier extends StableIdentifier {
  id: string | null;
  type: string;
  [DEBUG_CLIENT_ORIGINATED]: boolean;
}
</code></pre>
<h2 id="how-we-teach-this-68"><a class="header" href="#how-we-teach-this-68">How we teach this</a></h2>
<p>Largely this is an internal feature, although one that power users will sometimes need
access to. Additional guides should be created showing how identifiers may be used to
solve common edge cases unique to given users. We have attempted to go into depth here
with examples and documentation about the capabilities provided to make creating these
additional resources as easy as possible.</p>
<p>Existing APIs that accept or provide <code>id</code> and <code>type</code> information will continue to do so
unchanged.</p>
<h2 id="drawbacks-92"><a class="header" href="#drawbacks-92">Drawbacks</a></h2>
<ul>
<li>None, the performance characteristics of the setup here described may seem worse on
allocation (object vs string identifier) but in reality they significantly improve our
ability to reduce allocations, duplicate logic, and branching code paths throughout the
library.</li>
</ul>
<h2 id="alternatives-94"><a class="header" href="#alternatives-94">Alternatives</a></h2>
<p>A lengthy amount of discussion was had revolving around whether <code>Identifiers</code> shouldn't be
a simple <code>string</code> (e.g. just the <code>lid</code> portion).</p>
<p>The arguments for doing so revolve around <code>string</code> being referentially stable automatically,
and that we do not require an <code>object reference</code> for being able to use identifiers as keys in
<code>WeakMaps</code> both because <code>lid</code> is stable and because <code>ember-data</code> has need of controlling most
of the object lifecycle.</p>
<p>However, continuing to use an object wrapper, especially a stable object wrapper, comes with
a multitude of benefits, including:</p>
<ul>
<li><strong>debugging:</strong> enhanced debugging by associating additional information with the
identifier in development builds</li>
<li><strong>debugging:</strong> enhanced debugging by users being able to see type and id at a 
glance when inspecting state.</li>
<li><strong>bug prevention:</strong> enforcement of the use of the identifier generation process 
(to ensure lookup tables are properly populated)</li>
<li><strong>debugging:</strong> ability to tell at a glance that an identifier was properly processed</li>
<li><strong>ergonomics:</strong> closer alignment to <code>jsonapi</code> that makes it true that all <code>RecordIdentifiers</code>
are also <code>ResourceIdentifierObjects</code></li>
<li><strong>ergonomics:</strong> We can provide better <code>typescript</code> support for an object interface than a <code>string</code>
given that any <code>string</code> would fit the <code>lid</code> interface but only correctly shaped objects (which includes
the <code>Symbol</code> for <code>identifier</code>) would fit the correct object interface.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-10-20
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/408
Tracking: https://github.com/emberjs/rfc-tracking/issues/7</p>
<hr />
<h1 id="decorators"><a class="header" href="#decorators">Decorators</a></h1>
<h2 id="summary-97"><a class="header" href="#summary-97">Summary</a></h2>
<p>Native classes are now officially supported in Ember, but currently their usage
is very limited. Core Ember features such as computed properties, actions, and
service injections have no publicly supported APIs to be used with native class
syntax.</p>
<p>Decorators provide a way to abstract functionality and improve the developer
experience of working with native classes.  This RFC outlines the implementation
and rollout plan for bringing decorators to Ember's computed properties (and
other behavior) for use in native classes.</p>
<h3 id="a-note-on-decorator-stability"><a class="header" href="#a-note-on-decorator-stability">A Note on Decorator Stability</a></h3>
<p><a href="https://github.com/tc39/proposal-decorators">Decorators</a> are important to
adopting native class syntax. They are a formalization of the patterns we have
been using as a community for years, and it will not be possible to use native
classes ergonomically without them unless a number of major concepts (computed
properties, injections, actions) are rethought. That said, as of today (01/03/19)
decorators are still a <a href="https://tc39.github.io/process-document"><em>stage 2</em> proposal</a>
in TC39, which means that while they are fully defined as a spec, they are not
yet considered a candidate for inclusion in the language, and may have
incremental changes that could be breaking if/when moved to stage 3. As such,
merging support for them now would pose some risk. Additionally, <a href="https://github.com/tc39/proposal-class-fields">class
fields</a> are also required for
effective use of decorators, and while they are stage 3 in the process, they
have not yet been fully accepted either.</p>
<p>Ember cannot guarantee that the spec won't change, and such changes cannot apply
to Ember's normal semver guarantees. But it can make the following guarantees:</p>
<ol>
<li>
<p>If there are changes to the spec, and it <em><strong>is</strong></em> possible to avoid changing
the public APIs of decorators, then Ember will make the changes necessary to
avoid public API changes.</p>
</li>
<li>
<p>If there are changes to the spec, and it <em><strong>is not</strong></em> possible to avoid
breaking changes, Ember will minimize the changes as much as possible, and
will provide a codemod to convert from the previous version of the spec to
the next.</p>
</li>
<li>
<p>If the spec is dropped from TC39 altogether, Ember would have to continue to
provide support for decorators via babel transforms until they are deprecated
following the standard RFC process, and removed according to SemVer. Reverse
codemods which translate decorators and native class syntax back to classic
class syntax <em>will</em> be made, and alternatives for native class syntax will be
explored.</p>
</li>
<li>
<p>Classic class syntax will continue to be supported <em>at least</em> until these
features have been stabilized in the JavaScript language, to allow us to
revert these changes if necessary. They will most likely be supported for
longer to allow a smooth transition for users who do not want to adopt native
classes until they are completely stable.</p>
</li>
</ol>
<p>This RFC is being made with the assumption that decorators will be moved to
stage 3 in the near future, <em>before</em> this RFC is implemented in Ember,
dramatically reducing the risk of adopting decorators. If this RFC is accepted
and decorators are not advanced in a timely manner, a followup RFC should be
made to determine whether or not decorators should be adopted in stage 2, and
what the support for them would look like.</p>
<h2 id="terminology-2"><a class="header" href="#terminology-2">Terminology</a></h2>
<p>For the purposes of this RFC, we'll use the following terminology:</p>
<ul>
<li>The <strong>Octane programming model</strong> refers to the new programming model
established by the Ember Octane edition. It includes <em>native classes</em>,
<em>tracked properties</em> and <em>Glimmer components</em>, and more generally refers to
features that will be considered <em>core to Ember</em> in the future.</li>
<li>The <strong>classic programming model</strong> refers to the traditional programming model.
It includes <em>classic classes</em>, <em>computed properties</em>, <em>event listeners</em>,
<em>observers</em>, <em>property notifications</em>, and <em>classic components</em>, and more
generally refers to features that will not be central to Ember Octane.</li>
<li><strong>Native classes</strong> are classes defined using the JavaScript <code>class</code> keyword</li>
<li><strong>Classic classes</strong> are classes defined by subclassing from <code>EmberObject</code>
using the static <code>extend</code> method.</li>
</ul>
<h2 id="motivation-98"><a class="header" href="#motivation-98">Motivation</a></h2>
<p>Native JavaScript class syntax has been evolving for the past three years, filling in
the cracks and providing better, more standardized ways to write classes for the
web. They will be a key part of the Octane programming model, and the ES Classes
RFC was the first step toward enabling Ember users to use native class syntax,
but there are still key features of Ember that are not usable with <code>class</code>
syntax today, including <em>computed properties</em>, <em>actions</em>, and <em>injections</em>.</p>
<p>These features cannot be used ergonomically with native classes as it stands.
The only options are to either use Ember's <code>defineProperty</code> function directly,
or to define these values in an anonymous class. Both of these options are hard
to read, and will be difficult to codemod in the future:</p>
<pre><code class="language-js">// Using define property
import { computed, defineProperty } from '@ember/object';

class Person {
  constructor() {
    this.firstName = 'Melanie';
    this.lastName = 'Sumner';
  }
}

// define a computed property
defineProperty(
  Person.prototype,
  'fullName',
  computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
);

// Using intermediate extends
import EmberObject, { computed } from '@ember/object';

class Person extends EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
}) {
  constructor() {
    super(...arguments);
    this.firstName = 'Melanie';
    this.lastName = 'Sumner';
  }
}
</code></pre>
<p>Another method which was used for some time was to assign these values using
class field initializers. This practice is problematic however as it creates a
new instance of the computed property per <em>instance</em> of the class, and does not
work with native getters either:</p>
<pre><code class="language-ts">import EmberObject, { computed } from '@ember/object';

export default class Person extends EmberObject {
  firstName = 'Melanie';
  lastName = 'Sumner';

  fullName = computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  });
}

new Profile().fullName; // returns the CP instance, not 'Melanie Sumner'
</code></pre>
<p>The missing piece of functionality that we need here are <em>decorators</em>, and in
fact that is not a coincidence. The roots of the current TC39 decorator proposal
can be traced back to Ember (Yehuda having worked on the first few drafts of it)
specifically because computed properties, observers, and so on <em>are</em> decorators.
We've been using them for years in Ember, just with a non-standard,
slightly-less-clean syntax.</p>
<pre><code class="language-ts">import Component from '@ember/component';
import { computed } from '@ember/object';

export default class Profile extends Component {
  firstName = 'Melanie';
  lastName = 'Sumner';

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Native decorators bring a more natural way of declaring computed properties to
native classes than the current computed macros.</p>
<h2 id="prior-art-1"><a class="header" href="#prior-art-1">Prior Art</a></h2>
<p>The <a href="http://ember-decorators.github.io/ember-decorators/">Ember Decorators</a>
project has been experimenting with using decorators within Ember for some time
now, with the goal of reaching feature parity with the classic object model, and
the learnings from that project will be used to inform the API design in this
RFC.</p>
<h2 id="detailed-design-83"><a class="header" href="#detailed-design-83">Detailed design</a></h2>
<p>This RFC proposes that:</p>
<ol>
<li><code>Ember.computed</code>, the <code>inject</code> macros, and the computed property macros be
updated to return a standard JavaScript decorator. Internally, the classic
object model will be made aware of these decorators, and know how to apply
them. This will allow the same exact imports to continue working as both
native decorators and classic decorators. This decorator <em>will</em> be compatible
with classes that extend from <code>EmberObject</code> and classes which do not.</li>
<li>A new <code>@action</code> decorator be added to allow the definition of actions on
classes. This decorator will <em>only</em> be compatible with classes that are
action handlers.</li>
</ol>
<p>This does leave out some features from the classic programming model which are
currently provided by Ember Decorators. This is both to minimize decorators' API
surface area, and because they will not be a major part of Ember Octane's
programming model. Addressing them individually:</p>
<ul>
<li><strong>Observers and event listeners</strong>, which have long been considered an
antipattern.</li>
<li><strong>Classic component</strong> functionality such as <code>classNames</code>, <code>classNameBindings</code>,
<code>attributeBindings</code>, etc. will be unnecessary with Glimmer components.</li>
<li><strong>Ember Data</strong> provides computed properties which had to be manually wrapped
in decorators. With the changes proposed in this RFC, however, they should
continue to work without any additional changes. In fact, all computed
property macros will.</li>
</ul>
<p>Users who want these features will still be able to rely on addons such as Ember
Decorators, which will provide decorator support for them for the forseeable
future. Moving forward, this RFC breaks down into <em>computed properties</em> and
<em>actions</em>.</p>
<h3 id="computed-properties"><a class="header" href="#computed-properties">Computed Properties</a></h3>
<p>As mentioned before, computed properties essentially <em>are</em> decorators. However,
they are not spec compliant. Currently, <code>computed()</code> returns an instance of the
<code>ComputedProperty</code> class, which contains all of the meta information about the
decorated property. Native decorators, by contrast, are functions which receive
a descriptor and modify it as necessary.</p>
<p>Unfortunately, there's no way for us to know <em>ahead of time</em> when a computed
property is going to be used as a native decorator in a native class, and when
it is going to be used in a classic class. Consider the following:</p>
<pre><code class="language-js">class Person {
  @alias('prefix') title;
}
</code></pre>
<p>Really, what's going on there is <em>not</em> that we are invoking the <code>@alias</code>
decorator with parameters. We are invoking a function which <em>returns</em> a
decorator, so it desugars to:</p>
<pre><code class="language-js">const aliasForPrefix = alias('prefix');

class Person {
  @aliasForPrefix title;
}
</code></pre>
<p>Therefore, the <code>alias</code> function <em>must</em> itself return a decorator function.
However, this conflicts with usage in the classic programming model:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  title: alias('prefix')
})
</code></pre>
<p>We just established that <code>alias</code> must return a decorator function, but here it
is with the exact same arguments, and it needs to return a <code>ComputedProperty</code>
instance. There is nothing we can branch on here - in both cases, <code>alias</code> only
receives the string <code>'prefix'</code>, so it has no context for how it will be used.</p>
<p>The native class piece of this puzzle is completely inflexible. A decorator must
be a function, there is no choice about it. However, the <em>Ember</em> piece is <em>very</em>
flexible. The classic object model just needs a way to get the meta information
for the property when the class is being finalized. We can either assign the
meta information to the decorator function directly, or we can associate it via
a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"><code>WeakMap</code></a>.</p>
<p>The benefit of doing this is that the entire Ember ecosystem will get decorator
support with no extra work required. Because standard <code>computed</code> definitions
will work as decorators, existing macros will also work as decorators with no
changes to existing code.</p>
<p>All of Ember's built in computed macros in the <code>@ember/object/computed</code> module
will also become decorators with no extra work. However, the injection macros
will require slight updates as they use a subclass of the <code>ComputedProperty</code>
class. These updates should be relatively minor, and will follow the same
strategy as <code>computed()</code>.</p>
<h4 id="usage-and-api"><a class="header" href="#usage-and-api">Usage and API</a></h4>
<p>The API for <code>computed</code> will remain mostly the same. The key differences will be:</p>
<ol>
<li>The result of <code>computed</code> will be a decorator which can be applied directly to
native <em>getters</em>, <em>setters</em>, and <em>class fields</em>.</li>
<li>The <code>ComputedPropertyConfig</code> (the getter/setter functions) argument provided
to <code>computed</code> will now be optional when used as a decorator on a native
getter or setter, and the native getter/setter will be used instead.</li>
</ol>
<pre><code class="language-ts">function computed(...args: (string | ComputedPropertyConfig)[]): PropertyDecorator;
</code></pre>
<p>The function signatures of all existing macros, including <code>inject</code> macros, would
change in the same way.</p>
<p>In general usage, these three definitions are equivalent:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
});

class Person {
  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

class Person {
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
  fullName;
}
</code></pre>
<p>That last example may seem confusing at first, but this is actually the same as
defining a computed property macro:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

function join(...dependentKeys) {
  return computed(...dependentKeys, {
    get() {
      return dependentKeys.map(key =&gt; this[key]).join(' ');
    }
  });
}

class Person {
  @join('firstName', 'lastName')
  fullName;
}
</code></pre>
<p>Notably, using <code>@computed</code> as a decorator <em>directly</em>, without parenthesis, will
not be supported. This is to prevent a parameter check on a critical path:</p>
<pre><code class="language-js">class Person {
  @computed
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>The most common use case for this form in classic classes was to provide a new
instance of an object or array per instance of the class. This use case is
solved in native classes by class fields:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  cache: computed(function() {
    return {};
  })
})

class Person {
  cache = {};
}
</code></pre>
<p>For other use cases, such as lazy evaluation and caching, it will still be
possible to call <code>@computed</code> with no arguments:</p>
<pre><code class="language-js">class Person {
  @computed()
  get cache() {
    return {};
  };
}
</code></pre>
<h4 id="preventing-incoherent-usage"><a class="header" href="#preventing-incoherent-usage">Preventing Incoherent Usage</a></h4>
<p>Making the <code>ComputedPropertyConfig</code> optional opens up lots of room for
accidents. A computed property without a getter or setter does not make sense,
nor does a computed propery with <em>two</em> getters or setters. The new decorator
will assert at <em>decorator application</em> time to ensure it is being used
correctly:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

// This will throw because the user attempted to define a CP without a getter
const Person = EmberObject.extend({
  fullName: computed()
});

// This will also throw because it is missing a getter
class Person {
  @computed('firstName', 'lastName')
  fullName;
}

// This will throw because a getter was already defined
class Person {
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  })
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Effectively, if <code>computed</code> is passed a <code>ComputedPropertyConfig</code>, it returns a
class field decorator. Otherwise, it returns an accessor (getter/setter)
decorator.</p>
<h4 id="property-modifiers"><a class="header" href="#property-modifiers">Property Modifiers</a></h4>
<p>Almost all computed property modifiers have been deprecated at this point, but
they are still in use today and will still be available until Ember v4. As such,
their syntax needs to remain available and unchanged:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    }
  }).readOnly().volatile().property('lastName') // a very strange combination
});
</code></pre>
<p>The decorator returned from <code>computed()</code> will need to have these chainable
methods available, and they will need to set the state of the decorator. This
should not be too difficult to accomplish.</p>
<p>Usage in native decorator syntax is a little bit trickier. In the current
proposal, only simple chaining is allowed in a decorator invocation. You may not
chain on the result of a function:</p>
<pre><code class="language-js">import { computed } from '@ember/object';

const fullName = computed('firstName', 'lastName', function() {
  return `${this.firstName} ${this.lastName}`;
});

class Person {
  @computed('firstName', 'lastName').readOnly() // this is invalid JS decorator syntax
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  @fullName.readOnly() // this is valid because it's a simple chain
  otherFullName;
}
</code></pre>
<p>Luckily, there is one other form of invocation which is available - wrapping the
entire decorator expression in parenthesis:</p>
<pre><code class="language-js">import { computed } from '@ember/object';

class Person {
  @(computed('firstName', 'lastName').readOnly()) // this is valid
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>This is clearly <em>not</em> ideal for commonly used features, and while <code>volatile()</code>
and <code>property()</code> are not very well known, <code>readOnly()</code> is generally considered
best practice, and is used all over the place. However, it <em>is</em> deprecated, and
in the future computed properties will be read only by default. Rather than
attempt to write a different API for decorators, this RFC proposes that we
accept the current syntax, and focus instead on the implementation of Svelte.
This will allow users to enable default read only CPs much sooner, and prevent
the need to use <code>readOnly()</code> at all.</p>
<h5 id="a-tale-of-two-readonlys"><a class="header" href="#a-tale-of-two-readonlys">A Tale of Two <code>readOnly</code>s</a></h5>
<p>You may be wondering why we can't add more decorators to Ember to take the place
of these modifiers. The crux of the issue is the <code>readOnly()</code> modifier, and the
<code>readOnly()</code> macro. These share a name, and when macros become decorators as
well they will collide. The only difference would be the import paths, and this
would result in awkward renaming which would likely <em>not</em> be conventional:</p>
<pre><code class="language-js">import { readOnly, computed } from '@ember/object';
import { readOnly as readOnlyAlias } from '@ember/object/computed';

class Person {
  @readOnly
  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  @readOnlyAlias('fullName')
  otherFullName;
}
</code></pre>
<p>Ember Decorators made the decision to attempt renaming the macros themselves,
since <code>reads</code>, <code>readOnly</code>, and <code>oneWay</code> were all poorly named (arguably, <code>reads</code>
should have been <code>readOnly</code> since it is the more common use case) but this is
not a possibility in Ember, since this would cause collisions and confusion
within the macros namespace.</p>
<p>All of this would be to support a deprecated feature, which can still be used
(albeit, with a less-than-ideal syntax). Accepting the current syntax would also
prevent us from polluting the decorator namespace - we may want to use
<code>@readOnly</code> or <code>@volatile</code> in the future with tracked properties instead.</p>
<h3 id="actions"><a class="header" href="#actions">Actions</a></h3>
<p>Actions are special in Ember because they are namespaced within a class on the
<code>actions</code> object, despite being able to reference the class directly using
<code>this</code> when called, and otherwise behaving like standard methods. The reason for
this stems from the early days of Ember, when users would accidentally name an
action something that conflicted with existing lifecycle and event hooks (e.g.
<code>destroy</code>, or <code>click</code>). The <code>actions</code> namespace was added as a convenience to
prevent these collisions, and to separate them from the rest of the class body
organizationally.</p>
<p>This namespace is problematic for native classes for a number of reasons:</p>
<ol>
<li>The namespace cannot be defined using class field syntax, since that would
assign a copy of the object to every instance of the class, and there is no
other native way to easily assign it.</li>
<li>Actions must inherit from the parent, which means that the <code>actions</code> object
must have its prototype set to the parent class's <code>actions</code> object.</li>
<li>It is not possible to use <code>super</code> within non-class methods, meaning an
alternative would have to be developed specifically for the namespace.</li>
</ol>
<p>With these constraints, a decorator would be necessary to maintain the current
namespacing functionality. The options for such a decorator are limited. It
could:</p>
<ol>
<li>
<p>Decorate a class field, placing the value on the class prototype and setting
up inheritance/super functionality. This would necessarily result in either
some amount of repetition in the decorator name and field name, or a
redundant field name:</p>
<pre><code class="language-js">class Foo {
  @actions actions = {
    onClick() { /* ... */ }
  }
}
</code></pre>
</li>
<li>
<p>Decorate the class itself with the actions object as a parameter. This would
be awkward, since actions would be removed from the class definition:</p>
<pre><code class="language-js">@actions({
  onClick() { /* ... */ }
})
class Foo {}
</code></pre>
</li>
<li>
<p>Decorate the class itself, with the expectation that the <code>actions</code> class
field exists and is an object. This leads to a disconnect between the
decoration and the definition that is easy to miss, and could be
counterintuitive to newcomers:</p>
<pre><code class="language-js">@actionHandler
class Foo {
  actions = {
    onClick() { /* ... */ }
  }
}
</code></pre>
</li>
</ol>
<p>None of these options is ergonomic in the least. Instead, it is much cleaner and
easier to decorate method definitions that are directly on the class body:</p>
<pre><code class="language-js">class Foo {
  @action
  onClick() { /* ... */ }
}
</code></pre>
<p>This would be implemented by creating the class's <code>actions</code> object and assigning
the method to it, setting up inheritance and such in the process. The decorator
leaves the method definition on the class, where it can be called like a normal
method would, including <code>super</code> functionality. This maintains compatibility with
the classic object model, while making the <code>actions</code> namespace an
<em>implementation</em> detail rather than something users need to know about.</p>
<p>This does mean that actions can once again collide with actual lifecycle and
event hooks on the class, since they are no longer namespaced. The decorator
<em>could</em> remove the method from the class definition entirely, but this would be
confusing for users not familiar with the old <code>actions</code> namespace - why does
this method disappear from the class? It would also break <code>super</code> functionality,
so it would not be ideal to do this.</p>
<p>The <code>@action</code> decorator <em>could</em> warn users when it collides with a lifecycle
hook. However, hooks may vary from class type to class type, which presents a
design challenge. We could either:</p>
<ol>
<li>Allow classes to specify lifecycle hooks, and throw whenever <code>@action</code>
collides with a specified hook.</li>
<li>Only throw on hooks that are shared across all classes, such as <code>init</code> and
<code>destroy</code>.</li>
<li>Do nothing, and leave it to user's to know which lifecycle hooks exist.</li>
</ol>
<p>Specifying hooks for each class would be time consuming and could fall out of
sync with the implementations. Throwing on &quot;universal&quot; hooks only is
inconsistent, and could lead users to think that they are safe when they are
not. This RFC suggests that we choose option 3 for this reason. When the actions
namespace was introduced, lifecycle hooks like <code>destroy</code> and <code>click</code> were less
commonly known and used (event listeners were not uncommon). Most Ember users
know they exist now, and will be aware that implementing an action with the same
name is not recommended. In addition, eslint rules can be added to hint against
these collisions.</p>
<h3 id="method-binding"><a class="header" href="#method-binding">Method Binding</a></h3>
<p><code>@action</code> will also bind the function to the class instance, allowing it to be
used in templates and elsewhere without having to be bound:</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  @action
  onClick() {
    // handle click
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{this.onClick}}&gt;Click me!&lt;/button&gt;
</code></pre>
<h4 id="usage-and-api-1"><a class="header" href="#usage-and-api-1">Usage and API</a></h4>
<p>The API for this new decorator would be much simpler than the computed API,
since it is only used as a decorator without parameters.</p>
<pre><code class="language-ts">// Technically `action` is a function, but we can't type it transparently that way
const action: MethodDecorator;
</code></pre>
<p>Attempting to pass any parameters to the decorator, or to apply the decorator to
anything other than a class method, will throw an error.</p>
<h2 id="how-we-teach-this-69"><a class="header" href="#how-we-teach-this-69">How we teach this</a></h2>
<p>Teaching decorators is intrinsically tied to a wider shift in the Ember
programming model - the Ember Octane edition. From a teaching perspective, this
edition will be completely overhauling the guides and updating all of the best
practices as they stand. New users should see native class syntax with
decorators as the <em>default</em>, and should not ever have to write a classic class
or see an example for one.</p>
<p>With this RFC, the majority of existing examples in the Ember guides will be
updatable to native class syntax. The exception would be examples of classic
components, which would be addressed separately by updating the guides to
Glimmer Components (proposed in a separate RFC). Otherwise, all examples in the
guides should be updated.</p>
<h3 id="updating-and-interop"><a class="header" href="#updating-and-interop">Updating and Interop</a></h3>
<p>For existing users, or users who have to interact with classic code from a modern
context, it'll be important to have a reference for the classic object model.
The current section on the object model in the guides can be moved to a classic
section, and a section on updating should be added. Links to relevant codemods,
such as the
<a href="https://github.com/scalvert/ember-es6-class-codemod">ember-es6-class-codemod</a>,
should be included. This section should remain updated and included in the main
guides for as long as <code>EmberObject</code> is a part of Ember's public API.</p>
<h2 id="acceptance-commitments"><a class="header" href="#acceptance-commitments">Acceptance Commitments</a></h2>
<blockquote>
<p>This section serves to capture the various commitments accepting this RFC
would entail.</p>
</blockquote>
<ul>
<li>Adds support for decorators and class fields to Ember's public API. Transforms
would be included out of the box as well.</li>
<li>Allows computed properties to work as a native decorators on native classes.</li>
<li>Adds the <code>@action</code> decorator for defining actions on native classes.</li>
</ul>
<h2 id="drawbacks-93"><a class="header" href="#drawbacks-93">Drawbacks</a></h2>
<ul>
<li>
<p>The <code>ComputedProperty</code> class has long been considered intimate API. Even with
recent changes as part of the native getter RFC to make it more private, these
changes could still cause breakage.</p>
</li>
<li>
<p>The strategy for converting <code>computed</code> to decorators has one major drawback,
which is that decorator macros cannot easily be customized and will require a
bit of boilerplate in some cases. For instance, currently in Ember Decorators
it is possible to apply the <code>map</code> and <code>reduce</code> macros directly to a <em>method</em>,
which becomes the method to map or reduce by:</p>
<pre><code class="language-js">@map('array')
mappedArray() {}

@map('array', function() {}) mappedArray;
</code></pre>
<p>With this method, only the second form would be usable. Likewise, by default
addons like Ember Data would need to write thin decorator wrappers around
macros that may be called <em>without</em> parameters, or which require key
reflection:</p>
<pre><code class="language-js">@attr name; // This would not work OOTB
@attr('string') name; // This would

@belongsTo user; // This would not work OOTB
@belongsTo('user') user; // This would
</code></pre>
</li>
</ul>
<h2 id="alternatives-95"><a class="header" href="#alternatives-95">Alternatives</a></h2>
<h3 id="no-decorators"><a class="header" href="#no-decorators">No Decorators</a></h3>
<p>We could not have official Ember support for any aspects of the classic
programming model. This essentially means computed properties, since <code>@action</code>
and the injection helpers are still needed for the Octane model. This would
leave many users in limbo, unable to update to native class syntax fully because
it would mean rewriting large amounts of classes and components, and would make
libraries like <code>@ember-decorators</code> essential.</p>
<h3 id="namespaced-decorators"><a class="header" href="#namespaced-decorators">Namespaced Decorators</a></h3>
<p>We could include decorators as a separate package, such as <code>@ember/decorators</code>.
This is not ideal as it would force users to remember more import paths, and it
would make eventual deprecation of the classic form much more difficult. It would
also mean that the wider ecosystem would have to do much more work to adopt
decorator syntax.</p>
<h3 id="full-compatibility-decorators"><a class="header" href="#full-compatibility-decorators">Full Compatibility Decorators</a></h3>
<p>We could include decorators for the remaining classic features: Observers, event
listeners, and classic components. These would add extra weight, and may
encourage users to continue using these features, which would not be ideal.</p>
<p>Instead, we can recommend that users wanting to update to native class syntax
use external packages that implement these features, such as
<code>@ember-decorators</code>. The native class codemod will detect and automatically
include these packages if they are necessary.</p>
<h3 id="default-read-only-decorator"><a class="header" href="#default-read-only-decorator">Default Read Only Decorator</a></h3>
<p>In this proposal, computeds used as decorators match the semantics of computeds
used in classic classes exactly. This is true even in the unfortunate case of
computed overridability:</p>
<pre><code class="language-js">class Person {
  firstName = 'Stefan';
  lastName = 'Penner';

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let person = new Person;

person.fullName; // 'Tom Dale'

person.set('firstName', 'Kris');
person.set('lastName', 'Selden');

person.set('fullName', 'Melanie Sumner'); // overrides the setter

person.fullName; // 'Melanie Sumner'
</code></pre>
<p>We could, instead, make decorators apply computeds as <em>readOnly by default</em>,
since this is a new usage of them and not a breaking change. This would require
us to add a new <code>overridable()</code> modifier to opt-out of readOnly behavior by
default, for backwards compatibility, and would add a fair amount of complexity
to codemods. Either way, this behavior will be the default in Ember v4, and
deprecations will begin appearing when this happens soon.</p>
<h3 id="allow-action-to-rename-actions"><a class="header" href="#allow-action-to-rename-actions">Allow <code>@action</code> to Rename Actions</a></h3>
<p>If the namespace collisions caused by actions becoming standard methods are
difficult to refactor around or codemod, we can consider allowing the <code>@action</code>
helper to receive an alternative action name:</p>
<pre><code class="language-js">export default class ButtonComponent extends GlimmerComponent {
  @action('destroy')
  destroyAction() {
    // handle click
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button {{action 'destroy'}}&gt;Click me!&lt;/button&gt;
</code></pre>
<p>This could be added later by a followup RFC, so it is not part of this proposal.
Ideally it won't be necessary.</p>
<h2 id="unresolved-questions-65"><a class="header" href="#unresolved-questions-65">Unresolved questions</a></h2>
<p>As stated in the introduction, this RFC is being made with the assumption that
decorators will be moved to stage 3 before this RFC is actually implemented. If
they are <em>not</em> moved to stage 3, we will have to decide if decorators should be
supported in while they are in stage 2.</p>
<p>If they are supported while in stage 2, there are some additional questions:</p>
<ul>
<li>Should stage 2 transforms continue to be supported after decorators move to
stage 3? Would removing stage 2 support require a major version bump?</li>
<li>Should Typescript's stage 1-like decorators be supported, since Typescript
will not implement new decorator transforms until they reach stage 3?</li>
</ul>
<h2 id="appendix-a-1"><a class="header" href="#appendix-a-1">Appendix A</a></h2>
<p>This appendix contains the list of affected APIs and new APIs for quick reference.</p>
<table><thead><tr><th><code>@ember/controller</code></th></tr></thead><tbody>
<tr><td><code>inject</code></td></tr>
</tbody></table>
<table><thead><tr><th><code>@ember/object</code></th></tr></thead><tbody>
<tr><td><code>computed</code></td></tr>
<tr><td><em><code>action</code></em></td></tr>
</tbody></table>
<table><thead><tr><th><code>@ember/object/computed</code></th></tr></thead><tbody>
<tr><td><code>alias</code></td></tr>
<tr><td><code>and</code></td></tr>
<tr><td><code>bool</code></td></tr>
<tr><td><code>collect</code></td></tr>
<tr><td><code>deprecatingAlias</code></td></tr>
<tr><td><code>empty</code></td></tr>
<tr><td><code>equal</code></td></tr>
<tr><td><code>filter</code></td></tr>
<tr><td><code>filterBy</code></td></tr>
<tr><td><code>gt</code></td></tr>
<tr><td><code>gte</code></td></tr>
<tr><td><code>intersect</code></td></tr>
<tr><td><code>lt</code></td></tr>
<tr><td><code>lte</code></td></tr>
<tr><td><code>map</code></td></tr>
<tr><td><code>mapBy</code></td></tr>
<tr><td><code>match</code></td></tr>
<tr><td><code>max</code></td></tr>
<tr><td><code>min</code></td></tr>
<tr><td><code>none</code></td></tr>
<tr><td><code>not</code></td></tr>
<tr><td><code>notEmpty</code></td></tr>
<tr><td><code>oneWay</code></td></tr>
<tr><td><code>or</code></td></tr>
<tr><td><code>readOnly</code></td></tr>
<tr><td><code>reads</code></td></tr>
<tr><td><code>setDiff</code></td></tr>
<tr><td><code>sort</code></td></tr>
<tr><td><code>sum</code></td></tr>
<tr><td><code>union</code></td></tr>
<tr><td><code>uniq</code></td></tr>
<tr><td><code>uniqBy</code></td></tr>
</tbody></table>
<table><thead><tr><th><code>@ember/service</code></th></tr></thead><tbody>
<tr><td><code>inject</code></td></tr>
</tbody></table>
<h2 id="appendix-b-2"><a class="header" href="#appendix-b-2">Appendix B</a></h2>
<p>This appendix contains a full list of changed APIs and their old and new signatures.</p>
<h3 id="embercontroller-1"><a class="header" href="#embercontroller-1"><strong><code>@ember/controller</code></strong></a></h3>
<ul>
<li><code>inject</code>
<pre><code class="language-ts">// old
function inject(): ComputedProperty&lt;Controller&gt;;
function inject&lt;K extends keyof ControllerRegistry&gt;(
    name: K
): ComputedProperty&lt;ControllerRegistry[K]&gt;;

// new
function inject(): PropertyDecorator;
function inject&lt;K extends keyof ControllerRegistry&gt;(
    name: K
): PropertyDecorator;
</code></pre>
</li>
</ul>
<h3 id="emberobject-1"><a class="header" href="#emberobject-1"><strong><code>@ember/object</code></strong></a></h3>
<ul>
<li>
<p><code>computed</code></p>
<pre><code class="language-ts">// old
function computed(...args: (string | ComputedPropertyConfig&lt;T&gt;)[]): ComputedProperty&lt;T&gt;;

// new
function computed(...args: (string | ComputedPropertyConfig)[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>action</code></p>
<pre><code class="language-ts">// old
// N/A

// new
const action: MethodDecorator;
</code></pre>
</li>
</ul>
<h3 id="emberobjectcomputed"><a class="header" href="#emberobjectcomputed">**<code>@ember/object/computed</code></a></h3>
<ul>
<li>
<p><code>alias</code></p>
<pre><code class="language-ts">// old
function alias(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function alias(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>and</code></p>
<pre><code class="language-ts">// old
function and(...dependentKeys: string[]): ComputedProperty&lt;boolean&gt;;

// new
function and(...dependentKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>bool</code></p>
<pre><code class="language-ts">// old
function bool(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function bool(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>collect</code></p>
<pre><code class="language-ts">// old
function collect(...dependentKeys: string[]): ComputedProperty&lt;any[]&gt;;

// new
function collect(...dependentKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>deprecatingAlias</code></p>
<pre><code class="language-ts">// old
function deprecatingAlias(
  dependentKey: string,
  options: { id: string; until: string }
): ComputedProperty&lt;any&gt;;

// new
function deprecatingAlias(
  dependentKey: string,
  options: { id: string; until: string }
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>empty</code></p>
<pre><code class="language-ts">// old
function empty(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function empty(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>equal</code></p>
<pre><code class="language-ts">// old
function equal(dependentKey: string, value: any): ComputedProperty&lt;boolean&gt;;

// new
function equal(dependentKey: string, value: any): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>filter</code></p>
<pre><code class="language-ts">// old
function filter(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; boolean
): ComputedProperty&lt;any[]&gt;;

// new
function filter(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; boolean
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>filterBy</code></p>
<pre><code class="language-ts">// old
function filterBy(
  dependentKey: string,
  propertyKey: string,
  value?: any
): ComputedProperty&lt;any[]&gt;;

// new
function filterBy(
  dependentKey: string,
  propertyKey: string,
  value?: any
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>gt</code></p>
<pre><code class="language-ts">// old
function gt(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function gt(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>gte</code></p>
<pre><code class="language-ts">// old
function gte(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function gte(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>intersect</code></p>
<pre><code class="language-ts">// old
function intersect(...propertyKeys: string[]): ComputedProperty&lt;any[]&gt;;

// new
function intersect(...propertyKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>lt</code></p>
<pre><code class="language-ts">// old
function lt(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function lt(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>lte</code></p>
<pre><code class="language-ts">// old
function lte(dependentKey: string, value: number): ComputedProperty&lt;boolean&gt;;

// new
function lte(dependentKey: string, value: number): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>map</code></p>
<pre><code class="language-ts">// old
function map&lt;U&gt;(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; U
): ComputedProperty&lt;U[]&gt;;

// new
function map&lt;U&gt;(
  dependentKey: string,
  callback: (value: any, index: number, array: any[]) =&gt; U
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>mapBy</code></p>
<pre><code class="language-ts">// old
function mapBy(dependentKey: string, propertyKey: string): ComputedProperty&lt;any[]&gt;;

// new
function mapBy(dependentKey: string, propertyKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>match</code></p>
<pre><code class="language-ts">// old
function match(dependentKey: string, regexp: RegExp): ComputedProperty&lt;boolean&gt;;

// new
function match(dependentKey: string, regexp: RegExp): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>max</code></p>
<pre><code class="language-ts">// old
function max(dependentKey: string): ComputedProperty&lt;number&gt;;

// new
function max(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>min</code></p>
<pre><code class="language-ts">// old
function min(dependentKey: string): ComputedProperty&lt;number&gt;;

// new
function min(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>none</code></p>
<pre><code class="language-ts">// old
function none(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function none(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>not</code></p>
<pre><code class="language-ts">// old
function not(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function not(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>notEmpty</code></p>
<pre><code class="language-ts">// old
function notEmpty(dependentKey: string): ComputedProperty&lt;boolean&gt;;

// new
function notEmpty(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>oneWay</code></p>
<pre><code class="language-ts">// old
function oneWay(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function oneWay(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>or</code></p>
<pre><code class="language-ts">// old
function or(...dependentKeys: string[]): ComputedProperty&lt;boolean&gt;;

// new
function or(...dependentKeys: string[]): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>readOnly</code></p>
<pre><code class="language-ts">// old
function readOnly(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function readOnly(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>reads</code></p>
<pre><code class="language-ts">// old
function reads(dependentKey: string): ComputedProperty&lt;any&gt;;

// new
function reads(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>setDiff</code></p>
<pre><code class="language-ts">// old
function setDiff(setAProperty: string, setBProperty: string): ComputedProperty&lt;any[]&gt;;

// new
function setDiff(setAProperty: string, setBProperty: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>sort</code></p>
<pre><code class="language-ts">// old
function sort(
  itemsKey: string,
  sortDefinition: string | ((itemA: any, itemB: any) =&gt; number)
): ComputedProperty&lt;any[]&gt;;

// new
function sort(
  itemsKey: string,
  sortDefinition: string | ((itemA: any, itemB: any) =&gt; number)
): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>sum</code></p>
<pre><code class="language-ts">// old
function sum(dependentKey: string): ComputedProperty&lt;number&gt;;

// new
function sum(dependentKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>union</code></p>
<pre><code class="language-ts">// old
function union(...propertyKeys: string[]): ComputedProperty&lt;any[]&gt;;

// new
function union(...propertyKeys: string[]): PropertyDecorator
</code></pre>
</li>
<li>
<p><code>uniq</code></p>
<pre><code class="language-ts">// old
function uniq(propertyKey: string): ComputedProperty&lt;any[]&gt;;

// new
function uniq(propertyKey: string): PropertyDecorator;
</code></pre>
</li>
<li>
<p><code>uniqBy</code></p>
<pre><code class="language-ts">// old
function uniqBy(dependentKey: string, propertyKey: string): ComputedProperty&lt;any[]&gt;;

// new
function uniqBy(dependentKey: string, propertyKey: string): PropertyDecorator;
</code></pre>
</li>
</ul>
<h3 id="emberservice-1"><a class="header" href="#emberservice-1"><strong><code>@ember/service</code></strong></a></h3>
<ul>
<li><code>inject</code>
<pre><code class="language-ts">// old
function inject(): ComputedProperty&lt;Service&gt;;
function inject&lt;K extends keyof ServiceRegistry&gt;(
    name: K
): ComputedProperty&lt;ServiceRegistry[K]&gt;;

// new
function inject(): PropertyDecorator;
function inject&lt;K extends keyof ServiceRegistry&gt;(
    name: K
): PropertyDecorator;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-12-05
RFC PR: https://github.com/emberjs/rfcs/pull/410
Relevant Team(s): Ember.js
Authors: Tom Dale, Chris Garrett, Chad Hietala, Yehuda Katz
Tracking: https://github.com/emberjs/rfc-tracking/issues/4</p>
<hr />
<h1 id="tracked-properties"><a class="header" href="#tracked-properties">Tracked Properties</a></h1>
<h2 id="summary-98"><a class="header" href="#summary-98">Summary</a></h2>
<p>Tracked properties introduce a simpler and more ergonomic system for tracking
state change in Ember applications. By taking advantage of new JavaScript
features, tracked properties allow Ember to reduce its API surface area while
producing code that is both more intuitive and less error-prone.</p>
<p>This simple example shows a <code>Person</code> class with three tracked properties:</p>
<pre><code class="language-js">export default class Person {
  @tracked firstName = 'Chad';
  @tracked lastName = 'Hietala';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<h3 id="a-note-on-decorator-support"><a class="header" href="#a-note-on-decorator-support">A Note on Decorator Support</a></h3>
<p>This RFC proposes a decorator version of tracked properties, and uses this
decorator version in most examples, on the assumption that the [Decorators RFC]
(https://github.com/emberjs/rfcs/pull/408) will be accepted and implemented
before this RFC. If the Decorators RFC is <em>not</em> accepted, or cannot be
implemented due to other criteria not being met (such as decorators remaining at
stage 2), then only the classic class syntax for tracked properties will be
implemented.</p>
<h2 id="terminology-3"><a class="header" href="#terminology-3">Terminology</a></h2>
<p>Because of the occasional overlap in terminology when discussing similar
features, this document uses the following language consistently:</p>
<ul>
<li>A <strong>getter</strong> is an ES5 JavaScript feature that executes a function to
determine the value of a property. The function is executed every time the
property is accessed.</li>
<li>A <strong>computed property</strong> is a property on an Ember object whose value is lazily
produced by executing a function. That value is nearly always cached until one
of computed property's dependencies changes.</li>
<li>A <strong>tracked property</strong> refers to any class field that has been instrumented
with <code>@tracked</code>. Unlike computed properties, tracked properties are <em>never</em>
getters or setters.</li>
<li>The <strong>classic programming model</strong> refers to the traditional Ember programming
model. It includes <em>classic classes</em>, <em>computed properties</em>, <em>event
listeners</em>, <em>observers</em>, <em>property notifications</em>, and <em>classic components</em>,
and more generally refers to features that will not be central to Ember
Octane. Concepts like <em>routes</em>, <em>controllers</em>, and <em>services</em> belong to both
the Octane programming model and the classic programming model.</li>
<li><strong>Native classes</strong> are classes defined using the Javascript <code>class</code> keyword.</li>
<li><strong>Classic classes</strong> are classes defined by subclassing from <code>EmberObject</code>
using the static <code>extend</code> method.</li>
</ul>
<h2 id="motivation-99"><a class="header" href="#motivation-99">Motivation</a></h2>
<p>Tracked properties are designed to be simpler to learn, simpler to write, and
simpler to maintain than today's computed properties. In addition to clearer
code, tracked properties eliminate the most common sources of bugs and mental
model confusion in computed properties today, and reduce memory overhead by not
caching by default.</p>
<h3 id="leverage-existing-javascript-knowledge"><a class="header" href="#leverage-existing-javascript-knowledge">Leverage Existing JavaScript Knowledge</a></h3>
<p>Ember's computed properties provide functionality that overlaps with native
JavaScript getters and setters. Because native getters don't provide Ember with
the information it needs to track changes, it's not possible to use them
reliably in templates or in other computed properties.</p>
<p>New learners have to &quot;unlearn&quot; native getters, replacing them with Ember's
computed property system. Unfortunately, this knowledge is not portable to other
applications that don't use Ember that developers may work on in the future, and
while this problem may be lessened by adopting native classes and decorators, it
still requires users learn Ember's notification system and its quirks.</p>
<p>Tracked properties are as thin a layer as possible on top of native JavaScript.
Tracked properties look like normal properties because they <em>are</em> normal
properties.</p>
<p>Because there is no special syntax for retrieving a tracked property, any
JavaScript syntax that feels like it should work does work:</p>
<pre><code class="language-js">// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
</code></pre>
<p>Similarly, syntax for changing properties works just as well:</p>
<pre><code class="language-js">// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
</code></pre>
<p>This compares favorably with APIs from other libraries, which becomes more
verbose than necessary when JavaScript syntax isn't available:</p>
<pre><code class="language-js">this.setState({
  age: this.state.age + 1,
});
</code></pre>
<pre><code class="language-js">this.setState({
  lastName: this.state.lastName + &quot;Katz&quot;;
})
</code></pre>
<h3 id="avoiding-dependency-hell"><a class="header" href="#avoiding-dependency-hell">Avoiding Dependency Hell</a></h3>
<p>Currently, Ember requires developers to manually enumerate a computed property's
dependent keys: the list of <em>other</em> properties that <em>this</em> computed property
depends on. Whenever one of the listed properties changes, the computed
property's cache is cleared and any listeners are notified that the computed
property has changed.</p>
<p>In this example, <code>'firstName'</code> and <code>'lastName'</code> are the dependent keys of the
<code>fullName</code> computed property:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});
</code></pre>
<p>While this system typically works well, it comes with its share of drawbacks.</p>
<p>First, it's extra work to have to type every property twice: once as a string as
a dependent key, and again as a property lookup inside the function. While
explicit APIs can often lead to clearer code, this verbosity has the potential
to complicate the implementation without improving developer intent at all.
People understand intuitively that they are typing out dependent keys to help
<em>Ember</em>, not other programmers.</p>
<p>It's also not clear what syntax goes inside the dependent key string. In this
simple example it's a property name, but nested dependencies become a property
path, like <code>'person.firstName'</code>. (Good luck writing a computed property that
depends on a property with a period in the name.)</p>
<p>You might form the mental model that a JavaScript expression goes inside the
string—until you encounter the <code>{firstName,lastName}</code> expansion syntax or the
magic <code>@each</code> syntax for array dependencies.</p>
<p>The truth is that dependent key strings are made up of an unintuitive,
unfamiliar microsyntax that you just have to memorize if you want to use Ember
well.</p>
<p>Lastly, it's easy for dependent keys to fall out of sync with the
implementation, leading to difficult-to-detect, difficult-to-troubleshoot bugs.</p>
<p>For example, imagine a new member on our team is assigned a bug where a user's
middle name is not appearing in their profile. Our intrepid developer finds the
problem, and updates <code>fullName</code> to include the middle name:</p>
<pre><code class="language-js">import EmberObject, { computed } from '@ember/object';

const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }),
});
</code></pre>
<p>They test their change and it seems to work. Unfortunately, they've just
introduced a subtle bug. If the user's <code>middleName</code> were to change, <code>fullName</code>
wouldn't update! Maybe this will get caught in a code review, given how simple
the computed property is, but noticing missing dependencies is a challenge even
for experienced Ember developers when the computed property gets more
complicated.</p>
<p>Tracked properties have a feature called <em>autotrack</em>, where dependencies are
automatically detected as they are used. This means that as long as all
properties that are dependencies are marked as tracked, they will automatically
be detected:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>Note that getters and setters do <em>not</em> need to be marked as tracked, only the
properties that they access need to. This also allows us to opt out of tracking
entirely, like if we know for instance that a given property is constant and
will never change. In general, the idea is that <em>mutable</em>, <em>watchable</em>
properties should be marked as tracked, and <em>immutable</em> or <em>unwatched</em>
properties should not be.</p>
<h3 id="reducing-memory-consumption"><a class="header" href="#reducing-memory-consumption">Reducing Memory Consumption</a></h3>
<p>By default, computed properties cache their values. This is great when a
computed property has to perform expensive work to produce its value, and that
value gets used over and over again.</p>
<p>But checking, populating, and invalidating this cache comes with its own
overhead. Modern JavaScript VMs can produce highly optimized code, and in many
cases the overhead of caching is greater than the cost of simply recomputing the
value.</p>
<p>Worse, cached computed property values cannot be freed by the garbage collector
until the entire object is freed. Many computed properties are accessed only
once, but because they cache by default, they take up valuable space on the heap
for no benefit.</p>
<p>For example, imagine this component that checks whether the <code>files</code> property is
supported in input elements:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { computed } from '@ember/object';

export default Component.extend({
  inputElement: computed(function() {
    return document.createElement('input');
  }),

  supportsFiles: computed('inputElement', function() {
    return 'files' in this.inputElement;
  }),

  didInsertElement() {
    if (this.supportsFiles) {
      // do something
    } else {
      // do something else
    }
  },
});
</code></pre>
<p>This component would create and retain an <code>HTMLInputElement</code> DOM node for the
lifetime of the component, even though all we really want to cache is the
Boolean value of whether the browser supports the <code>files</code> attribute.</p>
<p>Particularly on inexpensive mobile devices, where RAM is limited and often slow, we should
be more conservative about our memory consumption. Tracked properties switch
from an opt-out caching model to opt-in, allowing developers to err on the side
of reduced memory usage, but easily enabling caching (a.k.a. memoization) if a
property shows up as a bottleneck during profiling.</p>
<h2 id="prior-art-2"><a class="header" href="#prior-art-2">Prior Art</a></h2>
<p>Tracked properties were first implemented in <a href="https://glimmerjs.com/">Glimmer.js</a>,
and were recently polyfilled with clever usage of <code>notifyPropertyChange</code> by
the <a href="https://github.com/rwjblue/sparkles-component/">sparkles-components</a> addon.
These initial implementations inform the design in this RFC, but differ from it
in some key ways. For instance, both Sparkles's and early versions of Glimmer's
<code>@tracked</code> did not have an autotracking stack, and instead relied on explicit
dependency keys. After benchmarking showed that autotracking was a viable
strategy, the API for <code>@tracked</code> was updated to what is proposed here.</p>
<h2 id="detailed-design-84"><a class="header" href="#detailed-design-84">Detailed Design</a></h2>
<p>This RFC proposes adding the <code>tracked</code> decorator function, used to mark class
fields as tracked:</p>
<pre><code class="language-ts">const tracked: PropertyDecorator;
</code></pre>
<p>This new function will be exported from <code>@glimmer/tracking</code>. Revisiting our
example from earlier, <code>@tracked</code> can be used on native class fields and
getters/setters:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<h3 id="getting-tracked-properties"><a class="header" href="#getting-tracked-properties">Getting Tracked Properties</a></h3>
<p>Tracked properties can be accessed using standard Javascript syntax. From the
user's point of view, there is nothing special about them. This should continue
to work in the future, even if new methods are added for accessing properties,
because tracked properties use native getters under the hood.</p>
<pre><code class="language-js">let person = new Person();

// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];
</code></pre>
<h3 id="setting-tracked-properties"><a class="header" href="#setting-tracked-properties">Setting Tracked Properties</a></h3>
<p>Tracked properties can be set using standard Javascript syntax. They use native
setters under the hood, meaning that there is no need for using a setter method
like <code>set</code>.</p>
<pre><code class="language-js">let person = new Person();

// Simple assignment
person.firstName = 'Jen';
// Addition assignment (+=)
person.lastName += 'Weber';
// Increment operator
person.age++;
</code></pre>
<h3 id="autotracking"><a class="header" href="#autotracking">Autotracking</a></h3>
<p>Tracked properties do not need to specify their dependencies. Under the hood,
this works by utilizing an <em>autotrack stack</em>. This stack is a bit of global
state which tracked properties can access. As tracked properties are accessed,
they push themselves onto the stack, and once they have finished running, the
stack contains the full list of all the tracked properties that were accessed
while it was running.</p>
<p>In our first example, with the <code>Person</code> class, we can see this in action:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Tom';
  @tracked lastName = 'Dale';

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>When we create a new instance of <code>Person</code>, the tracking system has no knowledge
of the connection between <code>fullName</code>, <code>firstName</code>, and <code>lastName</code>. Now, let's
say we go to render this person's name in a component's template:</p>
<pre><code class="language-hbs">{{this.person.fullName}}
</code></pre>
<p>When Glimmer accesses the <code>fullName</code> property on person, it creates an
<em>autotrack stack frame</em>. As we computed <code>fullName</code>, any values that are
decorated with <code>@tracked</code> push themselves into this stack frame. Because getters
and setters are pure functions, they will ultimately end up accessing some
tracked properties - in this case, the <code>fullName</code> getter accesses the
<code>firstName</code> and <code>lastName</code> properties, and they push themselves onto the stack
frame.</p>
<p>In this way, Glimmer will know about <em>all</em> properties that were accessed when
calculating any bound value in templates.</p>
<blockquote>
<p><strong>NOTE:</strong> This does <em>not</em> invalidate a cache like in computed properties.
Internally, Glimmer checks to see if a value has updated <em>before calling the
getter</em>. If it hasn't, then Glimmer does not rerender the related section of
the DOM. This is effectively an automatic <code>shouldComponentUpdate</code> (at least
the most common usage) from React.</p>
</blockquote>
<h3 id="manual-invalidation"><a class="header" href="#manual-invalidation">Manual Invalidation</a></h3>
<p>In user code, the idea that all mutable properties should be marked as tracked
and that all other properties are effectively immutable works well in isolation.
However, there are cases where users will want to work with code they do <em>not</em>
control, such as external library code.</p>
<p>Consider the following example. We have a <code>simple-timer</code> library that we've
imported from NPM, and we're trying to wrap it with a <code>TimerComponent</code> that
uses it to keep track of how much time has passed:</p>
<pre><code class="language-js">// simple-timer/index.js
export default class Timer {
  seconds = 0;
  minutes = 0;
  hours = 0;

  listeners = [];

  constructor() {
    setInterval(() =&gt; {
      this.seconds++;
      this.minutes = Math.floor(this.seconds / 60);
      this.hours = Math.floor(this.minutes / 60);
      this.notifyTick();
    }, 1000);
  }

  notifyTick() {
    for (let listener of this.listeners) {
      listener(this.seconds);
    }
  }

  onTick(listener) {
    this.listeners.push(listener);
  }
}
</code></pre>
<pre><code class="language-js">import Timer from 'simple-timer';
import Component, { tracked } from '@glimmer/tracking';

export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
</code></pre>
<p>Even though we've marked the <code>timer</code> property as tracked, the <code>timer.seconds</code>
property is untracked, and <em>it</em> is the field that is updated. We can solve this
problem by using the timer library's <code>onTick</code> event handler to re-set the field,
invalidating it:</p>
<pre><code class="language-js">export default class TimerComponent extends Component {
  @tracked timer = new Timer();

  constructor() {
    this.timer.onTick(() =&gt; {
      // invalidate the timer field.
      this.timer = this.timer;
    });
  }

  get currentSeconds() {
    return this.timer.seconds;
  }

  get currentMinutes() {
    return this.timer.minutes;
  }
}
</code></pre>
<h3 id="interop-with-the-classic-programming-model"><a class="header" href="#interop-with-the-classic-programming-model">Interop with the Classic Programming Model</a></h3>
<p>Tracked properties represent a paradigm shift. They are a completely new system,
fully independent of the classic programming model and based on modern
Javascript features and design, and they will be the <em>default</em> change tracking
system in Ember Octane.</p>
<p>However, existing apps, libraries, and addons will be using the classic
programming model for some time, and experience tells us that these sort of
transitions to new features take a while to settle in the community. To ease
this process and enable gradual adoption, tracked properties will be able to
interoperate with the most commonly used features of the classic model:</p>
<ul>
<li>Classic classes</li>
<li>Computed properties</li>
<li><code>get</code>/<code>set</code> and property notifications</li>
<li>Observers</li>
</ul>
<h4 id="classic-classes"><a class="header" href="#classic-classes">Classic Classes</a></h4>
<p>The <code>tracked</code> decorator function will be usable in classic classes, similar to
<code>computed</code>:</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { tracked } from '@glimmer/tracking';

const Person = EmberObject.extend({
  firstName: tracked({ value: 'Tom' }),
  lastName: tracked({ value: 'Dale' }),

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
});
</code></pre>
<p>This form will <em>not</em> be allowed on native classes, and will hard error if it is
attempted. Additionally, default values will be defined on the <em>prototype</em> to
maintain consistency with the classic object model.</p>
<p>This will allow existing libraries to transition incrementally, and add tracked
support minimally where necessary. This also brings the <em>benefits</em> of tracked
to classic classes, including the ability to drop usage of <code>set</code>:</p>
<pre><code class="language-js">// before
let person = Person.create();
person.set('firstName', 'Stefan');
person.set('lastName', 'Penner');

// after
let person = Person.create();
person.firstName = 'Stefan';
person.lastName = 'Penner';
</code></pre>
<p>Ember's <code>set</code> function is nowhere to be seen!</p>
<h4 id="computed-properties-1"><a class="header" href="#computed-properties-1">Computed Properties</a></h4>
<p>Computed properties will interoperate with tracked properties in both
directions:</p>
<ul>
<li>
<p>Accessing a computed property from a tracked property will add the computed
property to its list of depedencies. Whenever the computed property is
invalidated (i.e. because it or one of its dependencies is updated), the
tracked property will be invalidated as well.</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { set } from '@ember/object';
import { alias } from '@ember/object/computed';

class Person {
  @tracked firstName;
  @tracked lastName;

  @alias('title') prefix;

  get fullName() {
    return `${this.prefix} ${this.firstName} ${this.lastName}`;
  }
}

let person = new Person();

person.firstName = 'Tom';
person.lastName = 'Dale';

set(person, 'title', 'Mr.');

person.fullName; // 'Mr. Tom Dale'
</code></pre>
</li>
<li>
<p>Accessing a tracked property from a computed property will <em>also</em>
automatically add the tracked property to the list of its dependencies. In
this way, users will be able to gradually add tracked properties and
simultaneously reap the benefits of not having to use <code>set</code> with computeds,
and not having to specify dependent keys.</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  firstName;
  lastName;

  @tracked middleName;

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }
}

let person = new Person();

set(person, 'firstName', 'Tom');
set(person, 'lastName', 'Dale');

person.middleName = 'Tomster';

person.fullName; // 'Tom Tomster Dale'
</code></pre>
</li>
</ul>
<p>It will still be required to use <code>set</code> when updating computed properties and
their dependencies. In the future, this restriction could possibly be relaxed.</p>
<h4 id="get-and-set"><a class="header" href="#get-and-set"><code>get</code> and <code>set</code></a></h4>
<p>It is common in the classic model to set and consume plain object properties
which are not computed properties, or in any other way special. Ember's <code>get</code>
and <code>set</code> functions historically allowed this by giving us the ability to
intercept all property changes and watch for mutations.</p>
<p>This presents a problem for tracked properties, particularly because of the
recent change in Ember to enable native Javascript getters to replace <code>get</code>.
This change means that we have no way to intercept <code>get</code>, and consequently no
way for tracked properties to know whether or not a plain property will later
be updated with <code>set</code>.</p>
<p>To demonstrate this case, consider the following service and component:</p>
<pre><code class="language-js">const Config = Service.extend({
  polling: {
    shouldPoll: false,
    pollInterval: -1,
  },

  init() {
    this._super(...arguments);

    fetch('config/api/url')
      .then(r =&gt; r.json())
      .then(polling =&gt; set(this, 'polling', polling));
  },
});
</code></pre>
<pre><code class="language-js">class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let { shouldPoll, pollInterval } = this.config.polling;

    return shouldPoll ? pollInterval : -1;
  }
}
</code></pre>
<pre><code class="language-hbs">{{this.pollInterval}}
</code></pre>
<p>Let's walk through the flow here:</p>
<ol>
<li>The <code>SomeComponent</code> component is rendered for the first time, instantiating
the <code>Config</code> service (assuming this the first time it has ever been
accessed). The service's init hook kicks off an async request to get the
configuration from a remote URl.</li>
<li>The <code>pollInterval</code> property first accesses the service injection when
rendered, which is a computed property. The property is detected and added to
the tracked stack.</li>
<li>We then access the plain, undecorated <code>polling</code> object. Because it is
is not tracked and not a computed property, tracked does not know that it
could update in the future.</li>
<li>Sometime later, the async request returns with the configuration object. We
set it on the service, but because our tracked getter did not know this
property would update, it does not invalidate.</li>
</ol>
<p>In order to prevent this from happening, user's will have to use <code>get</code> when
accessing any values which may be set with <code>set</code>, and are not computed
properties.</p>
<pre><code class="language-js">class SomeComponent extends Component {
  @service config;

  get pollInterval() {
    let shouldPoll = get(this, 'config.polling.shouldPoll');
    let pollInterval = get(this, 'config.polling.pollInterval');

    return shouldPoll ? pollInterval : -1;
  }
}
</code></pre>
<p>The reverse, however, is not true - computed properties will be able to add
tracked properties, and listen to dependencies explicitly. In some cases, this
may be preferable, though undecorated getters should be the conventional
standard with the long term goal of removing all explicit dependencies and
computed decorations.</p>
<h4 id="observers"><a class="header" href="#observers">Observers</a></h4>
<p>While Ember's observer system has been minimized in recent years, it is still
supported in Ember 3 and used occasionally throughout the ecosystem. Observers
use a fundamentally different system for tracking changes than tracked
properties, but this does not mean that it is impossible for the two systems to
interoperate, and it theory it shouldn't require much effort to maintain such
interoperation or regress performance in any meaningful way.</p>
<p>As such, tracked properties will be made to interoperate with observers so that
whenever a tracked property is set using <em>any</em> valid syntax, observers watching
that key will be fired:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { addObserver } from '@ember/object/observers';

class Person {
  constructor() {
    addObserver('firstName', () =&gt; {
      console.log('firstName changed!');
    });
  }

  @tracked firstName;
}
</code></pre>
<p>If in the implementation of this RFC it becomes apparent that there <em>are</em> major
caveats to supporting interop with observers, a followup RFC will be made to
address those caveats and make a decision on whether or not to support observers
with those additional constraints.</p>
<h3 id="does-this-mean-i-still-have-to-use-get-and-set"><a class="header" href="#does-this-mean-i-still-have-to-use-get-and-set">Does this mean I still have to use <code>get</code> and <code>set</code>?</a></h3>
<p>Yes. As mentioned above, interoperating with legacy code will require using
<code>get</code> and <code>set</code> to be fully safe. However, even in greenfield applications which
do not need to interoperate with legacy addons or code, there will still be use
cases which are <em>not</em> covered by tracked properties. These use cases are roughly
the same as those that come with native <a href="https://github.com/emberjs/rfcs/blob/master/text/0281-es5-getters.md#motivation">ES Getters</a>:</p>
<ol>
<li>Objects that implement <code>unknownProperty</code> and <code>setUnknownProperty</code></li>
<li><a href="https://emberjs.com/api/ember/release/classes/ObjectProxy">Ember proxies</a>,
which use <code>unknownProperty</code> and <code>setUnknownProperty</code></li>
<li>In general, cases where change tracking should be <em>dynamic</em>, where the keys
that are being tracked are <em>not</em> known in advance and cannot be declared
using decorators.</li>
</ol>
<p><code>get</code> and <code>set</code> will continue to work (as defined in this RFC) and will be
necessary in many applications for the forseeable future. How long exactly is
an <a href="0410-tracked-properties.html#unresolved-questions">open question addressed below in the unresolved questions section</a>.</p>
<h2 id="how-we-teach-this-70"><a class="header" href="#how-we-teach-this-70">How we teach this</a></h2>
<p>There are three different aspects of tracked properties which need to be
considered for the learning story:</p>
<ol>
<li><strong>General usage.</strong> Which properties should I mark as tracked? How do I
consume them? How do I trigger changes?</li>
<li><strong>Interop with classic systems.</strong> How do I safely consume tracked properties
from classic classes and computeds? How do I safely consume classic APIs from
tracked properties?</li>
<li><strong>Interop with non-Ember systems.</strong> How do I tell my app that something has
changed in MobX objects, RxJS objects, Redux, etc.</li>
</ol>
<h3 id="general-usage"><a class="header" href="#general-usage">General Usage</a></h3>
<p>The mental model with tracked properties is that anything <em>mutable</em> that is
public should be tracked. If a value will ever change, and it will or could be
watched externally, it should have the <code>@tracked</code> decorator attached to it.</p>
<p>After that, usage should be &quot;Just Javascript&quot;. You can safely access values
using any syntax you like, including desctructuring, and you can update values
using standard assignments.</p>
<pre><code class="language-js">// Dot notation
const fullName = person.fullName;
// Destructuring
const { fullName } = person;
// Bracket notation for computed property names
const fullName = person['fullName'];

// Simple assignment
this.firstName = 'Yehuda';
// Addition assignment (+=)
this.lastName += 'Katz';
// Increment operator
this.age++;
</code></pre>
<h4 id="triggering-updates-on-complex-objects"><a class="header" href="#triggering-updates-on-complex-objects">Triggering Updates on Complex Objects</a></h4>
<p>There may be cases where users want to update values in complex, untracked
objects such as arrays or POJOs. <code>@tracked</code> will only be usable with class
syntax at first, and while it may make sense to formalize these objects into
tracked classes in some cases, this will not always be the case.</p>
<p>To do this, users can re-set a tracked value directly after its inner values
have been updated.</p>
<pre><code class="language-js">class SomeComponent extends Component {
  @tracked items = [];

  @action
  pushItem(item) {
    let { items } = this;

    items.push(item);

    this.items = items;
  }
}
</code></pre>
<p>This may seem a bit strange at first, but it allows users to mentally scope
off a tree of objects. They manipulate internals as they see fit, and the only
operation they need to do to update state is set the nearest tracked property.</p>
<h3 id="interop-with-classic-systems"><a class="header" href="#interop-with-classic-systems">Interop with Classic Systems</a></h3>
<p>There are two cases that we need to consider when teaching interoperability:</p>
<ol>
<li>Accessing non-tracked properties and computeds from an autotrack context</li>
<li>Accessing tracked properties from a computed context</li>
</ol>
<p>In the first case, the general rule of thumb is to use <code>get</code> if you want to be
100% safe. In cases where you are certain that the values you are accessing are
tracked, computeds, or immutable, you can safely use standard access syntax.</p>
<p>In the second case, no additional changes need to be made when using tracked
properties. They can be accessed as normal, and will be automatically added to
the computed's dependencies. There is no need to use <code>get</code>, and you can use
standard assignments when updating them.</p>
<h3 id="interop-with-non-ember-systems"><a class="header" href="#interop-with-non-ember-systems">Interop with Non-Ember Systems</a></h3>
<p>The strategy for trickier updates on complex objects by retriggering their
setters should cover most integration use cases. We should add a guide which
specifically demonstrates their usage by wrapping a common, simple external
library such as <code>moment.js</code>. This will demonstrate its usage concretely, and
establish best practices.</p>
<h2 id="drawbacks-94"><a class="header" href="#drawbacks-94">Drawbacks</a></h2>
<p>Like any technical design, tracked properties must make tradeoffs to balance
performance, simplicity, and usability. Tracked properties make a different set
of tradeoffs than today's computed properties.</p>
<p>This means tracked properties come with edge cases or &quot;gotchas&quot; that don't exist
in computed properties. When evaluating the following drawbacks, please consider
the two features in their totality, including computed property gotchas you have
learned to work around.</p>
<p>In particular, please try to compensate for <a href="https://en.wikipedia.org/wiki/Familiarity_heuristic">familiarity</a> and
<a href="https://en.wikipedia.org/wiki/Loss_aversion">loss aversion</a> biases. Before you form a strong opinion, <a href="https://signalvnoise.com/posts/3124-give-it-five-minutes">give
it five minutes</a>.</p>
<h3 id="tracked-properties--promises"><a class="header" href="#tracked-properties--promises">Tracked Properties &amp; Promises</a></h3>
<p>Dependency autotracking requires that tracked getters access their dependencies
synchronously. Any access that happens asynchronously will not be detected as a
dependency.</p>
<p>This is most commonly encountered when trying to return a <code>Promise</code> from a
tracked getter. Here's an example that would &quot;work&quot; but would never update if
<code>firstName</code> or <code>lastName</code> change:</p>
<pre><code class="language-js">class Person {
  @tracked firstName;
  @tracked lastName;

  get fullNameAsync() {
    return this.reloadUser().then(() =&gt; {
      return `${this.firstName} ${this.lastName}`;
    });
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }

  setFirstName(firstName) {
    // This should cause `fullNameAsync` to update, but doesn't, because
    // firstName was not detected as a dependency.
    this.firstName = firstName;
  }
}
</code></pre>
<p>One way you could address this is to ensure that any dependencies are consumed
synchronously:</p>
<pre><code class="language-js">get fullNameAsync() {
  // Consume firstName and lastName so they are detected as dependencies.
  let { firstName, lastName } = this;

  return this.reloadUser().then(() =&gt; {
    // Fetch firstName and lastName again now that they may have been updated
    let { firstName, lastName } = this;
    return `${firstName} ${lastName}`;
  });
}
</code></pre>
<p>However, <strong>modeling async behavior as tracked properties is an incoherent
approach and should be discouraged</strong>. Tracked properties are intended to hold
simple state, or to derive state from data that is available synchronously.</p>
<p>But asynchrony is a fact of life in web applications, so how should we deal with
async data fetching?</p>
<p><strong>In keeping with Data Down, Actions Up, async behavior should be modeled as
methods that set tracked properties once the behavior is complete.</strong></p>
<p>Async behavior should be explicit, not a side-effect of property access. Today's
computed properties that rely on caching to only perform async behavior when a
dependency changes are effectively reintroducing observers into the programming
model via a side channel.</p>
<p>A better approach is to call a method to perform the async data fetching, then
set one or more tracked properties once the data has loaded. We can refactor the
above example back to a synchronous <code>fullName</code> tracked property:</p>
<pre><code class="language-js">class Person {
  @tracked firstName;
  @tracked lastName;

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  async reloadUser() {
    const response = await fetch('https://example.com/user.json');
    const { firstName, lastName } = await response.json();
    this.firstName = firstName;
    this.lastName = lastName;
  }
}
</code></pre>
<p>Now, <code>reloadUser()</code> must be called explicitly, rather than being run implicitly
as a side-effect of consuming <code>fullName</code>.</p>
<h3 id="accidental-untracked-properties"><a class="header" href="#accidental-untracked-properties">Accidental Untracked Properties</a></h3>
<p>One of the design principles of tracked properties is that they are only
required for state that <em>changes over time</em>. Because tracked properties imply
some overhead over an untracked property (however small), we only want to pay
that cost for properties that actually change.</p>
<p>However, an obvious failure mode is that some property <em>does</em> change over time,
but the user simply forgets to annotate that property as <code>@tracked</code>. This will
cause frustrating-to-diagnose bugs where the DOM doesn't update in response to
property changes.</p>
<p>Fortunately, we have a strategy for mitigating some of this frustration. It
involves the way most tracked properties will be consumed: via a component
template. In development mode, we can detect when an untracked property is used
in a template and install a setter that causes an exception to be thrown if it
is ever mutated. (This is similar to today's &quot;mandatory setter&quot; that causes an
exception to be thrown if a watched property is set without going through
<code>set()</code>.)</p>
<p>Unfortunately this strategy cannot be applied to values accessed by tracked
getters. The only way we could detect such access would be with native
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a>, but proxies are more focussed on security over flexibility
and recent discussion shows that <a href="https://github.com/tc39/proposal-class-fields/issues/106">they may break entirely when used with
private fields</a>. As
such, it would not be ideal for us to use them in this way.</p>
<h2 id="alternatives-96"><a class="header" href="#alternatives-96">Alternatives</a></h2>
<h3 id="ship-tracked-properties-in-user-land"><a class="header" href="#ship-tracked-properties-in-user-land">Ship tracked properties in user-land</a></h3>
<p>Instead of shipping <code>@tracked</code> today, we can focus on formalizing the primitives
which it uses under the hood in Glimmer VM (References and Validators) and make
these publicly consumable. This way, users will be able to implement tracked in
an addon and experiment with it before it becomes a core part of Ember.</p>
<p>This approach is similar to the approach taken with component managers in the
past year, which unblocked experimentation with <code>SparklesComponent</code>s as a way to
validate the design of <code>GlimmerComponent</code>s, and unlocked the ability for power
users to create their own component APIs. However, the reference and validator
system is a much more core part of the Glimmer VM, and it could take much longer
to figure out the best and safest way to do this without exposing too much of
the internals. It would certainly prevent <code>@tracked</code> from shipping with Ember
Octane.</p>
<h3 id="keep-the-current-system"><a class="header" href="#keep-the-current-system">Keep the current system</a></h3>
<p>We could keep the current computed property based system, and refactor it
internally to use references only and not rely on chains or the old property
notification system. This would be difficult, since CPs are very intertwined
with property events as are their dependencies. It would also mean we wouldn't
get the DX benefits of cleaner syntax, and the performance benefits of opt-in
change tracking and caching.</p>
<h3 id="we-could-keep-set"><a class="header" href="#we-could-keep-set">We could keep <code>set</code></a></h3>
<p>Tracked properties were designed around wanting to use native setters to update
state. If we remove that constraint and keep <code>set</code>, it opens up some
possibilities. There is precedent for this in other frameworks, such as React's
<code>setState</code>.</p>
<p>However, keeping <code>set</code> likely wouldn't be able to restrict the requirement for
<code>@tracked</code> being applied to all mutable properties for the same reason <code>get</code>
must be used in interop - there's no way for a tracked property to know that a
plain, undecorated property could update in the future.</p>
<h3 id="allow-explicit-dependencies"><a class="header" href="#allow-explicit-dependencies">Allow explicit dependencies</a></h3>
<p>We could allow <code>@tracked</code> to receive explicit dependencies instead of forcing
<code>get</code> usage for interop. This would be very complex, if even possible, and is
ultimately not functionality <code>@tracked</code> should have in the long run, so it would
not make sense to add it now.</p>
<h3 id="we-could-wait-on-private-fields-and-proxy-developments"><a class="header" href="#we-could-wait-on-private-fields-and-proxy-developments">We could wait on private fields and Proxy developments</a></h3>
<p>Native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a> represent a lot of possibilities for automatic change
tracking. Other frameworks such as Vue and Aurelia are looking into using
recursive proxy structures to wrap objects and intercept access, which would
allow them to track changes without <em>any</em> decoration. We also considered using
recursive proxies in earlier drafts of this proposal, even though they aren't
part of our support matrix we believed they could be used during development to
assert when users attempted to update untracked properties which had been
consumed from tracked getters.</p>
<p>However, as mention above, TC39 has made it clear that this was <a href="https://github.com/tc39/proposal-class-fields/issues/106">not an intended
use for Proxy</a>, and
they will be <em>breaking</em> this functionality with the inclusion of private fields.
They have also expressed that <a href="https://github.com/tc39/proposal-class-fields/issues/162#issuecomment-441101578">they would like to solve this
use-case</a>
(observing object state changes in general) separately, and <a href="https://github.com/littledan/proposal-proxy-transparent">a strawman proposal
was made</a> (though it
has not advanced and does not seem like it will). We could wait to see what the
future looks like here, and see if we can provide a more ergonomic tracked
properties RFC in the future.</p>
<h2 id="unresolved-questions-66"><a class="header" href="#unresolved-questions-66">Unresolved questions</a></h2>
<h3 id="when-can-i-stop-using-get-and-set"><a class="header" href="#when-can-i-stop-using-get-and-set">When can I stop using <code>get</code> and <code>set</code>?</a></h3>
<p>This is the biggest open question in this RFC, and with the direction that
tracked properties set. How do we get rid of <code>get</code> and <code>set</code> for good, if that
is the direction we want to go in?</p>
<p>The full answer to that question is out of scope for tracked properties, but it
would likely require at least two additional steps:</p>
<ol>
<li>
<p>The underlying system for tracking changes, including the ability to create
tags for fields and the ability to add to the current autotracking stack,
will need to be made public for advanced users who need dynamic change
tracking.</p>
</li>
<li>
<p>First class support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">native proxies</a> within Ember.
<code>unknownProperty</code> and <code>setUnknownProperty</code> have no other analag in native
Javascript, and without support for native proxies there will likely be use
cases that cannot be supported in any other way.</p>
<p>As mentioned above, native proxies <em>will</em> (potentially) have more limitations
than Ember proxies, but these limitations will most likely be possible to
work around for advanced users who need this functionality in the first
place. In other words, while they probably don't make sense as a basis for
<em>all</em> change tracking in Ember, they will probably be invaluable for specific
use cases such as <a href="https://www.npmjs.com/package/ember-m3">Ember M3</a> which
require very dynamic change tracking.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-12-13
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/415
Tracking: https://github.com/emberjs/rfc-tracking/issues/8</p>
<hr />
<h1 id="render-element-modifiers"><a class="header" href="#render-element-modifiers">Render Element Modifiers</a></h1>
<h2 id="summary-99"><a class="header" href="#summary-99">Summary</a></h2>
<p>Element modifiers are a recently introduced concept in Ember that allow users to
run code that is tied to the lifecycle of an <em>element</em> in a template, rather
than the component's lifecycle. They allow users to write self-contained logic
for manipulating the state of elements, and in many cases can be fully
independent of component code and state.</p>
<p>However, there are many cases where users wish to run some component code when
an element is setting up or tearing down. Today, this logic conventionally lives
in the <code>didInsertElement</code>, <code>didRender</code>, <code>didUpdate</code>, and  <code>willDestroyElement</code>
hooks in components, but there are cases where these hooks are not ideal.</p>
<p>This RFC proposes creating an official Ember addon which provides three new
generic element modifiers: <code>{{did-insert}}</code>, <code>{{did-update}}</code>, and
<code>{{will-destroy}}</code>. Users will be able to use these to run code during the most
common phases of any element's lifecycle.</p>
<h2 id="motivation-100"><a class="header" href="#motivation-100">Motivation</a></h2>
<p>The primary component hooks for interacting with the DOM today are:</p>
<ul>
<li><code>didInsertElement</code></li>
<li><code>didRender</code></li>
<li><code>didUpdate</code></li>
<li><code>willDestroyElement</code></li>
</ul>
<p>These render hooks cover many use cases. However, there are some cases which
they do not cover, such as setting up logic for conditional elements, or tagless
components. There also is no easy way to share element setup logic, aside from
mixins or pure functions (which require some amount of boilerplate).</p>
<h3 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h3>
<p>Render code for elements which exist conditionally is fairly tricky. Consider a
simple popover component:</p>
<pre><code class="language-hbs">{{#if this.isOpen}}
  &lt;div class=&quot;popover&quot;&gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<p>If the developer decides to use an external library like <a href="https://popper.js.org">Popper.js</a>
to position the popover, they have to add a fair amount of boilerplate. On each
render, they need to check if the popover was added to the DOM or removed from
it, and setup or teardown accordingly.</p>
<pre><code class="language-js">export default Component.extend({
  didRender() {
    if (this.isOpen &amp;&amp; !this._popper) {
      let popoverElement = this.element.querySelector('.popover');

      this._popper = new Popper(document, popoverElement);
    } else if (this._popper) {
      this._popper.destroy();
    }
  },

  willDestroyElement() {
    if (this._popper) {
      this._popper.destroy();
    }
  }
});
</code></pre>
<p>At this level of complexity, most developers would reasonably choose to create
a second component to be used within the <code>{{if}}</code> block so they can use standard
lifecycle hooks. Sometimes this makes sense as it helps to separate concerns and
organize code, but other times it is clearly working around the limitations of
render hooks, and can feel like more components are being created than are
necessary.</p>
<p>With render modifiers, hooks are run whenever the <em>element</em> they are applied to
is setup and torn down, which means we can focus on the setup and teardown code
without worrying about the overall lifecycle:</p>
<pre><code class="language-hbs">{{#if this.isOpen}}
  &lt;div
    {{did-insert (action this.setupPopper)}}
    {{will-destroy (action this.teardownPopper)}}

    class=&quot;popover&quot;
  &gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  setupPopper(element) {
    this._popper = new Popper(document, element);
  },

  teardownPopper() {
    this._popper.destroy();
  }
});
</code></pre>
<p>The element that the modifiers are applied to is also passed to the function, so
there is no longer a need to use <code>querySelector</code>. Overall the end result is a
fair amount simpler, without the need for an additional component.</p>
<p>These same issues are also present for collections items within an <code>{{each}}</code>
loop, and the render modifiers can be used to solve them as well:</p>
<pre><code class="language-hbs">&lt;ul&gt;
  {{#each items as |item|}}
    &lt;li
      {{did-insert (action this.registerElement)}}
      {{will-destroy (action this.unregisterElement)}}
    &gt;
      ...
    &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;
</code></pre>
<h3 id="tagless-components"><a class="header" href="#tagless-components">Tagless Components</a></h3>
<p>Additionally, render hooks do not provide great support for tagless components
(<code>tagName: ''</code>). While the hooks fire when the component is rendered, they have
no way to target any of the elements which are in the component's template,
meaning users must use <code>querySelector</code> and setup some unique id or class to
target the element by:</p>
<pre><code class="language-js">export default Component.extend({
  tagName: '',

  listId: computed(function() {
    return generateId();
  }),

  didInsertElement() {
    let element = document.querySelector(`#${this.listId}`);

    // ...
  },

  willDestroyElement() {
    let element = document.querySelector(`#${this.listId}`);

// ...
  }
});
</code></pre>
<pre><code class="language-hbs">&lt;ul id={{listId}}&gt;
  ...
&lt;/ul&gt;

&lt;div&gt;
  ...
&lt;/div&gt;
</code></pre>
<p>The render modifiers can be used to add hooks to the appropriate main element in
tagless components:</p>
<pre><code class="language-js">export default Component.extend({
  tagName: '',

  didInsertList(element) {
    // ...
  },

  willDestroyList(element) {
    // ...
  }
});
</code></pre>
<pre><code class="language-hbs">&lt;ul
  {{did-insert (action this.didInsertList)}}
  {{will-destroy (action this.willDestroyList)}}
&gt;
  ...
&lt;/ul&gt;

&lt;div&gt;
  ...
&lt;/div&gt;
</code></pre>
<h3 id="reusable-helpers"><a class="header" href="#reusable-helpers">Reusable Helpers</a></h3>
<p>Currently, the best ways to share element setup code are either via mixins,
which are somewhat opaque and can encourage problematic patterns, or standard JS
functions, which generally require some amount of boilerplate.</p>
<p>Developers will be able to define element modifiers in the future with modifier
managers provided by addons. However, the proposed modifier APIs are fairly
verbose (with good reason) and not stabilized.</p>
<p>However, the render modifiers can receive <em>any</em> function as their first
parameter, allowing users to share and reuse common element setup code with
helpers. For instance, a simple <code>scrollTo</code> helper could be created to set the
scroll position of an element:</p>
<pre><code class="language-js">// helpers/scroll-to.js
export default function scrollTo() {
  return (element, [scrollPosition]) =&gt; element.scrollTop = scrollPosition;
}
</code></pre>
<pre><code class="language-hbs">&lt;div
  {{did-insert (scroll-to) @scrollPosition}}
  {{did-update (scroll-to) @scrollPosition}}
  class=&quot;scroll-container&quot;
&gt;
  ...
&lt;/div&gt;
</code></pre>
<h3 id="official-addon"><a class="header" href="#official-addon">Official Addon</a></h3>
<p>While these modifiers will be generally useful, modifiers are meant to be a more
generic API that can be used to create libraries for solving specific problems.
Unfortunately, the community hasn't had much time to experiment with modifiers,
since the public API for them hasn't been finalized.</p>
<p>The modifiers in this RFC will provide an basic stepping stone for users who
want to emulate lifecycle hooks and incrementally convert their applications to
modifiers while modifiers in general are being experimented with in the
community. In time, users should be able to pick and choose the modifiers that
suit their needs more directly and effectively, and they shouldn't have to
include these modifiers in the payload. These modifiers should also not be seen
as the &quot;Ember way&quot; - they are just another addon, a basic one supported by
the Ember core team, but one which may or may not be appropriate for a given
application.</p>
<h2 id="detailed-design-85"><a class="header" href="#detailed-design-85">Detailed design</a></h2>
<p>This RFC proposes adding three element modifiers:</p>
<ul>
<li><code>{{did-insert}}</code></li>
<li><code>{{did-update}}</code></li>
<li><code>{{will-destroy}}</code></li>
</ul>
<p>Note that element modifiers do <em>not</em> run in SSR mode - this code is only run on
clients. Each of these modifiers receives a callback as it's first positional
parameter:</p>
<pre><code class="language-ts">type RenderModifierCallback = (element: Element, positionalArgs: [any], namedArgs: object): void;
</code></pre>
<p>The <code>element</code> argument is the element that the modifier is applied to,
<code>positionalArgs</code> contains any remaining positional arguments passed to the
modifier besides the callback, and <code>namedArgs</code> contains any named arguments
passed to the modifier. If the first positional argument is not a callable
function, the modifier will throw an error.</p>
<blockquote>
<p>Note: The timing semantics in the following section were mostly defined in the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">element modifier manager RFC</a>
and are repeated here for clarity and convenience.</p>
</blockquote>
<h3 id="did-insert"><a class="header" href="#did-insert"><code>{{did-insert}}</code></a></h3>
<p>This modifier is activated only when The element is inserted in the DOM.</p>
<p>It has the following timing semantics when activated:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called after DOM insertion</li>
<li>called <em>after</em> any child element's <code>{{did-insert}}</code> modifiers</li>
<li>called <em>after</em> the enclosing component's <code>willRender</code> hook</li>
<li>called <em>before</em> the enclosing component's <code>didRender</code> hook</li>
<li>called in definition order in the template</li>
</ul>
</li>
<li><strong>May or May Not</strong>
<ul>
<li>be called in the same tick as DOM insertion</li>
<li>have the sibling nodes fully initialized in DOM</li>
</ul>
</li>
</ul>
<p>Note that these statements do not refer to when the modifier is <em>activated</em>,
only to when it will be run relative to other hooks and modifiers <em>should it be
activated</em>. The modifier is only activated on insertion.</p>
<h3 id="did-update"><a class="header" href="#did-update"><code>{{did-update}}</code></a></h3>
<p>This modifier is activated only on <em>updates</em> to it's arguments (both positional
and named). It does <em>not</em> run during or after initial render, or before
element destruction.</p>
<p>It has the following timing semantics when activated:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called after the arguments to the modifier have changed</li>
<li>called <em>after</em> any child element's <code>{{did-update}}</code> modifiers</li>
<li>called <em>after</em> the enclosing component's <code>willUpdate</code> hook</li>
<li>called <em>before</em> the enclosing component's <code>didUpdate</code> hook</li>
<li>called in definition order in the template</li>
</ul>
</li>
<li><strong>Never</strong>
<ul>
<li>called if the arguments to the modifier are constants</li>
</ul>
</li>
</ul>
<h3 id="will-destroy"><a class="header" href="#will-destroy"><code>{{will-destroy}}</code></a></h3>
<p>This modifier is activated:</p>
<ol>
<li>immediately before the element is removed from the DOM.</li>
</ol>
<p>It has the following timing semantics when activated:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called <em>after</em> any child element's <code>{{will-destroy}}</code> modifiers</li>
<li>called <em>before</em> the enclosing component's <code>willDestroy</code> hook</li>
<li>called in definition order in the template</li>
</ul>
</li>
<li><strong>May or May Not</strong>
<ul>
<li>be called in the same tick as DOM removal</li>
</ul>
</li>
</ul>
<h3 id="function-binding"><a class="header" href="#function-binding">Function Binding</a></h3>
<p>Functions which are passed to these element modifiers will <em>not</em> be bound to any
context by default. Users can bind them using the <code>(action)</code> helper:</p>
<pre><code class="language-hbs">&lt;div {{did-insert (action this.setupElement)}}&gt;&lt;/div&gt;
</code></pre>
<p>Or by using the <code>@action</code> decorator provided by the
<a href="https://github.com/emberjs/rfcs/pull/408">Decorators RFC</a> to bind the function
in the class itself:</p>
<pre><code class="language-js">export default class ExampleComponent extends Component {
  @action
  setupElement() {
    // ...
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;div {{did-insert this.setupElement}}&gt;&lt;/div&gt;
</code></pre>
<h2 id="how-we-teach-this-71"><a class="header" href="#how-we-teach-this-71">How we teach this</a></h2>
<p>Element modifiers will be new to everyone, so we're starting with a mostly blank
slate. The only modifier that exists in classic Ember is <code>{{action}}</code>, and while
most existing users will be familiar with it, that familiarity may not translate
to the more general idea of modifiers.</p>
<p>The first thing we should focus on is teaching <em>modifiers in general</em>. Modifiers
should be seen as the place for any logic which needs to act directly on an
element, or when an element is added to or removed from the DOM. Modifiers can
be fully independent (for instance, a <code>scroll-to</code> modifier that transparently
manages the scroll position of the element) or they can interact with the
component (like the <code>did-insert</code> and <code>will-destroy</code> modifiers). In all cases
though, they are <em>tied to the render lifecycle of the element</em>, and they
generally contain <em>side-effects</em> (though these may be transparent and
declarative, as in the case of <code>{{action}}</code> or the theoretical <code>{{scroll-to}}</code>).</p>
<p>Second, we should teach the render modifiers specifically. We can do this by
illustrating common use cases which can currently be solved with render hooks,
and comparing them to using modifiers for the same solution. We should also
emphasize that these are an addon, not part of the core framework, and are
useful as solutions for <em>specific</em> problems. As more modifiers become available,
we should create additional guides that focus on using the <em>best</em> modifier for
the job, rather than these generic ones.</p>
<p>One thing we should definitely avoid teaching except in advanced cases is the
<em>ordering</em> of element modifiers. Ideally, element modifiers should be
commutative, and order should not be something users have to think about. When
custom element modifiers become widely available, this should be considered best
practice.</p>
<h3 id="example-scrolling-an-element-to-a-position"><a class="header" href="#example-scrolling-an-element-to-a-position">Example: Scrolling an element to a position</a></h3>
<p>This sets the scroll position of an element, and updates it whenever the scroll
position changes.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{yield}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  classNames: ['scroll-container'],

  didRender() {
    this.element.scrollTop = this.scrollPosition;
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">&lt;div
  {{did-insert this.setScrollPosition @scrollPosition}}
  {{did-update this.setScrollPosition @scrollPosition}}

  class=&quot;scroll-container&quot;
&gt;
  {{yield}}
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">export default class Component.extend({
  setScrollPosition(element, scrollPosition) {
    element.scrollTop = scrollPosition;
  }
})
</code></pre>
<h4 id="example-adding-a-class-to-an-element-after-render-for-css-animations"><a class="header" href="#example-adding-a-class-to-an-element-after-render-for-css-animations">Example: Adding a class to an element after render for CSS animations</a></h4>
<p>This adds a CSS class to an alert element in a conditional whenever it renders
to fade it in, which is a bit of an extra hoop. For CSS transitions to work, we
need to append the element <em>without</em> the class, then add the class after it has
been appended.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{#if shouldShow}}
  &lt;div class=&quot;alert&quot;&gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  didRender() {
    let alert = this.element.querySelector('.alert');

    if (alert) {
      alert.classList.add('fade-in');
    }
  }
});
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#if shouldShow}}
  &lt;div {{did-insert this.fadeIn}} class=&quot;alert&quot;&gt;
    {{yield}}
  &lt;/div&gt;
{{/if}}
</code></pre>
<pre><code class="language-js">export default Component.extend({
  fadeIn(element) {
    element.classList.add('fade-in');
  }
});
</code></pre>
<h4 id="example-resizing-text-area"><a class="header" href="#example-resizing-text-area">Example: Resizing text area</a></h4>
<p>One key thing to know about <code>{{did-update}}</code> is it will not rerun whenever the
<em>contents</em> or <em>attributes</em> on the element change. For instance, <code>{{did-update}}</code>
will <em>not</em> rerun when <code>@type</code> changes here:</p>
<pre><code class="language-hbs">&lt;div {{did-update this.setupType}} class=&quot;{{@type}}&quot;&gt;&lt;/div&gt;
</code></pre>
<p>If <code>{{did-update}}</code> should rerun whenever a value changes, the value should be
passed as a parameter to the modifier. For instance, a textarea which wants to
resize itself to fit text whenever the text is modified could be setup like
this:</p>
<pre><code class="language-hbs">&lt;textarea {{did-update this.resizeArea @text}}&gt;
  {{@text}}
&lt;/textarea&gt;
</code></pre>
<pre><code class="language-js">export default Component.extend({
  resizeArea(element) {
    element.css.height = `${element.scrollHeight}px`;
  }
});
</code></pre>
<h4 id="example-ember-composability-tools-style-rendering"><a class="header" href="#example-ember-composability-tools-style-rendering">Example: <code>ember-composability-tools</code> style rendering</a></h4>
<p>This is the type of rendering done by libraries like <code>ember-leaflet</code>, which use
components to control the <em>rendering</em> of the library, but without any templates
themselves. The underlying library for this is <a href="https://github.com/miguelcobain/ember-composability-tools">here</a>.
This is a simplified example of how you could accomplish this with Glimmer
components and element modifiers.</p>
<p>Node component:</p>
<pre><code class="language-js">// components/node.js
export default Component.extend({
  init() {
    super(...arguments);
    this.children = new Set();

    this.parent.registerChild(this);
  }

  willDestroy() {
    super(...arguments);

    this.parent.unregisterChild(this);
  }

  registerChild(child) {
    this.children.add(child);
  }

  unregisterChild(child) {
    this.children.delete(child);
  }

  didInsertNode(element) {
    // library setup code goes here

    this.children.forEach(c =&gt; c.didInsertNode(element));
  }

  willDestroyNode(element) {
    // library teardown code goes here

    this.children.forEach(c =&gt; c.willDestroyNode(element));
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;!-- components/node.hbs --&gt;
{{yield (component &quot;node&quot; parent=this)}}
</code></pre>
<p>Root component:</p>
<pre><code class="language-js">// components/root.js
import NodeComponent from './node.js';

export default NodeComponent.extend();
</code></pre>
<pre><code class="language-hbs">&lt;!-- components/root.hbs --&gt;
&lt;div
  {{did-insert (action this.didInsertNode)}}
  {{will-destroy (action this.willDestroyNode)}}
&gt;
  {{yield (component &quot;node&quot; parent=this)}}
&lt;/div&gt;
</code></pre>
<p>Usage:</p>
<pre><code class="language-hbs">&lt;Root as |node|&gt;
  &lt;node as |node|&gt;
    &lt;node /&gt;
  &lt;/node&gt;
&lt;/Root&gt;
</code></pre>
<h2 id="drawbacks-95"><a class="header" href="#drawbacks-95">Drawbacks</a></h2>
<ul>
<li>
<p>Adding these modifiers means that there are more ways to accomplish similar
goals, which may be confusing to developers. It may be less clear which is the
conventional solution in a given situation.</p>
</li>
<li>
<p>Relying on users binding via <code>action</code> is somewhat unintuitive, and may feel
like it's getting in the way, especially considering sometimes methods will
work without binding (if they never access <code>this</code>).</p>
</li>
</ul>
<h2 id="alternatives-97"><a class="header" href="#alternatives-97">Alternatives</a></h2>
<ul>
<li>Stick with only lifecycle hooks for these situations, and don't add generic
modifiers for them.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-12-13
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/416
Tracking: https://github.com/emberjs/rfc-tracking/issues/2</p>
<hr />
<h1 id="glimmer-components"><a class="header" href="#glimmer-components">Glimmer Components</a></h1>
<h2 id="summary-100"><a class="header" href="#summary-100">Summary</a></h2>
<p>Glimmer components are a simpler, more ergonomic, and more declarative approach
to building components. They represent the sum of multiple years of design and
feature work by the community, which stemmed from the original RFCs and
discussions surrounding &quot;angle-bracket components&quot;.</p>
<p>This RFC proposes adding Glimmer components to Ember's public API, and making
them the default new app experience in Ember Octane.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>The Glimmer components API presented in this RFC was designed in cooperation
between @tomdale, @rwjblue, @krisselden, @pzuraq, and others.</p>
<h2 id="first-a-bit-of-history"><a class="header" href="#first-a-bit-of-history">First, a Bit of History</a></h2>
<p>As components became the standard for Single Page Apps (SPAs) several years ago,
and the Ember community began adopting them in earnest and converting from Ember
1's primarily MVC oriented approach, there were many small and large issues that
cropped up with Ember's component API and usage: <code>{{curly-bracket}}</code> syntax felt
dated with the introduction of Web Components and other major frameworks; the
inability to specify or override HTML attributes led to explosions in API
complexity; the implicit wrapper element and customization fields (<code>tagName</code>,
<code>classNames</code>, et al.) felt burdensome and made templates difficult to read
compared to other frameworks; two way data-binding led to strange, hard to
predict data cycles within apps; and so on.</p>
<p>From this came the original <a href="https://github.com/emberjs/rfcs/blob/0b32059b3704836e52c906a0ead64ac186c844d8/active/0000-component-unification.md">Angle Bracket component
RFC</a>.
The idea was simple: switch to the superior <code>&lt;angle-bracket&gt;</code> syntax of web
components, and solve all the other problems! Seems easy enough, right?</p>
<p>As you can imagine, it was <em>not</em> that easy. There was a flurry of discussion on
the original RFC, and many ideas were thrown around. This was seen as the <em>one</em>
chance Ember had to &quot;fix&quot; its component API, and the community did not want to
get it wrong and lock us into yet <em>another</em> set of painful papercuts. After much
debate and lots of back and forth with the design, it was ultimately decided
that attempting to redesign components all at once, monolithically, was too
much. Instead, the individual ideas from that discussion could be broken out and
implemented in isolation, in a backwards compatible way, both incrementally
building a new, well thought out component API <em>and</em> laying the groundwork in
the framework for future redesigns.</p>
<p>A lot of the foundational work that arose from these discussions and paves the
way for Glimmer components has already landed in Ember, including: Angle-bracket
invocation, named arguments, element modifiers, and component managers.</p>
<p>Glimmer components represent the final piece of that's required to enable the
&quot;ember octane&quot; programming model. They include the last of the major features
that were discussed during the original Angle Brackets RFC, and holistically, we
feel those features make a much simpler and more ergonomic component API. Taken
alone, they are an incremental change. Their individual features aren't <em>that</em>
much more than what we currently have in Ember today. But as a whole they
represent the culmination of multiple years of design work and discussion by the
Ember community, and the collective attention to detail and care of all of our
community members.</p>
<h2 id="terminology-4"><a class="header" href="#terminology-4">Terminology</a></h2>
<ul>
<li>The <strong>Glimmer VM</strong> is the underlying rendering engine which is used by
<em>Ember.js</em> and <em>Glimmer.js</em>.</li>
<li><strong>Glimmer.js</strong> is a thin wrapper on top of the <em>Glimmer VM</em> which exposes a
much simpler API compared to Ember. Historically it has been used to
experiment with ideas and implementations before bringing them into Ember via
RFC, and has been used to write applications which don't require the full
feature set of Ember.</li>
<li><strong>Glimmer components</strong> are a newly proposed component API which draw from the
experimental APIs provided in Glimmer.js, and Ember.js via
<a href="https://github.com/rwjblue/sparkles-component">sparkles-component</a>.</li>
<li><strong>Classic components</strong> refer to the standard component API at the time of this
RFC, which have been available in Ember in some form since v1.</li>
<li><strong>Tracked properties</strong> refer to a new method of change tracking which is being
proposed in a separate RFC, parallel to this one.</li>
</ul>
<h2 id="motivation-101"><a class="header" href="#motivation-101">Motivation</a></h2>
<p><code>GlimmerComponent</code> is a simpler base component class that enables smaller class
definitions, stronger conventions for lifecycle hooks and properties, and
unidirectional data flow. We aim to design them to be easier understand in
isolation, and require less knowledge of the framework to use effectively.</p>
<p>This example shows a component written with the classic component API:</p>
<pre><code class="language-hbs">&lt;!-- templates/components/post.hbs --&gt;
{{#if (eq type 'image'}}
  &lt;img src={{post.imageUrl}} title={{post.imageTitle}}&gt;
{{/if}}

{{post.text}}
</code></pre>
<pre><code class="language-js">// components/post.js
export default Component.extend({
  tagName: 'section',
  classNames: ['post'],
  classNameBindings: ['type'],
  ariaRole: 'region',

  /* Arguments */
  post: null,

  type: readOnly('post.type'),

  didInsertElement() {
    this._super(...arguments);
    if (this.type === 'image') {
      setupImageOverlay(this.element.querySelector('img'));
    }
  }
});
</code></pre>
<p>And here is an equivalent component written with the Glimmer component API:</p>
<pre><code class="language-hbs">&lt;!-- templates/components/post.hbs --&gt;
&lt;section ...attributes role=&quot;region&quot; type={{@post.type}} class=&quot;post {{@post.type}}&quot;&gt;
  {{#if (eq @post.type 'image')}}
    &lt;img
      {{did-insert this.didInsertImage}}
      src={{@post.imageUrl}}
      title={{@post.imageTitle}}
    /&gt;
  {{/if}}

  {{@post.text}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-js">// components/post.js
export default class PostComponent extends GlimmerComponent {
  @action
  didInsertImage(element) {
    setupImageOverlay(element);
  }
}
</code></pre>
<p>Glimmer components eliminate many of the common paper cuts that cause confusion
with classic components, and align more closely with modern template syntax and
features.</p>
<h3 id="outer-html-semantics"><a class="header" href="#outer-html-semantics">Outer HTML Semantics</a></h3>
<p>The biggest change Glimmer components make is defaulting to outer HTML
semantics. In the classic component API, components had a implicit wrapper
element. Given this component template:</p>
<pre><code class="language-hbs">Hello, world!
</code></pre>
<p>The output by <em>default</em> would be something like:</p>
<pre><code class="language-html">&lt;!-- OUTPUT --&gt;
&lt;div id=&quot;ember-1234&quot; class=&quot;ember-view&quot;&gt;
  Hello, world!
&lt;/div&gt;
</code></pre>
<p>But we can't know that for sure unless we look at the component definition. If
we do, we might see that the outer wrapping element is actually a <code>section</code>, and
it has a <code>.hello-world</code> class:</p>
<pre><code class="language-js">export default Component.extend({
  tagName: 'section',
  classNames: ['hello-world']
});
</code></pre>
<pre><code class="language-html">&lt;!-- OUTPUT --&gt;
&lt;section id=&quot;ember-1234&quot; class=&quot;hello-world ember-view&quot;&gt;
  Hello, world!
&lt;/section&gt;
</code></pre>
<p>This behavior means that the template for a component is missing crucial
information and context. Even for the simplest component, users must check the
class definition to know with certainty what the full template of the component
is. And unlike bindings, there is no hint to the user that there may be
something dynamic that they should check on - without advanced knowledge of
Ember's APIs, there is no way of knowing about this behavior.</p>
<p>By contrast, Glimmer components have no wrapping outer element - What you see in
the template is what you get in the output. There is no need to define class
names, class name bindings, attribute bindings, or any other DOM element values
<em>from the component class</em>; developers can achieve the equivalent result using
the same techniques they're familiar with from working with <code>Ember.Component</code>
templates. The template is the single source of truth for the output of a
component, and any dynamic values are explicitly stated in it.</p>
<pre><code class="language-hbs">&lt;!-- template.hbs --&gt;
&lt;section class=&quot;hello-world&quot;&gt;
  Hello, world!
&lt;/section&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- OUTPUT --&gt;
&lt;section class=&quot;hello-world&quot;&gt;
  Hello, world!
&lt;/section&gt;
</code></pre>
<p>We can immediately see that this is a simple component with no bindings, no
dynamic values, and no meaningful state. Even if there was a component
definition, we know that it is not in any way affecting the output of this
template. Special element ids and classes are also not present, making the
output appear less magical.</p>
<p>This micro change makes a macro difference:</p>
<ul>
<li>
<p>Users can spend less time switching back and forth between reading template
and class code, and can get a better idea of the structure of an app from its
declarative templates.</p>
</li>
<li>
<p>Component customization code becomes less imperative and more declarative,
meaning users no longer need to keep the state of bindings, class names, and
other class code in their heads.</p>
</li>
<li>
<p>The gap between template-only components - which are analogous to React and
other frameworks' functional components - and components with a backing class
is reduced, making them a more viable pattern.</p>
</li>
</ul>
<h3 id="namespaced-arguments"><a class="header" href="#namespaced-arguments">Namespaced Arguments</a></h3>
<p>In classic components, arguments are set as properties directly on the class
instance. This means that class methods and properties can be completely
overwritten by incoming arguments, which can have surprising and problematic
side effects. For example, let's say we have a component that has a <code>fullName</code>
computed property and expects <code>firstName</code> and <code>lastName</code> arguments:</p>
<pre><code class="language-js">// components/person.js
export default Component.extend({
  firstName: null,
  lastName: null,

  fullName: computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
});
</code></pre>
<p>The public API of this component is <em>supposed</em> to just be those two arguements.
However, a developer may realize that they can pass <code>fullName</code> directly to the
component, overriding the computed property:</p>
<pre><code class="language-hbs">&lt;Person @fullName={{this.fullNameWithMiddle}}&gt;
</code></pre>
<p>This is clearly a bad pattern, but it shows that in effect that most details of
a component's implementation are not truly private, and any property or value
can be overriden from external contexts. In most common day-to-day scenarios
developers just have to be careful that they are following the intended public
API of a component, but this also has the potential for misuse and enables
antipatterns.</p>
<p>Glimmer components assign their arguments to the <code>args</code> property on their
instance, preventing namespace collisions from happening in the first place.
This allows component authors to define a clear public API for a component which
<em>cannot</em> be circumvented.</p>
<h3 id="immutable-arguments"><a class="header" href="#immutable-arguments">Immutable Arguments</a></h3>
<p>In classic components argument values on the component are also <em>mutable</em>. This
can lead to some confusing behavior, because argument values in the <em>class</em> can
change, but named arguments in <em>templates</em> cannot. For instance, given this
component:</p>
<pre><code class="language-js">// components/welcome.js
export default Component.extend({
  firstName: 'Jen',
  lastName: 'Weber'
});
</code></pre>
<pre><code class="language-hbs">&lt;!-- templates/components/welcome.hbs  --&gt;
Hey there, {{@firstName}} {{@lastName}}!
</code></pre>
<p>And this invocation:</p>
<pre><code class="language-hbs">&lt;Welcome /&gt;
</code></pre>
<p>You might expect that the result would be:</p>
<pre><code class="language-hbs">Hey there, Jen Weber!
</code></pre>
<p>However, <code>{{@firstName}}</code> and <code>{{@lastName}}</code> would actually be empty values.
They refer <em>directly</em> to the arguments passed into the <em>invocation</em> of the
component, and to get the results we wanted, we would have to invoke it like so:</p>
<pre><code class="language-hbs">&lt;Welcome @firstName=&quot;Jen&quot; @lastName=&quot;Weber&quot; /&gt;
</code></pre>
<p>The advantage in this is that named arguments are fully transparent. When seen
in a template, users can know without a doubt that the named argument was a
value passed in from the invocation. Likewise, when they see a standard binding
to a value like <code>{{this.firstName}}</code> or <code>{{firstName}}</code>, they know this is a
value defined on the component - it could a computed property, it could come
from a service, it could be a random value, but it is <em>not</em> an argument.</p>
<p>Glimmer components align their argument access with named args by making
arguments available exclusively on a (shallow) frozen object, <code>this.args</code>.
Attempting to modify <code>this.args</code> will hard error, meaning that like templates,
users will always be able to refer to <code>this.args</code> as the canonical state of the
values passed to the component invocation.</p>
<p>Immutable arguments make reasoning about the state of a component simpler (&quot;Was
that a user provided value or a default/mutated/computed value?&quot; becomes &quot;Was it
an argument or not?&quot;), and encourages use of <code>{{@arg}}</code> syntax in templates
where appropriate. At scale, this makes reading templates even easier, since
more information is encoded in the template itself. One way data flow also
encourages the Data Down, Actions Up pattern, and normalizes the way that data
flows through apps, making reasoning about app state easier.</p>
<h3 id="minimal-classes"><a class="header" href="#minimal-classes">Minimal Classes</a></h3>
<p>Classic components are large classes, with lots of built up functionality and
debt from over the years. The total list of default properties and hooks
(including inherited ones) includes:</p>
<ul>
<li><strong>13</strong> Standard lifecycle hooks, such as
<code>didInsertElement</code>/<code>willDestroyElement</code> and <code>didUpdate</code>.</li>
<li><strong>29</strong> Event handlers, such as <code>click</code>, <code>mouseEnter</code>, and <code>dragStart</code>.</li>
<li><strong>9</strong> element/element customization properties, such as <code>element</code> and
<code>tagName</code>.</li>
<li><strong>21</strong> standard framework functions, such as <code>get</code>/<code>set</code>,
<code>addObserver</code>/<code>removeObserver</code> and <code>toggleProperty</code>.</li>
</ul>
<p>Coming from a class hierarchy that is 4 levels deep (<code>Component</code> -&gt; <code>CoreView</code>
-&gt; <code>EmberObject</code> -&gt; <code>CoreObject</code>, with about 19 mixins included along the way).</p>
<p>This is a large API surface to become acquainted with, and namespace
collisions are possible with new Ember users - collisions on <code>destroy</code>
were the original reason for adding the <code>actions</code> object to classes, and every
so often a user will pop in on <code>#help</code> wondering why their <code>click</code> or <code>submit</code>
methods trigger automagically, or why their component disappeared when they
added an <code>isVisible</code> property. Even putting aside the possibility of collisions,
the sheer amount of choice can sometimes be overwhelming: Do I put my
initialization logic in <code>init</code> or <code>didInsertElement</code>? Do I use an action or the
<code>click</code> handler? Which update method should I use - <code>didRender</code>, <code>didUpdate</code>,
<code>didReceiveAttrs</code>?</p>
<p>Glimmer components have a constructor, <strong>2</strong> lifecycle hooks, and <strong>3</strong>
properties. They only extend from the Glimmer Component base class -- a simple
ES6 class that does not extend from <code>EmberObject</code>. They don't have any
element/DOM based properties, hooks, event handler functions, whose
responsibilities have been passed on to element modifiers. This <em>dramatically</em>
simplifies what users need to learn in order to start using the bread-and-butter
class of Ember, and enforces a single conventional location for each of the
possible hooks in classic components, allowing users to focus on productivity
out of the box.</p>
<h3 id="glimmerjs-compatibility"><a class="header" href="#glimmerjs-compatibility">Glimmer.js Compatibility</a></h3>
<p>One of the goals for future versions of Ember, post Ember Octane, will be to
enable lighter-weight applications to be built using the framework. Breaking
Ember apart into smaller, fully independent and optional pieces is the core idea
behind the &quot;install your way to Ember&quot; goal, which will enable Ember to be used
in more constrained environments that smaller frameworks such as React, Preact,
Vue, and more excel in. It will also allow users who are size-conscious to adopt
Ember incrementally, adding functionality when it is <em>needed</em> rather than having
all-or-nothing.</p>
<p>This will take time though. Progress has been made, but parts of Ember are still
monolithic. And while it isn't Ember, Glimmer.js is a lightweight wrapper of the
Glimmer VM that enables users to drop that weight and begin writing much more
minimal apps today.</p>
<p>Glimmer components aren't just based on the Glimmer.js component API - they are
one and the same. They will be a shared package, which will be importable and
usable by the users of both frameworks. Not only will users be able to write
better components in Ember, those components will also be cross-compatible with
Glimmer apps (assuming they don't use Ember specific functionality).</p>
<p>It is important to note that while Glimmer components will be versioned
independently from Glimmer and Ember <em><strong>they will abide by the Ember RFC process
for any and all changes to user APIs</strong></em>. The implementations for their component
managers in Glimmer and Ember may change to keep them compatible, but they will
not make major changes without first getting community input, and will be
considered part of the public API of Ember.</p>
<h2 id="prior-art-3"><a class="header" href="#prior-art-3">Prior Art</a></h2>
<p>Part of the challenge in the original Angle Bracket components RFC was
attempting to design without implementation, testing, usage, and feedback.
Glimmer.js provided an early method to experiment, but because it was not widely
adopted there wasn't much feedback from larger-scale usage. This in part
motivated the <a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md">component manager
RFC</a>,
which enabled experimentation in Ember directly, and set us up for having
multiple implementations of component APIs which were interchangeable.</p>
<p>As such, we now have two reference implementations which can be referred to:</p>
<ul>
<li><a href="https://glimmerjs.com/">Glimmer.js</a>, the framework that this component API is
based on, and will be cross-compatible with.</li>
<li><a href="https://github.com/rwjblue/sparkles-component">sparkles-component</a>, an an
implementation of the Glimmer.js component API using Ember's component
managers. It is usable in Ember today.</li>
</ul>
<p>Both of these have minor differences from the API proposed in this RFC, mainly
because they were made before the <a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">element modifier manager
RFC</a>
was accepted and opened up additional design possibilities. However, they serve
as valuable data points for the viability of a simpler component API, and inform
the design accordingly.</p>
<h2 id="detailed-design-86"><a class="header" href="#detailed-design-86">Detailed design</a></h2>
<p>Glimmer components have the following interface:</p>
<pre><code class="language-ts">interface GlimmerComponent&lt;T = object&gt; {
  args: T;

  isDestroying: boolean;
  isDestroyed: boolean;

  constructor(owner: Opaque, args: T): void;
  willDestroy(): void;
}
</code></pre>
<p>This class will be importable from <code>@glimmer/component</code>;</p>
<pre><code class="language-js">import Component from '@glimmer/component';
</code></pre>
<h3 id="constructor"><a class="header" href="#constructor">Constructor</a></h3>
<p>The constructor for Glimmer components receives two arguments: The owner
instance and the named arguments object. Both of these arguments should
conventionally be passed to <code>super</code> immediately, and then accessed through
decorated service properties, <code>getOwner</code>, and <code>this.args</code>:</p>
<pre><code class="language-js">class PersonComponent extends GlimmerComponent {
  @service profile;

  constructor() {
    super(...arguments);

    let owner = getOwner(this);
    let profileService = this.profile;

    let firstName = this.args.firstName;
  }
}
</code></pre>
<p>These arguments are passed to the constructor so that they can be used for
initial setup of the component. Service injections and args being available in
this way also makes them available to class field initializers, which run
immediately <em>after</em> the call to <code>super</code>:</p>
<pre><code class="language-js">class PersonComponent extends GlimmerComponent {
  @service time;

  // Use the values of args in an initializer
  fullName = `${this.args.firstName} ${this.args.lastName}`;

  // Access a service in an initializer
  currentTime = this.time.now();
}
</code></pre>
<p>The <code>args</code> argument will be shallow-frozen (in development mode only) to prevent
users from modifying them.</p>
<h4 id="type-injections"><a class="header" href="#type-injections">Type Injections</a></h4>
<p>Ember's dependency injection system allows defining injections across an entire
type via
<a href="https://www.emberjs.com/api/ember/3.5/classes/ApplicationInstance/methods/inject?anchor=inject">RegistryProxy#inject</a> - for
instance, Ember Data's store, which is available by default as
<code>this.store</code> on all Routes and Controllers. These injections add a layer of
implicit state to objects, since users must know what the default injections are
ahead of time.</p>
<p>By contrast, service getters (decorated with <code>@service</code>) clearly and explicitly
state the dependencies of a class within its definition. The benefit of having
an explicit dependencies list within each class has proven to be invaluable in
practice since <code>inject.service()</code> was introduced.</p>
<p>Glimmer components will only receive the owner directly, and as such will <em>not</em>
support type injections. This cuts down on the implicit knowledge developers
must have when writing a component.</p>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>Glimmer components have 3 properties: <code>args</code>, <code>isDestroying</code>, and <code>isDestroyed</code>.</p>
<h4 id="args"><a class="header" href="#args"><code>args</code></a></h4>
<p>As discussed in the motivation section, <code>args</code> is an object with the values of
the named arguments passed to the component. This property will be updated
whenever the arguments change. It will be shallow-frozen in development mode to
prevent users from setting values on it.</p>
<h4 id="isdestroying"><a class="header" href="#isdestroying"><code>isDestroying</code></a></h4>
<p>This property will be set to <code>true</code> when component teardown has been initiated,
<em>before</em> the component's <code>willDestroy</code> hook is run, along with any other
components which are currently being torn down. This allows the entire component
tree to be marked before user code is run. It can be used by users to
conditionally prevent asynchronous code from running, and to check on the
teardown state of the component in general.</p>
<h4 id="isdestroyed"><a class="header" href="#isdestroyed"><code>isDestroyed</code></a></h4>
<p>This property will be set after any <code>willDestroy</code> hooks have run, and the
component has been fully torn down. It can be used by users to conditionally
prevent asynchronous code from running, and to check on the teardown state of
the component in general.</p>
<h3 id="lifecycle-hooks"><a class="header" href="#lifecycle-hooks">Lifecycle Hooks</a></h3>
<p>Classic components have 13 major lifecycle hooks that run during 3 major phases
of the component lifecycle, with some hooks running during multiple phases:</p>
<ol>
<li>
<p><strong>Initialization and Initial Render:</strong></p>
<ul>
<li><code>init</code></li>
<li><code>willInsertElement</code></li>
<li><code>didInsertElement</code>,</li>
<li><code>didReceiveAttrs</code></li>
<li><code>willRender</code></li>
<li><code>didRender</code>.</li>
</ul>
</li>
<li>
<p><strong>Rerenders and Updates:</strong></p>
<ul>
<li><code>didReceiveAttrs</code></li>
<li><code>didUpdateAttrs</code></li>
<li><code>willUpdate</code></li>
<li><code>didUpdate</code></li>
<li><code>willRender</code></li>
<li><code>didRender</code></li>
</ul>
</li>
<li>
<p><strong>Destruction:</strong></p>
<ul>
<li><code>willDestroyElement</code></li>
<li><code>didDestroyElement</code></li>
<li><code>destroy</code></li>
<li><code>willDestroy</code></li>
</ul>
</li>
</ol>
<p>Many of these hooks have overlapping or redundant functionality, and it's fairly
confusing when to use which and what the differences are. We can simplify this
cycle in a number of ways:</p>
<ul>
<li>
<p>Hooks that run during multiple phases such as <code>didRender</code> and
<code>didRecieveAttrs</code> can be convenient at times, but also add mental overhead and
redundancy. We can remove these in favor of clearly delineated hooks which
only run during <em>one</em> phase.</p>
</li>
<li>
<p>&quot;Bookend&quot; methods (<code>did*</code> and <code>will*</code>) can be confusing, since they require
some specific knowledge of what the &quot;bookended&quot; functionality is. For
instance, users almost <em>always</em> want to use <code>didInsertElement</code> and
<code>willDestroyElement</code>, but the existence of their opposite bookends can make
this confusing. Additionally, the fact that <code>didReceiveAttrs</code> and
<code>didUpdateAttrs</code> do <em>not</em> have opposing bookends is inconsistent with this
pattern.</p>
</li>
<li>
<p>Hooks that are used to update derived state, such as <code>didUpdate</code> and
<code>didUpdateAttrs</code>, can be generally be replaced with tracked or computed
properties that pull the required values as they are used, rather than eagerly
as they are updated. This is more inline with Glimmer's pull-based change
tracking system, and encourages better practices that are easier to optimize.</p>
</li>
<li>
<p>Hooks which are used to manipulate elements or the DOM in general can be
removed in favor of element modifiers, which are discussed in detail in the
next section.</p>
</li>
</ul>
<p>Based on these considerations, we can reduce these hooks to just a setup and
teardown method: <code>constructor</code> and <code>willDestroy</code>.</p>
<h4 id="constructor-1"><a class="header" href="#constructor-1"><code>constructor</code></a></h4>
<p>The native <code>constructor</code> method for the class can be used for initial setup of
the component. This effectively replaces <code>init</code>, and allows users to setup state
before <em>any</em> renders occur. It has the following timing semantics:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called when a component is created</li>
<li>called <em>before</em> any child components are created</li>
<li>called <em>before</em> any element modifiers with install hooks in the component's
template</li>
</ul>
</li>
</ul>
<p>In many cases, using the <code>constructor</code> directly will not be necessary due to
class fields, whose initializers run during instance construction.</p>
<pre><code class="language-js">class Person {
  constructor() {
    this.name = 'Tomster';
  }
}
</code></pre>
<p>Is the same as:</p>
<pre><code class="language-js">class Person {
  name = 'Tomster';
}
</code></pre>
<p>Class fields are assigned <em>after</em> the call to <code>super</code> in the constructor, but
<em>before</em> any of the user's code runs, allowing their values to be accessed by
users as well.</p>
<h4 id="willdestroy"><a class="header" href="#willdestroy"><code>willDestroy</code></a></h4>
<p>This hook runs when the component is being destroyed, and can be used for
cleanup code. It has the following timing semantics:</p>
<ul>
<li><strong>Always</strong>
<ul>
<li>called when a component is removed</li>
<li>called <em>after</em> any child component <code>willDestroy</code> hooks</li>
<li>called <em>after</em> any element modifiers with destroy hooks in the component's
template</li>
<li>called <em>after</em> <code>isDestroying</code> has been set to <code>true</code>, and <em>before</em>
<code>isDestroyed</code> has been set to <code>true</code></li>
<li>called <em>after</em> the DOM has been fully removed and is inaccessible</li>
</ul>
</li>
<li><strong>May or May Not</strong>
<ul>
<li>be called in a stable order relative to sibling component <code>willDestroy</code>
hooks</li>
</ul>
</li>
</ul>
<h3 id="element-modifiers"><a class="header" href="#element-modifiers">Element Modifiers</a></h3>
<p>DOM manipulation is a hard problem for component-oriented frameworks. We spend a
lot of time crafting elegant, functional, template oriented abstractions that
work very well, up until the point where we have to use an imperative native API
like <code>addEventListener</code> or <code>MutationObserver</code>. This is not a problem unique to
Ember - the recent introduction of the React Hooks API, and the <a href="https://nikgraf.github.io/react-hooks/">various flavors
of hooks that exist</a>, many of which
accomplish the same thing in slightly different ways, suggests that this is a
<em>fundamentally difficult problem</em> no matter how you tackle it.</p>
<p>This is also evidenced by the sheer <em>number</em> of hooks which have been added to
classic Ember components over time to handle various different use cases, and
the fact that there does not appear to be a general consensus on best practices
for using these hooks. In our audit, we observed the following:</p>
<ol>
<li><code>didInsertElement</code> was commonly used for setting up component state which had
nothing to do with the element and could have been accomplished in <code>init</code>.</li>
<li><code>didRender</code> was often used for setting up DOM state once on initial render
only, instead of <code>didInsertElement</code>.</li>
<li><code>didRender</code> and <code>didReceiveAttrs</code> (or <code>didUpdate</code> and <code>didUpdateAttrs</code>) were
used interchangeably for setting up and updating DOM state based on incoming
argument changes, without strong conventions on when to use one or the other,
or consideration for which ones fire in SSR (<code>didReceiveAttrs</code> and
<code>didUpdateAttrs</code>) and which do not.</li>
<li>Libraries like
<a href="https://github.com/ember-lifeline/ember-lifeline">ember-lifeline</a> were not
uncommon for managing the extra state that using hooks inevitably creates,
and imply that it is not always intuitive or well understood that you must
clean up that state.</li>
<li>Guards for SSR appear sporadically throughout various hooks, since some
(<code>didInsertElement</code>, <code>willDestroyElement</code>) do <em>not</em> run in SSR, but others
(<code>didReceiveAttrs</code>, <code>didUpdateAttrs</code>) do. This adds <em>another</em> layer of state
that developers must be aware of as they are using lifecycle hooks. Often
times these guards occured even in hooks which <em>did not run</em> in SSR, implying
that it is difficult to remember which hooks are best to use in either
situation.</li>
<li>Hooks such as <code>didRender</code> had many different potential use cases. It was used
for reacting to changes to component arguments in some cases, but in others
it was used as a more general purpose &quot;bloom filter&quot;, allowing the component
to react to <em>any</em> changes to the DOM subtree. The variety of use cases seemed
to add to the confusion about which hooks should be used in which
circumstances.</li>
<li>Another disadvantage of the flexibility of these hooks was that often
developers had to add additional validation steps for their specific use
case. For instance, if a developer wanted to react to a change to a specific
argument in <code>didRender</code> or <code>didReceiveAttrs</code>, they had to add cacheing and
comparison logic manually to do so for each property.</li>
</ol>
<p>In summary, lifecycle hooks attempted to provide on general solution to the
problem of DOM manipulation for <em>all</em> use-cases, and in doing so provided a
solution that solves each individual problem and use-case in a mediocre way.
Rather than continue these patterns in Glimmer components, we believe that they
should lean instead on <em>Element Modifiers</em>.</p>
<p>Modifiers provide a single unified way to define multiple <em>different</em> APIs for
interacting with the DOM. Individual modifiers can be targeted toward specific
use cases, such as adding an event listener or <code>MutationObserver</code>, triggering a
callback during certain lifecycle events, capturing element references for use
in components, and more. Importantly, modifiers are <em>easy to compose</em> and
<em>self-contained</em>, meaning that it will be possible for general purpose addons to
be built for various use cases, and for them all to be used together without
difficulty.</p>
<h4 id="conversion-and-path-forward"><a class="header" href="#conversion-and-path-forward">Conversion and Path Forward</a></h4>
<p>Modifiers may be the general purpose solution for writing DOM APIs, but average
Ember developers should not have to <em>write</em> a modifier very often. This is a key
distinction - it means that beginner Ember developers will not need to learn the
ins and outs of modifiers as soon as they need to use DOM, and that they will be
able to instead rely on established patterns from established libraries, similar
to helpers. This combined with the fact that DOM manipulation was on average a
<em>rare</em> occurence in our audits means they won't be overwhelming to learn.</p>
<p>However, while we have merged the <a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">Modifier Manager
RFC</a>,
the final API for modifiers themselves is still in RFC, and the community hasn't
had a chance to experiment with them and develop patterns yet. We also want to
be able to provide straightforward upgrade and migration guides for users who
want to convert from classic component lifecycle hooks to modifiers. In order to
cover this gap while the community is still absorbing the new APIs, the
modifiers proposed in the <a href="https://github.com/emberjs/rfcs/pull/415">Render Element Modifiers
RFC</a> will be released as an official
Ember addon. These essentially expose the three hooks of modifiers to users
directly, allowing them to pass callbacks from their components:</p>
<pre><code class="language-hbs">&lt;div
  {{did-insert this.setupElement @arg1 @arg2}}
  {{did-update this.updateElement @arg1 @arg2}}
  {{will-destroy this.teardownElement}}
&gt;
  ...
&lt;/div&gt;
</code></pre>
<p>These modifiers should allow users to approximate most of the existing lifecycle
hooks, and in most cases should be pretty straightforward to update to. The
Ember guides will provide migration examples for a variety of use cases to
assist in converting to these modifiers. Over time, as addons and libraries are
released that target specific use cases, the guides should be updated to include
popular patterns and demonstrate the most effective and conventional ways to
solve <em>specific</em> problems with DOM manipulation.</p>
<h3 id="lifecycle-hook-audit"><a class="header" href="#lifecycle-hook-audit">Lifecycle Hook Audit</a></h3>
<p>In the design process of this RFC, we wanted to provide the minimal set of
functionality that covered the previous use cases of classic components. The
final API of Glimmer components as proposed in this RFC is very small, cutting
out almost all existing hooks in favor of a handful of conventional hooks and
element modifiers.</p>
<p>In order to be sure that these hooks and modifiers would cover existing use
cases, we did an audit of a few popular addons: <a href="https://miguelcobain.github.io/ember-paper/">Ember
Paper</a>,
<a href="https://github.com/sandydoo/ember-google-maps">ember-google-maps</a>, and
<a href="https://github.com/ember-animation/liquid-fire">liquid-fire</a>. These libraries
were chosen because they represent a large mix of both common use cases and edge
cases, and give us a decent cross-section of what the hooks are used for today.</p>
<p>We also did a less formal audit of a variety of addons and open source apps,
including <a href="https://github.com/miguelcobain/ember-leaflet">ember-leaflet</a>,
<a href="https://github.com/cibernox/ember-power-select">ember-power-select</a>,
<a href="https://github.com/cibernox/ember-basic-dropdown">ember-basic-dropdown</a>,
<a href="https://github.com/Addepar/ember-table">ember-table</a>,
<a href="https://github.com/html-next/vertical-collection">vertical-collection</a>,
<a href="https://github.com/miguelcobain/ember-composability-tools">ember-composablity-tools</a>,
<a href="https://github.com/travis-ci/travis-web">Travis Web</a>, <a href="https://github.com/TryGhost/Ghost-Admin">the Ghost admin
app</a>, and <a href="https://github.com/HospitalRun/hospitalrun-frontend">Hospital
Run</a>, along with general
code searches through Ember Observer.</p>
<p>In all of these, the only use case we found that was <em>not</em> covered was the
ability to run a hook whenever a render occurs in the subtree of a component
using <code>didRender</code> or <code>didUpdate</code>. The only instance we found of this was in
<a href="https://github.com/sandydoo/ember-google-maps/blob/d901864e9198c1d4956d5ba9629147f64e4ae6b7/addon/templates/components/g-map/overlay.hbs#L6">ember-google-maps</a>,
where it was used detect when an
<a href="https://ember-google-maps.sandydoo.me/docs/overlays">overlay</a> component has
rendered and needs to be repositioned. For this rare case, we believe a
<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a>
set to detect mutations to the DOM subtreemay be more appropriate.
Alternatively, a component can be defined with a custom component manager, which
still retains this ability.</p>
<p>The usages from the audit and their equivalent solution in Glimmer components
have been included in this RFC in an appendix.</p>
<h3 id="actions-1"><a class="header" href="#actions-1">Actions</a></h3>
<p>In classic components, actions are defined on the <code>actions</code> hash, and can be
referenced in templates using strings passed to the <code>{{action}}</code> helper:</p>
<pre><code class="language-js">export default Component.extend({
  actions: {
    buttonPressed() {
      // ...
    }
  }
})
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{action 'buttonPressed'}}&gt;Press Me!&lt;/button&gt;
</code></pre>
<p>This form of action sending is based on the <code>ActionHandler</code> mixin and requires
that the component class have a <code>send</code> method. Glimmer components will <em>not</em>
implement this API, and as such will not support string based action helpers.
In development mode a special error will be thrown instead, informing users of
alternatives.</p>
<p>Instead, users should use helpers or decorators to bind functions to the
component instance. The <code>action</code> helper and modifier do this in templates, as
does the <code>bind</code> helper provided by the <a href="https://github.com/Serabe/ember-bind-helper">ember-bind-helper</a> addon:</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  buttonPressed() {
    // ...
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{action this.buttonPressed}}&gt;Press Me!&lt;/button&gt;
</code></pre>
<p>Alternatively, a decorator could be used to bind the helper to the instance,
such as the <code>@action</code> decorator proposed in the <a href="https://github.com/emberjs/rfcs/pull/408">Decorators RFC</a>.</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  @action
  buttonPressed() {
    // ...
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;button onclick={{this.buttonPressed}}&gt;Press Me!&lt;/button&gt;
</code></pre>
<p>However, one method for binding methods which should be discouraged is assigning
an arrow function to class fields:</p>
<pre><code class="language-js">export default class ButtonComponent extends Component {
  buttonPressed = () =&gt; {
    // ...
  }
}
</code></pre>
<p>This is messy for a few reasons:</p>
<ul>
<li>The method is no longer available on the prototype, making it difficult to
mock</li>
<li>It breaks <code>super</code> and inheritance, meaning subclasses have no way to override
the arrow function</li>
<li>Values such as <code>arguments</code> will not be set since it is an arrow function</li>
</ul>
<p>For more details, see <a href="https://github.com/tc39/proposal-decorators/blob/master/bound-decorator-rationale.md">this document explaining the rationale for decorators</a>
over class fields for binding.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>In it's current form this RFC is dependent on 2 of 3 open RFCs being accepted:</p>
<ul>
<li>
<p>The <a href="https://github.com/emberjs/rfcs/pull/408">Decorators RFC</a> must be
accepted, because Glimmer components cannot be defined using classic class
syntax. If it is not accepted this RFC will have to be amended to add a way
for users to define Glimmer components with classic classes.</p>
</li>
<li>
<p>The <a href="https://github.com/emberjs/rfcs/pull/415">Render Element Modifiers RFC</a>
must be accepted, since Glimmer components currently do not have any render
lifecycle hooks or ways to interact with the DOM.</p>
<p>If it is not accepted, this RFC will have to explore some of the alternatives
listed below (<code>{{capture-element}}</code>, <code>bounds</code>, and render hooks).</p>
</li>
</ul>
<h2 id="how-we-teach-this-72"><a class="header" href="#how-we-teach-this-72">How we teach this</a></h2>
<p>Teaching Glimmer components is intrinsically tied to a wider shift in the Ember
programming model - the Ember Octane edition. From a teaching perspective, this
edition will be completely overhauling the guides and updating all of the best
practices as they stand. New users should see Glimmer components as the
<em>default</em>, and should not ever have to write a classic component or see one in
the main guides.</p>
<p>Classic components will of course be widely used for some time however, so a
classic section which includes conversion guides and relevant codemods should be
made available in the guides, and maintained for as long as classic components
are supported by Ember.</p>
<p>Breaking down the public API of Glimmer components, we need to cover:</p>
<ul>
<li>Native class syntax, including the <code>constructor</code> and class fields</li>
<li>Arguments</li>
<li>Lifecycle hooks and properties</li>
<li>Element modifiers</li>
</ul>
<h3 id="native-class-syntax"><a class="header" href="#native-class-syntax">Native class syntax</a></h3>
<p>One of the benefits of native class syntax is that it is used outside of Ember,
so as time goes on we will be able to assume there is more general knowledge of
it, and provide links to documentation for it for users who are not familiar.
During this transitionary period though we should add a more thorough primer of
the syntax to our guides, and explicitly call out the differences between
classic class syntax and native class syntax, including:</p>
<ul>
<li>
<p>Usage of <code>constructor</code> in classes which <em>do not</em> extend from classic classes.
Otherwise, always use <code>init</code>. This will be tricky, because even when using
native classes to extend from classic classes, you should still use <code>init</code>.</p>
</li>
<li>
<p>Nuances of class fields - they run <em>after</em> <code>super</code>, and <em>before</em> user code.</p>
</li>
<li>
<p>Benefits of class field initializers, and how they can be used to do much of
the work that would otherwise be done in the <code>constructor</code> or <code>init</code></p>
</li>
<li>
<p>Expense of class fields - new objects and functions are created for every
instance, so users should also be careful with them.</p>
</li>
<li>
<p>What ends up on the prototype and what's on the instance</p>
</li>
<li>
<p>How do property initializers work</p>
</li>
<li>
<p>What's the default behavior of a constructor, as it pertains to <code>super()</code> and passing arguments</p>
</li>
<li>
<p>The risks of anonymous classes and class factories (i.e, you get poor stack traces)</p>
</li>
<li>
<p>How to implement &quot;default values&quot; in ES6</p>
</li>
<li>
<p>The risks of writing decorators in user-land code (until TC39 stage 4)</p>
</li>
<li>
<p>Methods vs arrow function member values</p>
</li>
<li>
<p>Getting ahold of prototypes if/when you need them</p>
</li>
</ul>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<p>For arguments, namespacing makes sense in general as an API choice and is common
in other frameworks (<code>props</code> in React, etc.). We should be sure to cover this
thoroughly for users who are used to classic components, but it shouldn't
require too much explaining.</p>
<p>Immutability will be a bigger sticking point in general, in particular the
inability to provide default argument values. This is easy enough to work around
using an <code>{{or}}</code> helper in templates:</p>
<pre><code class="language-hbs">Hello, {{or @firstName &quot;friend&quot;}}!
</code></pre>
<p>Or a defaulting alias getter in the class:</p>
<pre><code class="language-hbs">Hello, {{this.firstName}}!
</code></pre>
<pre><code class="language-js">export default class Greeting extends GlimmerComponent {
  @tracked
  get firstName() {
    return this.args.firstName || 'friend';
  }
}
</code></pre>
<p>But does add a bit of boilerplate to components. Users will also have to be
careful when attempting to override these &quot;defaults&quot; in subclasses, since it is
not as simple as overriding a class field or property. We can guide users to
use template-only components to &quot;partially applied&quot; components when trying to
provide defaults in subclasses instead, leveraging the outer HTML semantics of
Glimmer components:</p>
<pre><code class="language-hbs">&lt;!-- components/button.hbs --&gt;
&lt;button class=&quot;button {{@type}}&quot;&gt;
  &lt;i class=&quot;icon {{@type}}&quot;&gt;&lt;/i&gt;
  {{yield}}
&lt;/button&gt;
</code></pre>
<pre><code class="language-hbs">&lt;!-- component/success-button.hbs --&gt;
&lt;Button @type=&quot;success&quot;&gt;{{yield}}&lt;/Button&gt;
</code></pre>
<pre><code class="language-hbs">&lt;!-- component/danger-button.hbs --&gt;
&lt;Button @type=&quot;danger&quot;&gt;{{yield}}&lt;/Button&gt;
</code></pre>
<p>Or to explore possibilities using decorators, such as those in the
<a href="https://github.com/gossi/sparkles-decorators">sparkles-decorators</a> addon.</p>
<h4 id="lifecycle-hooks-and-properties"><a class="header" href="#lifecycle-hooks-and-properties">Lifecycle hooks and properties</a></h4>
<p>For users without framework experience, and users of other frameworks, lifecycle
hooks will be very minimal and fairly easy to understand. The lack of render
hooks may be the more difficult part to understand, and we'll have to lean on
the documentation for element modifiers and make sure that is <em>really</em> excellent
to get the concepts there across.</p>
<p>For existing users, who are used to having a variety of hooks to choose from
when coordinating lifecycle events, the hooks may be fairly confusing. The
bullet points here are:</p>
<ul>
<li>Tracked properties/computed properties are the primary place to react to
argument changes for any values that can be computed directly via getters.
Ideally, most logic for derived state is conventionally in tracked or computed
properties.</li>
<li><code>willDestroy</code> is the correct place for all teardown code, like in classic
components.</li>
<li><code>didReceiveAttrs</code>, <code>willRender</code>, and <code>didRender</code> code should be extracted into
functions which are then passed to <code>{{did-insert}}</code> and <code>{{did-update}}</code></li>
<li><code>willDestroyElement</code> code should be extracted into functions which are then
passed to <code>{{will-destroy}}</code></li>
</ul>
<p>Additionally, we should make sure we cover <code>isDestroying</code> and <code>isDestroyed</code>
pretty thoroughly. Users should know that they can (and probably should) check
these flags if they are doing anything asynchronous that could happen after the
component has been torn down.</p>
<h4 id="element-modifiers-1"><a class="header" href="#element-modifiers-1">Element modifiers</a></h4>
<p>The render element modifiers will be the most different part of Glimmer
components for users. The strategy for teaching these is <a href="https://github.com/emberjs/rfcs/blob/b9f390cb98f560d9cf876e3b1d67226fe0e1613b/text/0000-render-element-modifiers.md#how-we-teach-this">included in their
RFC</a>,
but the key points are:</p>
<ol>
<li>
<p>Teaching modifiers as a concept first, so users understand that what they're
looking at is a <em>general</em> tool, and that the render modifiers are an official
addon provided by Ember.</p>
</li>
<li>
<p>Providing <em>lots</em> of examples for various use cases, especially for users
transitioning from classic components.</p>
</li>
</ol>
<h3 id="template-only-components-1"><a class="header" href="#template-only-components-1">Template-Only Components</a></h3>
<p><a href="https://github.com/emberjs/rfcs/blob/master/text/0278-template-only-components.md">Template-only components</a>
are not strictly speaking related to the <code>GlimmerComponent</code> class proposed in
this RFC. However, conceptually they will probably be much easier to teach in
relation to Glimmer components, and will be an important part of Octane that we
should be sure to cover in depth. Additionally, the name of the optional feature
flag, <code>template-only-glimmer-components</code>, would make teaching the differences
between Glimmer components and template-only components much more difficult and
confusing.</p>
<p>As such, when writing the documentation for Glimmer components, we should ensure
that we cover template-only components in some detail as well.</p>
<h2 id="drawbacks-96"><a class="header" href="#drawbacks-96">Drawbacks</a></h2>
<h3 id="multiple-component-apis"><a class="header" href="#multiple-component-apis">Multiple component APIs</a></h3>
<p>One major drawback to Glimmer components is that they add a separate API for
components, meaning that for the forseeable future Ember users will likely
need to learn how to use both interchangeably. This introduces a fair amount of
mental overhead for users, but the benefits of Glimmer components and their
simplicity should make this less problematic.</p>
<h3 id="heavy-reliance-on-element-modifiers"><a class="header" href="#heavy-reliance-on-element-modifiers">Heavy reliance on element modifiers</a></h3>
<p>Glimmer components as proposed in this RFC are heavily reliant on element
modifiers for element manipulation. Element modifiers are a relatively new
concept in Ember, and as such will likely be unfamiliar to users and require
more learning than normal to get used to. This also means that users will not
be able to rely on well established patterns, and will have to develop new ones
for dealing with element manipulation.</p>
<h3 id="lack-of-positional-parameter-support"><a class="header" href="#lack-of-positional-parameter-support">Lack of positional parameter support</a></h3>
<p>Glimmer components are meant to cover <em>most</em> common use cases, but are also
meant to be as minimal as possible. As such, they do <em>not</em> have support for
positional parameters. Positional parameters are already unusable with any
component invoked using angle bracket syntax, but Glimmer components will also
not support them even when using curly bracket invocation.</p>
<p>The use cases for positional parameters are very uncommon, so it doesn't make
sense to add them to the main component class as an option. Instead, we should
make alternative component classes which support positional parameters, perhaps
exclusively (e.g. asserting if positional parameters are <em>not</em> defined).</p>
<h2 id="alternatives-98"><a class="header" href="#alternatives-98">Alternatives</a></h2>
<h3 id="render-lifecycle-hooks"><a class="header" href="#render-lifecycle-hooks">Render lifecycle hooks</a></h3>
<p>The ommission of <code>didRender</code>,  <code>didUpdate</code>, <code>didInsertElement</code>,
<code>willDestroyElement</code>, and other render oriented hooks could be confusing to
users. These were staples of classic components, are common in other frameworks,
and make it easy for users to orient themselves when looking at a component
class. They are part of the &quot;standard lifecycle&quot; that make up many component
rendering systems, and make components easier to teach. They also allow users to
place most of their element manipulation logic inside their components, which is
a benefit for users who prefer lighter templates with less logic in them.</p>
<p>Element modifiers, by contrast, are a very new concept in Ember and will require
users to learn a fair amount more just to get started. They force more logic
into the template, and mean users have to look at the template to know if a
method is an element lifecycle hook or an internal method.</p>
<p>Adding the standard element lifecycle hooks would allow users to follow the
patterns they are currently used to, and that are used in other frameworks. If
added without <code>{{capture-element}}</code> or <code>bounds</code> (see below), they could be used
with <code>{{did-insert}}</code> and <code>{{will-destroy}}</code> for registering elements:</p>
<pre><code class="language-hbs">&lt;div {{did-render this.registerElement}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">class ExampleComponent extends Component {
  @action
  registerElement(element) {
    this.element = element;
  }

  didRender() {
    setupElement(this.element);
  }
}
</code></pre>
<h3 id="add-a-capture-element-modifier"><a class="header" href="#add-a-capture-element-modifier">Add a <code>{{capture-element}}</code> modifier</a></h3>
<p>This alternative would go hand in hand with having render lifecycle hooks.
Rather than relying solely on element modifiers for DOM manipulation, we could
add a modifier that allows users to specify elements which they want to
reference in their component class:</p>
<pre><code class="language-hbs">&lt;div {{capture-element this}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">class ExampleComponent extends Component {
  didRender() {
    setupElement(this.elements.main);
  }
}
</code></pre>
<p>This would have to take into account multiple usages, and variations of usages.
For instance, how would using <code>capture-element</code> in an <code>if</code> or <code>each</code> work?</p>
<pre><code class="language-hbs">&lt;div {{capture-element this}}&gt;
  {{#if someBool}}
    &lt;div {{capture-element this 'conditionalElement'}}&gt;
  {{/if}}

  {{#each items as |item|}}
    &lt;div {{capture-element this 'itemElements'}}&gt;
  {{/each}}
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">class ExampleComponent extends Component {
  didRender() {
    this.elements.main; // the main outer div
    this.elements.conditionalElement; // the conditional element
    this.elements.itemElements; // An array of all the items that are rendered
  }
}
</code></pre>
<p>This would also mean a fair amount of additional code would need to be added for
reacting to changes in the DOM compared to <code>{{did-insert}}</code> and
<code>{{will-destroy}}</code>. For instance, if the case of conditionally captured element,
additional validation code will have to exist in <code>didRender</code>:</p>
<pre><code class="language-js">class ExampleComponent extends Component {
  didRender() {
    let { conditionalElement } = this.elements;

    if (conditionalElement) {
      this._previousConditionalElement = conditionalElement;

      setupPlugin(conditionalElement);
    } else {
      teardownPlugin(this._previousConditionalElement);
    }
  }
}
</code></pre>
<p>This problem is compounded in collections, where any number of elements may be
added or removed.</p>
<h3 id="add-element-or-bounds-on-the-component"><a class="header" href="#add-element-or-bounds-on-the-component">Add <code>element</code> or <code>bounds</code> on the component</a></h3>
<p>We could attempt to add DOM references back to the component, instead of adding
the <code>{{did-insert}}</code> and <code>{{will-destroy}}</code> modifiers. This would require us to
handle a number of edge-cases (0 element, multi element), and would open up some
intimate details of the Glimmer VM to user code (<code>bounds</code> nodes). If in the
future the VM wanted to change these details, it could be problematic.</p>
<p>Element modifiers are less invasive, more declarative, and handle a lot of
boilerplate type code (checking to see if an element exists, for instance).
However, they are also very new to Ember users as a concept (aside from
<code>{{action}}</code>) and could be difficult to teach.</p>
<h3 id="init-vs-constructor"><a class="header" href="#init-vs-constructor"><code>init</code> vs <code>constructor</code></a></h3>
<p>Recent changes to the way native classes extend from <code>EmberObject</code> made it so
users have to use <code>init</code> instead of the <code>constructor</code>. This is a pretty
universal caveat currently, so it's fairly teachable - there is a <code>constructor</code>,
but use <code>init</code> instead (see the <a href="https://github.com/emberjs/rfcs/blob/master/text/0337-native-class-constructor-update.md">Native Class Constructor
RFC</a>)</p>
<p>With the current design of Glimmer components, we are introducing the first base
class which doesn't extend from <code>EmberObject</code>, and requires users to use
<code>constructor</code> instead. This could be confusing, and will have to be <em>very</em>
clearly documented at the least.</p>
<p>We could alternatively include an <code>init</code> hook, or have both. This would allow
users to follow one rule for object initialization, but would also lock us into
the supporting the <code>init</code> hook for the forseeable future.</p>
<h3 id="no-owner-in-constructor"><a class="header" href="#no-owner-in-constructor">No owner in constructor</a></h3>
<p>Sparkles components do not provide access to the owner or injections in the
constructor, though it is a requested feature. Instead of passing the owner to
the constructor, we could add a <code>willCreate</code> or <code>init</code> hook which allows users
to setup the instance after the owner has been assigned.</p>
<p>Alternatively, the exact method by which the owner is passed to the constructor
can be changed (on an object vs directly) or all injections could be passed,
enabling typed injections.</p>
<h2 id="appendix-lifecycle-hook-audit"><a class="header" href="#appendix-lifecycle-hook-audit">Appendix: Lifecycle Hook Audit</a></h2>
<h3 id="ember-paper"><a class="header" href="#ember-paper"><a href="https://miguelcobain.github.io/ember-paper/">ember-paper</a></a></h3>
<h4 id="didupdateattrs-1"><a class="header" href="#didupdateattrs-1"><code>didUpdateAttrs</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-autocomplete-trigger.js#L37">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties</td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-tile.js#L41">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties</td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L69">link</a></td><td>Element setup/update code based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L75">link</a></td><td>Element setup/update code based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L65">link</a></td><td>Element setup/update code based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
</tbody></table>
<h4 id="didreceiveattrs-1"><a class="header" href="#didreceiveattrs-1"><code>didReceiveAttrs</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-autocomplete.js#L93">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-card-actions.js#L17">link</a></td><td>Setup component state based on incoming arguments</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L76">link</a></td><td>Setup component state based on incoming arguments, validate incoming arguments</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L126">link</a></td><td>Animate based on incoming arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select.js#L40">link</a></td><td>Trigger validations</td><td>Tracked properties and <code>constructor</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-sidenav-inner.js#L55">link</a></td><td>Element update code and sending an action</td><td>Tracked properties and <code>{{did-insert}}</code> with args</td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L131">link</a></td><td>Updating logic and element update code</td><td>Tracked properties and <code>{{did-insert}}</code> with args</td></tr>
</tbody></table>
<h4 id="willinsertelement"><a class="header" href="#willinsertelement"><code>willInsertElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L91">link</a></td><td>Container setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
</tbody></table>
<h4 id="didinsertelement"><a class="header" href="#didinsertelement"><code>didInsertElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog-inner.js#L39">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog.js#L64">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L52">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L89">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-menu-content-inner.js#L26">link</a></td><td>Set focus after initial render</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L118">link</a></td><td>Setup animation based on arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select-menu-inner.js#L29">link</a></td><td>Set focus after initial render</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-select-options.js#L14">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-sidenav-inner.js#L48">link</a></td><td>Element setup code on initialization (partially based on args)</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L62">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L56">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tab.js#L44">link</a></td><td>Measure element on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L71">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L58">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L96">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip-inner.js#L24">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip.js#L67">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat-scroller.js#L8">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L8">link</a></td><td>Measure element on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/ripple-mixin.js#L8">link</a></td><td>Element setup code on initialization</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/translate3d-mixin.js#L8">link</a></td><td>Element animation on setup</td><td><code>{{did-insert}}</code></td></tr>
</tbody></table>
<h4 id="willdestroyelement"><a class="header" href="#willdestroyelement"><code>willDestroyElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog-inner.js#L51">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-dialog.js#L79">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L64">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L104">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-progress-circular.js#L153">link</a></td><td>Teardown animations on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-slider.js#L81">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-switch.js#L70">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L102">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast-inner.js#L77">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-toast.js#L118">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tooltip.js#L110">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat-scroller.js#L17">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/child-mixin.js#L30">link</a></td><td>Unregister child class from parent</td><td><code>willDestroy</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/mixins/translate3d-mixin.js#L30">link</a></td><td>Teardown animations on destruction</td><td><code>{{will-destroy}}</code></td></tr>
</tbody></table>
<h4 id="didupdate"><a class="header" href="#didupdate"><code>didUpdate</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-grid-list.js#L57">link</a></td><td>Reapply styles based on changes to args</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
</tbody></table>
<h4 id="didrender"><a class="header" href="#didrender"><code>didRender</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-input.js#L97">link</a></td><td>Resize component based on changes to args</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-speed-dial-action-action.js#L34">link</a></td><td>Animate component based on changes to arguments</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-speed-dial.js#L32">link</a></td><td>Set <code>elementDidRender</code> boolean on instance</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tab.js#L52">link</a></td><td>Measure component on render</td><td><code>{{did-insert}}</code> and <code>{{did-update}}</code>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-tabs.js#L96">link</a></td><td>Resize component based on changes to size</td><td><code>{{did-insert}}</code> with args, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a></td></tr>
<tr><td><a href="https://github.com/miguelcobain/ember-paper/blob/b36f7a7b5e19c60fa71e945590178d86274bd49d/addon/components/paper-virtual-repeat.js#L156">link</a></td><td>Measure element sizes based on changes to args</td><td><code>{{did-insert}}</code> with args</td></tr>
</tbody></table>
<h3 id="ember-google-maps"><a class="header" href="#ember-google-maps"><a href="https://github.com/sandydoo/ember-google-maps">ember-google-maps</a></a></h3>
<h4 id="didupdateattrs-2"><a class="header" href="#didupdateattrs-2"><code>didUpdateAttrs</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map.js#L103">link</a></td><td>Synchronize options with Google maps</td><td>Refactor to use actions to modify data, or use a modifier</td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L54">link</a></td><td>Update component based on changes to arguments</td><td>Refactor to use actions to modify data, or use a modifier</td></tr>
</tbody></table>
<h4 id="didreceiveattrs-2"><a class="header" href="#didreceiveattrs-2"><code>didReceiveAttrs</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/waypoint.js#L20">link</a></td><td>Register component with parent</td><td><code>constructor</code></td></tr>
</tbody></table>
<h4 id="didinsertelement-1"><a class="header" href="#didinsertelement-1"><code>didInsertElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L46">link</a></td><td>Register component with parent and initialize</td><td><code>constructor</code> and parent component <code>{{did-insert}}</code></td></tr>
</tbody></table>
<h4 id="willdestroyelement-1"><a class="header" href="#willdestroyelement-1"><code>willDestroyElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/map-component.js#L60">link</a></td><td>Element teardown code on destruction (and potentially destruction of parent)</td><td><code>willDestroy</code> and parent component <code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/components/g-map/waypoint.js#L26">link</a></td><td>Unregister element from parent</td><td><code>willDestroy</code> and parent component <code>{{will-destroy}}</code></td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/mixins/process-options.js#L26">link</a></td><td>Teardown class state</td><td><code>willDestroy</code></td></tr>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/3f846751eda7fff08a02367c04407cf545741f00/addon/mixins/register-events.js#L26">link</a></td><td>Teardown class state</td><td><code>willDestroy</code></td></tr>
</tbody></table>
<h4 id="didrender-1"><a class="header" href="#didrender-1"><code>didRender</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sandydoo/ember-google-maps/blob/master/addon/templates/components/g-map/overlay.hbs#L6">link</a></td><td>Detect changes to subtree and reposition overlay</td><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a> or custom component that can trigger actions on subtree rerenders</td></tr>
</tbody></table>
<h3 id="liquid-fire"><a class="header" href="#liquid-fire"><a href="https://github.com/ember-animation/liquid-fire">liquid-fire</a></a></h3>
<h4 id="didreceiveattrs-3"><a class="header" href="#didreceiveattrs-3"><code>didReceiveAttrs</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/illiquid-model.js#L7">link</a></td><td>Capture argument as component state</td><td><code>constructor</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-outlet.js#L23">link</a></td><td>Capture argument as component state</td><td><code>constructor</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-versions.js#L15">link</a></td><td>Run update code for changing versions (and animating)</td><td><code>constructor</code> and tracked properties or element modifiers</td></tr>
</tbody></table>
<h4 id="didinsertelement-2"><a class="header" href="#didinsertelement-2"><code>didInsertElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-child.js#L12">link</a></td><td>Trigger animation</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-container.js#L44">link</a></td><td>Set did render</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-measured.js#L15">link</a></td><td>Element setup code on insertion</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-spacer.js#L11">link</a></td><td>Element setup code on insertion</td><td><code>{{did-insert}}</code></td></tr>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-sync.js#L8">link</a></td><td>Pause animations on insertion (continue later via action)</td><td><code>{{did-insert}}</code></td></tr>
</tbody></table>
<h4 id="willdestroyelement-2"><a class="header" href="#willdestroyelement-2"><code>willDestroyElement</code></a></h4>
<table><thead><tr><th>Usage</th><th>Use Case</th><th>Converts To</th></tr></thead><tbody>
<tr><td><a href="https://github.com/ember-animation/liquid-fire/blob/21711359faf0a396489f169ae34c1637e7f45828/addon/components/liquid-measured.js#L37">link</a></td><td>Element teardown code on destruction</td><td><code>{{will-destroy}}</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-19-12
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/418
Tracking: https://github.com/emberjs/rfc-tracking/issues/30</p>
<hr />
<h1 id="deprecate-route-render-apis"><a class="header" href="#deprecate-route-render-apis">Deprecate Route render APIs</a></h1>
<h2 id="summary-101"><a class="header" href="#summary-101">Summary</a></h2>
<p>This RFC proposses the deprecation of <a href="https://emberjs.com/api/ember/3.6/classes/Route/methods/render?anchor=render"><code>Route#render</code></a>, <a href="https://emberjs.com/api/ember/3.6/classes/Route/methods/render?anchor=renderTemplate"><code>Route#renderTemplate</code></a> and named <code>{{outlet}}</code> APIs. The following deprecation message will be emitted upon usage of <code>render</code> or <code>renderTemplate</code>:</p>
<pre><code>The usage of `renderTemplate` is deprecated. Please see the following deprecation guide to migrate.
</code></pre>
<p>and</p>
<pre><code>The usage of `render` is deprecated. Please see the following deprecation guide to migrate.
</code></pre>
<p>The following will be compile time deprecation for named outlets:</p>
<pre><code>Please refactor `{{outlet &lt;NAME&gt;}}` to a component &lt;SOURCE_INFO&gt;.
</code></pre>
<h2 id="motivation-102"><a class="header" href="#motivation-102">Motivation</a></h2>
<p>These APIs are largely holdovers from a time where components where not as prominent in your typical Ember application. While they are still documented, these APIs created an interesting coupling between the <code>Route</code> and the template. These APIs are also prone to breaking conventional naming conventions, which can lead to confusion for developers. Another issue is that it is unclear how something like this works with route based tree shaking, as there are no strong conventions or direct imports as to what is actually being used.</p>
<h2 id="transition-path-15"><a class="header" href="#transition-path-15">Transition Path</a></h2>
<p>The migration plan here is going to be somewhat situational based on the UI that was being constructed. For cases where named outlets were being used it is likely that they should just be moved to components. For cases where you were escaping the existing DOM hierarchy to render a template somewhere else in the DOM, one should use the built-in <a href="https://github.com/emberjs/rfcs/blob/master/text/0287-promote-in-element-to-public-api.md"><code>{{in-element}}</code></a> helper or an addon like <a href="https://github.com/ef4/ember-elsewhere">ember-elsewhere</a>. Below are some example of how a migration would look.</p>
<p><strong>Migrating Named Outlets</strong></p>
<p>Given:</p>
<pre><code class="language-js">Ember.Route.extend({
  // ...

  renderTemplate() {
    this.render('cart', {
      into: 'checkout',
      outlet: 'cart',
      controller: 'cart'
    })
  }
})
</code></pre>
<pre><code class="language-hbs">{{! checkout.hbs}}
&lt;section id=&quot;items&quot;&gt;
  {{outlet}}
&lt;/section&gt;
&lt;aside&gt;
  {{outlet &quot;cart&quot;}}
&lt;/aside&gt;
</code></pre>
<p>This would tell Ember to render <code>cart.hbs</code> into <code>checkout.hbs</code> at the <code>{{outlet &quot;cart&quot;}}</code> and use the <code>cart</code> controller to back the <code>cart.hbs</code> template. This is pretty confusing pattern and creates this implicit coupling that is spread between the <code>Route</code> and template.</p>
<p>Luckily, we can express this entire concept with components.</p>
<pre><code class="language-hbs">{{! checkout.hbs}}
&lt;section id=&quot;items&quot;&gt;
  {{outlet}}
&lt;/section&gt;
&lt;aside&gt;
  &lt;Cart /&gt;
&lt;/aside&gt;
</code></pre>
<p>In the event you were using <code>model</code> to derive what to render, you can us the <code>{{component}}</code> helper to dynamically render a component.</p>
<p><strong>Migrating Hiearchy Escaping</strong></p>
<p>Given:</p>
<pre><code class="language-hbs">{{! app/templates/authenticated.hbs}}

&lt;nav&gt;
  &lt;h1&gt;ACME Corp.&lt;/h1&gt;
  &lt;section&gt;
    {{outlet &quot;account&quot;}}
  &lt;/section&gt;
&lt;/nav&gt;

&lt;section id=&quot;content&quot;&gt;
  {{outlet}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/account.hbs }}
{{#link-to 'account'}}
  &lt;img src=&quot;{{this.img}}&quot; alt=&quot;{{this.name}} /&gt;
{{/link-to}}
</code></pre>
<pre><code class="language-js">// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  // ...
  user: service('user'),
  renderTemplate() {
    if (this.user.isLoggedIn) {
      this.render('account', {
        into: 'authenticated',
        outlet: 'account',
        controller: 'account'
      });
    } else {
      this.transitionTo('login')
    }
  }
});
</code></pre>
<p>One way this could be migrated is like the following:</p>
<pre><code class="language-hbs">{{! app/templates/authenticated.hbs}}

&lt;nav&gt;
  &lt;h1&gt;ACME Corp.&lt;/h1&gt;
  &lt;section id=&quot;account-placeholder&quot;&gt;&lt;/section&gt;
&lt;/nav&gt;

&lt;section id=&quot;content&quot;&gt;
  {{outlet}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/authenticated/campaigns.hbs }}

{{outlet}}

{{#in-element this.accountPlaceholder}}
  {{#link-to 'account'}}
    &lt;img src=&quot;{{this.account.img}}&quot; alt=&quot;{{this.account.name}} /&gt;
  {{/link-to}}
{{/in-element}}
</code></pre>
<pre><code class="language-js">// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  //...
  user: service('user'),
  beforeModel() {
    if (!this.user.isLoggedIn) {
      this.transitionTo('login')
    }
  }
});
</code></pre>
<pre><code class="language-js">// app/controller/authenticated/campaigns.js
import Route from '@ember/route';
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { inject as controller } from '@ember/controller';

export default Controller.extend({
  //...
  account: controller('account')
  init() {
    this._super(...arguments);
    this.accountPlaceholder = document.getElementById('account-placeholder');
  }
});
</code></pre>
<p>If you want to do this with components you could do the same thing as the following:</p>
<pre><code class="language-hbs">{{! app/templates/authenticated.hbs}}

&lt;nav&gt;
  &lt;h1&gt;ACME Corp.&lt;/h1&gt;
  &lt;section id=&quot;account-placeholder&quot;&gt;&lt;/section&gt;
&lt;/nav&gt;

&lt;section id=&quot;content&quot;&gt;
  {{outlet}}
&lt;/section&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/authenticated/campaigns.hbs }}
{{outlet}}

&lt;UserAccount /&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/components/user-account.hbs }}
{{#in-element this.accountPlaceholder}}
  {{#link-to 'account'}}
    &lt;img src=&quot;{{this.account.img}}&quot; alt=&quot;{{this.account.name}} /&gt;
  {{/link-to}}
{{/in-element}}
</code></pre>
<pre><code class="language-js">// app/routes/authenticated.js
import Route from '@ember/route';
import { inject as service } from '@ember/service';

export default Route.extend({
  //...
  user: service('user'),
  beforeModel() {
    if (!this.user.isLoggedIn) {
      this.transitionTo('login')
    }
  }
});
</code></pre>
<pre><code class="language-js">// app/components/user-account.js
import Component from '@ember/route';
import { inject as controller } from '@ember/controller';

export default Component.extend({
  // ...
  account: controller('account'),
  init() {
    this._super(...arguments);
    this.accountPlaceholder = document.getElementById('account-placeholder');
  }
});
</code></pre>
<h1 id="how-we-teach-this-73"><a class="header" href="#how-we-teach-this-73">How We Teach This</a></h1>
<p>These APIs not been a mainline API for quite some time now. The guides briefly mention this functionality. In those cases we should mirgate the guides should link to the <code>{{in-element}}</code> documentation and the component documentation. The above &quot;Transition Path&quot; will serve as the deprecation guide.</p>
<h1 id="role-out-plan"><a class="header" href="#role-out-plan">Role Out Plan</a></h1>
<p>Prior to adding the deprecation we must first do the following items</p>
<ul>
<li><input disabled="" type="checkbox"/>
The <code>{{in-element}}</code> helper implementation remains incomplete. It should be completed.
<ul>
<li><input disabled="" type="checkbox"/>
The <a href="https://github.com/emberjs/rfcs/blob/master/text/0287-promote-in-element-to-public-api.md#small-proposed-changes">small changes</a> section of the <code>{{in-element}}</code> RFC needs to be implemented. Specifically the helper should &quot;replace all the content of the destination&quot;.</li>
<li><input disabled="" type="checkbox"/>
The <code>{{in-element}}</code> helper should be documented in the <a href="https://emberjs.com/api/ember/release/classes/Ember.Templates.helpers">API docs</a>.</li>
<li><input disabled="" type="checkbox"/>
Adding <code>{{in-element}}</code> usage to the guides can be considered.</li>
</ul>
</li>
</ul>
<h2 id="drawbacks-97"><a class="header" href="#drawbacks-97">Drawbacks</a></h2>
<p>The drawback of this is that it is churn for applications that are relying heavily of these imperative APIs to construct their UI. They will need to encapsulate and use the existing declarative APIs.</p>
<h2 id="alternatives-99"><a class="header" href="#alternatives-99">Alternatives</a></h2>
<p>No real alternatives as we want to move away from these style of imperative APIs in favor of declarative ones.</p>
<h2 id="unresolved-questions-67"><a class="header" href="#unresolved-questions-67">Unresolved questions</a></h2>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-19-12
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/421
Tracking: https://github.com/emberjs/rfc-tracking/issues/5</p>
<hr />
<h1 id="deprecate-application-controller-router-properties"><a class="header" href="#deprecate-application-controller-router-properties">Deprecate Application Controller Router Properties</a></h1>
<h2 id="summary-102"><a class="header" href="#summary-102">Summary</a></h2>
<p>This RFC proposes the deprecation of <code>ApplicationController#currentPath</code> and <code>ApplicationController#currentRouteName</code>.</p>
<h2 id="motivation-103"><a class="header" href="#motivation-103">Motivation</a></h2>
<p>These APIs are no longer needed as the <code>RouterService</code> now has <code>RouterService#currentPath</code> and <code>RouterService#currentRouteName</code>.
These fields are only ever present on the application controller which is a weird special casing that we would like to remove.
Additionally, it's likely that there are very few if any consumers of this API as it is not documented.</p>
<h2 id="transition-path-16"><a class="header" href="#transition-path-16">Transition Path</a></h2>
<p>If you are reliant on <code>ApplicationController#currentPath</code> and <code>ApplicationController#currentRouteName</code> you can get the same functionality from the <code>RouterService</code> to migrate, inject the <code>RouterService</code> and read the <code>currentRouteName</code> or <code>currentPath</code> off of it.</p>
<p>Before:</p>
<pre><code class="language-js">// app/controllers/application.js
import Controller from '@ember/controller';
import fetch from 'fetch';

export default Controller.extend({
  store: service('store'),

  actions: {
    sendPayload() {
      fetch('/endpoint', {
        method: 'POST',
        body: JSON.stringify({
          route: this.currentRouteName
        })
      });
    }
  }
})
</code></pre>
<p>After:</p>
<pre><code class="language-js">// app/controllers/application.js
import Controller from '@ember/controller';
import fetch from 'fetch';

export default Controller.extend({
  store: service('store'),
  router: service('router'),

  actions: {
    sendPayload() {
      fetch('/endpoint', {
        method: 'POST',
        body: JSON.stringify({
          route: this.router.currentRouteName
        })
      });
    }
  }
})
</code></pre>
<h2 id="how-we-teach-this-74"><a class="header" href="#how-we-teach-this-74">How We Teach This</a></h2>
<p>There is likely very few consumers of this functionality and migration path is covered by existing documentation.</p>
<h2 id="drawbacks-98"><a class="header" href="#drawbacks-98">Drawbacks</a></h2>
<p>This may introduce churn that we are not aware of.</p>
<h2 id="alternatives-100"><a class="header" href="#alternatives-100">Alternatives</a></h2>
<p>No real alternative other than keep setting the properties.</p>
<h2 id="unresolved-questions-68"><a class="header" href="#unresolved-questions-68">Unresolved questions</a></h2>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-12-21
Relevant Team(s): Learning, Steering
RFC PR: https://github.com/emberjs/rfcs/pull/425
Tracking: https://github.com/emberjs/rfc-tracking/issues/35</p>
<hr />
<h1 id="website-redesign"><a class="header" href="#website-redesign">Website Redesign</a></h1>
<h2 id="summary-103"><a class="header" href="#summary-103">Summary</a></h2>
<p>The Ember homepage has been the same for a number of years, and while it's served us well in the past, it's been somewhat stale for a long time. For people who aren’t involved in the day-to-day of Ember development, it’s easy  to miss just how well the framework has kept up over the years. This redesign aims to modernize, update and improve all things website, so that the impression we give the general public matches reality.</p>
<p>Tremendous thank you to our friends at <a href="http://www.embermap.com">EmberMap</a> for stepping up to fund and do the lion's share of the work, organizing and cat-herding on this one. The key folks involved in this throughout the lifecycle of our redesign efforts are @wycats, @tomdale, @wifelette, @samselikoff, @ryanto, @melsumner and @jenweber, with lots of other folks at intervals along the way.</p>
<h2 id="motivation-104"><a class="header" href="#motivation-104">Motivation</a></h2>
<p>Right now a developer visiting emberjs.com is presented with light information about the framework, but little about what it’s like to use modern Ember. The homepage is a very different experience from the programming model, the things we say and do in other RFCs, forward-looking conference talks and what it’s like to actively develop an Ember app in 2018. The design also hasn't changed significantly in years, so someone who comes back after two or three years away gets the impression nothing has changed, even if we've made slow and subtle updates to the copy, and dramatic improvements to Ember itself.</p>
<p>The primary goal of this redesign is to make our website match reality. Some of the secondary goals include reorganizing information on internal pages for generally better information architecture, improving accessibility, improving the discoverability of important project resources, and looking overall modern and current.</p>
<h2 id="detailed-design-87"><a class="header" href="#detailed-design-87">Detailed design</a></h2>
<p>A visual redesign is a bit different than most of the Code RFCs, so showing becomes more important than explaining. What follows is the proposed design  (comp) for the redesign of the primary homepage, and the intent is to approve the RFC with this, and then keep working on the dozens of internal pages in the general Ember project under this umbrella and using this design language.</p>
<p>Like any good design project, we expect changes along the way, but that these comps present the primary thrust and look/feel of the things that have not yet been designed.</p>
<p><img src="/images/website_1.png" alt="Comp 1" /></p>
<p>Much of the copy is placeholder, but much of it represents concrete thought. A lot of that content was gleaned from a survey of about 200 of our most active users, who told us that they most value <em>clear best practices</em> and <em>productivity</em>.</p>
<p><img src="/images/survey_results.png" alt="Survey Results" /></p>
<p><a href="/images/survey_results_analysis.pdf">A significantly detailed write up of the survey results can be found here</a>. Various team members reviewed the results, and then worked together <a href="/images/EmberJS_Homepage_Outline.pdf">to outline copy for the website based on the feedback</a>. The goal was to reach consensus on what the homepage should communicate, disregarding design, aesthetic, and code.</p>
<p>The hierarchy of the first comp that resulted from that outline was deliberate—for example, the Social Proof section comes first right after the Hero, since it’s the next most important section. This hierarchy will continue to be apparent in the final design. The general instructions provided to the designer was that a tone of &quot;friendly professional&quot; was ideal, building on Ember's deliberately optimistic and friendly look and feel (and mascot!) up until now.</p>
<p>There are still missing pieces in the current mockup—the final code examples, images used in the Community section, and a few other graphics and copy odds and ends—but these ought be considered implementation details for now in the interest of involving the community earlier rather than later.</p>
<h2 id="drawbacks-99"><a class="header" href="#drawbacks-99">Drawbacks</a></h2>
<p>It's clear that most community members agree that the website is out of date and needs a refresh. That said, design is highly subjective and really easy to endlessly bikeshed over. The primary <em>risk</em> of this redesign is that we get too lost in the weeds (with comments or objections like &quot;I don't like that color purple,&quot; <em>literal</em> bikeshedding). Visual design is particularly vulnerable to that trap.</p>
<p>Change is also just difficult in general, and there will be a brief period of potentially frustrating transition where people look for things in places they're accustomed to, but don't find them there (see: improved IA). We expect this to be a brief irritation though, and that the new overall experience will be improved for new and old users alike.</p>
<p>To mitigate, we should be very clear that comments ought be structural, actionable and detailed. &quot;I just don't like that&quot; or &quot;I'd prefer a different color&quot; are unlikely to be useful; the first proposed designs have already been through several rounds like that and the comp here represents a palette and structure that improves upon the existing broad strokes, without being too dramatic a shift. It's moderate, in a way that ought help this go smoothly.</p>
<p>Comments like &quot;have you considered that X would be more accessible Y way&quot; and &quot;there's an inconsistency between these two things&quot; could be <em>very</em> helpful and potentially point out things we've missed. Questions like &quot;X used to be on the homepage but isn't anymore, can you explain the motivation and where will it go?&quot; could be thought-provoking and clarifying.</p>
<h2 id="alternatives-101"><a class="header" href="#alternatives-101">Alternatives</a></h2>
<p>Redesigning the Ember website has been a goal for several years now, always with the intent to get to a solid homepage comp and then share with the community pre-implementation for input and buy-in. There have been several attempts like this one that have failed along the way for various reasons. This is the first redesign that has achieved both internal consent <em>and</em> which hasn't fizzled out and died along the way, and represents the learnings of the failed previous attempts.</p>
<p>The alternative would be to <em>not</em> update the site, but that's not really an alternative. The website is our most public face, and every day that it doesn't represent <em>reality</em> is a day we're likely losing potential new Ember developers and users. The older site also makes it difficult for our current users to promote their technology choice, and to get their team members on board. We aim to improve all of the above and more.</p>
<h2 id="unresolved-questions-69"><a class="header" href="#unresolved-questions-69">Unresolved questions</a></h2>
<p>Even once more designs are completed, the new site will need to be implemented piece by piece, in a transitional way. The recent updates made to the current site by the Ember Learning Team prove that we're capable of digging in together and doing the incremental work to get us to larger, sweeping changes. That recent work gives us the confidence that we can accomplish this in an open, community-way, with help from new and old users alike.</p>
<p>The exact <em>plan</em> for this will have to be developed next, hence, unresolved.</p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>Some areas of the primary comp came with more detailed design views. Those can be seen here:</p>
<ul>
<li><a href="/images/website_2_header_dropdown.png">Header Dropdowns</a></li>
<li><a href="/images/website_3_url_examples.png">URL Examples</a></li>
<li><a href="/images/website_4-button_ui.png">Button UI</a></li>
<li><a href="/images/website_5_scrolled_nav.png">Scrolled Nav, Concept 1</a></li>
<li><a href="/images/website_6_nav_alt.png">Scrolled Nav, Concept 2</a></li>
<li><a href="/images/website_7_pointer.png">Pointer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-01-13
Relevant Team(s): Learning
RFC PR: https://github.com/emberjs/rfcs/pull/431
Tracking: https://github.com/emberjs/rfc-tracking/issues/29</p>
<hr />
<h1 id="restructuring-the-guides-table-of-contents"><a class="header" href="#restructuring-the-guides-table-of-contents">Restructuring the Guides Table of Contents</a></h1>
<h2 id="summary-104"><a class="header" href="#summary-104">Summary</a></h2>
<p>As our favorite framework has grown and changed a lot over the past few years, so have our <a href="https://guides.emberjs.com">Ember.js Guides</a>! This project aims to use the excellent work that has been done by hundreds of contributors and arrange it in a way that provides a natural learning flow for today’s Ember.js developers.</p>
<h2 id="motivation-105"><a class="header" href="#motivation-105">Motivation</a></h2>
<p>With Octane coming down the line, and an influx of fresh attention, it’s more important than ever to consider Ember's overall learning experience. It's time for a shift. The current structure and flow of the guides reflects the past, not the present experience for Ember. It’s time to fix that.</p>
<p>When the Guides were originally written, things like object-oriented programming in JavaScript, components, routing, and Single-Page Applications (<a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a>) in general were new ideas. For example, they start by teaching the “Ember Objects” programming concept, necessary background information at the time. It would have been an unfamiliar pattern at the time. Now, the learning hierarchy needs have shifted from “learn these unique web development concepts” to “learn how familiar pieces fit together so you can build great apps quickly.”</p>
<h2 id="detailed-design-88"><a class="header" href="#detailed-design-88">Detailed design</a></h2>
<p>The focus of this RFC is not to write new content, but make better use of what is already there by presenting it in a different order. We aim to rearrange the table of contents without breaking any URLs, with refactors necessary to fix the transitions between topics, and with the minimal <em>new</em> content needed to teach Octane. We take care to not make it look like there is “more to learn.”</p>
<p>The overall learning strategy is to establish a common core of sequential knowledge, and then later topics can be read standalone, skipping around. What this means is that if beginners read through to routes, they could skip around the topics lower down the chain successfully.</p>
<p>Finally, it is important to acknowlegde that the Guides are intended to represent the &quot;Happy Path&quot; of using Ember. It is not possible to have something that is a perfect fit for everyone's app needs, nor should they cover our entire API surface.</p>
<h3 id="process-and-preparation"><a class="header" href="#process-and-preparation">Process and preparation</a></h3>
<p>This Table of Contents plan was developed over the course of many months, meetings, and writing sessions. It includes input from many people in the community. Here are the sources of inspiration, information, and planning:</p>
<ul>
<li>Chris Garrett's (<a href="https://github.com/pzuraq">@pzuraq</a>) 2018 Roadmap Blog Post, <a href="https://medium.com/@pzuraq/emberjs-2018-ember-as-a-component-service-framework-2e49492734f1">Ember as a Component-Service Framework</a></li>
<li>My own Roadmap blog post reflections, <a href="https://gist.github.com/jenweber/a9fbea98478fc3841fb8b24f7dc961c8">Be loud and be ready</a></li>
<li>Extensive discussion in Ember Learning Team Meetings, which are held weekly and open to the public</li>
<li>The <a href="https://github.com/emberjs/rfcs/blob/26c4d83fb66568e1087a05818fb39a307ebf8da8/text/0000-roadmap-2018.md">2018 Roadmap RFC</a> by <a href="https://github.com/tomdale">Tom Dale</a></li>
<li>The Octane Strike Team meetings and followup conversations</li>
<li>Hands-on writing of a mini guide for Octane</li>
<li>Ember.js Framework Core Team meetings</li>
<li>A <a href="https://twitter.com/jwwweber/status/1081352702083452928">Twitter poll</a>, &quot;Name two things you think the guides should do well/better&quot;</li>
<li>Discussion on Discord of the initial Table of Contents draft with some key contributors and content creators</li>
<li><a href="https://github.com/cah-danmonroe">Dan Monroe</a>'s trailblazing work to <a href="https://github.com/ember-learn/guides-source/pull/357">convert the Guides to use Angle Brackets</a></li>
<li>Countless hours of Q&amp;A on Stack Overflow and Discord</li>
<li>Experience training new Ember developers in-house</li>
<li>Public Ember 101 workshops run in Boston, Massachusetts, USA</li>
<li>Studying the guides and tutorials of other JavaScript libraries</li>
<li>The successful restructure and rewrite of the <a href="https://cli.emberjs.com">Ember CLI Guides</a> (a far more drastic project than this RFC aims to be)</li>
<li>Attempting to reorder the Guides in a branch, as an experiment</li>
</ul>
<p>We are confident that this is possible thanks to the incredible response and effort shared by the community for the CLI Guides work.</p>
<h3 id="audience"><a class="header" href="#audience">Audience</a></h3>
<p>There are many different types of documentation within Ember, so it's important to identify a target audience for each, in order to guide decision making and provide a learning flow that grows with the reader.</p>
<p>There are 3 main audiences for our resources: </p>
<ol>
<li>newcomers</li>
<li>upgraders</li>
<li>specific-answer-seekers</li>
</ol>
<p>A huge challenge within the Guides is that they somewhat serve all three, and we'd like to have cleaner distinctions between sections and resources. For example, the Quickstart and Tutorials are distinct resources from the rest of the guides, and they clearly target new users. Upgraders could be served by adding 1 section to the guides as they are today. Specific-answer-seekers must lean on both the API docs and the Guides to find what they need.</p>
<p>We propose that the Guides should focus on the following audience - newcomers who have done the tutorial, and want to build real apps. It will show the &quot;happy path&quot; and how the parts of Ember interact to form good, useful patterns, in a way that would be out of scope for an API documentation block.</p>
<p>Along these lines, anything that can be offloaded to the API docs, should. For example, the Guides should show using a Computed Property/tracked property to solve a problem in a Component or Controller. They should not get into the depths of syntax option for one aspect of an API surface, but rather link to them.</p>
<p>We also have the current hypothesis to inform intro sections, as suggested by <a href="https://github.com/mike-north">Mike North</a>: &quot;People want to get the smallest understandable atom that they can jump in on.&quot; This will help us refactor how we present different topics.</p>
<h3 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h3>
<p>The following Table of Contents will be applied iteratively over the course of many months. It is not considered a blocker for the release of the Octane edition. The quick wins and urgent Octane refactors will be applied ASAP, and are described in the Implementation section of this RFC. Justification for the ordering is provided following the topics list.</p>
<p><strong>Core Concepts</strong></p>
<ul>
<li>What is Ember?</li>
<li>Getting Started</li>
<li>Anatomy of an app (future new content)</li>
</ul>
<p><strong>Fundamentals</strong></p>
<ul>
<li>Templating</li>
<li>Working with JavaScript</li>
<li>Components</li>
<li>Routing (includes Routes, Router, and Controllers)</li>
<li>State management (aka computed properties)</li>
<li>Services</li>
</ul>
<p><strong>Leveling up</strong></p>
<ul>
<li>Data management (future new content that references separate Ember Data guides)</li>
<li>Addons and dependencies</li>
<li>Testing</li>
<li>Configuration</li>
<li>Deploying</li>
<li>Upgrading (will contain links to upgrade resources, Editions, Deprecations)</li>
<li>Developer Tools (currently named Ember Inspector)</li>
<li>Reference 
<ul>
<li>Accessibility</li>
<li>Syntax conversion guide</li>
</ul>
</li>
</ul>
<h3 id="topic-naming"><a class="header" href="#topic-naming">Topic naming</a></h3>
<p>As much as possible, we aim for the topics to be named after their general web development concepts, and not the Ember-specific implementation of them.</p>
<h3 id="logic-for-ordering-and-grouping"><a class="header" href="#logic-for-ordering-and-grouping">Logic for ordering and grouping</a></h3>
<p>In this section, we will cover why this order and grouping is being proposed.</p>
<h4 id="groupings"><a class="header" href="#groupings">Groupings</a></h4>
<p>Groupings are added for the benefit of new learners. They break up the content visually and gives them a clue about which sections to pay the most attention to.</p>
<p>Just because something is included in &quot;Leveling up&quot; does not automatically make it an &quot;advanced&quot; topic. The main logic for the division between &quot;Fundamentals&quot; and &quot;Leveling up&quot; are the following tests: Can someone ignore this section and still use Ember effectively? Can it be learned in any order if someone knows the basics? If so, it goes in &quot;Leveling up.&quot;</p>
<p>As we look at each topic, we also ask: Does someone need prior knowledge of another topic in order to understand this section? Whatever those &quot;prior knowledge&quot; topics are, we add them as Fundamentals.</p>
<h4 id="anatomy-of-an-app"><a class="header" href="#anatomy-of-an-app">Anatomy of an app</a></h4>
<p>The most common points of confusion for new devs have become things like “how does everything fit together? Why can't I call a sibling component's actions directly?” The faster we can get the “Mental Model” of Ember across, the better. The Super Rentals tutorial covers the bases well for using the CLI and adding basic interactions. Anecdotally, thanks to the Tutorial, it seems that the missing pieces in the guides are mostly architectural. &quot;Anatomy of an app&quot; is the main area of new content, where we attempt to give an overview of the topics a web developer has to care about, the parts of Ember that address them, and the file structure. Current Ember developers will reference this section while learning new features.</p>
<h4 id="templates--template-helpers"><a class="header" href="#templates--template-helpers">Templates &amp; Template helpers</a></h4>
<p>Templates come before components, since it is possible for someone to not know JavaScript/Handlebars and still contribute to Ember apps. For example, designers could effectively work in only templates, using plain HTML. To make Templates work as the opening topic, additions are necessary in the introduction.</p>
<p>Template Syntax will cover Ember Handlebars basics and built-in features like <code>{{#each}}</code> and <code>{{#if}}</code>. It will take care to make it clear that Ember uses its own implementation of Handlebars. It will clearly differentiate between control structures (loops and conditionals), inline vs block styles, component invocation, and helpers.</p>
<p>Template helpers are split out and moved to &quot;Leveling Up&quot; because developers do not need to use them to write basic Ember apps (they are not a prerequisite). This section includes writing custom Helpers and using built-in helpers like <code>get</code>, <code>let</code>, and <code>array</code>. Although helpers themselves are not considered a difficult topic, they are used most often when developers understand their app's architecture and the flow of data. Also, template helpers have more in common with JavaScript functions than concerns relating to layout and data flow.</p>
<p>Lastly, another reason to split out Template syntax from Template Helpers is because the syntax section is expected to expand with the addition of Octane content.</p>
<p>An alternative to this split is to reduce the documentation of helpers themselves in the Guides, and lean on the API docs instead, however great care should be taken in removing documentation. Without a strong case for it, we lean towards leaving them in the Guides.</p>
<h4 id="working-with-javascript"><a class="header" href="#working-with-javascript">Working with JavaScript</a></h4>
<p>A common concern of new learners is, what is JavaScript and what is special to Ember? The Working with JavaScript section incorporates the existing JavaScript Primer and new content that will help make the distinctions clearer. Ember.js has proactively adopted JavaScript APIs as they become available, such as Classes and Decorators, in some cases before the larger JavaScript community becomes familiar with them. Key people in the Ember Community are also involved in the development of JavaScript itself through TC39. To an extent, it is our responsibility to at least suggest to developers which JavaScript concepts they must learn in order to feel comfortable with Ember.</p>
<h4 id="components-1"><a class="header" href="#components-1">Components</a></h4>
<p>Components will need the most refactor work and new content for Octane, so here’s the subtopic breakdown:</p>
<ul>
<li>Creating a component (includes Component Types post-Octane)</li>
<li>Displaying data in a Template</li>
<li>Adding actions</li>
<li>Nesting components (includes suggestions of when to break things into components)</li>
<li>Passing arguments</li>
<li>Using computed properties (extremely basic example, link to the Computed Property section)</li>
<li>Working with arrays of data</li>
<li>Lifecycle hooks</li>
</ul>
<h4 id="state-management"><a class="header" href="#state-management">State management</a></h4>
<p>The State Management section is important because whether &quot;computed properties&quot; are available in their current state or as <code>@tracked</code> Decorators, the nuances must be within easy reach for existing Ember developers and future learners. We rename this topic in alignment with the Topic Naming convention mentioned above.</p>
<h4 id="routing"><a class="header" href="#routing">Routing</a></h4>
<p>This RFC proposes grouping Routes, Routing, and Controllers under the same topic heading.</p>
<p>If that sounds like a lot, it's because it is. &quot;Routing&quot; is a responsibility that is divided into many pieces:</p>
<ul>
<li>the route declarations in <code>router.js</code>, including dynamic segments</li>
<li>the Handlebars route template, the middleman for passing data from the controller to components</li>
<li>the Route JavaScript file, which contains the model hook for fetching data and Transition rules in the form of hooks. The model hook receives the query params that are defined in the Controller</li>
<li>Controllers, which hold the results of the model hook, actions and other attributes that need to be passed to child components, and query param definitions.</li>
</ul>
<p>Common beginner mistakes are to define actions and attributes in a Route and try to pass them to components, plus attempts to access the result of the model hook in functions in the route JavaScript. Beginners think of Routes as &quot;special components&quot; and are surprised by their limitations. This becomes a long-lived pain point if developers hand off the controller's responsibilities to Components.</p>
<p>For better or for worse, there's a mental-model codependency between Routes and Controllers that is unlikely to change in the near term. Our Guides should reflect the best possible learning experience for today's constraints, rather than be a reflection of the codebase architecture. By grouping these topics together, we have an opportunity to heal confusion over Controllers and help new developers avoid unexpected pitfalls.</p>
<p>Based on initial feedback, this grouping is the most divisive part of the proposal. This grouping is informed by reflecting on how one might teach Controllers to a new developer, while working together in person. In order to reach consensus, any objections to the grouping should suggest solutions that include an explanation of how and where one would teach Routes, actions, routing with Query params, and passing arguments to the model hook.</p>
<h4 id="services"><a class="header" href="#services">Services</a></h4>
<p>The Services documentation is currently sparse, but it is included in &quot;Fundamentals&quot; for two reasons. First, an understanding of Services is a prerequisite for understanding Ember Data's store service. Second, the Router service is not well known by new developers, as it is solely found in the API documentation, and it provides behavior that new developers expect to have. Third, the popularity of the mental model of Ember as a Components-Services framework is a signal that this may be an effective teaching strategy.</p>
<h4 id="ember-data-1"><a class="header" href="#ember-data-1">Ember Data</a></h4>
<p>Ember Data will be gradually extracted into its own Guides. 2-3 years ago, there was a push to provide better official documentation of Ember Data, as a &quot;first class citizen.&quot; It was intermingled with the rest of the Ember.js Guides as a result. We will continue to treat Ember Data as a first class citizen, yet with improved separation of concerns similar to the approach to Ember CLI Guides. Ultimately, the content in other Guides topics will be refactored to show both Ember Data and non-Ember Data approaches, in an effort to lower the perceived cognitive overhead of Ember.</p>
<p>This change reflects the overall drive of the JavaScript Ecosystem towards interchangeable, composable parts.</p>
<p>The Ember Data team is especially requested to review this shift and provide feedback.</p>
<h4 id="deploying-and-upgrading"><a class="header" href="#deploying-and-upgrading">Deploying and Upgrading</a></h4>
<p>These sections have some existing content. They will aim to <em>not</em> duplicate the contents of the CLI Guides, but rather reference content found there. They are included in the top-level Table of Contents for two readons, discoverability and to showcase Ember's strengths</p>
<h4 id="ember-inspector"><a class="header" href="#ember-inspector">Ember Inspector</a></h4>
<p>Although the Ember.js Guides are versioned, the Inspector Guides do not need to follow the same versioning strategy. It would be reasonable to separate them out into their own, unversioned Guides. However the content is quite stable and therefore lower priority than other refactors.</p>
<p>The Ember Inspector team is requested to consider whether naming the section &quot;Debugging&quot; would improve discoverability of Ember Inspector for new developers, and whether the eventual unversioned separation aligns with expected technical development.</p>
<h4 id="unchanged-topics"><a class="header" href="#unchanged-topics">Unchanged topics</a></h4>
<p>Configuration, Testing, and Addons &amp; Dependencies remain unchanged in their approach. There are plans underway to make the Tutorial an unversioned, separate resource. That is outside the scope of this RFC, however this Table of Contents assumes that work comes to completion.</p>
<h4 id="removals"><a class="header" href="#removals">Removals</a></h4>
<p>Notably missing is &quot;Ember Object Model.&quot; This is on purpose. It will be pulled into other sections, in a “show, don’t tell” kind of approach. Also removed is &quot;Application Concerns,&quot; which are separated into their appropriate alternate subtopics.</p>
<h3 id="why-doesnt-this-rfc-include-rewriting-content"><a class="header" href="#why-doesnt-this-rfc-include-rewriting-content">Why doesn’t this RFC include rewriting content?</a></h3>
<p>Individual pages have already been refactored over the past two years by many contributors. Examples include the Ember Objects page, Controllers, using third party libraries, and explanations of data management. Many of the pain points that current Ember devs remember from their early days have been fixed. For example, it’s clear that Ember Data/JSONAPI aren’t mandatory, that you <em>can</em> use things like fetch, that Computed Properties need to be consumed for them to fire… we’re in a pretty good place! Those improvements of individual topics may continue without the need for an RFC.</p>
<p>If we choose a good structure for the Table of Contents, it will make it much easier to write/rewrite individual sections.</p>
<p>It is also important to note here that that Ember does not have a foundation or funding arm, so although it would be great to have a dedicated writer tackle this from the ground up, we must choose an approach that would be realistic for a group of volunteers to achieve.</p>
<h3 id="technical-approach"><a class="header" href="#technical-approach">Technical approach</a></h3>
<p>Thanks to Chris Manson’s work (<a href="https://github.com/mansona">@real_ate aka @mansona</a>) on the Guides app architecture, we can move content around while preserving existing links! The Table of Contents specified in the <code>pages.yml</code> file of guides-source can have any paths, and is not 100% dependent on the physical file structure to create URLs. It is very important that we don’t break existing blog articles, community tutorials, Stack Overflow answers, etc, both for user experience and SEO reasons.</p>
<p>All guides content is markdown. When we rearrange content, we’ll have to change some links and add redirects. However there are tests in place that check for bad links, so we can do this confidently.</p>
<h2 id="how-we-teach-this-75"><a class="header" href="#how-we-teach-this-75">How we teach this</a></h2>
<p>Community buy-in is important to reduce perception of churn and make “leveling up” our resources a team effort. Significant attention will be put towards informing the community of upcoming changes, and giving them the opportunity to participate.</p>
<p>We will also test major changes with beginner-level developers and developers who don’t know Ember. Although the rollout for the live site will take months, a rough cut, undeployed, could be completed in 1-2 weeks. It could serve as a North Star for the work to be done.</p>
<h3 id="implementation-plan-1"><a class="header" href="#implementation-plan-1">Implementation plan</a></h3>
<p>This work will need to be done incrementally over many months/the next year. It will be communicated in the form of Quest issues, with help requested via the Ember Times, Discord, Discuss, etc.</p>
<p>Community members will be asked to participate in PR reviews. A diversity of technical experience levels, language backgrounds, and use case perspectives will create a stronger output.</p>
<p>The intial steps will aim for the quick wins and the urgent changes that aid in Octane documentation.</p>
<p>Here's what we could expect a minimal first pass to look like:</p>
<ul>
<li>What is Ember?</li>
<li>Getting Started</li>
<li>Tutorial (already in progress of being split out)</li>
<li>Templates</li>
<li>Components</li>
<li>Routing (includes Routes, Router, and Controllers)</li>
<li>State management (aka computed properties)</li>
<li>Services</li>
<li>Ember Data (renamed from &quot;Models&quot;)</li>
<li>Addons and dependencies</li>
<li>Testing</li>
<li>Configuration</li>
<li>Application Concerns</li>
<li>Ember Inspector</li>
</ul>
<p>The groupings like &quot;Fundamentals&quot; require architectural work on the guides app. They can be done in parallel depending on volunteer capacity and interest, or delayed until the end.</p>
<h2 id="drawbacks-100"><a class="header" href="#drawbacks-100">Drawbacks</a></h2>
<p>This refactor is biased towards new user experience, so existing Ember users could experience the most drawbacks.</p>
<ol>
<li>They will need to discover where old content lives. This is mitigated by the site search, which is now stabilized</li>
<li>Experienced developers who haven’t looked at the Guides for a long time will all reference it during the Octane upgrade, and may be surprised to find a new layout. It’s another “new thing to learn.” This is mitigated by consolidating most of the new things to learn into the Components section</li>
<li>There will likely be some wrinkles to iron out with regards to content that should have been refactored during rearranging, but was overlooked. We are confident that the community will help identify these issues.</li>
</ol>
<h2 id="alternatives-102"><a class="header" href="#alternatives-102">Alternatives</a></h2>
<p>The main architectural pattern choices were as follows:</p>
<ol>
<li>On one extreme, make every section standalone</li>
<li>The middle ground, establish a “Common Core” to be read sequentially, and then have standalone sections that rely on knowledge of the core</li>
<li>The other extreme, make the entire guides sequential</li>
</ol>
<p>We choose the middle ground, because it requires the least new writing, and if we chose to move towards one of the other extremes, it does not prevent that choice nor would we throw away work.</p>
<p>It’s also useful to study the learning flow of other front end libraries in order to determine possible alternatives. Let’s look at a few.</p>
<h3 id="react"><a class="header" href="#react">React</a></h3>
<p>React is known for having low learning overhead for someone who is making their first app. With its popularity, we can guess that new users may expect to find similar topics easily accessible in our guides. This list is most useful for considering what should be in our Components section.</p>
<ol>
<li>Hello World</li>
<li>Introducing JSX</li>
<li>Rendering Elements</li>
<li>Components and Props</li>
<li>State and Lifecycle</li>
<li>Handling Events</li>
<li>Conditional Rendering</li>
<li>Lists and Keys</li>
<li>Forms
<ol>
<li>Lifting State Up</li>
<li>Composition vs Inheritance</li>
<li>Thinking In React</li>
</ol>
</li>
</ol>
<p>The Overview section of the React Tutorial also helps show what we may be missing:</p>
<ul>
<li>What Is React?</li>
<li>Inspecting the Starter Code</li>
<li>Passing Data Through Props</li>
<li>Making an Interactive Component</li>
<li>Developer Tools</li>
</ul>
<p>Nowhere on our current site do we have a highly visible explanation of what Ember is, beyond snippets. In light of this glaring omission, we have added a “What is Ember” section to the Guides Table of Contents above. It is not meant to replace the ongoing “Why Ember” and marketing-focused descriptions that are underway.</p>
<h3 id="vue"><a class="header" href="#vue">Vue</a></h3>
<p>As a fully-featured framework, Vue is an easier comparison for possible Table of Contents listings. Keep in mind that much of this type of content is present in our CLI docs instead, so this list will look longer than what we are aiming for.</p>
<ul>
<li>Introduction</li>
<li>What is Vue.js?</li>
<li>Getting Started</li>
<li>Declarative Rendering</li>
<li>Conditionals and Loops</li>
<li>Handling User Input</li>
<li>Composing with Components</li>
<li>Relation to Custom Elements</li>
<li>Ready for More?</li>
<li>The Vue Instance</li>
<li>Template Syntax</li>
<li>Computed Properties and Watchers</li>
<li>Class and Style Bindings</li>
<li>Conditional Rendering</li>
<li>List Rendering</li>
<li>Event Handling</li>
<li>Form Input Bindings</li>
<li>Components Basics</li>
<li>Components In-Depth</li>
<li>Component Registration</li>
<li>Props</li>
<li>Custom Events</li>
<li>Slots</li>
<li>Dynamic &amp; Async Components</li>
<li>Handling Edge Cases</li>
<li>Transitions &amp; Animation</li>
<li>Enter/Leave &amp; List Transitions</li>
<li>State Transitions</li>
<li>Reusability &amp; Composition</li>
<li>Mixins</li>
<li>Custom Directives</li>
<li>Render Functions &amp; JSX</li>
<li>Plugins</li>
<li>Filters</li>
<li>Tooling</li>
<li>Single File Components</li>
<li>Unit Testing</li>
<li>TypeScript Support</li>
<li>Production Deployment</li>
<li>Scaling Up</li>
<li>Routing</li>
<li>State Management</li>
<li>Server-Side Rendering</li>
<li>Internals</li>
<li>Reactivity in Depth</li>
<li>Migrating</li>
<li>Migration from Vue 1.x</li>
<li>Migration from Vue Router 0.7.x</li>
<li>Migration from Vuex 0.6.x to 1.0</li>
<li>Meta</li>
<li>Comparison with Other Frameworks</li>
<li>Join the Vue.js Community!</li>
<li>Meet the Team</li>
</ul>
<p>One possible lesson here is that we could split up Components like Vue did with Component Basics and Components In-Depth. Their dedicated section on Computed Properties inspired the inclusion in our new Table of Contents.</p>
<h3 id="angular"><a class="header" href="#angular">Angular</a></h3>
<p>Angular is also a full-featured framework that has a lot in common with Ember.</p>
<p>FUNDAMENTALS</p>
<ul>
<li>Architecture
<ul>
<li>Architecture Overview</li>
<li>Intro to Modules</li>
<li>Intro to Components</li>
<li>Intro to Services and DI</li>
<li>Next Steps</li>
</ul>
</li>
<li>Components &amp; Templates
<ul>
<li>Displaying Data</li>
<li>Template Syntax</li>
<li>User Input</li>
<li>Lifecycle Hooks</li>
<li>Component Interaction</li>
<li>Component Styles</li>
<li>Angular Elements</li>
<li>Dynamic Components</li>
<li>Attribute Directives</li>
<li>Structural Directives</li>
<li>Pipes</li>
</ul>
</li>
<li>Forms</li>
<li>Observables &amp; RxJS</li>
<li>Bootstrapping</li>
<li>NgModules</li>
<li>Dependency Injection</li>
<li>HttpClient</li>
<li>Routing &amp; Navigation</li>
<li>Animations</li>
</ul>
<p>SETUP &amp; DEPLOYMENT</p>
<ul>
<li>Project File Structure</li>
<li>Workspace Configuration</li>
<li>npm Dependencies</li>
<li>TypeScript Configuration</li>
<li>Ahead-of-Time Compilation</li>
<li>Building &amp; Serving</li>
<li>Testing</li>
<li>Deployment</li>
<li>Browser Support</li>
<li>Dev Tool Integration</li>
</ul>
<p>Angular is the closest match to our current guides structure. Notably, they work Styles in as part of their Components section.</p>
<h3 id="trends"><a class="header" href="#trends">Trends</a></h3>
<p>All three of the libraries above cover forms in their own dedicated section. They also cover styles and animation, which we do not cover at all. These are all good candidates for future guides.</p>
<h2 id="unresolved-questions-70"><a class="header" href="#unresolved-questions-70">Unresolved questions</a></h2>
<ul>
<li>What does the community think of this structure? How can it be improved?</li>
<li>Is it good for new learners? Is it good for existing users?</li>
<li>What possible pain points does the community see?</li>
<li>Are there any areas missing from the Table of Contents?</li>
<li>What do people think of removing the “Ember Object Model” section?</li>
<li>Are the goals of the Ember Data and Ember Inspector teams supported by this new layout?</li>
</ul>
<h3 id="one-last-note"><a class="header" href="#one-last-note">One last note</a></h3>
<p>The Guides are one of those things where everyone has an opinion, and that's ok! However, as a reminder, please be kind and constructive in your comments. The Guides and the tools they cover are the work of many dedicated community members. They are authored and maintained through donated effort, both by unpaid individuals and companies who encourage their teams to contribute. Although we always know there is room for improvement, we are proud of where we came from and excited for where we're going next!</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2018-12-17
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/432
Tracking: https://github.com/emberjs/rfc-tracking/issues/6</p>
<hr />
<h1 id="contextual-helpers-and-modifiers-aka-first-class-helpersmodifiers"><a class="header" href="#contextual-helpers-and-modifiers-aka-first-class-helpersmodifiers">Contextual Helpers and Modifiers (a.k.a. &quot;first-class helpers/modifiers&quot;)</a></h1>
<h2 id="summary-105"><a class="header" href="#summary-105">Summary</a></h2>
<p>We propose to extend the semantics of Handlebars helpers and modifiers such
that they can be passed around as first-class values in templates.</p>
<p>For example:</p>
<pre><code class="language-hbs">{{join-words &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; separator=&quot;,&quot;}}

{{!-- ...is functionally equivalent to... --}}

{{#let (helper &quot;join-words&quot; separator=&quot;,&quot;) as |join|}}
  {{#let (helper join &quot;foo&quot;) as |foo|}}
    {{#let (helper foo &quot;bar&quot;) as |foo-bar|}}
      {{foo-bar &quot;baz&quot;}}
    {{/let}}
  {{/let}}
{{/let}}
</code></pre>
<pre><code class="language-hbs">&lt;Submit {{on
  click=(action &quot;submit&quot;)
  mouseenter=(action &quot;highlight&quot;)
  mouseleave=(action &quot;unhighlight&quot;)
}} /&gt;

{{!-- ...is functionally equivalent to... --}}

{{#let (modifier &quot;on&quot;) as |on|}}
  {{#let (modifier on click=(action &quot;submit&quot;)) as |on-click|}}
    {{#let (modifier on-click mouseenter=(action &quot;highlight&quot;)) as |on-click-enter|}}
      {{#let (modifier on-click-enter mouseleave=(action &quot;unhighlight&quot;)) as |on-click-enter-leave|}}
        &lt;Submit {{on-click-enter-leave}} /&gt;
      {{/let}}
    {{/let}}
  {{/let}}
{{/let}}
</code></pre>
<h2 id="motivation-106"><a class="header" href="#motivation-106">Motivation</a></h2>
<p><a href="https://github.com/emberjs/rfcs/pull/64">RFC #64</a> introduced a feature known
as &quot;contextual components&quot;, which allowed components to be passed around as
first-class values. While this is a somewhat advanced feature, it allowed addon
authors to encapsulate internal state and logic, which in turns, allowed them
to create easy-to-use and easy-to-understand DSL-like APIs that could benefit
users of all level.</p>
<p>For example, the original RFC used form controls as a motivating example.
Without contextual components, an addon that provides form-building components
might have to expose an API like this:</p>
<pre><code class="language-hbs">&lt;SuperForm @model={{this.post}} as |f|&gt;
  &lt;SuperInput @model={{this.post}} @name=&quot;title&quot; /&gt;
  &lt;SuperTextarea @model={{this.post}} @name=&quot;body&quot; /&gt;
  &lt;SuperSubmit @form={{f}} /&gt;
&lt;/SuperForm&gt;
</code></pre>
<p>As you can see, this is far from ideal for several reasons. First, to avoid
collision, the addon author had to prefix all the components. Second, the
<code>@model</code> argument has to be passed to all the controls that needs it. Finally,
in cases where the components need to communicate with each other (the form and
the submit button in the example), they would have to expose some internal state
(the <code>|f|</code> block param) that the user would have to manually thread through. Not
only does this make the API very verbose, it also breaks encapsulation.</p>
<p>Instead, the contextual components feature allows the addon author to expose an
API like this:</p>
<pre><code class="language-hbs">&lt;SuperForm @model={{this.post}} as |f|&gt;
  &lt;f.Input @name=&quot;title&quot; /&gt;
  &lt;f.Textarea @name=&quot;body&quot; /&gt;
  &lt;f.Submit /&gt;
&lt;/SuperForm&gt;
</code></pre>
<p>Behind the scene, the <code>&lt;SuperForm&gt;</code> component's template would look something
like this:</p>
<pre><code class="language-hbs">&lt;form ...&gt;
  {{yield (hash
    Input=(component &quot;super-input&quot; form=this model=this.model)
    Textarea=(component &quot;super-textarea&quot; form=this model=this.model)
    Submit=(component &quot;super-submit&quot; form=this model=this.model)
  )}}
&lt;/form&gt;
</code></pre>
<p>Here, the <code>component</code> helper looked up the components by name (first argument)
and packaged up (&quot;curried&quot;) any additional arguments (<code>form=this</code>) into an
internal object (known as a &quot;component definition&quot; in the Glimmer VM). This
object can then be passed around like any other values and invoked at a later
time.</p>
<p>(Typically, a number of them are passed to the <code>hash</code> helper to &quot;bundle&quot; them
into a single object, but this is not required.)</p>
<p>While this is indeed a pretty advanced feature, the users of <code>SuperForm</code> do not
need to be aware of these implementation details in order to use the addon.
This had proved to be a very useful and powerful feature and enabled a number
of popular addons, such as
<a href="https://ember-learn.github.io/ember-cli-addon-docs/">ember-cli-addon-docs</a>,
<a href="https://www.ember-bootstrap.com">ember-bootstrap</a>,
<a href="https://opensource.addepar.com/ember-table/">ember-table</a>,
<a href="https://miguelcobain.github.io/ember-paper/">ember-paper</a>,
<a href="https://ember-power-calendar.com">ember-power-calendar</a>,
<a href="http://khorus.github.io/ember-accordion/">ember-accordion</a>,
<a href="https://emberx-select.netlify.com/">emberx-select</a>,
<a href="https://offirgolan.github.io/ember-light-table/">ember-light-table</a>.</p>
<p>The original RFC left an important question unanswered – <a href="https://github.com/emberjs/rfcs/blob/master/text/0064-contextual-component-lookup.md#unresolved-questions">should this feature
be available for helpers, too?</a></p>
<p>In this RFC, we argue – yes, this feature will be just as useful for helpers as
well as modifiers.</p>
<p>For example, the <code>SuperForm</code> addon API can be expanded to include some extra
helpers and modifiers, like so:</p>
<pre><code class="language-hbs">&lt;SuperForm @model={{this.post}} as |f|&gt;
  &lt;f.Input @name=&quot;title&quot; /&gt;

  {{!-- f.is-valid and f.error-for are contextual helpers --}}
  {{#unless (f.is-valid &quot;title&quot;)}}
    &lt;div class=&quot;error&quot;&gt;This field {{f.error-for &quot;title&quot;}}&lt;/div&gt;
  {{/unless}}

  {{!-- f.auto-resize is a contextual modifier --}}
  &lt;f.Textarea @name=&quot;body&quot; {{f.auto-resize maxHeight=&quot;500&quot;}} /&gt;

  &lt;f.Submit /&gt;
&lt;/SuperForm&gt;
</code></pre>
<p>For reference, the <code>&lt;SuperForm&gt;</code> component's template would look something like
this:</p>
<pre><code class="language-hbs">&lt;form ...&gt;
  {{yield (hash
    is-valid=(helper &quot;super-is-valid&quot; form=this model=this.model)
    error-for=(helper &quot;super-error-for&quot; form=this model=this.model)
    auto-resize=(modifier &quot;super-auto-resize&quot;)
    ...
  )}}
&lt;/form&gt;
</code></pre>
<p>This RFC proposes a complete design for enabling this capability.</p>
<h2 id="detailed-design-89"><a class="header" href="#detailed-design-89">Detailed design</a></h2>
<h3 id="the-helper-and-modifier-helpers"><a class="header" href="#the-helper-and-modifier-helpers">The <code>helper</code> and <code>modifier</code> helpers</a></h3>
<p>This RFC introduces two new helpers named <code>helper</code> and <code>modifier</code>, which work
similarly to the <code>component</code> helper:</p>
<ul>
<li>
<p>When passed a string (e.g. <code>(helper &quot;foo&quot;)</code>) as the first argument, it will
produce an opaque, internal &quot;helper definition&quot; or &quot;modifier definition&quot;
object that can be passed around and invoked elsewhere.</p>
</li>
<li>
<p>Any additional positional and/or named arguments (a.k.a. params and hash)
will be stored (&quot;curried&quot;) inside the definition object, such that, when
invoked, these arguments will be passed along to the referenced helper or
modifier.</p>
</li>
</ul>
<p>Some additional details:</p>
<ul>
<li>
<p>When the first argument passed to the <code>helper</code> or <code>modifier</code> helper is
<code>null</code>, <code>undefined</code> or an empty string, it will produce a no-op definition
object. In the case of the <code>helper</code> helper, this will produce <code>undefined</code>
when invoked, regardless of the arguments that are passed to the invocation.
In the case of the <code>modifier</code> helper, it will not perform any operations on
the target element.</p>
</li>
<li>
<p>When the first argument passed to the <code>helper</code> or <code>modifier</code> helper is a
string, it will be used to resolve a helper or modifier (respectively) with
the same name. If the resolution failed, it will result in a runtime error.
However, the timing of this lookup is unspecified. <code>(helper &quot;not-a-helper&quot;)</code>
may result in an immediate error, or it may happen when it is later passed
into the <code>helper</code> helper a second time, or it may happen when it is invoked.
If it is never invoked, the error may not be reported at all. This timing may
change between releases and should not be relied upon.</p>
</li>
<li>
<p>Some built-in helpers or modifiers may not be resolvable with the <code>helper</code>
and <code>modifier</code> helpers. For example, <code>(helper &quot;debugger&quot;)</code> and
<code>(helper &quot;yield&quot;)</code> will not work, as they are considered <em>keywords</em>. For
implementation simplicity, we propose to forbid resolving built-in helpers,
components and modifiers this way across the board (i.e. a runtime error).
We acknowledge that there are good use cases for this feature such as
currying the <code>array</code> and <code>hash</code> helpers, and will consider enabling them in
the future on a case-by-case basis.</p>
</li>
<li>
<p>Similarly, contextual helpers cannot be named after certain keywords. For
example, <code>{{#let ... as |yield|}} {{yield}} {{/let}}</code> will not work. We
propose to turn these cases into syntax errors.</p>
</li>
<li>
<p>A contextual helper or modifier can be further &quot;curried&quot; by passing them back
into the <code>helper</code> or <code>modifier</code> helper again, as shown in the example in the
<a href="0432-contextual-helpers.html#Summary">summary</a> section. This will produce a new definition object.</p>
</li>
<li>
<p>When the first argument passed to the <code>helper</code> or <code>modifier</code> helper is a
bound value, a new definition object will be produced whenever the value
changes. This will <em>invalidate</em> all downstream invocations. If the previous
value is a <a href="https://emberjs.com/api/ember/3.7/functions/@ember%2Fcomponent%2Fhelper/helper">simple helper</a>,
this has no observable effect and Ember will simply invoke the new helper
value. If the previous value is a <a href="https://emberjs.com/api/ember/3.7/classes/Helper">class-based helper</a>,
or a modifier, the existing instance will be destroyed before the new value
is invoked. On the other hand, if only the curried arguments has changed, the
helper or modifier instances (if any) will remain.</p>
</li>
<li>
<p>An important implication of the teardown semantics is that it is possible for
a modifier to be destroyed while its target element lives on for much longer.
Therefore, it is important to actually teardown any event listeners and
cleanup any associated states in the <code>destroyModifier</code> hook.</p>
</li>
<li>
<p>Positional arguments are &quot;curried&quot; the same way as the <code>component</code> helper.
This matches the behavior of <code>Function.prototype.bind</code>.</p>
<pre><code class="language-hbs">{{#let (helper &quot;join-words&quot; separator=&quot;,&quot;) as |join|}}
  {{join &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;}} {{!-- &quot;foo,bar,baz&quot; --}}

  {{#let (helper join &quot;foo&quot;) as |foo|}}
    {{foo &quot;bar&quot; &quot;baz&quot;}} {{!-- &quot;foo,bar,baz&quot; --}}

    {{#let (helper foo &quot;bar&quot;) as |foo-bar|}}
      {{foo-bar &quot;baz&quot;}} {{!-- &quot;foo,bar,baz&quot; --}}
    {{/let}}

  {{/let}}

{{/let}}
</code></pre>
</li>
<li>
<p>Named arguments are curried the same way as the <code>component</code> helper.
This matches the &quot;last-write-wins&quot; behavior of <code>Object.assign</code>.</p>
<pre><code class="language-hbs">{{#let (helper &quot;join-words&quot; &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;) as |join|}}
  {{join separator=&quot;,&quot;}} {{!-- foo,bar,baz --}}

  {{#let (helper join separator=&quot;,&quot;) as |comma|}}
    {{comma separator=&quot; &quot;}} {{!-- foo bar baz --}}

    {{#let (helper comma separator=&quot; &quot;) as |space|}}
      {{space separator=&quot;-&quot;}} {{!-- foo-bar-baz --}}
    {{/let}}

  {{/let}}

{{/let}}
</code></pre>
</li>
<li>
<p>When a definition object is passed into JavaScipt (e.g. as an argument to a
JavaScript helper), the resulting value is unspecified (hence &quot;opaque&quot;). In
particular, for helpers, it is <em>not</em> guarenteed that it will be an invokable
JavaScript function. The only guarentee provided is that, when passed back
into Handlebars it will be an invokable value. Hanging onto a definition
object in JavaScript may result in unexpected memory leaks, as these objects
may close over arbitrary template states.</p>
</li>
</ul>
<h3 id="invoking-contextual-helpers"><a class="header" href="#invoking-contextual-helpers">Invoking contextual helpers</a></h3>
<p>Invoking a contextual helper is no different from invoking any other helpers:</p>
<pre><code class="language-hbs">{{#let (helper &quot;join-words&quot; &quot;foo&quot; &quot;bar&quot; separator=&quot; &quot;) as |foo-bar|}}

  {{!-- content position --}}

  {{foo-bar}}

  {{foo-bar &quot;baz&quot;}}

  {{foo-bar separator=&quot;,&quot;}}

  {{!-- not necessary, but works --}}

  {{helper foo-bar}}

  {{helper foo-bar &quot;baz&quot;}}

  {{helper foo-bar separator=&quot;,&quot;}}

  {{!-- attribute position --}}

  &lt;div class={{foo-bar}}&gt;...&lt;/div&gt;

  &lt;div class={{foo-bar &quot;baz&quot;}}&gt;...&lt;/div&gt;

  &lt;div class={{foo-bar separator=&quot;,&quot;}}&gt;...&lt;/div&gt;

  {{!-- not necessary, but works --}}

  &lt;div class={{helper foo-bar}}&gt;...&lt;/div&gt;

  &lt;div class={{helper foo-bar &quot;baz&quot;}}&gt;...&lt;/div&gt;

  &lt;div class={{helper foo-bar separator=&quot;,&quot;}}&gt;...&lt;/div&gt;

  {{!-- curly invocation, argument position --}}

  {{my-component value=(foo-bar)}}

  {{my-component value=(foo-bar &quot;baz&quot;)}}

  {{my-component value=(foo-bar separator=&quot;,&quot;)}}

  {{!-- these will pass the helper itself into the component, instead of invoking it now --}}

  {{my-component helper=foo-bar}}

  {{my-component helper=(helper foo-bar)}}

  {{my-component helper=(helper foo-bar &quot;baz&quot;)}}

  {{my-component helper=(helper foo-bar separator=&quot;,&quot;)}}

  {{!-- angle bracket invokation, argument position --}}

  &lt;MyComponent @value={{(foo-bar)}} /&gt;

  &lt;MyComponent @value={{foo-bar &quot;baz&quot;}} /&gt;

  &lt;MyComponent @value={{foo-bar separator=&quot;,&quot;}} /&gt;

  {{!-- these will pass the helper itself into the component, instead of invoking it now --}}

  &lt;MyComponent @helper={{foo-bar}} /&gt;

  &lt;MyComponent @helper={{helper foo-bar}} /&gt;

  &lt;MyComponent @helper={{helper foo-bar &quot;baz&quot;}} /&gt;

  &lt;MyComponent @value={{helper foo-bar separator=&quot;,&quot;}} /&gt;

  {{!-- sub-expression positions --}}

  {{yield (foo-bar)}}

  {{yield (foo-bar &quot;baz&quot;)}}

  {{yield (foo-bar separator=&quot;,&quot;)}}

  {{!-- these will yield the helper itself (&quot;contextual helper&quot;), instead of invoking it now --}}

  {{yield foo-bar}}

  {{yield (helper foo-bar)}}

  {{yield (helper foo-bar &quot;baz&quot;)}}

  {{yield (helper foo-bar separator=&quot;,&quot;)}}

  {{!-- deeply nested sub-expression --}}

  {{#if (eq (concat &quot;&gt;&gt;&gt; &quot; (foo-bar &quot;baz&quot;) &quot; &lt;&lt;&lt;&quot;) &quot;&gt;&gt;&gt; foo bar baz &lt;&lt;&lt;&quot;)}}
    This is true.
  {{/if}}

  {{!-- runtime error: not a component --}}
  &lt;foo-bar /&gt;

  {{!-- runtime error: not a modifier --}}
  &lt;div {{foo-bar}}&gt;
{{/let}}
</code></pre>
<h3 id="invoking-contextual-modifiers"><a class="header" href="#invoking-contextual-modifiers">Invoking contextual modifiers</a></h3>
<p>Invoking a contextual helper is no different from invoking any other modifiers:</p>
<pre><code class="language-hbs">{{#let (modifier &quot;on&quot; click=(action &quot;submit&quot;)) as |on-click|}}

  {{!-- HTML elements --}}

  &lt;button {{on-click}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{on-click &quot;extra&quot; &quot;args&quot;}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}}&gt;
    Click Me!!
  &lt;/button&gt;

  {{!-- not necessary, but works --}}

  &lt;button {{modifier on-click}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{modifier on-click &quot;extra&quot; &quot;args&quot;}}&gt;Click Me!!&lt;/button&gt;

  &lt;button {{modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}}&gt;
    Click Me!!
  &lt;/button&gt;

  {{!-- components --}}

  &lt;MyComponent {{on-click}} /&gt;

  &lt;MyComponent {{on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;MyComponent {{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{!-- not necessary, but works --}}

  &lt;MyComponent {{modifier on-click}} /&gt;

  &lt;MyComponent {{modifier on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;MyComponent {{modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{!-- these will pass the modifier itself into the component, instead of invoking it now --}}

  &lt;MyComponent @modifier={{on-click}} /&gt;

  &lt;MyComponent @modifier={{modifier on-click}} /&gt;

  &lt;MyComponent @modifier={{modifier on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;MyComponent @modifier={{modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{my-component modifier=on-click}}

  {{my-component modifier=(modifier on-click)}}

  {{my-component modifier=(modifier on-click &quot;extra&quot; &quot;args&quot;)}}

  {{my-component modifier=(modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;))}}

  {{!-- these will yield the modifier itself (&quot;contextual modifier&quot;), instead of invoking it now --}}

  {{yield on-click}}

  {{yield (modifier on-click)}}

  {{yield (modifier on-click &quot;extra&quot; &quot;args&quot;)}}

  {{yield (modifier on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;))}}

  {{!-- runtime error: cannot invoke a modifier as a helper --}}

  {{yield (on-click)}}

  {{yield (on-click &quot;extra&quot; &quot;args&quot;)}}

  {{yield (on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;))}}

  {{!-- runtime error: cannot append a modifier --}}

  {{on-click}}

  {{on-click &quot;extra&quot; &quot;args&quot;}}

  {{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}}

  {{!-- runtime error: cannot set an attribute to a modifier --}}

  &lt;div class={{on-click}} /&gt;

  &lt;div class={{on-click &quot;extra&quot; &quot;args&quot;}} /&gt;

  &lt;div class={{on-click mouseenter=(action &quot;highlight&quot;) mouseleave=(action &quot;unhighlight&quot;)}} /&gt;

  {{!-- runtime error: not a component --}}
  &lt;on-click /&gt;
{{/let}}
</code></pre>
<h3 id="relationship-with-globals"><a class="header" href="#relationship-with-globals">Relationship with globals</a></h3>
<p>Today, Ember apps rely heavily on the global namespace as the main mechanism of
making components, helpers and modifiers available. Ideally, in a world where
&quot;everything is a value&quot;, the global and local namespace should behave the same
way. Global components, helpers and modifiers should just be global variables
that are implicitly defined around every templates in the app.</p>
<p>In other words, it is as if every template has the following hidden &quot;prelude&quot;
around its content:</p>
<pre><code class="language-hbs">{{!-- prelude --}}
{{#let (component &quot;input&quot;) as |input|}}
  {{#let (helper &quot;concat&quot;) as |concat|}}
    {{#let (modifier &quot;action&quot;) as |action|}}
      {{!-- ...other global components, helpers and modifiers omitted... --}}

      {{!-- begin template content --}}
      Your name:
      {{concat this.firstName &quot; &quot; this.lastName}}

      Change it:
      {{input value=this.firstName}}
      {{input value=this.lastName}}

      &lt;button {{action &quot;submit&quot;}}&gt;&lt;/button&gt;
      {{!-- end tempalte content ---}}
    {{/let}}
  {{/let}}
{{/let}}
</code></pre>
<p>While this largely matches how things work today, there are a few notable
differences where globals behave &quot;unexpectedly&quot; in this world.</p>
<p>First of all, it is not possible to reference a component, helper or modifier
in templates without invoking them today:</p>
<pre><code class="language-hbs">{{!-- if `join-words` is a global helper, this works as expected --}}
{{!-- this invokes the helper and yield the result --}}

{{yield (join-words &quot;foo&quot; &quot;bar&quot; separator=&quot;,&quot;)}}
         ~~~~~~~~~~

{{!-- however, in this position, Ember does not &quot;see&quot; the helper --}}
{{!-- this falls back to looking up the `join-words` property on `this` --}}

{{yield join-words}}
        ~~~~~~~~~~

{{!-- as opposed to a &quot;true&quot; variable/value binding... --}}
{{!-- this yields the helper as a value, as expected --}}

{{#let (helper &quot;join-words&quot;) as |join-words|}}
  {{yield join-words}}
          ~~~~~~~~~~
{{/let}}
</code></pre>
<p>In the long term, we propose to unify the semantics such that globals will
behave exactly like local bindings (i.e. we should make this second case work).</p>
<p>However, is not possible in the short term. This is due to the ambiguity
between referencing a global variable and the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0308-deprecate-property-lookup-fallback.md">property lookup fallback</a>
feature. We propose we simply wait until the property lookup fallback is fully
deprecated and removed, at which point we can reclaim the syntax.</p>
<p>In the mean time, globals can be referenced explicitly using the <code>component</code>,
<code>helper</code>, and <code>modifier</code> helpers.</p>
<p>Another difference is how global helpers can be invoked without arguments in
named arguments position for angle bracket invocations:</p>
<pre><code class="language-hbs">{{!-- if `pi` is a global helper that returns the value of the constant 𝛑 --}}
{{!-- this invokes the helper and passes the value 3.1415... --}}
&lt;MyComponent @value={{pi}} /&gt;
                      ~~

{{!-- as opposed to a &quot;true&quot; variable/value binding... --}}

{{#let (helper &quot;pi&quot;) as |pi|}}
  {{!-- this passes the helper into the component --}}
  &lt;MyComponent @value={{pi}} /&gt;
                        ~~

  {{!-- this invokes the helper and passes the value 3.1415... --}}
  &lt;MyComponent @value={{(pi)}} /&gt;
                        ~~~~
{{/let}}
</code></pre>
<p>Notably, this problem only exists in the named arguments position and only in
angle bracket invocations. For content and attribute positions, it would not
make sense to pass a helper &quot;by value&quot;, so the ambiguity does not exist (so it
always invokes). For sub-expression positions (which includes argument
positions for curly invocations), the parentheses are already mandatory
(otherwise it invokes the property fallback).</p>
<p>We propose to deprecate auto-invoking global helpers with no arguments in named
argument positions for angle bracket invocations and require the parentheses
instead. This will make room for unifying the global semantics in the future.</p>
<p>It is also worth pointing out that, since helpers tend to be pure, helpers
that take no arguments are exceedingly rare.</p>
<p>Finally, the last challenge to the unification is it is entirely possible to
have any combinations of components, helpers and modifiers all with the same
name today. This works, as they currently live in different &quot;namespaces&quot;, and
each lookup is contextually scoped to their respective &quot;namespace&quot; depending on
the position where it is invoked:</p>
<pre><code class="language-hbs">{{!-- foo-bar, the modifier here --}}
&lt;div {{foo-bar}} /&gt;
       ~~~~~~~

{{!-- foo-bar, the helper here --}}
&lt;div class={{foo-bar}} /&gt;
             ~~~~~~~

{{!-- foo-bar, the helper here --}}
{{#let (foo-bar) as |result|}}
        ~~~~~~~
{{/let}}

{{!-- foo-bar, the component here --}}
{{#foo-bar}}...{{/foo-bar}}
   ~~~~~~~        ~~~~~~~

{{!-- prefers foo-bar, the component here --}}
{{!-- if not found, then foo-bar, the helper --}}
{{foo-bar}}
  ~~~~~~~
</code></pre>
<p>Since this could get pretty confusing, most developers already avoid giving
these unrelated the same names. However, it is certainly possible that they
may happen by accident and go unnoticed (e.g. an addon introducing a global
helper that &quot;conflicts&quot; with a component in the app).</p>
<p>These kind of naming conflicts would not make sense in the value-based world.
Imagine if this is how JavaScript works:</p>
<pre><code class="language-js">class FooBar {}

function FooBar() {}

const FooBar = 1;

class FooBarBaz extends FooBar {}
//                      ~~~~~~ FooBar, the class here

console.log(FooBar());
//          ~~~~~~ FooBar, the function here

console.log(FooBar + 1);
//          ~~~~~~ FooBar, the constant here

someObj.FooBar = FooBar;
//               ~~~~~~ well, which one is this?
</code></pre>
<p>Clearly, this would be unacceptable and is similar to the situation we find
ourselves in here.</p>
<p>We propose to issue deprecation warnings whenever we detect these conflicts,
both at build time and at invocation time, while maintaining the same lookup
precedence for the time being. For example, when invoking a component in the
content position, if we see that there is also a helper with the same name, it
should result in a deprecation asking the developer to remain one or the other.</p>
<p>Notably, there is such a conflict in Ember today where <code>action</code> is both a
helper and a modifier. Instead of deprecating one of them, we propose to use an
internal mechanism to produce a single special value such that it will be
invokable as either a modifier or a helper context. This is different than
&quot;namespace&quot; semantics in that there is only one context-independent value in this
special case, i.e. <code>(helper &quot;action&quot;) === (modifier &quot;action&quot;)</code>.</p>
<p>We also acknowledge that, so long as there are <em>implicit</em> globals, we may never
be able to truly unify global bindings with local ones, as implicit global
bindings have a high risk of conflicting with HTML elements. Consider the
built-in <code>input</code> helper, or an in-app <code>main</code> helper. If these were implicitly
turned into global identifiers, they would conflict with the HTML elements with
the same name:</p>
<pre><code class="language-hbs">&lt;input type=&quot;text&quot;&gt;
 ~~~~~ now refers to the global `input` identifier?

&lt;main&gt;...&lt;/main&gt;
 ~~~~ now refers to the global `main` identifier?
</code></pre>
<p>While the problem exists for local bindings also, it was already addressed in
<a href="https://github.com/emberjs/rfcs/pull/311">RFC #311</a>. With local bindings, this
problem is fairly noticible and understandable since the conflict is introduced
nearby. The solution is also fairly simple – just rename the local variable to
avoid the conflict. With proper linting, this could be quite easily avoided
altogether.</p>
<p>With <em>implicit</em> global bindings, this problem is much more difficult to spot
and reason about. There is also no quick way out, other than to rename the
global component, helper or modifer which could be difficult or not an option
at all for addon authors trying to maintain compatibility. To truly resolve
this conflict, we would have to eliminate implicit globals, which is out of
scope for this RFC. This also wouldn't be a problem until all the proposed
deprecations are implemented and removed, which would be quite some time.</p>
<p>We <em>speculate</em> that when all the of that is said and done, we would have an
alternative resolution mechanism (&quot;template imports&quot;) that does not have this
problem. Alternatively, we could exclude the angle bracket invocation position
from being able to &quot;see&quot; implicit global identifiers.</p>
<h3 id="local-helpers-and-modifiers"><a class="header" href="#local-helpers-and-modifiers">Local helpers and modifiers</a></h3>
<p>A nice fallout of this plan is that developers will be able to define helpers
and modifiers specific to a component locally in the same JavaScript file:</p>
<pre><code class="language-js">// app/components/date-picker.js

import Component from '@ember/component';
import { helper } from '@ember/component/helper';

export default Component.extend({
  date: null, // passed in

  'format-date': helper(function(params, hash) {
    /* ... */
  })
});
</code></pre>
<pre><code class="language-hbs">{{!-- app/templates/components/date-picker.hbs --}}
{{this.format-date this.date}}
</code></pre>
<p>In additional to encapsulation and namespacing, this will also enable even more
advanced use cases that uses the component's state:</p>
<pre><code class="language-js">// app/components/filtered-each.js

import Component from '@ember/component';
import { helper } from '@ember/component/helper';
import { computed } from '@ember/object';

export default Component.extend({
  list: null, // passed in
  callback: null, // passed in

  filter: computed('callback', function() {
    return helper(params =&gt; this.callback(params[0]));
  });
});
</code></pre>
<pre><code class="language-hbs">{{!-- app/templates/components/filtered-each.hbs --}}

{{#each this.list as |item|}}
  {{#if (this.filter item)}}
    {{yield item}}
  {{/if}}
{{/each}}
</code></pre>
<p>This feature would work with element modifiers as well.</p>
<p>Ideally, this should also work with components. However, currently there are
two pieces to a component – a template and a JavaScript class, either could be
optional. This poses a challenge to invoking components this way – without
going through the component helper, there is no easy way to import or package
a component into a single value. This is a solvable problem, but to design a
solution for that would be out of scope for this RFC. For the time being, the
only way to get a handle of a &quot;component defition value&quot; would be through the
component helper. Attempting to &quot;invoke&quot; just the component template or class
this way will result in a runtime error.</p>
<h2 id="how-we-teach-this-76"><a class="header" href="#how-we-teach-this-76">How we teach this</a></h2>
<p>There are two sides to this feature – the consumption side and the authoring
side.</p>
<p>The consumption side refers to learning how the contextual helper and modifier
values can be used (invoked). We expect developers to enounter this mainly
through addons that others have written. So long as there is adequate
documentation from the addon authors, we expect that this group of users can be
immediately productive by simply treating these APIs as DSLs, similar to the
Router DSL.</p>
<p>In other words, while this group of developer may not immediately understand
how to <em>author</em> these kind of APIs, or what is involved under-the-hood to make
it work, the design goal is that it should feel straightforward to <em>consume</em>
this style of API.</p>
<p>The authoring side refers to using the <code>helper</code> and <code>modifier</code> helpers, and
more importantly, the advanced composition patterns that motivated their
existence in the first place As with the <code>component</code> helper and other
&quot;higher-order functions&quot; in JavaScript, this is a somewhat advanced topic that
is mainly targeted at addon authors and advanced developers.</p>
<p>For this group of users, we expect this feature to complement and complete the
&quot;contextual components&quot; feature. Developers who are already familiar with that
feature should feel right at home. We expect to be able to introduce this new
feature at the point where we currently teach contextual components today.</p>
<p>In the long term, the unifications proposed in this RFC should make these
concepts easier to teach for this group of developers, as components, helpers
and modifiers, whether global or contextual, will all behave uniformly. The
value-based semantics also better matches JavaScript which they are probably
already familiar with.</p>
<p>The official documentations should be updated to include this feature:</p>
<ul>
<li>
<p>The new <code>helper</code> and <code>modifier</code> helpers need be be added to the API docs.
We should consider cross-linking between the <code>helper</code>, <code>modifier</code> and
<code>component</code> helpers since they solve a similar problem.</p>
</li>
<li>
<p>The guide should be updated to teach this feature as well. We recommend
teaching the two sides of the feature separately, and prioritize the
consumption side, as that is what beginners are likely to encounter first.</p>
<p>For example, when teaching component invocations, there can be a section that
mentions:</p>
<blockquote>
<p>Sometimes, components may be yielded to you as a block param. These are
called contextual components, and they can be invoked just like any other
components you have encountered so far.</p>
<p>...examples...</p>
<p>To learn how to do this yourself, skip ahead to the &quot;Composition Patterns&quot;
section (link).</p>
</blockquote>
</li>
<li>
<p>For the authoring side, we recommend teaching the helper, modifier and
component version of the feature in a single place (such as a &quot;Composition
Patterns&quot; section), cross-linked from their respective sections, rather than
repeating it three times.</p>
</li>
</ul>
<h2 id="drawbacks-101"><a class="header" href="#drawbacks-101">Drawbacks</a></h2>
<p>This RFC introduces another feature that developers may encounter and have to
learn when consuming addons. However, on the whole, we think this will simplify
things more than adding to the concepts – as it ultimiately try to unify the
behavior of components, helpers and modifiers (and in the future, globals).
This should make things feel more consistent and allow developers to apply
their knowledge consistently across the board.</p>
<p>In the short term, this feature may amplify some of the mismatches and causes
confusions where the legacy semantics does not perfectly match the new world we
are building. This could be mitigated with helpful deprecation messages.</p>
<h2 id="alternatives-103"><a class="header" href="#alternatives-103">Alternatives</a></h2>
<p><a href="https://github.com/emberjs/rfcs/pull/208">RFC #208</a> has previously explored
the same design space. It solves the same fundamental problems, but proposes
two seperate helpers resolution/currying and invocation. This is largely due to
limitations and ambiguities in Handlebars. This RFC attempts to remove the need
of a separate invocation helper by resolving the ambiguities and integrating
more tightly with Handlebars. If accepted, this RFC will supersede the design
proposed in RFC #208.</p>
<p>As proposed, this RFC relies heavily on context-dependent syntatic positions to
disambiguate between component, helper and modifier invocations. For example,
while they may look similar, the following syntax does not produce the same
result:</p>
<pre><code class="language-hbs">{{foo-bar baz=&quot;bat&quot;}}

{{(foo-bar baz=&quot;bar&quot;)}}
</code></pre>
<p>If <code>foo-bar</code> is a helper, either would work. However, if <code>foo-bar</code> is a
component, only the first form would work and the second form would result in
a runtime error (trying to invoke a component as helper).</p>
<p>A different design has been considered where the first form is just strictly a
syntactic sugar for the latter and <code>(...)</code> invocation is one true primitive
that ties everything together.</p>
<p>Specifically, when &quot;invoked&quot; with <code>(...)</code>, a component or modifier simply
produces a value, which is a definition object with the curried arguments, i.e.
<code>(...)</code> is a syntatic surgar for currying using the <code>helper</code> and <code>modifier</code>
helpers. The <code>{{...}}</code> syntax then simply &quot;append&quot; the curried definition
object by first invoking it.</p>
<p>This design turned out to add more complexities and confusions than the
unification has brought to the table, and so that design was abandoned in favor
of what is proposed here.</p>
<p>Another alternative is to keep the global namespace separate from the local
namespace, thus avoiding the need for most deprecations. In practice, we
believe this would result in much more confusion when things do not behave the
way you would expect, but only in some niche corner cases.</p>
<h2 id="unresolved-questions-71"><a class="header" href="#unresolved-questions-71">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-01-18
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/435
Tracking: https://github.com/emberjs/rfc-tracking/issues/9</p>
<hr />
<h1 id="forwarding-element-modifiers-with-splattributes"><a class="header" href="#forwarding-element-modifiers-with-splattributes">Forwarding Element Modifiers with &quot;Splattributes&quot;</a></h1>
<h2 id="summary-106"><a class="header" href="#summary-106">Summary</a></h2>
<p>This is a small amendment to
<a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html">RFC #311 &quot;Angle Bracket Invocation&quot;</a>
and <a href="https://emberjs.github.io/rfcs/0373-Element-Modifier-Managers.html">RFC #373 &quot;Element Modifier Manager&quot;</a>
to clarify how the &quot;splattributes&quot; feature interact with element modifiers.</p>
<h2 id="motivation-107"><a class="header" href="#motivation-107">Motivation</a></h2>
<p>RFC #311 introduced the angle bracket component invocation feature. Aside from
the syntatic differences, the angle bracket invocation syntax enabled passing
HTML attributes to components, which can then be applied the underlying HTML
element(s) in the component's layout using the <code>...attributes</code> &quot;splattributes&quot;
syntax.</p>
<p>For example, given the following invocation:</p>
<pre><code class="language-hbs">&lt;FooBar class=&quot;foo-bar&quot; /&gt;
</code></pre>
<p>...and the following layout for the <code>FooBar</code> component:</p>
<pre><code class="language-hbs">&lt;div ...attributes&gt;foo bar!&lt;/div&gt;
</code></pre>
<p>Ember will render the following HTML content:</p>
<pre><code class="language-html">&lt;div class=&quot;foo-bar&quot;&gt;foo bar!&lt;/div&gt;
</code></pre>
<p>See the <a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html#html-attributes">HTML Attributes section</a>
of RFC #311 for more information on this feature.</p>
<p>On the other hand, RFC #373 introduced the element modifier manager feature.
This enabled Ember developers to define custom element modifiers, similar to
the built-in <code>{{action}}</code> modifier that ships with Ember.</p>
<p>This feature can be quite useful for encapsulating, among other things, DOM
event handling and accessibility concerns. For example:</p>
<pre><code class="language-hbs">&lt;a {{on click=(action this.onClick)}} {{act-as &quot;button&quot;}}&gt;Click Me!&lt;/a&gt;
</code></pre>
<p>While these features are both very useful on their own, they can be combined
to enable powerful abstraction and composition patterns. Unfortunately, the
two RFCs did not explicitly describe how these features would interact with
each other. This RFC proposes three admenments to clarify their relationship:</p>
<ol>
<li>
<p>It is legal to apply modifiers to angle bracket component invocations, i.e.</p>
<pre><code class="language-hbs">{{!-- this is legal --}}
&lt;MyButton {{action this.onClick}}&gt;Click Me!&lt;/MyButton&gt;
</code></pre>
</li>
<li>
<p>Element modifiers can be applied to the underlying HTML element(s), along
with any HTML attributes, using the splattributes syntax.</p>
<pre><code class="language-hbs">{{!-- this apply any modifiers in addition to HTML attributes --}}
&lt;a ...attributes&gt;{{yield}}&lt;/a&gt;
</code></pre>
</li>
<li>
<p>In addition, the splattributes syntax can be used to forward HTML attributes
and element modifiers to subsequent angle bracket component invocations.</p>
<pre><code class="language-hbs">{{!-- this is also legal, does the same as the above --}}
&lt;InternalButton ...attributes&gt;{{yield}}&lt;/InternalButton&gt;
</code></pre>
</li>
</ol>
<p>This allows the end-users to retain some control over DOM event handling and
other HTML concerns (such as CSS and ARIA roles/accessibility concerns) when
invoking components.</p>
<p>Fundamentally, element modifiers simply enable more fine-grained customization
of an HTML element, on top of what one could accomplish with HTML attributes.
If it is possible to configure the <code>class</code> and <code>aria-role</code> attributes of a
component's HTML element, it should also be possible to extract them into a
custom element modifier.</p>
<p>It is also adventageous to allow modifiers like <code>action</code> to work consistently,
whether the invocation happens to be an HTML element or a component. This allow
features like the <a href="https://github.com/emberjs/rfcs/pull/389">element helper</a> to
compose better.</p>
<p>For these reasons, we believe it is important and consistent to allow these
interactions.</p>
<h2 id="detailed-design-90"><a class="header" href="#detailed-design-90">Detailed design</a></h2>
<p>From Glimmer VM's perspective, the foundation for these features are already
in-place. Specifically, when applied on an angle bracket invocation, HTML
attributes and element modifiers are collected into an internal block, and the
splattributes syntax simply yields back to that block. Similarly, when applying
the splattributes to another angle bracket invocation, it simply fowards the
block recurrsively. This feature is only currently gated by a precautionary
&quot;compile time error&quot; which can be easily removed once this RFC is accepted.</p>
<p>As laid out in the <a href="https://github.com/emberjs/rfcs/pull/373">modifier manager RFC</a>,
the <code>createModifier</code> hook is called in the order they appear in the template.
This means that given the following invocation:</p>
<pre><code class="language-hbs">&lt;MyComponent {{bar}} /&gt;
</code></pre>
<p>And the following template for <code>MyComponent</code>:</p>
<pre><code class="language-hbs">&lt;div {{foo}} ...attributes {{baz}} /&gt;
</code></pre>
<p>The creation order will be <code>{{foo}}</code>, <code>{{bar}}</code>, <code>{{baz}}</code>. However, the RFC
only provide relative timing guarentees for <code>createModifier</code>, and notably <em>not</em>
for <code>installModifier</code> and <code>updateModifier</code> where most of the interesting work
happen (<code>createModifier</code> does not receive the element). Therefore, in practice,
it is both not very useful to rely on this timing guarentee, nor is it a good
idea.</p>
<h2 id="how-we-teach-this-77"><a class="header" href="#how-we-teach-this-77">How we teach this</a></h2>
<p>This should be taught in the guides:</p>
<ol>
<li>
<p>When teaching angle bracket invocations, we should mention that HTML
attributes and modifiers, in addition to named arguments, can be passed to
components. Some examples would be passing <code>class</code>, <code>aria-role</code> and the
built-in <code>action</code> modifier.</p>
</li>
<li>
<p>When teaching how to author component layouts, we should introduce the
splattributes syntax and explain why it is a good practice to include it on
the primary element(s) in the layout, in order to allow custom styling and
accessibility management by the end-user.</p>
</li>
<li>
<p>When teaching advanced component composition patterns, we can introduce the
concept of &quot;components that invokes other components&quot;. This would be a good
place to explain how the splattributes can be used to forward both HTML
attributes as well as modifiers to child components.</p>
</li>
<li>
<p>When teaching element modifiers, we can give use cases of refactoring common
set of HTML attributes (e.g. classes that goes together with aria-roles)
into named element modifiers (e.g. <code>{{act-as &quot;button&quot;}}</code>).</p>
</li>
</ol>
<p>With the changes proposed in this RFC, it becomes more important to emphasize
that element modifier is a &quot;sharp tool&quot;. As with lifecycle hooks in the classic
<code>Ember.Component</code>, element modifier is an escape valve from the declarative,
pure and functional world of Handlebars templates, into the messy world of
imperative code, shared states and mutability. While they are very flexible,
that flexibility comes at a cost. When used incorrectly, they can easily leak
state, stomp over each other and causes problems in the app.</p>
<p>Therefore, when authoring element modifiers, it is important to be a &quot;good
citizen&quot;, keeping in mind that the underlying HTML element is &quot;shared&quot; among
any bound attributes in the template and other element modifiers. For example,
it is probably a bad idea to prevent event propagation from within an element
modifier, as it may break other modifiers that are listening to the same DOM
event.</p>
<p>This problem is not new, as it is already possible to have multiple element
modifiers attached to the same HTML element. However, when intermediate
components are involved, this could become very difficult to notice.</p>
<p>Therefore, it is even more important to teach and encourage users to author
element modifiers that play well with each other to allow the kind of
composition proposed in this RFC to work at scale.</p>
<p>On the flip side, installing element modifiers on extenal components (i.e.
those that came from outside the app, such as those provided by addons) is also
a somewhat fragile act as it pierces through an encapsulation boundries. Very
generic modifiers like <code>{{action}}</code> and <code>{{on}}</code> are unlikely to cause problems,
but more special-purpose ones may not be appropiate, unless they are sanctioned
by the component authors.</p>
<p>This is already a risk with splattributes in general, as there are plenty of
context-specific HTML attributes. However, allowing element modifiers here is
going to increase the risk as the operations they perform are hidden further
away.</p>
<h2 id="drawbacks-102"><a class="header" href="#drawbacks-102">Drawbacks</a></h2>
<p>The main drawback is the added risk of breaking encapsulation boundries of
components. Specifically, because the element modifiers have access to the raw
underlying HTML element, they may inadvertently depend upon details about the
element (it is of a particular type, has certain attributes or properties set,
etc), beyond what was intended by the component author as a public API. If this
turned out to be a wide-spread problem, it can be mitigated by adding linting
rules to the template linter.</p>
<p>Separately, as proposed, this API does not allow the element modifiers to &quot;see&quot;
any intermediate components, only the final HTML element. If this turned out to
be useful, we can consider introducing it as an optional capability in future
extensions.</p>
<h2 id="alternatives-104"><a class="header" href="#alternatives-104">Alternatives</a></h2>
<p>We can disallow using element modifiers on components, as well as using
splattributes to forward HTML attributes on child component invocations.</p>
<h2 id="unresolved-questions-72"><a class="header" href="#unresolved-questions-72">Unresolved questions</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-06
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/440
Tracking: https://github.com/emberjs/rfc-tracking/issues/41</p>
<hr />
<h1 id="decorator-support"><a class="header" href="#decorator-support">Decorator Support</a></h1>
<h2 id="summary-107"><a class="header" href="#summary-107">Summary</a></h2>
<p>Move forward with the Decorators RFC via stage 1 decorators, and await a stable
future decorators proposal.</p>
<h2 id="motivation-108"><a class="header" href="#motivation-108">Motivation</a></h2>
<p>The recently merged <a href="https://github.com/emberjs/rfcs/blob/master/text/0408-decorators.md">Decorators
RFC</a>
contained an explicit condition: That it was premised on decorators moving from
stage 2 in the TC39 process to stage 3. If this were to not happen, the original
RFC stipulates that a followup (this RFC) should be created to clarify whether
or not we should move forward with decorators while they remain in stage 2, and
how we would do so.</p>
<p>This RFC proposes that we do so. As discussed in the original, the decorator
pattern has been in use in Ember since the beginning, and there is no easy path
forward to native class syntax without a native equivalent to &quot;classic&quot;
decorators.</p>
<p><a href="https://tc39.github.io/process-document/">Stage 2 in TC39</a> signals that the
committee expects this feature to be included in the language in the future, and
is working out the details and semantics. The fact that decorators <em>remain</em> in
stage 2, and have not been rejected, signals that they still expect this to be
the case. However, it is clear based on the initial work following the January
TC39 meeting that <a href="https://github.com/tc39/proposal-decorators/pull/250">the proposal could change
significantly</a> between now
and stage 3.</p>
<p>Parts of the proposal, such as how decorators are invoked, seem solid based on
the feedback we received at the January TC39 meeting, and based on the draft of
the new spec. The definition of decorators is the most likely thing to change.
As such, user code should be minimally affected by any changes, and most changes
should be codemod-able. This reduces the risk of adopting decorators now, since
code <em>written</em> with decorators shouldn't need to change that much.</p>
<p><a href="https://github.com/tc39/proposal-decorators/tree/static#how-should-i-use-decorators-in-transpilers-today">The current recommendation from the authors of the
spec</a>
is to use the stage 1 decorators proposal until the next iteration is ready.
Stage 1 decorators are very stable, and used by a large community of developers
outside of Ember. By standardizing on this version of the spec, we'll be able to
gain the benefits of using a shared solution with the wider ecosystem while we
wait for the next iteration.</p>
<h2 id="detailed-design-91"><a class="header" href="#detailed-design-91">Detailed design</a></h2>
<h3 id="classic-classes-1"><a class="header" href="#classic-classes-1">Classic Classes</a></h3>
<p>The first thing to note is that Ember.js will continue to work with classic
classes and classic class syntax for the forseeable future, as a way for users
to opt-out if they don't want to take the risk of using native classes. This
includes:</p>
<ul>
<li>Classic Classes</li>
<li>Classic Components</li>
<li>Mixins</li>
<li>Computed Properties</li>
<li>Observers</li>
<li>Tracked Properties</li>
<li>Injections</li>
<li>All existing classes defined with classic class syntax</li>
</ul>
<p>Notably, <code>GlimmerComponent</code> will <em>not</em> support classic class syntax, due to its
constraint of having to support both Ember.js <em>and</em> Glimmer.js, where the
classic class model is not available. However, creating an API compatible
classic class version using Ember's component manager API should be possible if
users want to write Glimmer-like components with classic syntax.</p>
<h3 id="decorator-semantics"><a class="header" href="#decorator-semantics">Decorator Semantics</a></h3>
<p>Ember will support Babel's stage 1 decorator transforms. Since Babel and
TypeScript's decorators overlap so much, most TypeScript decorators should also
work in Ember apps. However, due to subtle differences in the way Babel and
TypeScript's decorators work, we can't support them both in <em>all</em> cases. In
cases where there are nuanced differences, Babel's transforms will be considered
the canonical source of truth. For <code>ember-cli-typescript</code> users this shouldn't
be an issue, since they can use Babel's transforms in the latest versions of
<code>ember-cli-typescript</code>.</p>
<h4 id="class-field-assigment-order"><a class="header" href="#class-field-assigment-order">Class Field Assigment Order</a></h4>
<p>Ember also does <em>not</em> guarantee a particular ordering for the assignment of
decorated fields in order to support users who want to use <em>native</em> class fields
when they are available. All that Ember guarantees is that by the time the
<code>constructor</code>'s <code>super</code> method completes (or the constructor code begins, if the
class is not extending), all class fields will be assigned.</p>
<p>Assigning class fields based on the values of other class fields is somewhat of
an anti-pattern as is, so this would reinforce discouraging problematic
patterns. To be clear:</p>
<pre><code class="language-js">class MyComponent extends Component {
  // This is ok, because the component instance exists
  // for all class fields.
  stateManager = new StateManager(this);

  @service time;

  // This is ok, because the `time` is an injection,
  // and always available for all class fields.
  createdAt = this.time.now();

  // This is problematic in general, not just with decorators, because
  // it relies on the order of class field assignment within this class.
  // It is a refactoring hazard, and should likely be done in the
  // constructor instead.
  registry = new Registry();
  container = new Container(this.registry);
}
</code></pre>
<p>Ember will attempt to provide a lint rule which can handle this level of nuance
and prevent frustration when users copy and paste code around the class body.</p>
<h4 id="class-field-assignment-semantics"><a class="header" href="#class-field-assignment-semantics">Class Field Assignment Semantics</a></h4>
<p>Currently, the Babel stage 1 transforms require <code>loose</code> mode for class fields
which causes them to be assigned directly rather than using
<code>Object.defineProperty</code>, which is not inline with the class fields spec. The
biggest difference in behavior is when a child class attempts to override a
getter/setter on the parent class:</p>
<pre><code class="language-js">class Foo {
  get baz() {
    return this._baz;
  }

  set baz(value) {
    this._baz = value;
  }
}

class Bar extends Foo {
  baz = 123;
}
</code></pre>
<p>In strict mode, <code>baz</code> in the child class would completely override the
getter/setter, and they would not exist/be usable on an instance of <code>Bar</code>
(except through calls to <code>super</code>). In loose mode, <code>baz</code> in the child class would
go through the getter/setter, and be assigned to <code>_baz</code> on the instance.</p>
<p>In order to mitigate this, Ember will provide an assertion in development builds
via a babel transform for fields that are assigned in a non-spec compliant way
that throws in this scenario. This will prevent users from accidentally writing
code that will be hard to migrate forward to class fields in the future.</p>
<h3 id="decorator-support-timeframe"><a class="header" href="#decorator-support-timeframe">Decorator Support Timeframe</a></h3>
<p>Stage 1 decorators will be considered a first class Ember API. They will be
supported until:</p>
<ol>
<li>A new RFC has been made to introduce a new decorator API as a parallel API to
the stage 1 decoraters.</li>
<li>A deprecation RFC has been created for Stage 1 decorators.</li>
</ol>
<p>They will follow the same deprecation flow, and same SemVer requirements, as any
other Ember feature.</p>
<h2 id="how-we-teach-this-78"><a class="header" href="#how-we-teach-this-78">How we teach this</a></h2>
<p>There are a few different important aspects of this that should be taught:</p>
<ol>
<li>
<p><strong>Class Field and Decorator semantics</strong>, specifically around the ordering of
class fields. While any step to change a user's class field ordering would
likely be based on their target browsers and configuration, and would be
unlikely to change in a patch or minor version release, users writing code
that could be difficult to upgrade or dependent on a particular version of
the class field/decorator transforms is a failure case we want to avoid.</p>
</li>
<li>
<p><strong>Support timeframe and alternatives.</strong> Users should be aware that this will
be a feature that will <em>likely</em> change in the future, if only subtly. We
should highlight that there <em>is</em> an alternative, classic class syntax, and
that it will still be fully supported. Ultimately, this point is about
setting expectations - that a year or so from now, when decorators are truly
final, there will be another shift.</p>
</li>
<li>
<p><strong>Custom Decorators.</strong> We should document how users can write their own
decorators, but also caution against behaviors that will be difficult to
replicate in Stage 3 decorators when they are ready. This will <em>necessarily</em>
be a moving target, since stage 3 decorators are not yet finished, but we can
try our best to recommend against usages that could be problematic.</p>
<p>We should also warn that decorator definition code will almost definitely
have to be rewritten for stage 3. This should be very clear, so that users
understand that adopting custom decorators in their apps means taking on more
tech debt than just using official Ember decorators, and decorators provided
by addons.</p>
</li>
</ol>
<h2 id="drawbacks-103"><a class="header" href="#drawbacks-103">Drawbacks</a></h2>
<ul>
<li>
<p>The fact that decorators did not move to stage 3 signals that there may be
additional changes to the spec in the near future. Adopting them now could
cause more churn than it's worth.</p>
</li>
<li>
<p>By adopting decorators now, we are essentially taking on some amount of debt
that we know will have to be repaid in the future as a community. This is less
than ideal, since we know that standardization is coming, it's just a matter
of when. This is also the situation we've been in for quite some time already,
and with the latest turn of events, it seems unlikely that decorators will be
fully standardized within the year.</p>
<p>We can continue to wait, but there is no deadline on the design process, and
we could be stuck here indefinitely. This move is pragmatic in that it
unblocks us for now, and moves us toward using modern syntax that will be
compatible with stage 3 decorators - it allows us to begin unwinding other
layers of technical debt. It also represents minimal risk and debt to <em>users</em>
of decorators, since the invocation style will likely be the same.</p>
</li>
</ul>
<h2 id="alternatives-105"><a class="header" href="#alternatives-105">Alternatives</a></h2>
<ul>
<li>
<p>We could continue to rely on unofficial addons such as <code>ember-decorators</code>,
which allow users to opt-in to using decorators. However, these libaries have
limitations that first class decorators will not have, and they don't allow us
to update the official guides to use them.</p>
</li>
<li>
<p>We could create an official decorators addon. However, this means that
decorators would be available at a different import path, meaning that any
code which seeks to work with <em>both</em> classic classes and native classes would
have to be written twice. This would be very difficult for applications that
are mid-transition, and even more difficult throughout the ecosystem for addon
authors.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-13
Relevant Teams: Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/445
Tracking: https://github.com/emberjs/rfc-tracking/issues/40</p>
<hr />
<h1 id="deprecate-with"><a class="header" href="#deprecate-with">Deprecate <code>{{with}}</code></a></h1>
<h2 id="summary-108"><a class="header" href="#summary-108">Summary</a></h2>
<p>The <code>{{with}}</code> helper has always had slightly confusing conditional semantics, this was one of the motivators for <a href="https://github.com/emberjs/rfcs/blob/master/text/0286-block-let-template-helper.md">introducing</a> the easier to understand <code>{{let}}</code> helper. Now that <code>{{let}}</code> exists, the remaining use case for using <code>{{with}}</code> is for its unique conditional semantics. These conditional semantics can be cleanly represented with a combination of <code>{{let}}</code> and <code>{{if}}</code> statements so we should deprecate <code>{{with}}</code>.</p>
<h2 id="motivation-109"><a class="header" href="#motivation-109">Motivation</a></h2>
<p>The difference between <code>{{let}}</code> and <code>{{with}}</code> is with how they handle conditional arguments. The <code>{{let}}</code> helper's block content is always rendered, regardless of its parameters. In contrast, <code>{{with}}</code> only renders its main block when the first position parameter is truthy. For example:</p>
<pre><code class="language-hbs">{{#with &quot;Alex&quot; as |value|}}
  {{value}} is truthy
{{else}}
  The first positional param was falsy
{{/with}}
</code></pre>
<p>Will render &quot;[Alex] is truthy&quot;.</p>
<pre><code class="language-hbs">{{#with false as |value|}}
  {{value}} is truthy
{{else}}
  The first positional param was falsy
{{/with}}
</code></pre>
<p>Will render &quot;The first positional param was falsy&quot;.</p>
<p>The conditional arguments behavior of <code>{{with}}</code> can easily be replicated using a combination of <code>{{let}}</code> and <code>{{if}}</code> in a way that's easily readable:</p>
<pre><code class="language-hbs">{{#let &quot;Alex&quot; as |value|}}
  {{#if value}}
    {{value}} is truthy
  {{else}}
    The first positional param was falsy
  {{/if}}
{{/let}}
</code></pre>
<h2 id="detailed-design-92"><a class="header" href="#detailed-design-92">Detailed design</a></h2>
<p>We'll create an AST transform in <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-template-compiler"><code>packages/ember-template-compiler</code></a> which will emit a deprecation warning for all uses of <code>{{with}}</code>. The deprecation warning will be:</p>
<pre><code>Using `{{with}}` is deprecated, please use `{{let}}` instead.
</code></pre>
<p>This message will link to the following deprecation details which aim to give clear guidance on how to migrate to using <code>{{let}}</code>, <code>{{if}}</code> and <code>{{else}}</code> in different combinations:</p>
<hr />
<p>The use of <code>{{with}}</code> has been deprecated, you should replace it with either <code>{{let}}</code> or a combination of <code>{{let}}</code>, <code>{{if}}</code> and <code>{{else}}</code>:</p>
<p><strong>If you always want the block to render, replace <code>{{with}}</code> with <code>{{let}}</code> directly:</strong></p>
<p>Before:</p>
<pre><code class="language-hbs">{{#with (hash name=&quot;Ben&quot; age=4) as |person|}}
  Hi {{person.name}}, you are {{person.age}} years old.
{{/with}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#let (hash name=&quot;Ben&quot; age=4) as |person|}}
  Hi {{person.name}}, you are {{person.age}} years old.
{{/let}}
</code></pre>
<p><strong>If you want to render a block conditionally, use a combination of <code>{{let}}</code> and <code>{{if}}</code>:</strong></p>
<p>Before:</p>
<pre><code class="language-hbs">{{#with user.posts as |blogPosts|}}
  There are {{blogPosts.length}} blog posts
{{/with}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#let user.posts as |blogPosts|}}
  {{#if blogPosts}}
    There are {{blogPosts.length}} blog posts
  {{/if}}
{{/let}}
</code></pre>
<p><strong>If you want to render a block conditionally, and otherwise render an alternative block, use a combination of <code>{{let}}</code>, <code>{{if}}</code> and <code>{{else}}</code>:</strong></p>
<p>Before:</p>
<pre><code class="language-hbs">{{#with user.posts as |blogPosts|}}
  There are {{blogPosts.length}} blog posts
{{else}}
  There are no blog posts
{{/with}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{#let user.posts as |blogPosts|}}
  {{#if blogPosts}}
    There are {{blogPosts.length}} blog posts
  {{else}}
    There are no blog posts
  {{/if}}
{{/let}}
</code></pre>
<hr />
<p>For people on older versions of Ember that support <code>{{let}}</code>, we'll create an <code>ember-template-lint</code> rule that they can use to prevent the use of <code>{{with}}</code>.</p>
<p>We'll also create a codemod which will assist people when migrating from <code>{{with}}</code> to <code>{{let}}</code>.</p>
<h2 id="how-we-teach-this-79"><a class="header" href="#how-we-teach-this-79">How we teach this</a></h2>
<p>We'll mentiton the deprecation in an Ember point release blog post.</p>
<p>As mentioned above, the deprecation message will contain a link to clear guidelines on how to migrate to using <code>{{let}}</code>.</p>
<p>There is nothing to remove from the Ember.js Guides since we already teach only the use of <code>{{let}}</code>.</p>
<h2 id="drawbacks-104"><a class="header" href="#drawbacks-104">Drawbacks</a></h2>
<p>This adds a little churn to Ember's API.</p>
<h2 id="alternatives-106"><a class="header" href="#alternatives-106">Alternatives</a></h2>
<p>We could leave <code>{{with}}</code> as is. I don't believe that this is a good option as the name <code>{{with}}</code> is confusing.</p>
<p>We could deprecate <code>{{with}}</code> and introduce <code>{{if-let}}</code> in Ember core. This RFC originally made that exact proposal, I was strongly persuaded of the <a href="https://github.com/emberjs/rfcs/pull/445#issuecomment-463594185">lack of need for <code>{{if-let}}</code> by @tcjr</a>.</p>
<p>We could deprecate <code>{{with}}</code> and introduce <code>{{if-let}}</code> in an addon instead of Ember core.</p>
<h2 id="unresolved-questions-73"><a class="header" href="#unresolved-questions-73">Unresolved questions</a></h2>
<p>(none)</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-14
Relevant Team(s): Learning
RFC PR: https://github.com/emberjs/rfcs/pull/446
Tracking: https://github.com/emberjs/rfc-tracking/issues/39</p>
<hr />
<h1 id="contribution-guides"><a class="header" href="#contribution-guides">Contribution Guides</a></h1>
<h2 id="summary-109"><a class="header" href="#summary-109">Summary</a></h2>
<p>This RFC proposes the creation of an official <strong>Contribution Guide</strong> that aims to improve the discoverability of Ember-related projects that require help by the community and outlines the general contribution workflow for these projects.</p>
<h2 id="motivation-110"><a class="header" href="#motivation-110">Motivation</a></h2>
<p>In the past year alone, <a href="https://github.com/emberjs/ember.js/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">43</a>, <a href="https://github.com/ember-cli/ember-cli/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">34</a>, <a href="https://github.com/emberjs/data/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">29</a>, <a href="https://github.com/ember-learn/guides-source/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">81</a> and <a href="https://github.com/emberjs/website/graphs/contributors?from=2018-01-01&amp;to=2019-01-01&amp;type=c">31</a> people made contributions to the <a href="https://github.com/emberjs/ember.js">core framework library</a>, the <a href="https://github.com/ember-cli/ember-cli">Ember CLI</a>, Ember’s <a href="https://github.com/emberjs/data">Data library</a>, the source for <a href="https://github.com/ember-learn/guides-source">the official framework Guides</a>, and the <a href="https://github.com/emberjs/website">project website</a>, respectively. An already impressive amount of developers decided to dedicate their time and effort to contribute to Ember - a project, that has been actively supported, maintained and developed by a strong open-source community for over seven years. Besides the code contributions to the main project repositories, the community can also look back on years of immense effort that has been put into the development of community-maintained packages which resulted in the vast Ember addon ecosystem as we know it today, as well as independent documentation and learning resources.</p>
<p>We are confident that there is an even greater potential for the community to contribute and that this can be unlocked by facilitating the contribution process - especially in regards to the on-boarding process for first-time contributors to Ember. Today, new community members oftentimes need to spend some time and effort to find a suitable project that allows them to apply a) their skills efficiently and b) is in their eyes worthwhile.</p>
<p>This RFC proposes to create and release a Contribution Guide - a new website as part of the <code>emberjs.com</code> domain. This new site should allow contributors to find Ember-related projects to work on easily and should provide more information on the workflow for their potentially (but not necessarily) first open-source contribution.</p>
<h2 id="detailed-design-93"><a class="header" href="#detailed-design-93">Detailed design</a></h2>
<p>The new Contribution Guides should be as <strong>beginner-friendly</strong> as possible to accommodate the needs of those who might make their very first code contribution to an open-source project.</p>
<p>The list of topics covered should therefore include:</p>
<ul>
<li>
<p><strong>A summary of the motivation of open-source and its meaning for Ember as an OSS project.</strong> This aims to provide more context to those new to Ember and open-source in general about the purpose of the project and how Ember values a collaborative approach in the development of the framework.</p>
</li>
<li>
<p><strong>A How-To for code contributions with a real-world example.</strong> This can include tips on how to find and claim a suitable issue, an introduction to Git and how to send a pull request, tips for the review process about finding a reviewer, communicating effectively and submitting changes and easy-to-review chunks of contribution work.</p>
</li>
<li>
<p><strong>A How-To for filing a new issue on an Ember project</strong></p>
</li>
<li>
<p><strong>An issue finder functionality inspired by the <a href="https://whatcanidoformozilla.org/#!/progornoprog/teach">What Can I Do for Mozilla landing page</a></strong>. This should lead users to a) a list of relevant issues on the <a href="https://help-wanted.emberjs.com/">Ember Help Wanted App</a>, b) a related strike team channel on the Ember Discord chat, c) a link to the description of an on-going initiative on the <a href="https://emberjs.com/statusboard/">Status Board</a>.</p>
</li>
</ul>
<p>Any subjects covered in the Guides should be presented as text instruction at least, but each topic can be enhanced with relevant code examples and multi-media content (e.g. slides of a relevant community talk, video content among others).</p>
<p>To help with the integration of the issue finder on the Contribution Guides with the Ember Help Wanted app, this proposes to extend the Ember Help Wanted App with a search filter for the main programming language used in the project. To make the Contribution Guides easy to discover from Ember projects, each project's specific contribution guidelines (e.g. <a href="https://github.com/ember-cli/ember-cli/blob/master/CONTRIBUTING.md">Ember CLI's <code>CONTRIBUTING.md</code></a>) should cross link back to the new Contribution Guides site for reference.</p>
<p>To improve discoverability of the Contribution Guides via search engines, it is also proposed to host the Guides on their own Ember sub domain: <strong>contribute.emberjs.com</strong></p>
<h2 id="alternatives-107"><a class="header" href="#alternatives-107">Alternatives</a></h2>
<p>An alternative would be to not create a dedicated Contribution Guide and instead refer those that want to contribute to <a href="https://guides.emberjs.com/release/contributing/adding-new-features/">the related section in the Ember Guides</a>. It would also be possible to expand this section of the Ember Guides further with more content we'd like to share with contributors.</p>
<p>Also, the Ember Help Wanted App already works in favour of one of the goals of this proposal which is increasing the discoverability of issues that require contribution help. Instead of creating a new, dedicated website for the Contribution Guides, it would also make sense to progressively enhance the Help Wanted App with relevant content on contribution, e.g. with a short tutorial on the contribution workflow or How-Tos on other kinds of contribution work.</p>
<h2 id="unresolved-questions-74"><a class="header" href="#unresolved-questions-74">Unresolved questions</a></h2>
<p>Although this RFC already answers questions about the kind of content we’d like to see with an Contribution Guide for Ember, it is not clear yet, how the infrastructure for this guide looks like. Some of related questions are:</p>
<ul>
<li>
<p>Should the Guide be another Ember app, e.g another dedicated Guides app, in a similar to the official Ember and <a href="https://github.com/ember-learn/cli-guides">Ember CLI Guides</a>? Making it an Ember app might in return help community members to contribute to it since they’re most likely already familiar with Ember. Choosing a similar format as the one of the Ember CLI Guides comes with the additional benefit of making it particularly easy to contribute to the Guide’s content since this only requires an understanding of Markdown, lowering the entry hurdle for a first-time contribution</p>
</li>
<li>
<p>If we decide to not create another Guides app for the Contribution Guides, how should the design for the new website look like?</p>
</li>
<li>
<p>This RFC only considered content related to code contributions relevant for the Contribution Guides. This excludes other types of important contribution work to Ember and the community, as event organisation, blogging, release management and many other topics. Should the Guides be expanded by relevant information about other types of contribution work as we iterate on it? This could include How-Tos for organising meetups, a collection of workshop materials for reuse, an introduction to the RFC process and other pieces of information</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-17
Relevant Teams: Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/449
Tracking: https://github.com/emberjs/rfc-tracking/issues/38</p>
<hr />
<h1 id="deprecate-partial"><a class="header" href="#deprecate-partial">Deprecate <code>{{partial}}</code></a></h1>
<h2 id="summary-110"><a class="header" href="#summary-110">Summary</a></h2>
<p>Partials are an old Ember construct that have no benefits and many downsides when compared to modern Ember components. We should deprecate them in favor of components.</p>
<h2 id="motivation-111"><a class="header" href="#motivation-111">Motivation</a></h2>
<p>Partials have a number of downsides when compared with components: </p>
<ul>
<li>They are hard to reason about as they inherit the scope of the calling template</li>
<li>They perform poorly in comparison to components</li>
</ul>
<p>Partials should have no place in modern Ember applications, components should always be preferred.</p>
<p>Once removed, Ember's API will become smaller and more consistent.</p>
<h2 id="detailed-design-94"><a class="header" href="#detailed-design-94">Detailed design</a></h2>
<p>We'll create an AST transform in <a href="https://github.com/emberjs/ember.js/tree/master/packages/ember-template-compiler"><code>packages/ember-template-compiler</code></a> which will emit a deprecation warning for all uses of <code>{{partial}}</code>. The deprecation warning will be:</p>
<pre><code>Using `{{partial}}` is deprecated, please use a component instead.
</code></pre>
<p>This message will link to the following deprecation details which aim to give clear guidance on how to migrate to component:</p>
<hr />
<p>The use of <code>{{partial}}</code> has been deprecated, you should replace the partial with a component as follows:</p>
<p>Let's consider a simple example of a <code>partials/quick-tip</code> partial being invoked from the <code>application.hbs</code> template:</p>
<p><code>app/templates/application.hbs</code></p>
<pre><code class="language-hbs">{{#let (hash title=&quot;Don't use partials&quot; body=&quot;Components are always better&quot;) as |tip|}}
  {{partial &quot;partials/quick-tip&quot;}}
{{/let}}
</code></pre>
<p><code>app/templates/partials/quick-tip.hbs</code></p>
<pre><code class="language-hbs">&lt;h1&gt;Tip: {{tip.title}}&lt;/h1&gt;
&lt;p&gt;{{tip.body}}&lt;/p&gt;
&lt;button {{action 'dismissTip'}}&gt;OK&lt;/button&gt;
</code></pre>
<p>Here's the same template code after migrating the <code>partials/quick-tip</code> partial to be a component.</p>
<p><code>app/templates/application.hbs</code></p>
<pre><code class="language-hbs">{{#let (hash title=&quot;Don't use partials&quot; body=&quot;Components are always better&quot;) as |tip|}}
  &lt;QuickTip @tip={{tip}} @onDismiss={{action 'dismissTip'}} /&gt;
{{/let}}
</code></pre>
<p><code>app/templates/components/quick-tip.hbs</code></p>
<pre><code class="language-hbs">&lt;h1&gt;Tip: {{@tip.title}}&lt;/h1&gt;
&lt;p&gt;{{@tip.body}}&lt;/p&gt;
&lt;button {{action @onDismiss}}&gt;OK&lt;/button&gt;
</code></pre>
<hr />
<p>A codemod, while not necessary for this RFC to land, would greatly simplify the migration of partials to components. We should endeavor to create this codemod as part of efforts to implement this RFC. The codemod might work as follows:</p>
<ul>
<li>Examine each partial template to recognize which properties originate from the caller scope</li>
<li>Generate a component to replace each partial</li>
<li>Replace each <code>{{partial &quot;foo-bar&quot;}}</code> invocation with a component invocation, passing arguments as required</li>
<li>Delete the partial handlebars files</li>
</ul>
<p>If we do implement a codemod, we should mention it in the deprecation details above.</p>
<h2 id="how-we-teach-this-80"><a class="header" href="#how-we-teach-this-80">How we teach this</a></h2>
<p>We'll mentiton the deprecation in an Ember point release blog post.</p>
<p>The deprecation message will contain a link to clear guidelines on how to migrate from a <code>{{partial}}</code> to a component. See the section above beginning with &quot;The use of <code>{{partial}}</code> has been deprecated...&quot; for the content.</p>
<p>There are no changes to make to the Ember.js guides, since mentions of <code>{{partial}}</code> were removed in 2.x guides.</p>
<h2 id="drawbacks-105"><a class="header" href="#drawbacks-105">Drawbacks</a></h2>
<p>This adds a little churn to Ember's API.</p>
<h2 id="alternatives-108"><a class="header" href="#alternatives-108">Alternatives</a></h2>
<p>We could do nothing and leave things as is.</p>
<h2 id="unresolved-questions-75"><a class="header" href="#unresolved-questions-75">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-19
Relevant Team(s): Ember.js, Ember Data, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/451
Tracking: https://github.com/emberjs/rfc-tracking/issues/34</p>
<hr />
<h1 id="injection-parameter-normalization"><a class="header" href="#injection-parameter-normalization">Injection Parameter Normalization</a></h1>
<h2 id="summary-111"><a class="header" href="#summary-111">Summary</a></h2>
<p>Normalize on passing the <code>owner</code> as the first parameter to the constructor for
the following built in framework classes:</p>
<ul>
<li><code>GlimmerComponent</code></li>
<li><code>EmberComponent</code></li>
<li><code>Service</code></li>
<li><code>Route</code></li>
<li><code>Controller</code></li>
<li><code>Helper</code></li>
</ul>
<p>Along with the following Ember Data classes:</p>
<ul>
<li><code>Model</code></li>
<li><code>Adapter</code></li>
<li><code>Serializer</code></li>
<li><code>Transform</code></li>
</ul>
<h2 id="terminology-5"><a class="header" href="#terminology-5">Terminology</a></h2>
<ul>
<li>
<p><em>Explicit injections</em> are injections which are defined in the class body using
the <code>inject</code> APIs:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { inject as service } from '@ember/service';

export default Component.extend({
  store: service(),
});
</code></pre>
<p>The are <em>explicit</em> because they don't require any knowledge of the system to
outside of the class itself to know they exist.</p>
</li>
<li>
<p><em>Implicit injections</em> are injections which are defined using the container
APIs directly, often in initializers:</p>
<pre><code class="language-js">import Application from '@ember/application';

Application.initializer({
  name: 'inject-session',

  initialize() {
    // Inject the session service onto all factories of the type 'controller'
    // with the name 'session'
    App.inject('controller', 'session', 'service:session');
  },
});
</code></pre>
<p>They are implicit because they require knowledge of the context
of the class to know whether or not they exist, simply looking at the class
body (without looking at method logic) will not hint at their existence. The
canonical example here is the Ember Data <code>store</code>, which is implicitly injected
into all routes and controllers.</p>
</li>
</ul>
<h2 id="motivation-112"><a class="header" href="#motivation-112">Motivation</a></h2>
<p>The introduction of native class syntax in Ember has recently exposed some of
the inner-workings and expectations of Ember's Dependency Injection (DI) system.
Specifically, it is now possible to write code that can run <em>before</em>
dependencies are injected in some base classes, such as Services and
Controllers. Currently, users must use the <code>init</code> hook in these classes if they
wish to run setup code that accesses injections, but this is somewhat confusing
since <code>init</code> has historically been taught as the same as the <code>constructor</code> in
native classes.</p>
<p>Glimmer components made the decision to break from this pattern, and instead
pass the DI Owner as the first parameter to the constructor. They then set it
using <code>setOwner</code> in the base class, making explicit injections available during the
constructor, and to class field initializers.</p>
<p>So far this has worked pretty well in practice:</p>
<ul>
<li>Glimmer components have just 2 lifecycle hooks, which makes them simpler to
understand and learn about.</li>
<li>We don't have to teach the differences between <code>constructor</code> and <code>init</code>, when
to use one or the other, and debugging issues when the two have mixed usage
throughout the class hierarchy</li>
<li>We don't have to worry about explaining the timings/lifecycle of the container
and the way it constructs classes in order to explain why these are separate.</li>
</ul>
<p>This RFC seeks to normalize this contract for all <em>Ember base classes</em> - that
is, framework classes that are provided by Ember:</p>
<ul>
<li><code>GlimmerComponent</code></li>
<li><code>EmberComponent</code></li>
<li><code>Service</code></li>
<li><code>Route</code></li>
<li><code>Controller</code></li>
<li><code>Helper</code></li>
</ul>
<p>Along with framework clases provided by Ember Data:</p>
<ul>
<li><code>Model</code></li>
<li><code>Adapter</code></li>
<li><code>Serializer</code></li>
<li><code>Transform</code></li>
</ul>
<p>This RFC does <strong><em>not</em></strong> aim to provide a single contract for <em>all</em> classes
registered on the container, in perpetuity. This would lock us into a tight
coupling between the container and constructors for objects that are registered,
and wouldn't provide much flexibility in the future.</p>
<p>Instead, we believe we should continue exploring APIs for generalizing the way
DI is configured for a given base class. It could be done via custom managers,
or via decoration, like the <a href="https://github.com/emberjs/rfcs/pull/467">Injection Hook Normalization
RFC</a>. When these APIs are fully
rationalized and accepted, we'll update Ember's base classes to use them to
specify the owner injection like any other user class could.</p>
<h2 id="detailed-design-95"><a class="header" href="#detailed-design-95">Detailed design</a></h2>
<p>This RFC has 2 major parts:</p>
<ol>
<li>The contract that we'll uphold for dependency injection in <em>Ember base
classes</em>.</li>
<li>The implementation of that contract for existing base classes (the tunnel).</li>
</ol>
<h3 id="dependency-injection-contract"><a class="header" href="#dependency-injection-contract">Dependency Injection Contract</a></h3>
<p>For all Ember base classes created by the container, such as <code>GlimmerComponent</code>,
<code>Service</code>, <code>Controller</code>, etc. we will:</p>
<ol>
<li>Pass the owner as the first parameter when constructing the class.</li>
<li>Set the owner with <code>setOwner</code> in the base class constructor.</li>
</ol>
<p>This will make explicit injections available during the <code>constructor</code> method of
the class, and for access by class field initializers.</p>
<p>This contract <em>only</em> applies to Ember base classes and framework objects, and
classes that extend <code>EmberObject</code>. It does <em>not</em> apply to arbitrary
classes that are created and registered in the container.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>The &quot;tunnel&quot; itself is fairly simple. As described in the Constructor Update
RFC, this is how the <code>create</code> method on framework classes works currently:</p>
<pre><code class="language-js">class Service extends EmberObject {
  constructor() {
    super();
    // ..class setup things
  }

  static create(args) {
    let instance = new this();

    Object.assign(instance, args);
    instance.init();

    return instance;
  }
}
</code></pre>
<p>We would update this to the following:</p>
<pre><code class="language-js">class Service extends EmberObject {
  constructor(owner) {
    super();
    setOwner(this, owner);
    // ..class setup things
  }

  static create(args) {
    let owner = args ? getOwner(args) : undefined;
    let instance = new this(owner);

    Object.assign(instance, args);
    instance.init();

    return instance;
  }
}
</code></pre>
<p>Now, when any subclass's constructor code is run it will have the owner
available, which in turn makes all <em>explicit</em> injections work (they use
<code>getOwner</code> under the hood).</p>
<p>However, <em>implicit</em> injections will still only be available during <code>init</code>,
because they are passed in and assigned as <code>args</code>. This RFC proposes that rather
than attempting to fix implicit injections, we create development-mode
assertions for them which throw if a user attempts to use them during the
<code>constructor</code>, before they are assigned. This will give a helpful error message
that instructs them to add the injection explicitly (ideally), or to use <code>init</code>.</p>
<h3 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h3>
<p>This change is backwards compatible, so existing applications will not be
affected. These changes will also be backported to at least:</p>
<ul>
<li>lts-3.8</li>
<li>lts-3.4</li>
</ul>
<p>via the <code>ember-native-class-polyfill</code>, which currently supports polyfilling to
Ember@3.4. If possible, that range will be extended to the last v2 LTS versions.</p>
<h2 id="how-we-teach-this-81"><a class="header" href="#how-we-teach-this-81">How we teach this</a></h2>
<p>This change would take some burden off of the guides for <em>new</em> Ember users,
post-Octane, since it would simplify them. New documentation should only refer
to <code>constructor</code> when talking about native class syntax, and should guide users
toward using <code>constructor</code> over <code>init</code>.</p>
<p>For existing apps and upgrade documentation, the distinction needs to be made
clear about the two types of classes that <em>should</em> still use <code>init</code>:</p>
<ul>
<li>Classic Components</li>
<li>Utility Classes (e.g. user defined classes that extend <code>EmberObject</code>)</li>
</ul>
<p>These two require <code>init</code> if users need access to component args or create args,
respectively.</p>
<p>The main guides will recommend that users refactor these classes entirely rather
than convert them to native classes. Classic components should become Glimmer
components, and utility classes should be refactor <em>away</em> from extending
<code>EmberObject</code>.</p>
<p>The <a href="https://github.com/emberjs/rfcs/pull/468"><code>@classic</code></a> decorator will also
provide a way to guide users toward the correct usage, based on whether they are
in &quot;classic&quot; mode or &quot;octane&quot; mode. We will be able to provide linting and
warnings/assertions to prevent users from accidentally using <code>init</code> when they
should have used <code>constructor</code>, and vice-versa.</p>
<h2 id="drawbacks-106"><a class="header" href="#drawbacks-106">Drawbacks</a></h2>
<ul>
<li>More churn in the ecosystem, early adopters of classes already switched from
<code>constructor</code> -&gt; <code>init</code>, switching back would be painful.</li>
<li>Where to use <code>init</code> and where to use <code>constructor</code> may be a bit less clear
after. This was already a concern with <code>GlimmerComponent</code>, but it may be more
problematic if there are more exceptions.</li>
</ul>
<h2 id="alternatives-109"><a class="header" href="#alternatives-109">Alternatives</a></h2>
<ul>
<li>Add an <code>init</code> hook to <code>GlimmerComponent</code> to unify it with the classic classes.
This could be confusing to users of <code>GlimmerComponent</code> (why do injections
work in GC but not any other class constructor? Why does GC have <code>init</code> <em>and</em>
<code>constructor</code>?)</li>
<li>Keep using <code>init</code> for classic classes for the indefinite future, and teach
around it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-20
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/452
Tracking: https://github.com/emberjs/rfc-tracking/issues/50</p>
<hr />
<h1 id="summary-112"><a class="header" href="#summary-112"><strong>Summary</strong></a></h1>
<p>This RFC sets the plan for Ember Data's medium term development, on the path towards modularizing the library. We expect the following immediate design and implementation work to take between one and two quarters. The main goals are:</p>
<ul>
<li>Increase approachability of the library for both the users and contributors</li>
<li>Increase iteration speed and stability</li>
<li>Enable shedding of legacy layers</li>
<li>Increase flexibility and lay the foundation for future improvements</li>
</ul>
<h1 id="background-and-motivation"><a class="header" href="#background-and-motivation">Background and Motivation</a></h1>
<p>Ember Data needs to continue to evolve with Ember and the wider Javascript ecosystem and provide a modern first class data handling support. Moreover, we want to reach the future in which using ED is a much more modular and composable experience. In order to do this, we need to create a foundation for future development while making sure we are honoring our stability guarantees and helping the ecosystem evolve together with us. The two main motivations for this RFC are:</p>
<ul>
<li>Enabling future improvements</li>
<li>Increasing velocity and stability</li>
</ul>
<h2 id="enabling-future-improvements"><a class="header" href="#enabling-future-improvements">Enabling future improvements</a></h2>
<p>In order to provide Ember users with a future proof data stack, ED has to mold and adapt. A sample of requirements for a modern data library for Ember include:</p>
<ul>
<li>Not depending on Ember's object model</li>
<li>Support for complex persistence strategies</li>
<li>Flexible query expressions and mutations, allowing optional GraphQL support</li>
<li>Out of the box high level of performance without compromises</li>
</ul>
<p>Ember Data should incrementally evolve to support all of the above with full backwards compatibility. However, evolving a complex codebase over time while maintaining compatibility has always been a tricky endeavor abound with tradeoffs. In the 3.x cycle there have been several angles of attack towards exploring the future of ED.</p>
<hr />
<ul>
<li>Orbit.js has been driving experimentation with a multi source transformation driven approach</li>
<li>An experimental spike of Ember Data frontend backed by Orbit.js (https://github.com/igorT/data-orbit)</li>
<li>Single model class Ember Data Addon with dynamic schemas and no normalization (https://github.com/hjdivad/ember-m3)</li>
<li>Public interface in Ember Data that allows for above efforts to be stable and exposes the internals for more experimentation (https://github.com/emberjs/rfcs/pull/293)</li>
</ul>
<p>While some of these efforts are experimental spikes and others have seen production use, we want to bring their ideas and improvements back into ED proper. The first motivation for this RFC is to design our internal architecture so that we can iteratively move the library in that direction. We have already done the first part of this work, refactoring the bulk of in memory data storage into a pluggable RecordData interface and now need to spread that approach to the rest of the library.</p>
<p>However, we will not succeed in delivering this future vision in a timely manner and bringing it's benefits to our existing body of users if we do not improve our velocity and stability.</p>
<h1 id="increasing-velocity-and-stability"><a class="header" href="#increasing-velocity-and-stability">Increasing velocity and stability</a></h1>
<p>Ember Data has continuously evolved over seven years and over time acquired several layers of cruft along with a intimately connected internal architecture. The current state of the library is not particularly hospitable to new contributors while at the same time being hard to iterate on in a stable manner. Lots of Ember Data's public apis have been designed with stability and extensibility in mind, but the internal layers of the library have not benefited from the same amount of design work. The unspecified internal layers together with a host of implicit dependencies make it hard to expose parts of Ember Data to addon developers as well as prevent ED contributors from being able to easily do experimental iterative work. </p>
<p>The three main problems this internal structure causes us is: </p>
<ul>
<li>It is hard for developers to grok the codebase and become prolific contributors due to the complexity</li>
<li>Testing ideas in addons is usually a great way to move faster and derisk ideas. However due to the internal structure of ED, such addons use a large surface area of internal apis, negating most of the benefits</li>
<li>Due to the structure of the code base and the inherent complex nature of data retrieval and storage, it is hard to make changes to ED with confidence. While we have an extensive acceptance level test suite, testing of the internal apis and data structures is lacking at best</li>
</ul>
<p>We have already begun some efforts to address these problems: incremental conversion to Typescript and the RecordData refactor stand out as biggest value adds.</p>
<p>A great example of how these issues impact us are the problems one runs into when trying to remove ED's dependency on DS.Model and Ember's object model. In a perfect world, if we wanted to ship ED that used ES6 classes instead of DS.Models, we would adopt an incremental approach:</p>
<ul>
<li>A small refactor of ED to make base record class pluggable</li>
<li>Develop an addon that uses ES6 classes as a base record class and experiment with it</li>
<li>After a period of experimentation, merge the addon into ED core with a compatibility layer for legacy users</li>
</ul>
<p>However, this is currently very hard to do in the ED codebase, because the whole system is littered with both explicit and implicit assumptions about record's intimate apis and it's class structure. The implicit assumptions throughout the codebase of how a record behaves are especially challenging to reason about and test.</p>
<h1 id="goals"><a class="header" href="#goals">Goals</a></h1>
<p>Success criteria for this plan is shipping an Ember data release which:</p>
<ul>
<li>Does not break SemVer and has no user facing changes</li>
<li>Consists of several independently tested packages with clearly defined boundaries and interfaces</li>
<li>(mostly) In Typescript</li>
<li>Enables a path for users to not have model classes dependent on the old Ember object model and DS.Model</li>
<li>And allows addons like ModelFragments and ember-m3 to not use any private apis</li>
</ul>
<h1 id="non-goals-1"><a class="header" href="#non-goals-1">Non Goals</a></h1>
<p>While the internal apis and interfaces will be designed with an eye towards the future public and addon use, in this phase of the work we will not be exposing all of them to apps and addons as fully stable public apis, or we will do so for addon author with an explicit plan to deprecate and replace.</p>
<p>Moreover, as part of the RFC we will not be deciding on, or baking in the future app level public apis. </p>
<h1 id="high-level-plan"><a class="header" href="#high-level-plan">High Level plan</a></h1>
<p>The high level plan is to refactor the ED internals so that:</p>
<ul>
<li>DS.Model and code relying on it is isolated from the rest of the system allowing us to swap it out in the future</li>
<li>InternalModel is removed in favor of moving the functionality to specced out APIs</li>
<li>We introduce a concept of RecordIdentity, a string or POJO which can be used to uniquely identify a record throughout the system</li>
<li>Boundaries between parts of the system are hardened, specced out and implemented in typescript</li>
</ul>
<p>In a typical Ember app, Ember Data sits as a layer between the application code which issues queries for data, reads and manipulates the results and the browser fetch or websocket interface.  You could model a typical use of ED at a high level as :</p>
<p>App Query —&gt;   In memory cache —&gt;  Request sent → Data normalized → Result object returned</p>
<p>However Ember Data's architecture currently is quite a bit more complex:</p>
<p><img src="https://i.imgur.com/98oiXCx.png" alt="" /></p>
<p>While the overall shape of the architecture looks as you might expect, our current implementation suffers from several critical problems:</p>
<ul>
<li>A large part of critical model behavior is handled by the internal model abstraction</li>
<li>Entire library implicitly relies on DS.Model classes, Ember's object model</li>
<li>The division of responsibilities between internalModel, RecordData, Store are not clear</li>
</ul>
<p>This medium size ball of mud should be refactored to the following high level pieces: (add diagram here): </p>
<p><img src="https://i.imgur.com/C3tNcH2.png" alt="" /></p>
<p><em>this is a high level design, each of these would correspond to an RFC</em></p>
<ul>
<li>User facing record objects, and a corresponding interface which the rest of the system uses to interact with records. This currently corresponds to DS.Model, DS.RecordArray, ObjectProxy and ArrayProxy. These classes will be swappable, and give us a path to change ED's object model</li>
<li>RecordIdentity - a system wide way to uniquely identify records</li>
<li>In memory store, RecordData++, taking what RecordData does today(in memory storage of record and relationship information) and adding record state management, error handling and capability to have a singleton Record Data instead of having to have a Record Data instance per Record</li>
<li>Schema Service - a service for providing attribute and relationship info to the rest of the system, the initial implementation would just provide a wrapper for DS.Model, but allows us a path forward to dropping DS.Models</li>
<li>Identity Map, which is keyed of record identity objects instead of holding references to internal models</li>
<li>User facing Store - class that most resembles todays Store which exposes finder methods to the user</li>
<li>Query builder - a service which takes user queries such as <code>findRecord</code> and turns them into Orbit.js like query objects that can be passed around</li>
<li>Fetching service - layer that takes user queries, relationship queries and save requests and decides whether they need fulfillment, and if so delegates to adapter/serialzier. Currently done by a mix of store and internal model.</li>
</ul>
<p>Adapter, Serializer and Snapshots would not have major changes at this time, other than those needed to make use of the schema service and public apis for accessing records. </p>
<p>It is important to note that none of the existing public user apis would change, and that the bulk of this work is taking existing code structures and making the specified and isolated.</p>
<h1 id="tactical-plan"><a class="header" href="#tactical-plan">Tactical plan</a></h1>
<ul>
<li>Continue the Typescript conversion</li>
<li>Implement packages RFC</li>
<li>Cleanup Record Data</li>
</ul>
<p>Write RFCs for:</p>
<ul>
<li>RecordIdentity</li>
<li>Custom Record Classes</li>
<li>Record Data incremental improvements for:
<ul>
<li>Internal Error storage</li>
<li>Record State RFC</li>
</ul>
</li>
<li>Schema Service</li>
<li>Query builder</li>
</ul>
<h1 id="open-questions-1"><a class="header" href="#open-questions-1">Open questions</a></h1>
<p>What level of future support should we commit ourselves to with the new apis?</p>
<h1 id="downsides"><a class="header" href="#downsides">Downsides</a></h1>
<ul>
<li>Exposing more intimate apis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-05
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/457
Tracking: https://github.com/emberjs/rfc-tracking/issues/37</p>
<hr />
<h1 id="nested-invocations-in-angle-bracket-syntax"><a class="header" href="#nested-invocations-in-angle-bracket-syntax">Nested Invocations in Angle Bracket Syntax</a></h1>
<h2 id="summary-113"><a class="header" href="#summary-113">Summary</a></h2>
<p>Create a syntax for invoking components nested inside of directories in angle-bracket syntax. The invocation <code>&lt;AppIcons::Warning&gt;</code> refers to the component <code>app/components/app-icons/warning.js</code> when using the default resolver, and looks up <code>component:app-icons/warning</code> in the container.</p>
<h2 id="motivation-113"><a class="header" href="#motivation-113">Motivation</a></h2>
<p>Today's angle-bracket syntax conversion guide says this:</p>
<p><img src="/images/457-when-to-use-curlies.jpg" alt="existing documentation" /></p>
<p>This has been an acceptable interim step as we have worked on completing the work of revamping the component model, but it's a source of incoherence (and a reported adoption blocker for some apps) in the Ember design, and we need to eliminate this source of incoherence in order to recommend angle bracket components in the Octane edition.</p>
<p>For positional arguments, we recommend that add-on authors migrate to named arguments. There is one exception to this rule: addons that are mimicking control-flow syntax (like <code>liquid-if</code>). These addons should clearly document that they are meant to be used with curly syntax.</p>
<p>For components nested inside of directories, this RFC proposes a new syntax to allow users to migrate directly to angle bracket invocation.</p>
<h2 id="detailed-design-96"><a class="header" href="#detailed-design-96">Detailed design</a></h2>
<blockquote>
<p>Note: This RFC uses curly syntax without blocks for illustrative purposes. In all cases, adding a block doesn't change the normalization or lookup rules described here.</p>
</blockquote>
<p>When using curly syntax, component invocation looks like this:</p>
<pre><code class="language-hbs">{{some-component some=parameters}}
</code></pre>
<p>If <code>some-component</code> is not a local variable in scope, the semantics of this invocation are:</p>
<ol>
<li>look up <code>component:some-component</code> in the container</li>
<li>look up <code>template:components/some-component</code> in the container</li>
<li>invoke the component with its template (using the relevant component manager semantics)</li>
</ol>
<p>When using angle-bracket syntax, the equivalent invocation looks like this:</p>
<pre><code class="language-hbs">&lt;SomeComponent @some={{parameters}}&gt;
</code></pre>
<p>The syntax means the same thing, with one additional step:</p>
<ol>
<li><strong>normalize <code>SomeComponent</code> into <code>some-component</code> using the dasherization rule specified in <a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html#tag-name">RFC #311</a></strong></li>
<li>look up <code>component:some-component</code> in the container</li>
<li>look up <code>template:components/some-component</code> in the container</li>
<li>invoke the component with its template (using the relevant component manager semantics)</li>
</ol>
<p>Curly bracket syntax also allows the user to invoke a component nested inside of a directory. This syntax:</p>
<pre><code class="language-hbs">{{app-icons/warning color=&quot;yellow&quot;}}
</code></pre>
<p>has these semantics:</p>
<ol>
<li>look up <code>component:app-icons/warning</code> in the container</li>
<li>look up <code>template:components/app-icons/warning</code> in the container</li>
<li>invoke the component with its template (using the relevant component manager semantics)</li>
</ol>
<p>However, RFC #311 didn't specify an angle-bracket equivalent syntax for the same semantics.</p>
<p>This RFC proposes that the <code>::</code> separator serve the same purpose, with the same semantics, in angle-bracket notation:</p>
<pre><code class="language-hbs">&lt;AppIcons::Warning @color=&quot;yellow&quot; /&gt;
</code></pre>
<hr />
<p>This RFC is an extension to the <strong>normalization</strong> rules that already occur in angle bracket notation.</p>
<p>RFC #311 specified the normalization rules as:</p>
<blockquote>
<p>The tag name will be normalized using the dasherize function, which is the same rules used by existing use cases, such as service injections</p>
</blockquote>
<p>This RFC amends the normalization rule by first replacing any occurrences of <code>::</code> in the tag name with a <code>/</code>, but otherwise doesn't change the semantics of RFC #311.</p>
<p><a href="https://emberjs.github.io/rfcs/0143-module-unification.html">RFC #143</a>, Module Unification, uses <code>::</code> as a package separator, but because of problems with scoped packages in npm, we no longer intend to use the <code>::</code> syntax in that way. Instead, we intend to allow templates to import components from other packages using import syntax, and the <code>::</code> syntax is therefore available for this purpose.</p>
<h2 id="how-we-teach-this-82"><a class="header" href="#how-we-teach-this-82">How we teach this</a></h2>
<p>We currently don't cover directory nesting in the guides, and directory nesting is not an extremely early-stage Ember feature. That said, most Ember developers encounter a need or desire to group components together relatively quickly, and it does make sense to cover it.</p>
<p>RFC #311 introduced a normalization rule for angle bracket invocation, and the guides mention that <code>&lt;NavBar&gt;</code> invokes a component that appears in the file system as <code>nav-bar</code>.</p>
<p><img src="/images/457-dasherization.jpg" alt="rental-listing in the docs" /></p>
<p>After this RFC, the documentation should add a &quot;Zoey says&quot; sidebar that describes the rule in more detail, and mentions that you can refer to components nested in a directory with the <code>::</code> separator.</p>
<p>Finally, the goal of this RFC is to make it possible to recommend that users always use angle-bracket invocation for components other than control flow (<code>if</code>, <code>each</code>).</p>
<p>This means that we should update the syntax conversion guide to no longer say that <code>{{</code> syntax is sometimes required, and avoid recommending it.</p>
<p>We should also recommend that component authors who are using positional parameters (other than control flow components like <code>liquid-if</code>) should stabilize, document and recommend named argument for their parameters so that their users can uniformly use angle bracket invocation syntax.</p>
<h2 id="drawbacks-and-alternatives"><a class="header" href="#drawbacks-and-alternatives">Drawbacks and Alternatives</a></h2>
<p>This RFC introduces another normalization rule--Ember developers will need to understand that <code>::</code> refers to nested directories in the file system. It also introduces another divergence from the <code>{{</code> syntax, which already uses <code>/</code> for the same purpose.</p>
<p>Alternatively, we could use <code>/</code> as the separator for the same purpose. This would have the benefit of matching the idiomatic way that people describe file system nesting as well as matching the existing <code>{{</code> syntax.</p>
<p>On the other hand, it has poor syntax highlighting in virtually all existing highlighters:</p>
<pre><code class="language-hbs">&lt;AppIcons::Warning&gt;&lt;/AppIcons::Warning&gt;
&lt;AppIcons/Warning&gt;&lt;/AppIcons/Warning&gt;
</code></pre>
<p>Additionally, some autocomplete systems assume that <code>&lt;AppIcons/</code> is the beginning of a self-closing tag.</p>
<p><img src="/images/457-autocomplete-problem.gif" alt="an example of an IDE confusing this syntax as a self-closing tag" /></p>
<p>Another drawback of this proposal is that it uses <code>::</code> syntax for today's templates, and we don't expect that syntax to be relevant to templates using template imports. It's possible that we would want to use this syntax, which might be considered valuable, in templates using template imports. That said, there is no specific proposal for what we might want to use this syntax for, and we could compatibly reclaim it in the context of template imports, at the cost of some mental churn.</p>
<p>Another alternative is to recommend that people use <code>#let</code> with <code>(component)</code> in situations where nesting is required.</p>
<pre><code class="language-hbs">{{#let (component 'app-icons/warning') as |Warning|}}
  &lt;Warning&gt;&lt;/Warning&gt;
{{/let}}
</code></pre>
<p>The primary drawback of this approach is that the need to group components together in directories comes up earlier in the typical Ember developer's experience than learning the ins and outs of <code>let</code> and the <code>component</code> helper. It seems likely that developers could encounter a desire to group components in directories even before they have a full understanding of <code>let</code> and block parameters.</p>
<p>Secondarily, this is a fairly verbose syntax that introduces a significant cliff from top-level components to grouped components.</p>
<p>Another alternative is to introduce a new non-block syntax for bringing components into scope, such as:</p>
<pre><code class="language-hbs">{{resolve-component 'app-icons/warning' as Warning}}

&lt;Warning&gt;&lt;/Warning&gt;
</code></pre>
<p>This avoids introducing rightward drift, but it is still relatively verbose. It also creates a question that we would need to provide guidance on whether people should use this feature for all components or just nested ones (both sides have plausible arguments).</p>
<p>I also comes at the cost of creating a brand new way to bring variables into scope in Glimmer templates. Up to this point, we have carefully maintained the constraint that variables come into scope using nesting and <code>as |name|</code> syntax. While we might be willing to introduce new variable binding forms in the future, adding such a form to this proposal would significantly increase its design scope, and maintaining a small scope is a key goal of this RFC.</p>
<p>Another alternative is to avoid introducing a solution to this problem, and wait for the expected longer-term solution, template imports. While this is indeed expected to serve our longer-term goals, it would mean that Ember users couldn't use angle-bracket invocation, with all the benefits they bring, with nested components, or choose not to nest components at all.</p>
<p>On balance, it seems better to introduce an interim syntax that restores feature parity with curly invocation.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-05
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/459
Tracking: https://github.com/emberjs/rfc-tracking/issues/36</p>
<hr />
<h1 id="angle-bracket-invocations-for-built-in-components"><a class="header" href="#angle-bracket-invocations-for-built-in-components">Angle Bracket Invocations For Built-in Components</a></h1>
<h2 id="summary-114"><a class="header" href="#summary-114">Summary</a></h2>
<p><a href="./0311-angle-bracket-invocation.html">RFC #311</a> introduced the angle bracket
component invocation syntax. Many developers in the Ember community have since
adopted this feature with very positive feedback. This style of component
invocation will become the default style in the Octane edition and become the
primary way component invocations are taught.</p>
<p>However, Ember ships with three built-in components – <code>{{link-to}}</code>, <code>{{input}}</code>
and <code>{{textarea}}</code>. To date, it is not possible to invoke them with the angle
bracket syntax due to various API mismatches and implementation details.</p>
<p>This RFC proposes some small amendments to these APIs and their implementations
to allow them to be invoked with the angle bracket syntax, i.e. <code>&lt;LinkTo&gt;</code>,
<code>&lt;Input&gt;</code> and <code>&lt;Textarea&gt;</code>.</p>
<h2 id="motivation-114"><a class="header" href="#motivation-114">Motivation</a></h2>
<p>As mentioned above, this will allow Ember developers to invoke components with
a consistent syntax, which should make it easier to teach.</p>
<p>This RFC <em>does not</em> aim to &quot;fix&quot; issues or quirks with the existing APIs – it
merely attempts to provide a way to do the equivalent invocation in angle
bracket syntax.</p>
<h2 id="detailed-design-97"><a class="header" href="#detailed-design-97">Detailed design</a></h2>
<h3 id="linkto"><a class="header" href="#linkto"><code>&lt;LinkTo&gt;</code></a></h3>
<p>There are two main problem with <code>{{link-to}}</code>:</p>
<ul>
<li>It uses positional arguments as the main API.</li>
<li>It supports an &quot;inline&quot; form (i.e. without a block).</li>
</ul>
<p>In the new world, components are expected to work with named arguments. This is
both to improve clarity and to match the HTML tags model (which angle bracket
invocations are loosely modelled after). Positional arguments are reserved for
&quot;control-flow-like&quot; components (e.g. <code>liquid-if</code>) and to be paired with the
curly bracket invocation style. Since links are not that, it is not appropiate
for this component to use positional params.</p>
<p>When invoked with a block, the first argument is the route to navigate to. We
propose to name this argument explicitly, with <code>@route</code>:</p>
<pre><code class="language-hbs">{{#link-to &quot;about&quot;}}About Us{{/link-to}}

...becomes...

&lt;LinkTo @route=&quot;about&quot;&gt;About Us&lt;/LinkTo&gt;
</code></pre>
<p>The second argument can be used to provide a model to the route. We propose to
name this argument explicitly, with <code>@model</code>:</p>
<pre><code class="language-hbs">{{#let this.model.posts.firstObject as |post|}}

  {{#link-to &quot;post&quot; post}}Read {{post.title}}...{{/link-to}}

  ...becomes...

  &lt;LinkTo @route=&quot;post&quot; @model={{post}}&gt;Read {{post.title}}...&lt;/LinkTo&gt;

{{/let}}
</code></pre>
<p>In fact, it is possible to pass multiple models to deeply nested routes with
additional positional arguments. For this use case, we propose the <code>@models</code>
named argument which accepts an array:</p>
<pre><code class="language-hbs">{{#let this.model.posts.firstObject as |post|}}
  {{#each post.comments as |comment|}}

    {{#link-to &quot;post.comment&quot; post comment}}
      Comment by {{comment.author.name}} on {{comment.date}}
    {{/link-to}}

    ...becomes...

    &lt;LinkTo @route=&quot;post.comment&quot; @models={{array post comment}}&gt;
      Comment by {{comment.author.name}} on {{comment.date}}
    &lt;/LinkTo&gt;

  {{/each}}
{{/let}}
</code></pre>
<p>The singular <code>@model</code> argument is a special case of <code>@models</code>, provided as a
convenience for the common case. Passing both <code>@model</code> and <code>@models</code> will be an
error. Passing insufficient amount of models for the given route, will continue
to be an error.</p>
<p>It is also possible to pass query params to the <code>{{link-to}}</code> component with
the somewhat awkward <code>(query-params)</code> API. We propose to replace it with a
<code>@query</code> named argument that simply take a regular hash (or POJO):</p>
<pre><code class="language-hbs">{{#link-to &quot;posts&quot; (query-params direction=&quot;desc&quot; showArchived=false)}}
  Recent Posts
{{/link-to}}

...becomes...

&lt;LinkTo @route=&quot;posts&quot; @query={{hash direction=&quot;desc&quot; showArchived=false}}&gt;
  Recent Posts
&lt;/LinkTo&gt;
</code></pre>
<p>Finally, as mentioned above, <code>{{link-to}}</code> supports an &quot;inline&quot; form without a
block. This form doesn't bring much value and causes confusion around
the ordering of the arguments. We propose to simply not support this for the
angle bracket invocation style:</p>
<pre><code class="language-hbs">{{link-to &quot;About Us&quot; &quot;about&quot;}}

...becomes...

&lt;LinkTo @route=&quot;about&quot;&gt;About Us&lt;/LinkTo&gt;
</code></pre>
<p>Other APIs of this compoment are already based on named arguments.</p>
<h4 id="migration-path-3"><a class="header" href="#migration-path-3">Migration Path</a></h4>
<p>We would provide a codemod to convert the old invocation style into the new
style.</p>
<h4 id="template-lints"><a class="header" href="#template-lints">Template Lints</a></h4>
<p>Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, <code>{{link-to}}</code> would still work and
invoke the same component.</p>
<p>We propose to add template lint rules to using this component with the curly
invocation style.</p>
<h3 id="input"><a class="header" href="#input"><code>&lt;Input&gt;</code></a></h3>
<p>Today, the <code>{{input}}</code> component is internally implemented as several internal
components that are selected based on the <code>type</code> argument. This is intended as
an internal implementation detail, but as a result, it is not possible to invoke
the component with <code>&lt;Input&gt;</code> since it does not exist as a &quot;real&quot; component.</p>
<p>We propose to change this internal implementation strategy to make it possible
to invoke it with angle brackets just like any other components.</p>
<p>For example:</p>
<pre><code class="language-hbs">{{input type=&quot;text&quot; value=this.model.name}}

...becomes...

&lt;Input @type=&quot;text&quot; @value={{this.model.name}} /&gt;
</code></pre>
<p>Another example:</p>
<pre><code class="language-hbs">{{input type=&quot;checkbox&quot; name=&quot;email-opt-in&quot; checked=this.model.emailPreference}}

...becomes...

&lt;Input @type=&quot;checkbox&quot; @name=&quot;email-opt-in&quot; @checked={{this.model.emailPreference}} /&gt;
</code></pre>
<h4 id="migration-path-4"><a class="header" href="#migration-path-4">Migration Path</a></h4>
<p>We would provide a codemod to convert the old invocation style into the new
style.</p>
<h4 id="template-lints-1"><a class="header" href="#template-lints-1">Template Lints</a></h4>
<p>Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, <code>{{input}}</code> would still work and
invoke the same component.</p>
<p>We propose to add template lint rules to using this component with the curly
invocation style.</p>
<h3 id="textarea"><a class="header" href="#textarea"><code>&lt;Textarea&gt;</code></a></h3>
<p>Due to a similar implementation issue, it is also not possible to invoke the
<code>{{textarea}}</code> component with angle bracket invocation style.</p>
<p>We propose to change this internal implementation strategy to make it possible
to invoke this with angle brackets just like any other components.</p>
<p>For example:</p>
<pre><code class="language-hbs">{{textarea value=this.model.body}}

...becomes...

&lt;Textarea @value={{this.model.body}} /&gt;
</code></pre>
<h4 id="migration-path-5"><a class="header" href="#migration-path-5">Migration Path</a></h4>
<p>We would provide a codemod to convert the old invocation style into the new
style.</p>
<p><a href="./0176-javascript-module-api.html">RFC #176</a> picked <code>text-area</code>/<code>TextArea</code> for
this component. To prevent confusion, we will add a helpful hint to the error
message (&quot;did you mean <code>&lt;Textarea&gt;</code>?&quot;) when a user mistakenly typed
<code>{{text-area}}</code> or <code>&lt;TextArea&gt;</code> in development mode.</p>
<h4 id="template-lints-2"><a class="header" href="#template-lints-2">Template Lints</a></h4>
<p>Even though the angle bracket invocation style is recommended going forward,
components can generally be invoked using the either the curly or angle bracket
syntax. Therefore, while not recommended, <code>{{textarea}}</code> would still work and
invoke the same component.</p>
<p>We propose to add template lint rules to using this component with the curly
invocation style.</p>
<h2 id="how-we-teach-this-83"><a class="header" href="#how-we-teach-this-83">How we teach this</a></h2>
<p>Going forward, we will focus on teaching the angle bracket invocation style as
the main (only?) way of invoking components. In that world, there wouldn't be
anything extra to teach, as the invocation style proposed in this RFC is not
different from any other components, which is the purpose of this proposal. Of
course, the APIs of these components will still need to be taught, but that is
not a new change.</p>
<p>The only caveat is that, since the advanced <code>&lt;LinkTo&gt;</code> APIs require passing
arrays and hashes, the <code>{{array}}</code> and <code>{{hash}}</code> helper would have to be
taught before those advanced features can be introduced. However, since the
basic usage (linking to top-level routes) does not require either of those
helpers, it doesn't really affect things from a getting started perspective.</p>
<p>It should also be mentioned that, other built-ins, such as <code>{{yield}}</code>,
<code>{{outlet}}</code>, <code>{{mount}}</code>, etc are considered &quot;keywords&quot; not components, they
are also &quot;control-flow-like&quot;, so it wouldn't be appropiate to invoke them with
angle brackets.</p>
<p>The technical implementation of this RFC will need to be accompanied by changes to the API docs for the built-in template helpers, <a href="https://emberjs.com/api/ember/3.8/classes/Ember.Templates.helpers/methods/link-to?anchor=link-to">link-to</a> and <a href="https://emberjs.com/api/ember/3.8/classes/Ember.Templates.helpers/methods/input?anchor=input">input</a>. In keeping with past decisions for Angle Brackets, the API docs should show both curly and Angle Bracket invocations of these helpers. The API docs are expected to show the full supported API surface of Ember.</p>
<p><code>link-to</code> and <code>input</code> are used liberally throughout the Ember.js Guides, Tutorial, and <code>super-rentals</code> <a href="https://github.com/ember-learn/super-rentals">sample app</a>, so those examples will need to be updated. In the Guides, we want to show solely Angle Brackets invocation. The <a href="https://guides.emberjs.com/release/reference/syntax-conversion-guide/">syntax conversion guide</a> should be revised to include these helpers.</p>
<h2 id="drawbacks-107"><a class="header" href="#drawbacks-107">Drawbacks</a></h2>
<p>None.</p>
<h2 id="alternatives-110"><a class="header" href="#alternatives-110">Alternatives</a></h2>
<ul>
<li>
<p><code>&lt;LinkTo&gt;</code> could only support <code>@models</code> without special casing <code>@model</code> as a
convenience.</p>
</li>
<li>
<p><code>&lt;LinkTo&gt;</code> could support a <code>@text</code> argument for inline usage.</p>
</li>
<li>
<p><code>&lt;Textarea&gt;</code> could be named <code>&lt;TextArea&gt;</code>.</p>
</li>
</ul>
<h2 id="unresolved-questions-76"><a class="header" href="#unresolved-questions-76">Unresolved questions</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-06
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/460</p>
<hr />
<h1 id="yieldable-named-blocks"><a class="header" href="#yieldable-named-blocks">Yieldable Named Blocks</a></h1>
<h2 id="summary-115"><a class="header" href="#summary-115">Summary</a></h2>
<p>This RFC amends <a href="https://emberjs.github.io/rfcs/0226-named-blocks.html">#226 (named blocks)</a> to finalize the syntax of named blocks and reduce the scope of the feature.</p>
<h2 id="motivation-115"><a class="header" href="#motivation-115">Motivation</a></h2>
<p>The original named blocks RFC (#226) defined a mechanism for passing multiple blocks to a component, as well as semantics for capturing the block in JavaScript.</p>
<p>Since #226, RFC <a href="https://emberjs.github.io/rfcs/0311-angle-bracket-invocation.html">#311 (angle bracket invocation)</a> repurposed the original syntax for invocation.</p>
<pre><code class="language-hbs">&lt;Tab&gt;
  &lt;@header&gt;&lt;/@header&gt;
&lt;/Tab&gt;
</code></pre>
<p>In #226, the above syntax passed a named block called <code>@header</code> to the <code>Tab</code> component. RFC #311 repurposed that syntax to mean &quot;invoke the component located at <code>@header</code> in the default block of <code>Tab</code>&quot;.</p>
<p>Curly bracket components already support two blocks (the default block and the <code>else</code> block), while angle bracket components, as implemented today in Ember, only support a single default block.</p>
<p>While RFC #226 predates a formal RFC about angle bracket components, it speculates significantly about usage in angle bracket components, and is heavily motivated by the desire to support more than a single block in that context.</p>
<p>That said, #226 included significant additional scope beyond allowing angle bracket invocations to pass more than one block, including:</p>
<ul>
<li>using <code>&lt;@name&gt;</code> as a syntax for passing named blocks to curly components</li>
<li>passing named blocks as <code>@name</code> variables, accessible in the receiving component as <code>@blockName</code></li>
<li>capturing named blocks in JavaScript using <code>this.blockName</code>, as well as capturing named blocks in JavaScript by forwarding them into JavaScript as a parameter to a helper or another named argument.</li>
</ul>
<p>While versions of those features are all desirable, the RFC, in total, had a fairly large scope and also speculated a lot about the future of angle bracket components which would not be approved until RFC #311.</p>
<p>This RFC proposes a version of named blocks with a smaller scope, with a plan to reintroduce the other goals of the original named blocks RFC in a subsequent RFC.</p>
<blockquote>
<p>Note: The version of named blocks described in this RFC has already been implemented in Glimmer VM.</p>
</blockquote>
<h2 id="detailed-design-98"><a class="header" href="#detailed-design-98">Detailed design</a></h2>
<blockquote>
<p>The detailed design of this RFC assumes a starting point without RFC #226, and describes the functionality in terms of RFC #311.</p>
</blockquote>
<p>When invoking a component with angle bracket syntax, the content between the starting tag and the ending tag is passed as a block to the receiving component.</p>
<p>This means that the receiving component can invoke the block using <code>{{yield}}</code>. The block is not exposed to JavaScript at all, and it may only be invoked in the body of the receiving component's template.</p>
<p>On their own, blocks provide useful functionality. For example, consider an <code>Article</code> component that takes a <code>@body</code> argument:</p>
<pre><code class="language-hbs">&lt;Article @body={{this.body}} /&gt;
</code></pre>
<p>The <code>Article</code> component could be implemented this way:</p>
<pre><code class="language-hbs">&lt;article&gt;
  &lt;section&gt;{{@body}}&lt;/section&gt;
&lt;/article&gt;
</code></pre>
<p>This works, but what if you want to include HTML functionality or use helpers. In that case, you could use a block:</p>
<pre><code class="language-hbs">&lt;Article&gt;
  &lt;div class='byline'&gt;{{byline this.author}}&lt;/div&gt;
  &lt;div class='body'&gt;{{this.body}}&lt;/div&gt;
&lt;/Article&gt;
</code></pre>
<p>The <code>Article</code> component could then be implemented by using <code>{{yield}}</code> to invoke the block:</p>
<pre><code class="language-hbs">&lt;article&gt;
  &lt;section&gt;{{yield}}&lt;/section&gt;
&lt;/article&gt;
</code></pre>
<p>But what if we also want the ability to pass a title to the component. We could use a <code>@title</code> argument:</p>
<pre><code class="language-hbs">&lt;Article @title={{this.title}}&gt;
  &lt;div class='byline'&gt;{{byline this.author}}&lt;/div&gt;
  &lt;div class='body'&gt;{{this.body}}&lt;/div&gt;
&lt;/Article&gt;
</code></pre>
<p>Implemented this way:</p>
<pre><code class="language-hbs">&lt;article&gt;
  &lt;header&gt;{{@title}}&lt;/header&gt;
  &lt;section&gt;{{yield}}&lt;/section&gt;
&lt;/article&gt;
</code></pre>
<p>Again, that works, but if you want to use any of the block features, such as the ability to use HTML, you can't pass a second block.</p>
<p>This RFC introduces the ability to pass any number of blocks to a component. With that capability, you could call <code>Article</code> this way:</p>
<pre><code class="language-hbs">&lt;Article&gt;
  &lt;:title&gt;
    &lt;h1&gt;{{this.title}}&lt;/h1&gt;
  &lt;/:title&gt;
  &lt;:body&gt;
    &lt;div class='byline'&gt;{{byline this.author}}&lt;/div&gt;
    &lt;div class='body'&gt;{{this.body}}&lt;/div&gt;
  &lt;/:body&gt;
&lt;/Article&gt;
</code></pre>
<p>And implement it this way:</p>
<pre><code class="language-hbs">&lt;article&gt;
  &lt;header&gt;{{yield to='title'}}&lt;/header&gt;
  &lt;section&gt;{{yield to='body'}}&lt;/section&gt;
&lt;/article&gt;
</code></pre>
<h3 id="block-parameters-1"><a class="header" href="#block-parameters-1">Block Parameters</a></h3>
<p>Just like normal blocks, named blocks can take block parameter, which are passed via <code>yield</code>.</p>
<pre><code class="language-hbs">&lt;Article @article={{this.article}}&gt;
  &lt;:header as |title|&gt;
    &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;/:header&gt;
  &lt;:body as |body|&gt;
    &lt;div&gt;{{body}}&lt;/div&gt;
  &lt;/:body&gt;
&lt;/Article&gt;
</code></pre>
<pre><code class="language-hbs">&lt;article&gt;
  &lt;header&gt;{{yield @article.title to='header'}}&lt;/header&gt;
  &lt;section&gt;{{yield @article.body to='body'}}&lt;/section&gt;
&lt;/article&gt;
</code></pre>
<p>To summarize, today's Ember allows all components to pass a default block, and curly components to pass a default block and an <code>inverse</code> block. Component templates can invoke default templates by using <code>{{yield}}</code> and <code>else</code> templates by using <code>{{yield to='inverse'}}</code>.</p>
<p>This RFC introduces a new syntax for passing arbitrary blocks to angle bracket components that can be invoked by the receiving component using the same <code>yield</code> syntax.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>This RFC proposes an extension to the angle bracket invocation syntax.</p>
<p>From:</p>
<pre><code>AngleBracketInvocation :
  | AngleBracketWithBlock
  | AngleBracketWithoutBlock

AngleBracketWithBlock :
  &quot;&lt;&quot; ComponentTag ComponentArgs? BlockParams? &quot;&gt;&quot;
  Block
  &quot;&lt;/&quot; ComponentTag &quot;&gt;&quot;

AngleBracketWithoutBlock :
  &quot;&lt;&quot; ComponentTag ComponentArgs? &quot;/&gt;&quot;
</code></pre>
<p>To:</p>
<pre><code>AngleBracketInvocation :
  | AngleBracketWithBlocks
  | AngleBracketWithBlock
  | AngleBracketWithoutBlock

AngleBracketWithBlock :
  &quot;&lt;&quot; ComponentTag ComponentArgs? BlockParams? &quot;&gt;&quot;
  BlockBody
  &quot;&lt;/&quot; ComponentTag &quot;&gt;&quot;

AngleBracketWithBlocks :
  &quot;&lt;&quot; ComponentTag ComponentArgs? &quot;&gt;&quot;
  NamedBlock+
  &quot;&lt;/&quot; ComponentTag &quot;&gt;&quot;

NamedBlock :
  | &quot;&lt;:&quot; Identifier &quot;/&gt;&quot;
  | &quot;&lt;:&quot; Identifier BlockParams? &quot;&gt;&quot; BlockBody &quot;&lt;/:&quot; Identifier &quot;&gt;&quot;

AngleBracketWithoutBlock :
  &quot;&lt;&quot; ComponentTag ComponentArgs? &quot;/&gt;&quot;

ComponentTag :
  | Identifier ; when ident is in scope variable
  | Path
  | AtName
</code></pre>
<p>A component invocation has named blocks if the first non-whitespace token after the invocation's closing <code>&quot;&gt;&quot;</code> is <code>&quot;&lt;:&quot;</code>. In that case, the whitespace around the named blocks is ignored. Otherwise, the contents between <code>&quot;&gt;&quot;</code> and <code>&quot;&lt;/&quot;</code> are the default block.</p>
<p>This RFC does not propose an extension to curly syntax, although a future extension to curly syntax is expected.</p>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p>A named block in angle bracket invocation has identical semantics to the <code>inverse</code> block created by <code>{{else}}</code>. It is invoked in the receiving component by <code>{{yield to='&lt;Identifier&gt;'}}</code>. Block parameters may appear after <code>&lt;:identifier</code> as <code>&lt;:identifier as |block params|&gt;</code>, and they are passed by the receiving component through positional parameters to <code>{{yield}}</code>.</p>
<p>In all observable ways, named blocks passed by angle bracket components behave like the <code>inverse</code> block passed by curly components.</p>
<p>This includes <code>has-block</code> and <code>has-block-params</code>, which take the name of the block as a parameter.</p>
<p>This RFC intentionally does not reify the block as an argument, either as an <code>@name</code> or into JavaScript. A future RFC is expected to specify and describe this kind of capturing semantics.</p>
<h2 id="how-we-teach-this-84"><a class="header" href="#how-we-teach-this-84">How we teach this</a></h2>
<p>This feature could be taught by example, using a situation where multiple blocks are relevant.</p>
<p>For example, the guides could describe an accordion widget, with two named blocks:</p>
<pre><code class="language-hbs">&lt;Article&gt;
  &lt;:title&gt;This article is awesome!&lt;/:title&gt;

  &lt;:body&gt;
    My blog has very awesome content, and everyone should
    read it.
  &lt;/:body&gt;
&lt;/Article&gt;
</code></pre>
<p>It should be taught after <code>yield</code>, so that describing how to implement a component that uses named blocks can lean on the existing knowledge of <code>yield</code>.</p>
<pre><code class="language-hbs">&lt;div class=&quot;accordion&quot;&gt;
  &lt;h1&gt;{{yield to='title'}}&lt;/h1&gt;
  &lt;div class=&quot;body&quot;&gt;{{yield to='body'}}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="drawbacks-108"><a class="header" href="#drawbacks-108">Drawbacks</a></h2>
<p>This feature introduces the concept of arbitrary named blocks, which adds cognitive overhead to the component model. On the other hand, it leans on the existing concept of blocks, including the existing well-trod syntax for block parameters and yielding.</p>
<p>Unlike the original #226, this RFC chooses not to provide a counterpart to this feature in curly components. RFC #226 used angle-bracket syntax inside of curly components for specifying named blocks:</p>
<pre><code class="language-hbs">{{#await this.article}}
  &lt;@loaded as |article|&gt;
    &lt;article&gt;
      &lt;header&gt;&lt;h1&gt;{{article.title}}&lt;/h1&gt;&lt;/header&gt;
      &lt;section&gt;{{article.body}}&lt;/section&gt;
    &lt;/article&gt;
  &lt;/@loaded&gt;
  &lt;@error as |reason|&gt;
    &lt;p class='error'&gt;Couldn't load article: {{reason}}&lt;/p&gt;
  &lt;/@error&gt;
  &lt;@loading&gt;
    &lt;img src=&quot;/assets/loading.gif&quot;&gt;
  &lt;/@loading&gt;
{{/await}}
</code></pre>
<p>This was always a strange syntax, and this RFC prefers to consider alternatives once named blocks in angle bracket syntax has been absorbed.</p>
<p>Additionally, it might make sense to support named blocks together with <code>else</code>, and defining the semantics for that behavior requires additional design.</p>
<p>One possible design contemplated by the authors of this RFC would look something like:</p>
<pre><code class="language-hbs">{{#await this.article}}
{{when :loaded}}
  &lt;article&gt;
    &lt;header&gt;&lt;h1&gt;{{article.title}}&lt;/h1&gt;&lt;/header&gt;
    &lt;section&gt;{{article.body}}&lt;/section&gt;
  &lt;/article&gt;
{{when :error}}
  &lt;p class='error'&gt;Couldn't load article: {{reason}}&lt;/p&gt;
{{else}}
  &lt;img src=&quot;/assets/loading.gif&quot;&gt;
{{/await}}
</code></pre>
<p>In this design, the <code>else</code> block would be rendered if none of the other named blocks were rendered, which is similar to the semantics of <code>{{#each}}</code>, which invokes the <code>else</code> block if the block passed to <code>#each</code> is never invoked (because the iterator had no values).</p>
<p>This design could make sense if curly invocation ends up being useful in the long-term for control flow (equivalent to <code>if</code>, <code>let</code> and <code>each</code>). The idea would be that in curly invocation, only one of the cases is expected to be invoked at a time, and if none of the cases are invoked, the <code>else</code> block is invoked.</p>
<p>This is just one possible design for curlies, but it is a possible design that the RFC authors believe should be explored separately.</p>
<h2 id="alternatives-111"><a class="header" href="#alternatives-111">Alternatives</a></h2>
<p>This RFC chooses not to specify &quot;block capturing&quot;, which is useful for features like <code>ember-elsewhere</code>. It's a genuinely useful feature that we expect to be specified in the future. However, that design is orthogonal to the use-cases anticipated by yieldable named blocks.</p>
<p>We could wait for a complete design on either (a) named blocks in curly components or (b) capturable named blocks. However, we believe that there's enough standalone value in this RFC to justify shipping it before finalizing either of those two designs.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-06
RFC PR: https://github.com/emberjs/rfcs/pull/461
Tracking: https://github.com/emberjs/rfc-tracking/issues/51</p>
<hr />
<h1 id="singleton-record-data"><a class="header" href="#singleton-record-data">Singleton Record Data</a></h1>
<h2 id="summary-116"><a class="header" href="#summary-116">Summary</a></h2>
<p>Ensures that <code>RecordData</code> can be implemented as a singleton, eliminates several redundant APIs
that creeped into the original implementation, and simplifies the method signatures of
RecordData APIs by using <a href="https://github.com/emberjs/rfcs/pull/403"><code>Identifiers</code></a>.</p>
<h2 id="motivation-116"><a class="header" href="#motivation-116">Motivation</a></h2>
<p><code>RecordData</code> is the data-cache primitive for information given to <code>ember-data</code>, and while
a cache-per-entity setup is sometimes desired, a singleton cache offers opportunities for
performance optimization and improved feature sets. Current default <code>RecordData</code>, and
<code>InternalModel</code> which it replaced are examples of cache-per-entity strategies.</p>
<p>Our original intent <a href="https://github.com/emberjs/rfcs/pull/293">when discussing <code>RecordData</code></a>
was for it to be possible to be implemented as a singleton; however, this intent was not
captured well in that RFC and while the APIs presented there would have enabled it, the
actual implementation differed in ways that prevent <code>singleton</code> implementations.</p>
<p>The introduction of <code>Identifiers</code> presents us with a good opportunity to refactor the API
surface of our cache-primitive, simplifying and streamlining how it works while solidifying
and codifying its ability to be a <code>singleton</code>.</p>
<h3 id="reduce-overloading"><a class="header" href="#reduce-overloading">Reduce Overloading</a></h3>
<p>Previously, to deal with the lack of a unified identifier concept, we overloaded many
<code>StoreWrapper</code> and <code>RecordData</code> method signatures with <code>modelName, id, clientId</code> as
<code>arguments</code>. The original intent was to overload <strong>all</strong> of their method signatures
in this way to ensure <code>singleton</code> implementations could be built, but we failed to
correctly implement the original <code>RecordData RFC</code> in this regard.</p>
<p>The introduction of <code>Identifiers</code> provides us a cleaner interface for communicating identity
in these APIs. For uniformity, methods will always take an <code>identifier</code> as their <strong>first
argument</strong>.</p>
<h2 id="detailed-design-99"><a class="header" href="#detailed-design-99">Detailed design</a></h2>
<p>Because <code>RecordData</code> is a public userland interface we
must rely on capabilities reporting to handle the
deprecations for it introduced by this RFC.</p>
<p>We will use this opportunity to improve the encapsulation
of <code>RecordData</code> via introduction of a sandbox.</p>
<p>This sandbox will be responsible for handling interop,
deprecations and other book-keeping tasks we require as needed
while ensuring that <code>RecordData</code> implementations are properly
encapsulated (e.g. implementations can only talk to other
implementations via public API).</p>
<p>RecordData implementations must now specify a <code>version</code>.
The implicit version when unspecified is <code>&quot;1&quot;</code> (the version
which this RFC supplants and deprecates). Implementations
without a version or with a version equal to <code>&quot;1&quot;</code> will
receive a deprecation notice the first time an instance of
a previously unseen <code>RecordData</code> class is encountered.</p>
<p>In keeping with the support policy of <code>Ember.js</code>, future
releases of <code>ember-data</code> will support the versions of <code>RecordData</code>
current at the time of the last two <code>ember-data</code> <code>LTS</code> releases.</p>
<p>The APIs proposed by this RFC constitute version <code>&quot;2&quot;</code>
and will be used by <code>ember-data</code> when the following is
<code>true</code>.</p>
<pre><code class="language-js">recordData.version === &quot;2&quot;;
</code></pre>
<p>It is possible that once this upgrade to <code>identifiers</code> has occurred that we never need to
increment this <code>version</code> again. If so, a future RFC may choose to deprecate the <code>version</code>
property altogether once &quot;version 1&quot; is no longer supported.</p>
<h3 id="sandboxing"><a class="header" href="#sandboxing">Sandboxing</a></h3>
<p>The sandbox implementation would guarantee the following</p>
<p>Beginning with this RFC, <code>StoreWrapper.recordDataFor</code> will no longer directly return the <code>RecordData</code>
instance provided by the <code>createRecordDataFor</code> hook, instead returning a delegate.</p>
<p>This encapsulates the <code>RecordData</code> feature ensuring that communication is via public API
and provides us the ability to manage the three concerns listed above and described below.</p>
<p><strong>Managing Deprecations</strong></p>
<p>When a <code>RecordData</code> method or method signature is deprecated, we will detect calls to deprecated
methods or calls using deprecated method signatures and print the appropriate deprecation messages.</p>
<p><strong>Version Interop</strong></p>
<p>When a <code>RecordData</code> method or method signature is deprecated the instance provided by <code>createRecordDataFor</code>
may not have implemented the deprecated method or signature. Using the supplied version, calling context,
and other information available we will transform calls to deprecated methods or signatures
into their supported equivalent.</p>
<p><strong>Updates to Store Methods</strong></p>
<table>
<thead>
<tr>
<th>Old</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td width="50%" valign="top">
<pre><code class="language-ts">class Store {
  createRecordDataFor(
    modelName: string,
    id: string,
    clientId: string | null,
    storeWrapper
  ): RecordData;
  createRecordDataFor(
    modelName: string,
    id: null,
    clientId: string,
    storeWrapper
  ): RecordData {}
}
</code></pre>
</td>
<td valign="top">
<pre><code class="language-ts">class Store {
  createRecordDataFor(identifier: RecordIdentifier, storeWrapper): RecordData {}
}
</code></pre>
</td>
</tr>
</tbody>
</table>
<p><strong>Updates to StoreWrapper Methods</strong></p>
<table>
<thead>
<tr>
<th>Old</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top">
<pre><code class="language-ts">class RecordDataStoreWrapper {
  recordDataFor(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): RecordData {}

  notifyPropertyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  notifyHasManyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  notifyBelongsToChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  attributesDefinitionFor(modelName: string): AttributesSchema {}

  relationshipsDefinitionFor(modelName: string): RelationshipsSchema {}

  setRecordId(modelName: string, id: string, clientId: string): void {}

  disconnectRecord(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): void {}

  @deprecated // Use hasRecord
  isRecordInUse(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): boolean {}

  inverseForRelationship(modelName: string, key: string): string {}
  inverseIsAsyncForRelationship(modelName: string, key: string): boolean {}
}
</code></pre>
</td>
<td valign="top">
<pre><code class="language-ts">class RecordDataStoreWrapper {
  recordDataFor(identifier: RecordIdentifier): RecordData {}

  @deprecated // use notifyChange instead
  notifyPropertyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  @deprecated // not in the original RFC, use notifyChange instead
  notifyHasManyChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  @deprecated // not in the original RFC, use notifyChange instead
  notifyBelongsToChange(
    modelName: string,
    id: string | null,
    clientId: string | null,
    key: string
  ): void {}

  // replaces notifyErrorsChange introduced by RecordData Errors RFC
  notifyChange(
    identifier: RecordIdentifier,
    namespace: &quot;errors&quot; | &quot;relationships&quot; | &quot;attributes&quot; | &quot;meta&quot; | &quot;state&quot;
  ): void {}

  attributesDefinitionFor(identifier: RecordIdentifier): AttributesSchema {}

  relationshipsDefinitionFor(
    identifier: RecordIdentifier
  ): RelationshipsSchema {}

  setRecordId(identifier: RecordIdentifier, id: string): void {}

  disconnectRecord(identifier: RecordIdentifier): void {}

  @deprecated // Use hasRecord
  isRecordInUse(
    modelName: string,
    id: string | null,
    clientId: string | null
  ): boolean {}

  hasRecord(identifier: RecordIdentifier): boolean {}

  inverseForRelationship(identifier: RecordIdentifier, key: string): string {}
  inverseIsAsyncForRelationship(
    identifier: RecordIdentifier,
    key: string
  ): boolean {}
}
</code></pre>
</td>
</tr>
</tbody>
</table>
<p><strong>Updates to RecordData Methods</strong></p>
<table>
<thead>
<tr>
<th>Old</th>
<th>New</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top">
<pre><code class="language-ts">interface LegacyResourceIdentifierObject {
  type: string;
  id: string | null;
  clientId: string | null;
}

interface RecordDataV1 {
  unloadRecord(): void;

  @deprecated // This RFC deprecates this method without replacement. It was not in
  // the original RecordData RFC and after investigation is unneeded once the singleton
  // and identifiers refactoring are completed.
  isRecordInUse(): boolean;
  isEmpty(): boolean;
  isNew(): boolean;

  getAttr(propertyName: string): any;
  isAttrDirty(propertyName: string): boolean;
  changedAttributes(): AttributesChanges;
  hasChangedAttributes(): boolean;
  rollbackAttributes(): void;

  @deprecated // this RFC deprecates this method entirely
  getBelongsTo(propertyName: string): { data: LegacyResourceIdentifierObject };
  @deprecated // this RFC deprecates this method entirely
  getHasMany(propertyName: string): { data: LegacyResourceIdentifierObject[] };

  willCommit(): void;
  didCommit(data: any): void;

  @deprecated // this RFC deprecates this method entirely
  _initRecordCreateOptions(options: object): object;
  clientDidCreate(): void;

  @deprecated // this RFC deprecates this method entirely and without replacement
  getResourceIdentifier(): LegacyResourceIdentifierObject;

  // original RecordData RFC specified setBelongsTo
  // with the 2nd arg being LegacyResourceIdentifierObject
  // but that was not what the resulting implementation in
  // ember-data did
  setDirtyBelongsTo(propertyName: string, value: RecordData | null): void;

  // original RecordData RFC specified setAttribute
  // but that was not what the resulting implementation in
  // ember-data did
  setDirtyAttribute(propertyName: string, value: any): void;

  // original RecordData RFC specified setHasMany
  // with the 2nd arg being LegacyResourceIdentifierObject[]
  // but that was not what the resulting implementation in
  // ember-data did
  setDirtyHasMany(propertyName: string, value: RecordData[]): void;

  // original RecordData RFC specified addToHasMany
  // with the 2nd arg being LegacyResourceIdentifierObject[]
  // but that was not what the resulting implementation in
  // ember-data did
  addToHasMany(propertyName: string, values: RecordData[], startIndex?: number): void;

  // original RecordData RFC specified removeFromHasMany
  // with the 2nd arg being LegacyResourceIdentifierObject[]
  // but that was not what the resulting implementation in
  // ember-data did
  removeFromHasMany(propertyName: string, values: RecordData[]): void;

  @deprecated // this RFC deprecates this method entirely and without replacement
  removeFromInverseRelationships(isNew: boolean): void;
}
</code></pre>
</td>
<td valign="top">
<pre><code class="language-ts">interface RecordDataV2 {
  version: &quot;2&quot;;
  unloadRecord(identifier: Identifier);
  isEmpty(identifier: Identifier): boolean;
  isNew(identifier: Identifier): boolean;

  getAttr(identifier: Identifier, propertyName: string): any;
  isAttrDirty(identifier: Identifier, propertyName: string): boolean;
  changedAttrs(identifier: Identifier): AttributesChanges;
  hasChangedAttrs(identifier: Identifier): boolean;
  rollbackAttrs(identifier: Identifier): void;

  getRelationship(
    identifier: Identifier,
    propertyName: string
  ): { data: Identifier | Identifier[] };

  willCommit(identifier: Identifier): void;
  didCommit(identifier: Identifier, data: any);

  clientDidCreate(identifier: Identifier, options: object): void;

  setBelongsTo(
    identifier: Identifier,
    propertyName: string,
    value: Identifier | null
  ): void;

  setAttr(identifier: Identifier, propertyName: string, value: any): void;

  setHasMany(
    identifier: Identifier,
    propertyName: string,
    values: Identifier[]
  ): void;

  addToHasMany(
    identifier: Identifier,
    propertyName: string,
    values: Identifier[],
    startIndex?: number
  ): void;

  removeFromHasMany(
    identifier: Identifier,
    propertyName: string,
    values: Identifier[]
  ): void;
}
</code></pre>
</td>
</tr>
</tbody>
</table>
<h2 id="how-we-teach-this-85"><a class="header" href="#how-we-teach-this-85">How we teach this</a></h2>
<p><code>RecordData</code> is primarily an API meant for power-user addon-authors,
and not something we expect everyday users of <code>ember-data</code> to be intimately
familiar with. It is unlikely that we produce a <code>guide</code> for using <code>RecordData</code>, but
a public <code>typescript</code> interface for <code>RecordData</code> should be introduced with
API Documentation for the available APIs and their roles.</p>
<h2 id="drawbacks-109"><a class="header" href="#drawbacks-109">Drawbacks</a></h2>
<p>It introduces churn in APIs we only recently introduced (in the past 6 months); however we have
strong reason to believe that very few implementations exist and that those which do have their
migration path covered by the sandboxed RecordData implementation.</p>
<h2 id="alternatives-112"><a class="header" href="#alternatives-112">Alternatives</a></h2>
<ul>
<li>keep the status quo: large number of arguments to methods, no support for singleton RecordData,
renders <code>Identifier</code> RFC largely useless and makes future iteration on RecordData similarly difficult.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-13
Relevant Team(s): data
RFC PR: https://github.com/emberjs/rfcs/pull/463
Tracking: https://github.com/emberjs/rfc-tracking/issues/47</p>
<hr />
<h1 id="record-state-on-record-data-rfc"><a class="header" href="#record-state-on-record-data-rfc">Record State on Record Data RFC</a></h1>
<h2 id="summary-117"><a class="header" href="#summary-117">Summary</a></h2>
<p>This RFC is a follow-up RFC for #293 RecordData.</p>
<p>Add <code>isNew</code> , <code>isDeleted</code> and <code>isDeletionPersisted</code> methods on Record Data that expose information about newly created and deleted states on the record</p>
<h2 id="motivation-117"><a class="header" href="#motivation-117">Motivation</a></h2>
<p>RecordData handles managing local and server state for records. While the current API surface of RecordData handles most data wrangling needs, as we have used RD internally in ED and in addons we have repeatedly run into the need of knowing whether a record is in a new or a deleted state.  The initial version of Record Data made the choice to not expose state information in order to limit the scope of the RFC and to give us time to come up with a design.</p>
<h2 id="detailed-design-100"><a class="header" href="#detailed-design-100">Detailed design</a></h2>
<p>Add the following methods on the RecordData interface:</p>
<pre><code class="language-ts">interface RecordData {
    
  // To be added in this RFC
  isNew(identifier: RecordIdentifier): boolean

  isDeleted(identifier: RecordIdentifier): boolean

  isDeletionCommitted(identifier: RecordIdentifier): boolean
    
  setIsDeleted(identifier: RecordIdentifier, boolean: isDeleted): void
}
</code></pre>
<p><code>isNew</code> should return true if and only if the record with the given identifier was created on the client side (via clientDidCreate) and not successfully committed on the server, otherwise false.</p>
<p><code>isDeleted</code> should return true if and only if the record has been marked for deletion on the client side, otherwise false</p>
<p><code>isDeletionPersisted</code> should return true if and only if the record had been marked for deletion and that deletion has been successfully persisted, otherwise false.</p>
<p>The TS interface for the all of Record Data with the new methods can be be found <a href="https://github.com/emberjs/data/blob/igor/record-data-state-interface/packages/store/addon/-private/ts-interfaces/record-data.ts#L13">here</a>.</p>
<p>In order to notify changes to the state flags we would also add a notification method to the store wrapper which is passed to RecordData:</p>
<pre><code class="language-ts">interface RecordDataStoreWrapper {
  notifyStateChange(identifier: RecordIdentifier, key: 'isNew' | 'isDeleted' | 'isDeletionPersisted');
}
</code></pre>
<p>Which would bring Record Data Store Wrapper to look like:</p>
<pre><code class="language-ts">export interface RecordDataStoreWrapper {
  // This rfc
  notifyStateChange(identifier: RecordIdentifier, key: 'isNew' | 'isDeleted' | 'isDeletionPersisted');

  // Existing
  notifyAttributeChange(identifier: RecordIdentifier, key: string);
  notifyRelationshipChange(identifier: RecordIdentifier, key: string);
  notifyErrorsChange(identifier: RecordIdentifier, key: string);

  relationshipsDefinitionFor(identifier: RecordIdentifier): RelationshipsSchema
  attributesDefinitionFor(identifier: RecordIdentifier): AttributesSchema
  setRecordId(identifier: RecordIdentifier, id: string);
  disconnectRecord(identifier: RecordIdentifier);
  isRecordInUse(identifier: RecordIdentifier): boolean;
}
</code></pre>
<p>Currently calling <code>rollbackAttributes</code> rolls back <code>isDeleted</code> to a non deleted state. This logic would be the responsibility of Record Data to implement. </p>
<h2 id="how-we-teach-this-86"><a class="header" href="#how-we-teach-this-86">How we teach this</a></h2>
<p>We currently do not have a comprehensive way to teach RecordData api. This RFC will be tought alongisde the rest of upcoming Record Data docs. </p>
<h2 id="alternatives-113"><a class="header" href="#alternatives-113">Alternatives</a></h2>
<p>Instead of separate methods, have a single methods, somehting like <code>getState</code> that returns a POJO with keys like </p>
<pre><code>{ isDeleted: true, isNew: false }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-13
Relevant Team(s): data
RFC PR: https://github.com/emberjs/rfcs/pull/465
Tracking: https://github.com/emberjs/rfc-tracking/issues/46</p>
<hr />
<h1 id="record-data-errors-rfc"><a class="header" href="#record-data-errors-rfc">Record Data Errors RFC</a></h1>
<h2 id="summary-118"><a class="header" href="#summary-118">Summary</a></h2>
<p>This RFC is a follow-up RFC for #293 RecordData.</p>
<p>Exposes the content of Invalid Errors returned by the adapter on Record Data.</p>
<h2 id="motivation-118"><a class="header" href="#motivation-118">Motivation</a></h2>
<p>Currently Record Data manages and exposes all of the attributes and relationships for a record. However, the initial version of Record Data made the choice to not expose error information in order to limit the scope of the RFC and to give us time to come up with a design. This RFC, together with the Request State RFC, addresses this capability gap.</p>
<p>When a user sends a record save request, it can fail in two different ways:</p>
<ul>
<li>It can fail as a generic Adapter Error, and put the record in an <code>isError</code> state. This corresponds to any failure, including those such as the network being down, server returning 500s or the auth layer returning a 401. Because these errors are not tied to the Record or it's data, they do not belong in the Record Data layer and will be exposed separately as part of the Request State RFC</li>
<li>However, the request can also fail with a more specific <code>InvalidError</code> This currently puts the record in the <code>invalid</code> state. <code>InvalidError</code> corresponds to a specific validation failure of the request being made. Currently, the default adapter implementation creates an <code>InvalidError</code> if the server returns a <code>422</code> . <code>InvalidError</code> payload follows the JSON API error object spec, and if the error payload contains pointers those get mapped to attributes on a record. Because an Invalid Error maps to the data on a record, it should be managed by Record Data together with the attributes and relationships.</li>
</ul>
<h2 id="detailed-design-101"><a class="header" href="#detailed-design-101">Detailed design</a></h2>
<p>Currently on a failed save, Record Data receives a call to </p>
<p><code>commitWasRejected(recordIdentifier: RecordIdentifier): void;</code></p>
<p>This RFC proposes passing an optional errors object that would follow a subset of the JSON api errors spec, only in case an invalid error has been returned. We would also expose a getter for the errors.</p>
<pre><code class="language-ts">interface RecordValidationError {
  title: string;
  detail: string;
  source: {
    pointer: string;  &lt;relative to record&gt;
  }
}

interface RecordData {
  commitWasRejected(recordIdentifier: RecordIdentifier, errors?: RecordValidationError[]): void;
  getErrors(recordIdentifier: RecordIdentifier): RecordValidationError[]
}
</code></pre>
<p><code>RecordValidationError</code> follows the subset of the JSON api errors spec. For example, if the record being saved was rejected because the attribute <code>password</code> was empty, the <code>RecordValidationError</code> could look like: </p>
<pre><code class="language-ts">{
  title: 'Field cant be empty',
  detail: 'Field must be at least 8 characters long',
  source: {
    pointer: 'attributes/password'
  }
}
</code></pre>
<p>The source pointer is a JSON pointer relative to the Resource Object.</p>
<p>We would also add a method on the <code>RecordDataStoreWrapper</code> to enable Record Data to notify the store that the errors properties have changed.</p>
<pre><code class="language-ts">class RecordDataStoreWrapper {
  notifyErrorsChange(recordIdentifier: RecordIdentifier)
}
</code></pre>
<p>There would be no api for changing the errors from the client side, they would be read only from the perspective of the <code>DS.Model</code>  Currently <code>DS.Model</code>  exposes an <code>Errors</code> object, which has the behavior of removing errors if an attribute has been modified. This behavior would not be the responsibility of the <code>RecordData</code> layer which is tasked only with exposing the errors it received from the server and would remain an implementation detail of <code>DS.Model</code></p>
<h2 id="how-we-teach-this-87"><a class="header" href="#how-we-teach-this-87">How we teach this</a></h2>
<p>We currently do not have a comprehensive way to teach the RecordData api. This RFC will be taught alongisde the rest of upcoming Record Data docs. </p>
<h2 id="alternatives-114"><a class="header" href="#alternatives-114">Alternatives</a></h2>
<p>We could add a method to <code>RecordData</code> to make the errors setable from the model, something like <code>setErrors</code>. However, conceptually, because updated errors don't get sent back to the server they shouldn't be managed by the data cache layer. Removing or updating Error values should be the responsibility of the Model or UI layer.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-09
Relevant Team(s): data
RFC PR: https://github.com/emberjs/rfcs/pull/466
Tracking: https://github.com/emberjs/rfc-tracking/issues/52</p>
<hr />
<h1 id="request-state-service"><a class="header" href="#request-state-service">Request State Service</a></h1>
<h2 id="summary-119"><a class="header" href="#summary-119">Summary</a></h2>
<p>Currently, Ember Data internally uses a complicated state machine abstraction to help records keep track of what state they are in and expose state flags. A lot of those flags try to expose request state. Instead of relying on a complicated inflexible state machine, this RFC proposes exposing a Request State service which would expose inflight and completed requests.</p>
<h1 id="motivation-119"><a class="header" href="#motivation-119">Motivation</a></h1>
<p>Currently DS.Model has several flags that expose information about either inflight requests or completed requests. <code>isReloading</code> and <code>isSaving</code> expose inflight request state, while <code>isLoaded</code>, <code>isValid</code>, <code>isError</code>, expose state about the last completed request. While these flags are very convenient, the have several drawbacks:</p>
<ul>
<li>They rely on Ember Data's internal state machine which is not app controllable and is very inflexible</li>
<li>They assume a single source, and as we try to support more advanced use cases will prove insufficient. For example, if you are saving records both in IndexDB and on the backend, <code>isSaving</code> as a flag is insufficient.</li>
</ul>
<p>This RFC proposes creating a RequestState service which would allow us to rewrite the current flags as helper methods and move us away from the internal state machine implementations. It would also allow users to handle cases not covered by the rigid model flags, and give us a place to experiment with a multi source approach. Moreover, such a service would also allow for a better debugging experience and could be easily exposed in the Ember Inspector, allowing for a much nicer debugging experience compared to the existing Promises tab.</p>
<h2 id="detailed-design-102"><a class="header" href="#detailed-design-102">Detailed design</a></h2>
<p>This RFC exposes the minimal necessary set of APIs needed to reimplement the existing flags on DS.Models. In particular, it only covers requests pertaining to <code>findRecord</code> , <code>reload</code></p>
<p>and <code>save</code> methods. Those are also easier to design and implement because they match up to a single record and don't require a more complex <code>Query</code> interface. We would expect RequestState Services scope of responsibility to grow in the future to where it would handle all of requests.</p>
<p>Design of the RequestState service:</p>
<pre><code class="language-ts">// no id yet
interface Request {
  data: RequestOperation[];
}

interface RequestOperation {
  op: string
}

interface FindRecordRequestOp extends RequestOperation {
  op: 'findRecord'
  recordIdentifier: RecordIdentifier
  options: : { [k: string]: any }
}

interface SaveRecordRequestOp extends RequestOperation {
  op: 'saveRecord'
  recordIdentifier: RecordIdentifier
  options: : { [k: string]: any }
}

interface RequestState {
  state: 'pending' | 'fulfilled' | 'rejected'
  type: 'query' | 'mutation'
  request: Request;
  response?: Response;
}

interface Response {
  rawData: unknown;
  data: unknown;
}


// exported from '@ember-data/store';
function unsubscribe(token: UnsubscribeToken): void

interface NotificationCallback {
  (request: RequestState): void;
}

class RequestStateService {
  getPendingRequestsForRecord(recordIdentifier: RecordIdentifier): RequestState[]
  getLastRequestForRecord(recordIdentifier: RecordIdentifier): RequestState | null
  subscribeForRecord(recordIdentifier: RecordIdentifier, callback: NotificationCallback): UnsubscribeToken
  unsubcribe(token: UnsubscribeToken): void
}
</code></pre>
<p>The subscription methods are needed in order the model to learn about changes to network states. Once tracked properties exposes a public way for manipulating Tags, we will likely be able to move away from the subscription mechanism to a nicer notification mechanism.</p>
<p>Expose a service on the store</p>
<pre><code class="language-ts">class Store {
  getRequestStateService(): RequestStateService
}   
</code></pre>
<p>Using these  we can reimplement the current <code>isSaving</code> method on <code>DS.Model</code></p>
<p>The subscription mechanism is deliberately somewhat klunky in anticipation of replacing it with an automatic tracked properties solution.</p>
<pre><code class="language-ts">DS.Model.extend({

  isSaving: computed(function () {
    let requests = this.store.getRequestStateService().getPending(this);
    return !!requests.find((req) =&gt; req.data.op === 'saveRecord');
  })

});
</code></pre>
<pre><code class="language-ts">DS.Model.extend({
  isSaving: computed(function () {
    let requests = this.store.getRequestStateService().getPending(this);
    return !!requests.find((req) =&gt; req.data.op === 'saveRecord');
  })

});
</code></pre>
<h2 id="how-we-teach-this-88"><a class="header" href="#how-we-teach-this-88">How we teach this</a></h2>
<p>Initially we would write up the API docs for the request. Once several followup RFCs which made the design ergonomic and added other use cases,
we would write up a guide entry showing common ways to handle request based use cases with the request state service.</p>
<h2 id="drawbacks-110"><a class="header" href="#drawbacks-110">Drawbacks</a></h2>
<p>We are exposing more internal state as public api.</p>
<p>The subscription mechanism is not extremely ergonomic.</p>
<p>Exposing the raw results in request objects might lead to apps using the raw payloads and punching wholes through our existing api boundaries</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-14
Relevant Team(s): Ember.js, Ember Data, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/468
Tracking: https://github.com/emberjs/rfc-tracking/issues/55</p>
<hr />
<h1 id="classic-decorator"><a class="header" href="#classic-decorator"><code>@classic</code> Decorator</a></h1>
<h2 id="summary-120"><a class="header" href="#summary-120">Summary</a></h2>
<p>Add a set of warnings for users who adopt native class syntax with
<code>EmberObject</code> base classes, and a <code>@classic</code> decorator which can be used to
disable these warnings on a per-class basis.</p>
<h2 id="motivation-120"><a class="header" href="#motivation-120">Motivation</a></h2>
<p>As we've added native class support to Ember and moved forward with Ember
Octane, it's become increasingly clear that there are still a number of strange
behaviors, edge-cases, and other issues with adopting native class syntax and
extending from <code>EmberObject</code>. These issues include:</p>
<ul>
<li>The timings of <code>init</code> and <code>constructor</code>, and how the two can interact through
a class hierachy in a way that causes confusing failures.</li>
<li>The differences between class fields and properties, and how class fields can
override properties even in a subclass.</li>
<li>The use of Mixins, which lack a native class alternative, and can force users
to interop and have even more failure cases.</li>
</ul>
<p>Despite these edge cases, the community has made progress using native class
syntax, and it is absolutely necessary for some users (<code>ember-cli-typescript</code>
users in particular). The ability to transition progressively to a new syntax is
also very valuable, and allowing users to adopt native class syntax <em>without</em>
completely rewriting their classes means that they can upgrade one step at a
time.</p>
<p>However, as we begin to move into a world where more and more classes <em>don't</em>
extend from <code>EmberObject</code> (starting with <code>GlimmerComponent</code>), these edge cases
will become more common and confusing. It won't be enough to rely on simple
rules of thumb like &quot;always use <code>init</code>&quot; because in some cases, there won't <em>be</em>
an <code>init</code> method. It'll also become a question of &quot;which class am I extending?
<code>GlimmerComponent</code>? <code>EmberComponent</code>?</p>
<p>This RFC proposes adding a <code>@classic</code> decorator which can be used on classes
that still use <code>EmberObject</code> APIs:</p>
<pre><code class="language-js">import classic from 'ember-classic-decorator';

@classic
export default class ApplicationController extends Controller {
  init() {
    super.init(...arguments);
    // setup the controller class
  }
}
</code></pre>
<p>This decorator will:</p>
<ol>
<li>Provide a visual hint to users that they class they are working on uses
<code>EmberObject</code> specific functionality, and to be aware that they are not
working with &quot;just&quot; native classes.</li>
<li>Provide a hint to <em>linters</em> so that they can use a different set of rules for
&quot;classic&quot; classes, such as always use <code>init</code>, etc. and native classes, such
as to never use <code>.extend()</code> or mixins.</li>
<li>Disable a number of warnings that will alert users when they have encountered
an edge case, such as using <code>init</code> in a parent class and <code>constructor</code> in a
child class.</li>
</ol>
<p>This should allow users who wish to adopt native class syntax to do so
incrementally, one change at a time, with as much safety as possible.</p>
<h2 id="detailed-design-103"><a class="header" href="#detailed-design-103">Detailed design</a></h2>
<p>There are roughly two categories of base classes in Ember:</p>
<ol>
<li>Base classes which do not have alternatives, <em>and</em> use a very minimal amount
of <code>EmberObject</code> APIs
<ul>
<li><code>Route</code></li>
<li><code>Controller</code></li>
<li><code>Service</code></li>
<li><code>Helper</code></li>
</ul>
</li>
<li>Base classes which have modern alternatives, <em>and</em> use a much larger amount
of <code>EmberObject</code> APIs:
<ul>
<li><code>Component</code>, which can be converted to <code>GlimmerComponent</code></li>
<li>Utility classes, which can be converted plain native classes that do not
extend <code>EmberObject</code></li>
</ul>
</li>
</ol>
<p><code>@classic</code> will work slightly differently for these two categories. We'll call
them <em>transitionable</em> and <em>non-transitionable</em> respectively.</p>
<h3 id="transitionable-base-classes"><a class="header" href="#transitionable-base-classes">Transitionable Base Classes</a></h3>
<p>Transitionable base classes can be converted to native classes safely <em>without</em>
using any <code>EmberObject</code> APIs. Once converted, we can safely lint against using
any <code>EmberObject</code> APIs, preventing any future confusion. As such, it will only
be necessary to apply the <code>@classic</code> decorator for as long as any of the user's
own classes use <code>EmberObject</code> APIs. These include:</p>
<ul>
<li><code>extend</code></li>
<li><code>reopen</code> and <code>reopenClass</code></li>
<li><code>init</code></li>
<li><code>destroy</code></li>
<li><code>proto</code></li>
<li><code>detect</code></li>
<li><code>get</code>/<code>set</code></li>
</ul>
<p>Along with any other extra methods or APIs that exist on <code>CoreObject</code> and
<code>EmberObject</code>. Methods and APIs that exist on the class itself, such as
<code>transitionTo</code> on Routes, or <code>send</code> and <code>sendAction</code> on Controllers, are <em>not</em>
considered <code>EmberObject</code> APIs, since they could be implemented purely in native
classes, and aren't tied to the way <code>EmberObject</code> does inheritance.</p>
<p>If a class, or any of its parent classes, uses one of these methods <em>without</em>
being decorated with <code>@classic</code>, a lint rule will log a warning to let users
know that they are using classic object APIs, and they should either refactor
away from using those APIs, or use the <code>@classic</code> decorator to opt-out of
warnings.</p>
<p>The <code>@classic</code> decorator itself will brand the class it is applied to, disabling
warnings on that instance of the class.</p>
<h3 id="non-transitionable-base-classes"><a class="header" href="#non-transitionable-base-classes">Non-transitionable Base Classes</a></h3>
<p>Non-transitionable base classes <em>cannot</em> be converted to native classes without
relying on behaviors that are specific to <code>EmberObject</code>. Classic components, for
instance, rely deeply on the way that <code>EmberObject.create</code> sets up its instance,
and any utility class that extends from <code>EmberObject</code> <em>must</em> use <code>create</code> to
create instances. While this is also true of <code>Route</code>s and <code>Service</code>s, the
important distinction is that <em>users</em> don't have to ever use <code>create</code> in their
own code, or are not passed any arguments other than injections, so for those
classes the usage of <code>create</code> is an implementation detail.</p>
<p>These classes will <em>always</em> warn users if they are not decorated with
<code>@classic</code>. In order to transition away the decorator, they must be converted
into newer base classes, such as <code>GlimmerComponent</code>, or away from base classes
entirely.</p>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<p>The decorator and the warnings would be added by an official Ember addon,
<code>ember-classic-decorator</code>. This would allow us to keep the implementation
details separate from the main Ember codebase, especially specifics like babel
transforms for stripping out the <code>@classic</code> decorator in production builds.</p>
<p>The <code>@classic</code> decorator should only be applied in DEBUG mode, and should be
stripped entirely from production builds. Other than that, the details of the
exact implementation is left up to the champions, though it should likely use
symbols to brand classes marked with the decorator.</p>
<h2 id="how-we-teach-this-89"><a class="header" href="#how-we-teach-this-89">How we teach this</a></h2>
<p>In the Working with JavaScript section of the guides, when we discuss both
native class syntax and classic class syntax, we should also provide a breakdown
of using native classes with objects that implement or use classic class APIs.
We can explain the usage of the <code>@classic</code> decorator here, along with clear
examples for how it should be applied, and what will warnings without it.</p>
<p>The warnings themselve should also link to this guide page, with a clear
explanation for <em>why</em> the warning was triggered, and a link to a section on the
page that covers the specific API, and how to convert that API to use native
class syntax. In the case of Glimmer components and utility classes, the
sections should point to the more detailed Octane Edition guide, which covers
the various differences between classic and Glimmer components and classic and
native classes, and how to convert the two.</p>
<h2 id="drawbacks-111"><a class="header" href="#drawbacks-111">Drawbacks</a></h2>
<p>Adding the <code>@classic</code> decorator could encourage more usage of native classes
with <code>EmberObject</code>, which in turn could lead to even more confusion as users
attempt to navigate the edge cases in differences between native and classic
syntax. If the warnings provided by <code>@classic</code> are not strong enough, it could
result in a frustrating developer experience when the differences between the
two cause problems and failures.</p>
<h2 id="alternatives-115"><a class="header" href="#alternatives-115">Alternatives</a></h2>
<p>This RFC is taking the stance that:</p>
<ol>
<li>Adopting native class syntax with <code>EmberObject</code> is valuable enough to a
significant number of users that we should support it, and recommend it in
some cases (such as for transitionable classes)</li>
<li>There are enough caveats with doing this that we must warn users of them in
order to support it.</li>
</ol>
<p>We could alternatively <em>not</em> recommend using native class syntax with any class
that extends <code>EmberObject</code>, even Route/Controller/Service and other
transitionable classes, and wait until we have a pure native alternative to
transition to.</p>
<p>We could also not warn, if we believe the caveats are actually not that
problematic, and that users can figure out the details on their own without any
hinting.</p>
<h3 id="built-in-instead-of-addon"><a class="header" href="#built-in-instead-of-addon">Built-in Instead of Addon</a></h3>
<p>This RFC currently proposes adding <code>@classic</code> as a default addon, which will
allow us to keep its implementation separate from the main Ember codebase. This
could lead to users dropping it or not adding it to existing codebases, which
would in turn lead to users encountering failures without any warnings.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-20
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/470
Tracking: https://github.com/emberjs/rfc-tracking/issues/33</p>
<hr />
<h1 id="fn-helper"><a class="header" href="#fn-helper"><code>{{fn}}</code> Helper</a></h1>
<h2 id="summary-121"><a class="header" href="#summary-121">Summary</a></h2>
<p>This RFC introduces a new helper, <code>{{fn}}</code>, to allow clear argument passing for functions in templates.</p>
<h2 id="motivation-121"><a class="header" href="#motivation-121">Motivation</a></h2>
<p>The current <code>action</code> helper has a lot of implicit and confusing behavior that is different than the Octane and post Octane programming model.</p>
<p>To understand the complexity of <code>action</code> there are many complex behaviors including:</p>
<ol>
<li>Argument partial application (currying)</li>
<li><code>this</code> context binding</li>
<li><code>send</code> checks for Component and Controllers</li>
</ol>
<p>At build time the <code>action</code> helper currently is passed through an AST transform to explicitly bind the <code>this</code> to be deterministic at runtime. This is a private API where the outputted Glimmer is not a 1-1 to the template. Also, the <code>action</code> helper is confused and has overlap with the <code>action</code> modifier which has similar but slightly different behavior.</p>
<p>Instead of this confusing and overloaded behavior, a new <code>fn</code> helper would be introduced to do partial application (with no need for build time private APIs), and context binding will be done instead using the <code>@action</code> decorator in classes.</p>
<h2 id="detailed-design-104"><a class="header" href="#detailed-design-104">Detailed design</a></h2>
<p>The <code>fn</code> helper will take in a function and then the set of arguments that will be partially applied to the function.</p>
<p>Here are some examples of the <code>fn</code> helper and the equivalent JS:</p>
<h3 id="simple-case-on-argument-curry"><a class="header" href="#simple-case-on-argument-curry">Simple Case On Argument Curry</a></h3>
<pre><code class="language-hbs">{{fn this.log 1}}
</code></pre>
<pre><code class="language-js">return function() {
  this.log.call(this, 1);
}
</code></pre>
<h3 id="multiple-argument-partial-application"><a class="header" href="#multiple-argument-partial-application">Multiple Argument Partial Application</a></h3>
<pre><code class="language-hbs">{{fn this.add 1 2}}
</code></pre>
<pre><code class="language-js">return function() {
  this.add.call(this, 1, 2);
}
</code></pre>
<p>The use of <code>function</code> application like so allows us to preserve/pass through the <code>this</code> context of the calling site accurately, so creating a function <code>fn</code> is equivalent to the same function <em>without</em> args.</p>
<h3 id="comparison-to-action-helpermodifier"><a class="header" href="#comparison-to-action-helpermodifier">Comparison to Action Helper/Modifier</a></h3>
<pre><code class="language-hbs">{{!-- Actions --}}
&lt;button {{action &quot;increment&quot; 5}}&gt;Click&lt;/button&gt;
&lt;button {{action this.increment 5}}&gt;Click&lt;/button&gt;
&lt;button onclick={{action &quot;increment&quot; 5}}&gt;Click&lt;/button&gt;
&lt;button onclick={{action this.increment 5}}&gt;Click&lt;/button&gt;
&lt;button {{action (action &quot;increment&quot; 5)}}&gt;Click&lt;/button&gt;
&lt;button {{action (action this.increment 5)}}&gt;Click&lt;/button&gt;

&lt;button onclick={{fn this.increment 5}}&gt;Click&lt;/button&gt;
&lt;button {{on &quot;click&quot; (fn this.increment 5)}}&gt;Click&lt;/button&gt;
</code></pre>
<h3 id="with-mut"><a class="header" href="#with-mut">With <code>mut</code></a></h3>
<pre><code class="language-hbs">{{!-- Actions --}}
&lt;button {{action (mut showModal) true}}&gt;Click&lt;/button&gt;
&lt;button onclick={{action (mut showModal) true}}&gt;Click&lt;/button&gt;
&lt;button {{action (action (mut showModal) true)}}&gt;Click&lt;/button&gt;

&lt;button onclick={{fn (mut showModal) true}}&gt;Click&lt;/button&gt;
&lt;button {{on &quot;click&quot; (fn (mut showModal) true)}}&gt;Click&lt;/button&gt;
</code></pre>
<h2 id="how-we-teach-this-90"><a class="header" href="#how-we-teach-this-90">How we teach this</a></h2>
<p>For guides we would switch to recommending the <code>fn</code> helper to pass functions into components args and modifiers. We'll teach the helper as similar to the <code>hash</code> and <code>arr</code> helpers - <code>fn</code> returns a function with some arguments being passed to it.</p>
<p>In guides we would no longer recommend using the <code>action</code> helper based on the reasons listed in motivations.</p>
<h2 id="drawbacks-112"><a class="header" href="#drawbacks-112">Drawbacks</a></h2>
<ul>
<li><code>fn</code> is not the clearest name, and could be difficult for users to understand.</li>
</ul>
<h2 id="alternatives-116"><a class="header" href="#alternatives-116">Alternatives</a></h2>
<p>One alternative would be to continue using the <code>action</code> helper despite confusion and overloading behavior.</p>
<p>There are also a number of potential alternatives for names:</p>
<ul>
<li><code>args</code> - A shorter, simpler name with similar properties. This is somewhat less self-explanatory (on its own, without context, one might think it refers to component args, or does something with them), but may make up for this by being short and simple.</li>
<li><code>bind</code> - The original name this RFC suggested. <code>bind</code> is fairly <em>imperative</em>, it describes the action that we do to the function rather than what is returned. It also does not exactly match the JS method API, and as noted in the RFC feedback this could be confusing. Finally, it requires stopping to teach the concept of binding and how that works, which is a lot of overhead for a helper that will be used early and often.</li>
<li><code>call</code> - This reads nicely in templates, but is <em>very</em> imperative and has already been confusing to folks when discussed. It differs significantly from the JS method API, teaching around this would be difficult, though possible. It also is not clear that it is <em>not required</em> unless args are being passed, so we may see users attempting to use it for plain functions.</li>
<li><code>with-args</code> - Descriptive, but fairly verbose</li>
</ul>
<p>Names that have been considered, but passed over:</p>
<ul>
<li><code>apply</code> - Same downsides as <code>call</code>, but less nice to read.</li>
<li><code>applyArgs</code> - Similar enough to <code>fn</code>, but uses more obscure computer-science-y terminology without many benefits.</li>
<li><code>partial</code> - From LISP and other languages. <code>partial</code> there means &quot;Partial Application&quot;. This is a computer-science-y term that isn't super explanatory, plus <code>partial</code> is already a (deprecated) feature in Ember templates.</li>
<li><code>papply</code> - From R. Generally unaesthetically pleasing, and same issues as <code>partial</code></li>
<li><code>action</code> - We considered trying to reclaim the &quot;action&quot; term, but it still has the same problems of overlap with the modifier and decorator, and there isn't an easy transition path to deprecating the automatic <code>this</code> binding.</li>
<li><code>callback</code> - Considered, but it conflicts with the <code>@action</code> decorator's naming - the method is an action, until we pass it to callback, at which point it's a callback? This felt too confusing, and we believe it makes most sense if the helper is an &quot;adjective&quot; that modifies whatever its input is.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-03-21
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/471
Tracking: https://github.com/emberjs/rfc-tracking/issues/32</p>
<hr />
<h1 id="on-modifier"><a class="header" href="#on-modifier"><code>{{on}}</code> Modifier</a></h1>
<h2 id="summary-122"><a class="header" href="#summary-122">Summary</a></h2>
<p>Add an <code>{{on}}</code> modifier for adding event listeners to elements.</p>
<h2 id="motivation-122"><a class="header" href="#motivation-122">Motivation</a></h2>
<p>Currently, there are two ways to bind event listeners to elements in Ember
templates with built-in, official Ember APIs:</p>
<ol>
<li>Use the <code>{{action}}</code> element modifier</li>
<li>Use the <code>on*=</code> property bindings</li>
</ol>
<p>Both of these solutions are problematic for a number of reasons.</p>
<p>The <code>{{action}}</code> modifier:</p>
<ul>
<li>Uses a non-standard AST transform to pass <code>this</code> in order to bind the context
of the template (the component) to the function (typically a component
method). This is problematic behavior, not just because of the transform, but
because of the implicit state that is being passed to the modifier in the
first place, and the fact that the modifier is &quot;magical&quot; in the sense that it
can do things that no other modifier or helper can do.</li>
<li>Binds to the <code>click</code> event by default, which requires a bit of knowledge to
understand on first glance, and requires a bit of extra knowledge to figure
out how to bind to other events. Compared to <code>onclick=</code>, this is less
explicit, and requires more knowledge of the framework out of the box.</li>
<li>Is confusing when used with the <code>@action</code> decorator to bind the function, and
the <code>{{action}}</code> helper. The term &quot;action&quot; is highly overloaded here, and it
is unclear what it concretely means without context.</li>
</ul>
<p>The <code>on*</code> properties, by contrast, may seem to be a better approach overall to
the problem, but they have their own issues:</p>
<ul>
<li>The require the ability to bind to element <em>properties</em>. Properties are <em>not</em>
attributes, and the distinction is subtle, but important. Most importantly,
props are <em>not</em> rendered, and thus are <em>not</em> SSR/rehydration friendly, since
it is difficult to assign during rehydration. By constrast, modifiers are
specifically designed around SSR. They do not trigger at all during server
side render, and then are run specifically during rehydration.</li>
<li>Not all events are bindable via <code>on*</code> properties, and some events such as
<code>focus</code> have different behavior than when assigned with <code>addEventListener</code>
directly. This behavior has been a pain point in other frontend frameworks,
and requires workarounds in most cases.</li>
<li>They do not work on certain elements at all, such as <code>&lt;svg&gt;</code>.</li>
<li>They are not compatible at all with standard web components. Web components
don't send events in the same way as standard elements for properties, and
instead rely on event listeners added via <code>addEventListener</code>. While web
components are not currently used in the Ember ecosystem, they are advancing
and may eventually be useful for smaller, self-contained components,
especially for users that want to share code between framework ecosystems.</li>
</ul>
<p>Neither of these solutions is perfect for solving the problem of adding event
listeners. This RFC proposes adding a new modifier to Ember: the <code>{{on}}</code>
modifier. This modifier will explicitly add event listeners using the
<code>addEventListener</code> API.</p>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>The design of this modifier is based on <a href="https://github.com/buschtoens/ember-on-modifier">ember-on-modifier</a>
by Jan Buschtöns, which is an excellent addon that has allowed us to test this
design in real apps and get feedback about the design.</p>
<h2 id="detailed-design-105"><a class="header" href="#detailed-design-105">Detailed design</a></h2>
<p>The <code>{{on}}</code> modifier will recieve:</p>
<ol>
<li>The event name as a string as the first positional parameter</li>
<li>The event listener function as the second positional parameter</li>
<li>Named parameters as options</li>
</ol>
<p>The following usages are equivalent:</p>
<pre><code class="language-hbs">&lt;div {{on &quot;click&quot; this.handleClick passive=true}}&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">element.addEventListener('click', this.handleClick, { passive: true });
</code></pre>
<p>Multiple event listeners can be added to an element by adding the modifier more
than once:</p>
<pre><code class="language-hbs">&lt;div
  {{on &quot;click&quot; this.handleClick}}
  {{on &quot;mouseenter&quot; this.handleMouseEnter}}
&gt;
&lt;/div&gt;
</code></pre>
<p>Extra positional parameters will be ignored. In order to pass values to a
function, users should use a helper such as the <a href="https://github.com/emberjs/rfcs/pull/470">fn helper</a>:</p>
<pre><code class="language-hbs">&lt;div {{on &quot;click&quot; (fn this.addNumber 123)}}&gt;&lt;/div&gt;
</code></pre>
<p>The event will also be passed as a parameter to the function, so it can be used
directly.</p>
<p><code>{{on}}</code> does <em>not</em> bind context. Context binding must be handled via a helper,
or in the component definition via the <code>@action</code> decorator, which will be the
recommended path:</p>
<pre><code class="language-js">class ClickComponent extends Component {
  @action
  handleClick() {
    // ...
  }
}
</code></pre>
<h3 id="named-parameters"><a class="header" href="#named-parameters">Named Parameters</a></h3>
<p>The following named parameters will be accepted as options to <code>{{on}}</code>:</p>
<ul>
<li><code>capture</code></li>
<li><code>once</code></li>
<li><code>passive</code></li>
</ul>
<p>These will be passed forward to <code>addEventListener</code> as options in modern
browsers, and will be polyfilled in older browsers. Other options will be
ignored.</p>
<h2 id="how-we-teach-this-91"><a class="header" href="#how-we-teach-this-91">How we teach this</a></h2>
<p><code>{{on}}</code> itself can be taught in conjuction with event listeners. We can give
users an overview of event listeners and the <code>addEventListener</code> API, and then
relate the modifier directly to it. We should provide lots of examples of usage
throughout the guides for how users can use it, including some examples of how
to apply multiple event listeners to an element.</p>
<p><code>{{on}}</code> also does not bind context, and we should make it clear that the
<code>@action</code> decorator is the recommended way to bind methods to their components.</p>
<p>Other than that, most examples in the guides can be translated directly from
the <code>{{action}}</code> modifier to the <code>{{on}}</code> modifier.
Documentation work would include:</p>
<ul>
<li>revising <a href="https://guides.emberjs.com/release/components/handling-events/#toc_event-names">Handling Events</a> or the corresponding Octane article in entirety</li>
<li>revising <a href="https://guides.emberjs.com/release/components/triggering-changes-with-actions/">Triggering Changes with Actions</a> or the corresponding Octane article</li>
<li>Updating 50+ uses of <code>{{action}}</code> in the guides</li>
<li>Adding <code>{{on}}</code> as a new API docs entry</li>
<li>Update examples within the API docs to show all uses of actions that are supported in the API docs - <code>{{on}}</code>, <code>{{action}}</code>, <code>onclick={{action}}</code></li>
</ul>
<p><code>{{action}}</code> is used 130+ times in the API docs. Not all examples would need to be updated, however an audit would be needed to figure out which need to be added to/changed.</p>
<h2 id="drawbacks-113"><a class="header" href="#drawbacks-113">Drawbacks</a></h2>
<ul>
<li>This API is somewhat more verbose than the <code>{{action}}</code> modifier since it
requires a helper for passing additional values to the function. However, this
explicitness makes it much more clear what the separation of concerns is, and
allows users to fine tune their event handling.</li>
<li>The <code>{{on}}</code> modifier requires another helper to pass values. Currently, the
ideal companion helper is the <code>{{fn}}</code> helper, which is still in RFC.</li>
<li>The <code>onclick=</code> style at first looks like a native browser API, and is
sometimes easier to teach because of this. However, it is <em>not</em> the same as
the <code>onclick</code> attribute, which only receives strings, and the differences are
often confusing. In addition, the fact that there are many use cases that
aren't covered by these properties, and the fact that they are hostile to SSR,
makes them less than ideal.</li>
</ul>
<h2 id="alternatives-117"><a class="header" href="#alternatives-117">Alternatives</a></h2>
<p>One option would be to allow the <code>{{on}}</code> modifier to receive event listeners
as named parameters instead:</p>
<pre><code class="language-hbs">&lt;div
  {{on
    click=this.handleClick
    mouseenter=this.handleMouseEnter
  }}
&gt;
&lt;/div&gt;
</code></pre>
<p>One downside of this style of API is that there is no clear way to pass
additional options to the individual event listeners. We could pass them as a
positional parameter, but they would apply to <em>all</em> listeners, which would
require multiple invocations.</p>
<p>We could also allow the <code>{{on}}</code> modifier to bind context. This opens up a
question: Should helpers and modifiers by able to use the context of the
template implicitly? Since helpers are analogous to functions in JavaScript,
this would be an equivalent API choice in JS:</p>
<pre><code class="language-js">function foo() {
  this.bar = 123;
}

class Foo {
  doSomething() {
    foo();
  }
}

let foo = new Foo();

foo.doSomething();
console.log(foo.bar); // 123
</code></pre>
<p>Arbitrary functions being able to access <code>this</code> when used within a class like so
seems problematic from a language design standpoint, and we believe an API like
this in Ember's templates would be very problematic, and easy to misuse.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-04-17
Relevant Team(s): Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/477</p>
<hr />
<h1 id="syncing-blueprints"><a class="header" href="#syncing-blueprints">Syncing Blueprints</a></h1>
<h2 id="summary-123"><a class="header" href="#summary-123">Summary</a></h2>
<p>I want to use <a href="https://github.com/ember-cli/ember-cli-update">ember-cli-update</a> to keep any blueprint up-to-date. Since ember-cli-update can not possibly contain knowledge of all blueprints, some state must be stored in a project.</p>
<h2 id="motivation-123"><a class="header" href="#motivation-123">Motivation</a></h2>
<p>Projects like <a href="https://github.com/tildeio/libkit">libkit</a>, <a href="https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/blueprint">@glimmer/blueprint</a>, <a href="https://github.com/ember-cli/ember-octane-blueprint">@ember/octane-app-blueprint</a>, and other app replacement blueprints become out-of-date instantly after generation. Tweaks to the blueprints are only beneficial to newly generated apps.</p>
<h2 id="detailed-design-106"><a class="header" href="#detailed-design-106">Detailed design</a></h2>
<p><strong>State storage schema</strong></p>
<p>Up until now, ember-cli-update could update apps without any configuration, but in order to handle all blueprints and their options, some state has to be stored in the project.</p>
<p>The code is already completed but opt-in. I wanted to publish this RFC before releasing it into the wild. I want to make sure the format of these files are agreed upon, because if this is successful, it will probably propagate throughout the ecosystem.</p>
<pre><code class="language-json">// config/ember-cli-update.json
{
  &quot;packages&quot;: [
    {
      &quot;name&quot;: &quot;my-custom-blueprint&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;blueprints&quot;: [
        {
          &quot;name&quot;: &quot;my-custom-blueprint&quot;
        }
      ]
    }
  ]
}
</code></pre>
<p><code>ember-cli-update.json</code> will be rewritten by the tool, which is why JSON is preferred over JS.</p>
<p>How should the state be structured?</p>
<pre><code class="language-ts">/**
  This lives at config/ember-cli-update.json by default.
*/
interface BlueprintConfig {
  /**
    Keep track of incompatible schema changes.
  */
  schemaVersion: number;

  /**
    A package is a collection of blueprints from a single source.
  */
  packages: {
    /**
      The name of the package.
    */
    name: string;

    /**
      Target a blueprint on your local filesystem, monorepo or otherwise.
    */
    location?: string;

    /**
      The version of the package used for blueprint diffing.
    */
    version: string;

    /**
      The blueprints in the package. Can be a default blueprint having
      the same name as the package, or a named blueprint like component
      generators.
    */
    blueprints: {
      /**
        A base blueprint is the blueprint you started your project with.
        This could be the ember app blueprint, or a custom blueprint like libkit.
        If this is missing or false, it is a partial blueprint, like the changes
        you get when installing an ember addon like ember-cli-mirage.
        There must be one base blueprint at all times.
      */
      isBaseBlueprint?: boolean;

      /**
        The name of the blueprint to be run.
      */
      name: string;

      /**
        The path inside your project to run in. Think deeply nested
        component generators. Missing means project root.
      */
      cwd?: string;

      /**
        The location of a codemods manifest if there are codemods
        associated with this blueprint.
      */
      codemodsUrl?: string;

      /**
        All options should be normalized to match any codemod requirements.
        The work to normalise them might not be done at first, so users
        writing the CLI commands are expected to do it. For example,
        `--no-welcome` should be expanded to `--welcome=false` so that
        a codemod with a requirement of `[ &quot;--welcome=false&quot; ]` can match it.
      */
      options?: string[];
    }[]
  }[]
}
</code></pre>
<p><strong>Commands</strong></p>
<p><em><strong>bootstrap</strong></em></p>
<pre><code>ember-cli-update bootstrap
</code></pre>
<p>This starts an <code>ember-cli-update.json</code> file for you with the detected ember-cli blueprint version. It uses the same logic we currently have for detecting the ember-cli blueprint version, but now since the state is stored, we don't have to run the detection logic anymore.</p>
<p><em><strong>init</strong></em></p>
<pre><code>ember-cli-update init
ember-cli-update init -b libkit
ember-cli-update init -b my-custom-blueprint --custom-option-1 --custom-option-2 foo
</code></pre>
<p>This is similar to <code>ember init</code> or <code>ember-cli-update --reset</code>, but also stores the blueprint information in <code>ember-cli-update.json</code>. It also stores any options used to create future update diffs.</p>
<p><em><strong>install</strong></em></p>
<pre><code>ember-cli-update install ember-cli-mirage
</code></pre>
<p>This is the same as <code>ember install ember-cli-mirage</code> except that it stores the blueprint state for later updating.</p>
<p><em><strong>save</strong></em></p>
<pre><code>ember-cli-update save libkit --from 0.5.18
ember-cli-update save ember-cli-mirage --from 0.4.0
</code></pre>
<p>This is a helper for saving the state of an old blueprint's run without ember-cli-update. The usefulness of this is questionable, because you have to remember something you did in the past. Its only usefulness is getting a project set up without having to know the <code>ember-cli-update.json</code> schema.</p>
<p><strong>Methods of delivery</strong></p>
<p>The goal is for when you type <code>ember-cli-update</code> in your project, you will get a prompt like</p>
<pre><code>$ ember-cli-update
Multiple blueprint updates found, which would you like to update?
 * ember-cli
 * ember-cli-mirage
 * ember-ci
</code></pre>
<p>The reason this is so powerful is any org could create their own <em>partial</em> project blueprint (public or private). This blueprint can make any slight (or massive) tweaks to the official blueprints, and ember-cli-update can keep any project in sync with both the official blueprint and your org's blueprints, at the same time.</p>
<p><strong>Preserving options</strong></p>
<p>I'm not sure if anyone does it now, but it could be possible to handle options when generating a new project via a custom blueprints.</p>
<pre><code>ember new my-app -b my-blueprint --option1 --option2=foo
</code></pre>
<pre><code class="language-json">// my-app/config/ember-cli-update.json
{
  &quot;packages&quot;: [
    {
      &quot;name&quot;: &quot;my-blueprint&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;blueprints&quot;: [
        {
          &quot;name&quot;: &quot;my-blueprint&quot;,
          &quot;options&quot;: [
            &quot;option1=true&quot;,
            &quot;option2=\&quot;foo\&quot;&quot;
          ]
        }
      ]
    }
  ]
}
</code></pre>
<p>The updater can now generate a project with the correct options.</p>
<p><strong>Codemods</strong></p>
<p>There is no reason why you couldn't provide your own codemods with this system. This would be especially useful for project replacement blueprints. We would use the existing codemod system with version detection, option detection, etc.</p>
<pre><code class="language-json">{
  &quot;packages&quot;: [
    {
      &quot;name&quot;: &quot;my-blueprint&quot;,
      &quot;version&quot;: &quot;0.0.1&quot;,
      &quot;blueprints&quot;: [
        {
          &quot;name&quot;: &quot;my-blueprint&quot;,
          &quot;codemodsUrl&quot;: &quot;some-server.com/my-blueprint-codemods-manifest.json&quot;
        }
      ]
    }
  ]
}
</code></pre>
<h2 id="how-we-teach-this-92"><a class="header" href="#how-we-teach-this-92">How we teach this</a></h2>
<p>I’m not sure. It could be a section in the ember-cli-update README, or leave it up to the blueprints that want to support this to document. If this feature takes off in the ecosystem, then it might warrant a guides section on keeping your blueprints up-to-date.</p>
<h2 id="drawbacks-114"><a class="header" href="#drawbacks-114">Drawbacks</a></h2>
<p>A drawback could be that blueprints start writing this state, but the consumer doesn’t want to use ember-cli-update to keep it in sync. In that case, it’s another file the user has to delete.</p>
<h2 id="unresolved-questions-77"><a class="header" href="#unresolved-questions-77">Unresolved questions</a></h2>
<p>The options need to be normalized somehow to be used in the codemods system.</p>
<p><code>--custom-option foo</code> vs <code>--custom-option=foo</code> vs <code>--custom-option=&quot;foo&quot;</code></p>
<pre><code class="language-js">// This would probably be bad as `foo` would be treated as an option
&quot;options&quot;: [
  &quot;--custom-option&quot;,
  &quot;foo&quot;
]
// This is better
&quot;options&quot;: [
  &quot;--custom-option=\&quot;foo\&quot;&quot;
]
// or maybe this?
&quot;options&quot;: [
  &quot;customOption=\&quot;foo\&quot;&quot;
]
</code></pre>
<p>For now, we should leave it up to the end-user to normalize the options to match any codemod manifest. This is too hard a problem to nail down on the first iteration.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-04-12
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/478
Tracking: https://github.com/emberjs/rfc-tracking/issues/45</p>
<hr />
<h1 id="tracked-properties-updates"><a class="header" href="#tracked-properties-updates">Tracked Properties Updates</a></h1>
<h2 id="summary-124"><a class="header" href="#summary-124">Summary</a></h2>
<p>During the Ember Octane preview period we encountered some issues with the
current design for Tracked Properties that was proposed and accepted in
<a href="https://github.com/emberjs/rfcs/blob/master/text/0410-tracked-properties.md">RFC 410</a>.
The primary issues were specifically around interop between tracked properties,
computed properties, and autotracking, with a few extra issues and
inconsistencies surrounding these. This RFC seeks to fix these issues and
provide a new interop path.</p>
<h2 id="motivation-124"><a class="header" href="#motivation-124">Motivation</a></h2>
<p>During the preview for Octane, we've encountered a few issues with tracked
properties:</p>
<ol>
<li>Computed property autotracking interop was too aggresive, and resulted in
breaking changes in existing applications.</li>
<li>When users need to use <code>get()</code> and <code>set()</code> is still fairly confusing, and we
don't have enough warnings to help guide users down the happy path.</li>
<li>Users were confused by the fact that <code>set()</code> was still required when updating
computed properties, especially CP macros like <code>DS.attr()</code>.</li>
</ol>
<h3 id="autotracking-interop"><a class="header" href="#autotracking-interop">Autotracking Interop</a></h3>
<p>The core of the autotracking issue was that autotracking <em>inside</em> computed
properties resulted in more values being consumed and watched than before,
fundamentally changing the dynamic of the CP. For instance, consider this code
example:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  init(...args) {
    this._super(...args);

    let fullName = `${this.get('firstName')} ${this.get('lastName')}`;

    this.set('fullName', fullName);
  },
});

const Profile = EmberObject.create({
  person: computed('firstName', 'lastName', function() {
    return Person.create({
      firstName: this.get('firstName'),
      lastName: this.get('lastName'),
    });
  }),
});
</code></pre>
<p>The <code>Profile#person</code> computed would currently only invalidate if
<code>Profile#firstName</code> or <code>Profile#lastName</code> was updated, and it would be possible
to update the person like so:</p>
<pre><code class="language-js">// without autotracking
let profile = Profile.create({
  firstName: 'Chris',
  lastName: 'Thoburn',
});

let p1 = profile.get('person');
profile.set('person.firstName', 'Christopher');
let p2 = profile.get('person');

p1 === p2; // true
</code></pre>
<p>However, because <code>get</code> now autotracks, the fact that the <code>Person</code> class uses
<code>this.get()</code> in its own constructor causes <code>Profile#person.firstName</code> to
autotrack. When we go to update the object later on, it invalidates the
underlying computed property.</p>
<pre><code class="language-js">// with autotracking
let profile = Profile.create({
  firstName: 'Chris',
  lastName: 'Thoburn',
});

let p1 = profile.get('person');
profile.set('person.firstName', 'Christopher');
let p2 = profile.get('person');

p1 === p2; // false
</code></pre>
<p>It's arguable that computed properties that are relying on these caching
semantics are problematic in general. After all, it's strange to setup state
like this <em>during</em> construction, usually you would use a CP instead, and if CPs
<em>are</em> trying to use a value, it generally means that value <em>should</em> be a
dependency. However, based on our experiences with attempting to upgrade
existing applications to enable autotracking, we believe it likely would result
in enough breakage that it would be a breaking change.</p>
<h3 id="when-to-use-get-and-set"><a class="header" href="#when-to-use-get-and-set">When to Use <code>get</code> and <code>set</code></a></h3>
<p>While the original tracked properties RFC laid the groundwork for getting rid of
<code>get</code> and <code>set</code> in the browser, there are still cases where users need to use
it. Specifically, users must use <code>get</code> and <code>set</code> when:</p>
<ul>
<li>Getting and setting values on POJOs</li>
<li>Using Ember Proxies</li>
<li>Setting Computed Properties</li>
</ul>
<p>Ember proxies already throw errors if users don't use <code>get</code> and <code>set</code>, so users
can generally get the feedback they need for them, and setting computed
properties is addressed in the next section. For POJOs, however, the feedback
can be lacking. Users could access a POJO from a tracked context like so:</p>
<pre><code class="language-js">class MyComponent extends GlimmerComponent {
  featureFlags = {};

  get someValue() {
    if (get(this.featureFlags, 'someValueEnabled')) {
      // ... do things
    }
  }
}
</code></pre>
<p>And later on, try to update <code>featureFlags.someValueEnabled</code>, and be confused
when it doesn't work and they don't have any actionable feedback:</p>
<pre><code class="language-js">class MyComponent extends GlimmerComponent {
  featureFlags = {};

  get someValue() {
    if (get(this.featureFlags, 'someValueEnabled')) {
      // ... do things
    }
  }

  @action
  updateFlag() {
    this.featureFlags.someValueEnabled = true;
  }
}
</code></pre>
<p>Adding an assertion to values that are accessed like this which requires <code>set</code>
will help to prevent confusion from occuring.</p>
<h3 id="computed-property-setters"><a class="header" href="#computed-property-setters">Computed Property Setters</a></h3>
<p>As we move toward removing <code>get</code> and <code>set</code> entirely, computed properties stick
out somewhat as a sore thumb. They generally look and feel like standard getters
and setters with some caching, but while modern Ember users can use native
getters to <em>get</em> the computed, they must use <code>set()</code> to update them. This is
particularly annoying when dealing with macros, like aliases and Ember Data
attributes such as <code>DS.attr</code>.</p>
<p>Installing a native setter for computed properties will smooth over these
inconistencies, and give us a clear learning boundary for <code>get</code> and <code>set</code> - you
only need to use them for plain, undecorated properties on POJOs, and for Ember
proxies.</p>
<h2 id="detailed-design-107"><a class="header" href="#detailed-design-107">Detailed design</a></h2>
<h3 id="autotracking-interop-1"><a class="header" href="#autotracking-interop-1">Autotracking Interop</a></h3>
<p>Not all of the interop in the original RFC was problematic, and as such, the
following parts will remain the same:</p>
<ul>
<li><code>get</code> - will still autotrack any value that is accessed</li>
<li><code>set</code>/<code>notifyPropertyChange</code> - will still invalidate any value that was
accessed with <code>get</code></li>
<li>Computed properties - will still autotrack <em>if accessed in an autotracking
context</em>.</li>
</ul>
<p>What will change is that computed properties will no longer autotrack as they
are being evaluated. Instead, they will follow the same rules as they do
currently, listing explicit dependencies and only invalidating when one of those
dependencies changes. Any autotracking that may have occured during the
computation of the computed will instead no-op, making the computed a <em>black
box</em>.</p>
<p>Since computed properties no longer autotrack, they will need a different
interop story for tracked properties and autotracking. Autotracking is a very
general tool - as we saw in the motivation, it's possible to track through
<em>function calls</em>, something that wasn't possible before.</p>
<p>However, we don't need to enable interop with <em>all</em> of autotracking. All we
really need is the ability to depend on the autotracking equivalents of what
computed properties already are capable of depending on, so that users can
convert existing code to autotracking incrementally. Computed properties can
already depend on:</p>
<ul>
<li>Properties</li>
<li>Other Computed Properties</li>
</ul>
<p>The equivalents to these in autotracking are:</p>
<ul>
<li>Tracked Properties</li>
<li>Native Getters</li>
</ul>
<h4 id="depending-on-tracked-properties"><a class="header" href="#depending-on-tracked-properties">Depending on Tracked Properties</a></h4>
<p>Tracked properties are already instrumented under the hood. They have a native
setter that calls <code>notifyPropertyChange</code>, and this will automatically invalidate
any computeds that specify the property as a dependency. There is no need to do
any further work.</p>
<h4 id="depending-on-native-getters"><a class="header" href="#depending-on-native-getters">Depending on Native Getters</a></h4>
<p>Native getters are just that - native. They don't have any special autotracking
behavior, which was part of the benefits of tracked properties. However, this
means there is nothing to notify computed properties of changes.</p>
<p>To solve this problem, we propose the <code>@dependentKeyCompat</code> decorator. This decorator
would instrument a native getter with its own autotracking frame, which would
allow it to track any events in its evaluation. It would coalesce these into its
own tag, which computed properties (and observers) would be able to depend on:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';

class Person {
  @tracked firstName;
  @tracked lastName;

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

const Profile = EmberObject.extend({
  // provided on create
  person: null,

  username: alias('person.fullName'),
});
</code></pre>
<p><code>@dependentKeyCompat</code> would be imported from <code>@ember/object/compat</code>, since it is used
specifically in Ember apps for interop with Ember object model abstractions.
Like other Ember decorators, it would be usable in both classic and native
classes. When used in classic classes, it will be able to define its underlying
getter and setter using the same API as computed properties. However, it will
throw an error if it is used to define more than one getter/setter - dependentKeyCompat
macros should be avoided and discouraged.</p>
<p>Observers and computed properties will throw an error if they attempt to watch
a getter which is not marked as dependentKeyCompat.</p>
<h4 id="debugging-assertions"><a class="header" href="#debugging-assertions">Debugging Assertions</a></h4>
<p>Consuming a value using <code>get()</code> inside of a tracked context will both autotrack
the value, and in <em>development</em> builds install the mandatory setter assertion.
This assertion already exists and is currently installed on values that are
watched by computeds, observers, and templates, but not for values accessed
using <code>get()</code>. Extending it to these values should not be too difficult.</p>
<h3 id="computed-property-setters-1"><a class="header" href="#computed-property-setters-1">Computed Property Setters</a></h3>
<p>Computed properties will no longer install the mandatory setter assertion like
they have for much of Ember's existence. Instead, they will install a native
setter that proxies to the one defined for the computed property. This will
allow users to use native setters instead of <code>set()</code>.</p>
<h2 id="how-we-teach-this-93"><a class="header" href="#how-we-teach-this-93">How we teach this</a></h2>
<p>There are two major points of consideration here:</p>
<ul>
<li>How do we teach classic/autotrack interop and <code>@dependentKeyCompat</code></li>
<li>How do we teach <code>get</code>/<code>set</code> and when they are necessary to use</li>
</ul>
<h3 id="classicautotrack-interop"><a class="header" href="#classicautotrack-interop">Classic/Autotrack Interop</a></h3>
<p>Many of the points from the original tracked property RFC remain valid, but we
will have to update the way that we teach computed properties. In some ways the
overall mental model is simplified - computed properties will only update
whenever a dependent property is updated, as they always have. The following
table describes what types of values can be depended on, and how they can
trigger updates:</p>
<table><thead><tr><th>Type</th><th>Updates By</th></tr></thead><tbody>
<tr><td>Plain, undecorator property</td><td><code>set()</code></td></tr>
<tr><td>Tracked property</td><td>Native setter</td></tr>
<tr><td>Computed property</td><td><code>set()</code>, or upstream invalidations</td></tr>
<tr><td>Dependency compatible getters</td><td>Tracked value changes</td></tr>
</tbody></table>
<p>We should cover each of these in some detail in the main guides.</p>
<h4 id="dependentkeycompat-api-docs"><a class="header" href="#dependentkeycompat-api-docs"><code>@dependentKeyCompat</code> API Docs</a></h4>
<p><code>@dependentKeyCompat</code> is decorator that can be used on <em>native getters</em> that use tracked
properties. It exposes the getter to Ember's classic computed property and
observer systems, so they can watch it for changes. It can be used in both
native and classic classes.</p>
<p>Native Example:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';
import { computed, set } from '@ember/object';

class Person {
  @tracked firstName;
  @tracked lastName;

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

class Profile {
  constructor(person) {
    set(this, 'person', person);
  }

  @computed('person.fullName')
  get helloMessage() {
    return `Hello, ${this.person.fullName}!`;
  }
}
</code></pre>
<p>Classic Example:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { dependentKeyCompat } from '@ember/object/compat';
import EmberObject, { computed, observer, set } from '@ember/object';

const Person = EmberObject.extend({
  firstName: tracked(),
  lastName: tracked(),

  fullName: dependentKeyCompat(function() {
    return `${this.firstName} ${this.lastName}`;
  }),
});

const Profile = EmberObject.extend({
  person: null,

  helloMessage: computed('person.fullName', function() {
    return `Hello, ${this.person.fullName}!`;
  }),

  onNameUpdated: observer('person.fullName', function() {
    console.log('person name updated!');
  }),
});
</code></pre>
<p><code>dependentKeyCompat()</code> can receive a getter function or an object containing <code>get</code>/<code>set</code>
methods when used in classic classes, like computed properties.</p>
<p>In general, only properties which you <em>expect</em> to be watched by older, untracked
clases should be marked as dependency compatible. The decorator is meant as an interop layer
for parts of Ember's older classic APIs, and should not be applied to every
possible getter/setter in classes. The number of dependency compatible getters should be
<em>minimized</em> wherever possible. New application code should not need to use
<code>@dependentKeyCompat</code>, since it is only for interoperation with older code.</p>
<h3 id="computed-properties-2"><a class="header" href="#computed-properties-2">Computed Properties</a></h3>
<p>Computed properties are a pre-Octane concept in Ember. They serve the same
purpose as tracked properties and native getters, allowing users to respond to
changes, derive state, and ultimately update the DOM. They also have built-in
caching to prevent having to perform expensive calculations more than once.</p>
<p>While computed properties are no longer the recommended default, it's likely
that you may encounter them in code that hasn't been updated to tracked
properties just yet, either in existing applications or in the wider Ember
ecosystem, so this guide exists both to describe how they work and can be used,
and how they interoperate with tracked properties.</p>
<h4 id="computed-property-usage"><a class="header" href="#computed-property-usage">Computed Property Usage</a></h4>
<p>You can create a computed property by using the <code>@computed</code> decorator to
decorate standard computed property getters and setters:</p>
<pre><code class="language-javascript">import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // &quot;Tony Stark&quot;
</code></pre>
<p>This computed property works just like a normal getter/setter, with two key
differences:</p>
<ol>
<li>
<p>It will cache its value by default, and it will only update that value if its
<em>dependencies</em>, in this case the <code>firstName</code> and <code>lastName</code> properties,
change.</p>
<pre><code class="language-javascript">class Counter {
  _count = 0;

  @computed
  get count() {
    console.log('counted!');
    return this._count;
  }
}

let counter = new Counter();

counter.count; // logs 'counted!'
counter.count; // logs nothing, the values was cached and hasn't updated
</code></pre>
</li>
<li>
<p>It will notify other &quot;watchers&quot;, such as other computed properties and
templates, if any of its dependencies has updated and it needs to be
recalculated.</p>
</li>
</ol>
<h5 id="specifying-dependencies"><a class="header" href="#specifying-dependencies">Specifying Dependencies</a></h5>
<p>So far we've seen computed properties with dependencies on properties that are
<em>local</em> to the object, but you can specify a few other types of dependencies:</p>
<ul>
<li>
<p><strong>Chain dependencies.</strong> If you need to specify a dependency on an <em>object</em>,
you can use dot notation to do so:</p>
<pre><code class="language-js">class Profile {
  constructor(user) {
    set(this, 'user', user);
  }

  @computed('user.firstName', 'user.lastName')
  get userName() {
    return `${this.user.firstName} ${this.user.lastName}`;
  }
}
</code></pre>
<p>When doing this for more than one value on the object, you can also use a
special truncated syntax as shorthand:</p>
<pre><code class="language-js">class Profile {
  constructor(user) {
    set(this, 'user', user);
  }

  @computed('user.{firstName,lastName}')
  get userName() {
    return `${this.user.firstName} ${this.user.lastName}`;
  }
}
</code></pre>
<p>Note that no spaces are allowed in this truncated syntax, Ember will assert if
you place any inside of it.</p>
</li>
<li>
<p><strong>Array dependencies.</strong> It's possible to depend on an array, and the items in
the array, by watching the <code>[]</code> property on the array:</p>
<pre><code class="language-js">class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}
</code></pre>
<p>You can also depend directly on a <em>property</em> of each item in the array using
<code>@each</code> syntax:</p>
<pre><code class="language-js">class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.@each.name')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}
</code></pre>
<p>However, you cannot <em>chain</em> on these properties, as it is a performance
pitfall. You can only do 1 level of <code>@each</code> watching.</p>
</li>
</ul>
<h5 id="defining-setters"><a class="header" href="#defining-setters">Defining Setters</a></h5>
<p>If you define a setter for your computed property, it'll work just like a normal
setter:</p>
<pre><code class="language-javascript">import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }
}

let hero = new Person('Tony', 'Stark');

hero.fullName; // 'Tony Stark'

hero.fullName = 'Hope Pym';
hero.firstName; // 'Hope'
</code></pre>
<p>It's worth noting that we do <em>not</em> need to use <code>set</code> to update the computed
property. It wraps the native setter transparently, so there is no need for the
set function. The properties it <em>depends</em> on, however, <em>do</em> need to be updated
with <code>set</code>, since they are not marked as <code>@tracked</code> and we don't have another
way of knowing they were updated. We will dive into this a bit more below.</p>
<p>The setter will also immediately call the getter for the computed in order to
recalculate the cached value. You can also return the value, as an optimization:</p>
<pre><code class="language-js">class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);

    return value;
  }
}
</code></pre>
<h5 id="computed-property-macros"><a class="header" href="#computed-property-macros">Computed Property Macros</a></h5>
<p>It's possible to define <em>macros</em> using computed properties. This works because
the <code>@computed</code> decorator can receive getter and setter functions, and be
applied to a normal class field instead of a getter/setter:</p>
<pre><code class="language-js">class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  // Just a getter function
  @computed('firstName', 'lastName', function() {
    return `${this.firstName} ${this.lastName}`;
  })
  fullName;

  // With setter and getter
  @computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, 'firstName', firstName);
      set(this, 'lastName', lastName);

      return value;
    },
  })
  fullNameWithSetter;
}
</code></pre>
<p>You can then extract this decorator to create a new decorator definition:</p>
<pre><code class="language-js">const fullNameMacro = computed('firstName', 'lastName', {
  get() {
    return `${this.firstName} ${this.lastName}`;
  },

  set(key, value) {
    let [firstName, lastName] = value.split(' ');

    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);

    return value;
  },
});

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @fullNameMacro fullName;
}
</code></pre>
<p>And we can abstract this further to create a function that generates the
decorator dynamically, which allows us to reuse the macro:</p>
<pre><code class="language-js">function fullNameMacro(firstNameKey, lastNameKey) {
  return computed(firstNameKey, lastNameKey, {
    get() {
      return `${this[firstNameKey]} ${this[lastNameKey]}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, firstNameKey, firstName);
      set(this, lastNameKey, lastName);

      return value;
    },
  });
}

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @fullNameMacro fullName('firstName', 'lastName');
  @otherFullNameMacro fullName('first', 'last');
}
</code></pre>
<p>When you provide a getter and setter like this to <code>@computed</code>, the getter and
setter receive the <code>key</code> of the property they are decorating as the first value,
and the setter receives the actual value second. The setter also <strong>must</strong> return
the value to be cached - the getter will not be rerun if it does not, and the
value will be <code>undefined</code>.</p>
<h5 id="computed-properties-in-classic-classes"><a class="header" href="#computed-properties-in-classic-classes">Computed Properties in Classic Classes</a></h5>
<p>Computed properties can be used in classic class syntax as well. This works by
passing the getter and setter to the <code>computed()</code> decorator just like we would
for a macro:</p>
<pre><code class="language-js">const Person = EmberObject.extend({
  fullName: computed('firstName', 'lastName', {
    get() {
      return `${this.firstName} ${this.lastName}`;
    },

    set(key, value) {
      let [firstName, lastName] = value.split(' ');

      set(this, 'firstName', firstName);
      set(this, 'lastName', lastName);

      return value;
    },
  }),
});
</code></pre>
<h4 id="computed-property-dependency-types"><a class="header" href="#computed-property-dependency-types">Computed Property Dependency Types</a></h4>
<p>You may have noticed that in the previous section, our computed properties were
depending on normal, undecorated properties. This is possible in classic Ember
if we always update those properties using Ember's <code>set</code> method, which is why
all of the examples use it. Computed properties can depend on other types of
values as well though. Altogether, the types of values are:</p>
<ul>
<li>Plain, undecorated object properties</li>
<li><code>@tracked</code> properties</li>
<li><code>@computed</code> properties</li>
<li><code>@dependentKeyCompat</code> getters</li>
<li>Arrays</li>
</ul>
<p>We'll talk about each of these individually, and discuss how they are watched
and updated.</p>
<h5 id="plain-properties"><a class="header" href="#plain-properties">Plain Properties</a></h5>
<p>In all the examples above, we demonstrated computed properties that depended on
plain object properties which hadn't been otherwise decorated. This was the
default in classic Ember, before tracked properties were introduced, and it
still works today - however, to trigger updates on a plain property dependency,
you <em>must</em> use <code>set</code>:</p>
<pre><code class="language-js">import { computed, set } from '@ember/object';

class Person {
  constructor(firstName, lastName) {
    set(this, 'firstName', firstName);
    set(this, 'lastName', lastName);
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // &quot;Tony Stark&quot;
ironMan.firstName = 'Anthony'; // This will throw an error
set(ironMan, 'firstName', 'Anthony'); // This will work, and update `fullName`
</code></pre>
<p>In general Ember will try to throw an error if you should use <code>set</code> to update a
value, but you didn't.</p>
<h5 id="tracked-properties-1"><a class="header" href="#tracked-properties-1">Tracked Properties</a></h5>
<p>Computed properties can also depend directly on tracked properties, and tracked
properties do <em>not</em> need to be updated with <code>set</code>. Updating them with normal
JavaScript update syntax will invalidate them:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

let ironMan = new Person('Tony', 'Stark');

ironMan.fullName; // &quot;Tony Stark&quot;
ironMan.firstName = 'Anthony'; // Now this will work, because 'firstName' is tracked!
</code></pre>
<h5 id="computed-properties-3"><a class="header" href="#computed-properties-3">Computed Properties</a></h5>
<p>Computed properties can depend on other computed properties. If you depend on a
computed property, it will only trigger updates if <em>its</em> dependencies update, or
if you set it directly:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('fullName')
  get legalName() {
    return this.fullName;
  }
}

let hero = new Person('Tony', 'Stark');

hero.legalName; // 'Tony Stark'

hero.fullName = 'Hope Pym'; // Invalidates `legalName`
hero.legalName; // 'Hope Pym'

hero.firstName = 'Hank'; // Invalidates `fullName` _and_ `legalName`
hero.fullName; // 'Hank Pym'
hero.legalName; // 'Hank Pym'
</code></pre>
<h5 id="dependency-compatible-getters"><a class="header" href="#dependency-compatible-getters">Dependency Compatible Getters</a></h5>
<p>In modern, fully tracked classes, computed properties aren't recommended
anymore. However, if you are working in a legacy codebase and converting to
tracked properties and native getters, there may be a point in time where you
try to convert a computed property that is being depended on by <em>other</em> computed
properties. Native getters normally <em>cannot</em> be depended on, and this will
trigger an error in development mode.</p>
<p>However, this doesn't mean that you need to convert an entire tree of computed
properties every time you try to update a class! Instead, you can mark native
getters that need to be depended on by computed properties with the <code>@dependentKeyCompat</code>
decorator:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { dependentKeyCompat } from '@ember/object/compat';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @dependentKeyCompat
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('fullName')
  get legalName() {
    return this.fullName;
  }
}
</code></pre>
<p>This decorator exposes the getter to computed properties, but otherwise leaves
it untouched - it'll operate just like a normal native getter with tracked
properties. When you have removed all computed properties that are depending on the
getter, you can remove the <code>@dependentKeyCompat</code> decorator.</p>
<p>In general, you should try to remove <code>@dependentKeyCompat</code> decorators as you convert your
app. Making getters compatible with the explicit dependency system means that more computeds can be written to watch
those getters, and the situation can get <em>worse</em> instead of better over time. If
you need to write a service or class that needs to interop with modern and
classic code for some time, try to <em>minimize</em> the number of <code>@dependentKeyCompat</code> getters
to just the ones that are the &quot;public API&quot; of the class - the values that are
expected to be depended on from the outside by other classes.</p>
<h5 id="arrays"><a class="header" href="#arrays">Arrays</a></h5>
<p>As we mentioned above, computed properties can specify dependencies on arrays.
They can watch for changes in the items of the array by watching the <code>[]</code> key of
the array, and they can watch for changes on properties of the items using the
<code>@each</code> syntax.</p>
<p>In order to be properly notified of changes to an array, you either use KVO
compliant methods of Ember arrays such as <code>pushObject</code> or <code>popObject</code>, or <code>set</code>
the entire array:</p>
<pre><code class="language-js">import { computed, set } from '@ember/object';
import { A as emberA } from '@ember/array';

class Person {
  constructor(friends = []) {
    set(this, 'friends', friends);
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}

let joey = new Person(
  emberA([
    { name: 'Phoebe' },
    { name: 'Monica' },
    { name: 'Chandler' },
    { name: 'Ross' },
  ])
);

// Using pushObject will cause `friendNames` to update
joey.friends.pushObject({ name: 'Rachel' });

// Alternatively, we can update the whole array:
set(joey, 'friends', [...joey.friends, { name: 'Rachel' }]);
</code></pre>
<p>If the property is tracked, then <code>set</code> is not necessary, and the field can be
updated directly as you would with normal tracked properties:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracking friends;

  constructor(friends = []) {
    this.friends = friends;
  }

  @computed('friends.[]')
  get friendNames() {
    return this.friends.map(friend =&gt; friend.name);
  }
}

let joey = new Person([
  { name: 'Phoebe' },
  { name: 'Monica' },
  { name: 'Chandler' },
  { name: 'Ross' },
]);

joey.friends = [...joey.friends, { name: 'Rachel' }];
</code></pre>
<h4 id="computed-properties-and-tracking"><a class="header" href="#computed-properties-and-tracking">Computed Properties and Tracking</a></h4>
<p>Computed properties will autotrack when they are accessed from templates or
through other getters, like tracked properties:</p>
<pre><code class="language-js">import { computed } from '@ember/object';
import { dependentKeyCompat } from '@ember/object/compat';
import { tracked } from '@glimmer/tracking';

class Person {
  @tracked firstName;
  @tracked lastName;

  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @computed('firstName', 'lastName')
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  set fullName(value) {
    let [firstName, lastName] = value.split(' ');

    this.firstName = firstName;
    this.lastName = lastName;
  }

  // legalName will update whenever `fullName` updates
  get legalName() {
    return this.fullName;
  }
}
</code></pre>
<h3 id="when-to-use-get-and-set-1"><a class="header" href="#when-to-use-get-and-set-1">When to Use <code>get</code> and <code>set</code></a></h3>
<p>Ember's classic change tracking system used two methods to ensure that all data
was accessed properly and updated correctly: <code>get</code> and <code>set</code>.</p>
<pre><code class="language-js">import { get, set } from '@ember/object';

let person = {};

set(person, 'firstName', 'Amy');
set(person, 'lastName', 'Lam');

get(person, 'firstName'); // 'Amy'
get(person, 'lastName'); // 'Lam'
</code></pre>
<p>In classic Ember, all property access had to go through these two methods. Over
time, these rules have become less strict, and now they have been minimized to
just a few cases. In general, in a modern Ember app, you shouldn't need to use
them all that much. As long as you are marking your properties as <code>@tracked</code>,
autotracking should automatically figure out what needs to change, and when.</p>
<p>However, there still are two cases where you <em>will</em> need to use them:</p>
<ul>
<li>When accessing and updating plain, undecorated properties on objects</li>
<li>When using Ember's <code>ObjectProxy</code> class, or a class that implements the
<code>unknownProperty</code> function (which allows objects to intercept <code>get</code> calls)</li>
</ul>
<p>Additionally, you will have to continue using <em>accessor</em> functions for arrays if
you want arrays to update as expected. These functions are covered in more
detail in the guide on arrays (LINK TO ARRAY GUIDES HERE).</p>
<p>Importantly, you do <em>not</em> have to use <code>get</code> or <code>set</code> when reading or updating
computed properties, as was noted in the computed property section.</p>
<h4 id="plain-properties-1"><a class="header" href="#plain-properties-1">Plain Properties</a></h4>
<p>In general, if a value in your application could update, and that update should
trigger rerenders, then you should mark that value as <code>@tracked</code>. This
oftentimes may mean taking a POJO and turning it into a class, but this is
usually better because it forces us to <em>rationalize</em> the object - think about
what its API is, what values it has, what data it represents, and define that in
a single place.</p>
<p>However, there are times when data is <em>too</em> dynamic. As noted below, proxies are
often used for this type of data, but usually they're overkill. Most of the
time, all we want is a POJO.</p>
<p>In those cases, you can still use <code>get</code> and <code>set</code> to read and update state from
POJOs within your getters, and these will track automatically and trigger
updates.</p>
<pre><code class="language-js">class Profile {
  person = {
    firstName: 'Chris',
    lastName: 'Thoburn',
  };

  get profileName() {
    return `${get(this.person, 'firstName')} ${get(this.person, 'lastName')}`;
  }
}

let profile = new Profile();

// render the page...

set(profile.person, 'firstName', 'Christopher'); // triggers an update
</code></pre>
<p>This is also useful for interoperating with older Ember code which has not yet
been updated to tracked properties. If you're unsure, you can use <code>get</code> and
<code>set</code> to be safe.</p>
<h4 id="objectproxy"><a class="header" href="#objectproxy"><code>ObjectProxy</code></a></h4>
<p>Ember has and continues to support an implementation of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>,
which is a type of object that can <em>wrap around</em> other objects and <em>intercept</em>
all of your gets and sets to them. Native JavaScript proxies allow you to do
this without any special methods or syntax, but unfortunately they are not
available in IE11. Since many Ember users must still support IE11, Ember's
<code>ObjectProxy</code> class allows us to accomplish something similar.</p>
<p>The use cases for proxies are generally cases where some data is very dynamic,
and its not possible to know ahead of time how to create a class that is
decorated. For instance, <a href="https://github.com/hjdivad/ember-m3">ember-m3</a> is an
addon that allows Ember Data to work with dynamically generated models instead
of models defined using <code>@attr</code>, <code>@hasMany</code>, and <code>@belongsTo</code>. This cuts back on
code shipped to the browser, but it means that the models have to <em>dynamically</em>
watch and update values. A proxy allows all accesses and updates to be
intercepted, so M3 can do what it needs to do without predefined classes.</p>
<p>Most <code>ObjectProxy</code> classes have their own <code>get</code> and <code>set</code> method on them, like
<code>EmberObject</code> classes. This means you can use them directly on the class
instance:</p>
<pre><code class="language-js">proxy.get('firstName');
proxy.set('firstName', 'Amy');
</code></pre>
<p>If you're unsure whether or not a given object will be a proxy or not, you can
still use Ember's <code>get</code> and <code>set</code> functions:</p>
<pre><code class="language-js">get(maybeProxy, 'firstName');
set(maybeProxy, 'firstName', 'Amy');
</code></pre>
<h2 id="drawbacks-115"><a class="header" href="#drawbacks-115">Drawbacks</a></h2>
<ul>
<li>The interop story here may a bit confusing for users at first. <code>@dependentKeyCompat</code>
should only be used in some cases, and it could unclear when it should be
used. Documentation should help alleviate this, along with clear examples.</li>
<li>We're introducing a decorator that will eventually be deprecated and removed
as part of this process, which is essentially some tech debt we're taking on.
However, we know that this has a timeline for removal, and it is purely a
temporary measure for interop, so it's not a significant amount of debt to
take on in the meantime.</li>
</ul>
<h2 id="alternatives-118"><a class="header" href="#alternatives-118">Alternatives</a></h2>
<ul>
<li>We could not provide <code>@dependentKeyCompat</code> instead. This would mean there isn't really
an interop path for users who want to depend on native getters from CPs and
observers, leaving a large gap that could prevent users from updating
altogether.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-04-12
Relevant Team(s): Ember.js, Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/481</p>
<hr />
<h1 id="component-templates-co-location"><a class="header" href="#component-templates-co-location">Component Templates Co-location</a></h1>
<h2 id="summary-125"><a class="header" href="#summary-125">Summary</a></h2>
<p>We propose to place a component's JavaScript file (the class) and its template
in the same directory on the file system.</p>
<p>Today:</p>
<pre><code>app
├── components
│   ├── just-class.js
│   ├── my-widget.js
│   ├── nested
│   │   └── another-widget.js
│   └── ...
├── models
│   └── ...
├── routes
│   └── ...
├── services
│   └── ...
├── templates
│   ├── components
│   │   ├── just-template.hbs
│   │   ├── my-widget.hbs
│   │   ├── nested
│   │   │   └── another-widget.hbs
│   │   └── ...
│   ├── some-route.hbs
│   └── ...
└── ...
</code></pre>
<p>Proposed:</p>
<pre><code>app
├── components
│   ├── just-class.js
│   ├── just-template.hbs
│   ├── my-widget.hbs
│   ├── my-widget.js
│   ├── nested
│   │   ├── another-widget.hbs
│   │   └── another-widget.js
│   └── ...
├── models
│   └── ...
├── routes
│   └── ...
├── services
│   └── ...
├── templates
│   ├── some-route.hbs
│   └── ...
└── ...
</code></pre>
<h2 id="motivation-125"><a class="header" href="#motivation-125">Motivation</a></h2>
<p>Today, a component's JavaScript file is located in the <code>app/components</code>
directory. On the other hand, its template is located in the
<code>app/templates/components</code> directory.</p>
<p>This design decision is a relic of Ember's pre-1.0 days. In those early days,
before components were even conceived, &quot;views&quot; were the primary building blocks
in Ember's UI programming model. Like components, they consist of a view class
located in <code>app/views/$NAME.js</code> (subclassing <code>Ember.View</code>), and/or a template
located in <code>app/templates/$NAME.hbs</code>. In other words, every template in Ember
could optionally have an associated view class, and vice versa.</p>
<p>Similar to components, they can be &quot;invoked&quot; in other templates using either
the <code>{{view &quot;$NAME&quot;}}</code> or <code>{{#view &quot;$NAME&quot;}}...{{/view}}</code> syntax. At the time,
this was how Ember developers create reusable pieces of UI in their app.</p>
<p>Unlike components, when a view is &quot;invoked&quot;, the view instance does not become
the <code>this</code> context of its template. Instead, the <code>this</code> from the calling side
will persist (similar to partials), while properties on the view instance are
accessible from within the template with <code>{{view.someProperty}}</code> syntax.</p>
<p>Over time, this programming model has gone through several iterations of
refinements (remember the short-lived &quot;controls&quot;? 😀), eventually evolved into
the component-based programming model as we know it today.</p>
<p>When components were introduced, it was decided that they would live in a
separate &quot;namespace&quot; than views: their JavaScript files are located in
<code>app/components</code> instead of <code>app/views</code>, and it uses the now-familiar curly
invocation syntax instead of the <code>view</code> keyword.</p>
<p>This decision causes two problems. First, given a template file, such as
<code>app/templates/foo-bar.hbs</code>, how do we know if it belongs to a component or a
view? Furthermore, since they live in different namespaces, it is totally legal
to have unrelated components and views with the same names, which could result
in naming collisions if their templates were both located in <code>app/templates</code>.
To solve this problem, component templates were also given a separate namespace
<code>app/templates/components</code>, as opposed to sharing <code>app/templates</code> with views.</p>
<p>Over the course of the Ember 1.x release series, components have taken over as
the primary UI programming primitive. Views were eventually deprecated and
removed from Ember's API entirely in Ember 2.0. Despite that, the ramifications
of that era are still around us.</p>
<p>We argue that the current file system layout for component files is one such
example. Given how much Ember has evolved since its early days, most of the
design constraints we had at the time no longer apply. On the other hand, new
features in the framework – such as the introduction of Ember CLI and the addon
ecosystem – has brought new capabilities and constraints to the table. As a
result, this design has caused a lot of &quot;ergonomics papercuts&quot;, which we have
enumerated below. While each of these may feel inconsequential on their own,
together they cause a lot of unnecessary friction and feel out-of-place in the
modern Ember experience.</p>
<h3 id="1-component-classtemplate-coupling"><a class="header" href="#1-component-classtemplate-coupling">1. Component class/template coupling</a></h3>
<p>The JavaScript class and template of a component are not just <em>related</em> but
fundamentally <em>coupled</em>. Together, they provide the whole implementation of
the component. It is impossible to understand one of them without the other.
When one file is changed, the other likely need to be updated as well. Placing
these files physically far apart on the file system fails to communicate this
tight coupling, in addition to causing a lot of inconveniences when navigating
a project.</p>
<h3 id="2-no-single-enumeration-of-components"><a class="header" href="#2-no-single-enumeration-of-components">2. No single enumeration of components</a></h3>
<p>Given the importance of components in modern Ember apps, when navigating a
large-scale or otherwise unfamiliar project, some of the most common task for
Ember developers is to enumerate all components from the given app or to
determine whether there exists a component with a specific name. The former is
useful for getting a general sense of the scope, scale and coding style, and
the latter is sometimes necessary to disambiguate components from helpers or
to determine whether a component is part of the app or provided by an addon.</p>
<p>Unfortunately, under the current filesystem layout, neither <code>app/components</code> or
<code>app/templates/components</code> provide a complete view for those purposes. With
template-only components, it is possible to define a component without a class,
therefore a casual scan of <code>app/components</code> will not discover those components.
With the release of Octane, we expect template-only components to become more
common. Likewise, albeit less common, it is also possible to define a component
with <em>only</em> a class, making <code>app/templates/components</code> potentially incomplete
also.</p>
<p>Therefore, the &quot;correct&quot; way to explore the components in an app is to mentally
merge the contents of both folders, which is difficult and counterproductive.</p>
<h3 id="3-deviation-from-route-template-conventions"><a class="header" href="#3-deviation-from-route-template-conventions">3. Deviation from route template conventions</a></h3>
<p>In the view-centric days of Ember, <code>app/templates</code> was a &quot;kitchen-sink&quot; folder
without much internal structure – it mixes route templates with reusable view
templates, as well as component templates, each of which could be grouped into
their own deeper nesting structure.</p>
<p>With Ember 2.0 removing views, and therefore view templates, <code>app/templates</code>
now has a clear purpose and internal structure: each template file corresponds
to a route, and each folder corresponding to a nested route. For example,
<code>app/templates/post.hbs</code> is the template for the top-level <code>post</code> route, and
<code>app/templates/admin/authors/new.hbs</code> is the template for <code>admin.authors.new</code>.</p>
<p>Of course, there is one prominent exception to this: <code>app/templates/components</code>
breaks the otherwise clear convention. Unlike other folders in <code>app/templates</code>,
<code>app/templates/components</code> does not represent a nested route. Furthermore, its
internal structure (if any) also differs from its siblings: folders represent
arbitrary logical/domain groupings, rather than sub-routes.</p>
<p>Since <code>app/templates/components</code> did not start with a special character (e.g.
<code>app/templates/-components</code>), it shows up in the middle between its routes
siblings in most apps, due to lexicographical sorting of the filenames.</p>
<p>This inconsistency causes confusion and prevents us from teaching the otherwise
clear convention crisply.</p>
<h3 id="4-lack-of-single-import"><a class="header" href="#4-lack-of-single-import">4. Lack of single import</a></h3>
<p>Even though the JavaScript class and template of a component are fundamentally
coupled and inseparable pieces, this relationship is only very loosely encoded
in Ember today. In fact – the only thing that ties them together is their name:
when Ember tries to render a component, it will separately lookup the class and
template by name through the resolver. These elements can both be present at
the same time, or in the cases of template-only or class-only components, one
of the resolutions will return a negative result. Only when both elements are
missing would Ember declare the component missing and raise an error.</p>
<p>This setup falls short when designing components meant for subclassing. For
example:</p>
<pre><code class="language-js">// app/components/foo-bar.js

import MyParentComponent from &quot;./my-parent&quot;;

export default class FooBarComponent extends MyParentComponent {
  // ...
}
</code></pre>
<p>As far as Ember can tell, this file defines a class-only component by the name
of <code>foo-bar</code>. The fact that it inherits from <code>my-parent</code> is an irrelevant and
unobservable detail. While the developer may expect this to also inherit the
parent component's template (<code>app/templates/components/my-parent.hbs</code>), Ember
has no way to know that the two are related.</p>
<p>Because of this problem, addons typically use the <code>layout</code> property from the
classic component API to get around this problem. When generating a component
in an addon, this is the default output from the blueprint:</p>
<pre><code class="language-js">// addon/components/foo-bar.js

import Component from &quot;@ember/component&quot;;
import layout from &quot;../templates/components/foo-bar&quot;;

export default Component.extend({
  layout
});
</code></pre>
<pre><code class="language-hbs">{{!-- addon/templates/components/foo-bar.hbs --}}

{{yield}}
</code></pre>
<pre><code class="language-js">// app/components/foo-bar.js

export { default } from &quot;my-addon/components/foo-bar&quot;;
</code></pre>
<p>First, within the <code>addon</code> folder, there is the component class and template.
Having these files in the <code>addon</code> folder allow them to be imported from
JavaScript (e.g. <code>import FooBar from 'my-addon/components/foo-bar';</code>) for
subclassing. However, as mentioned above, this does not also bring along the
component's template.</p>
<p>To avoid developers having to also import the template, the addon component
blueprint sets the <code>layout</code> property on the component's class. At runtime,
when Ember fail to find a template associated with the component, it will
then fall back to this property.</p>
<p>Finally, it re-exports the component in the <code>app</code> folder, which is merged with
the app's <code>app</code> folder, allowing the component to be resolved by the resolver
and invoked from Handlebars.</p>
<p>This workaround gets the job done, but has several major drawbacks.</p>
<p>First, it adds a significant amount of boilerplate to addon components, which
could be puzzling even to seasoned addon developers. In fact, the problem it
solves is unique to addons – there is nothing wrong with using inheritance in
apps – we just didn't think we could justify adding this amount of boilerplate
to every app and putting them in Ember's &quot;happy path&quot;.</p>
<p>Second, the <code>layout</code> property in classic component uses a feature in Glimmer VM
called &quot;late-bound layout&quot;, in which we must assume a different template for
each <em>instance</em> of the component (the <code>layout</code> property can be set in <code>init</code>).
This is fundamentally more difficult to optimize and excludes the component
from key optimizations (and opportunities for future optimizations).</p>
<p>Most importantly, Glimmer components do not have the equivalent of the <code>layout</code>
property, meaning that addons (or components designed for inheritance in mind)
cannot be written using Glimmer components today.</p>
<p>To solve these problems once and for all, we need to change things such that
component templates are automatically associated with their JavaScript class at
build time, and importing the JavaScript class should result in a value that
has this metadata associated with it, which needs to survive subclassing as
well. Solving this problem is also essential for unblocking template imports.</p>
<p>We believe the technical design for allowing co-location will solve this
problem nicely.</p>
<h2 id="detailed-design-108"><a class="header" href="#detailed-design-108">Detailed design</a></h2>
<h3 id="high-level-design-1"><a class="header" href="#high-level-design-1">High-level design</a></h3>
<p>We propose to allow placing a component's template adjacent to its JavaScript
file in <code>app/components</code>. For example, for a component named <code>foo-bar</code>, it will
be <code>app/components/foo-bar.js</code> and <code>app/components/foo-bar.hbs</code>.</p>
<p>In addition, per the node resolution convention, we propose to allow <code>index</code>
files inside a directory to have the equivalent semantics. In the example
above, it could also be structured as <code>app/components/foo-bar/index.js</code> and
<code>app/components/foo-bar/index.hbs</code>. This allows additional files related to the
component (such as a <code>README.md</code> file) to be co-located on the filesystem.</p>
<p>For template-only components, they can be either <code>app/components/foo-bar.hbs</code>
or <code>app/components/foo-bar/index.hbs</code> without a corresponding JavaScript file.</p>
<p>Similarly, for addons, templates can be placed inside <code>addon/components</code> with
the same rules laid out above.</p>
<p>In all of these case, if a template file is present in <code>app/components</code> or
<code>addon/components</code>, it will take precedence over any corresponding template
files in <code>app/templates</code>, the <code>layout</code> property on classic components, or a
template with the same name that is made available with the resolver API.
Instead of being resolved at runtime, a template in <code>app/components</code> will be
associated with the component's JavaScript class at build time.</p>
<h3 id="low-level-primitives"><a class="header" href="#low-level-primitives">Low-level primitives</a></h3>
<p>We propose to introduce the following low-level APIs:</p>
<ul>
<li>
<p>The <code>setComponentTemplate</code> function takes two arguments, the first being the
pre-compiled (wire-format) template, the second being the component class. It
transparently associates the given template with the component class in a way
can be retrieved later with the <code>getComponentTemplate</code> function described
below. For convenience, <code>setComponentTemplate</code> will return the component
class (the second argument).</p>
</li>
<li>
<p>The <code>getComponentTemplate</code> function takes a component class and returns the
template associated with the given component class, if any, or one of its
superclasses, if any, or <code>undefined</code> if no template association was found.</p>
</li>
</ul>
<p>This is one possible way to implement these functions:</p>
<pre><code class="language-js">function setComponentTemplate(template, componentClass) {
  Object.defineProperty(componentClass, &quot;__template__&quot;, {
    configurable: true,
    enumerable: false,
    writable: false,
    value: template
  });

  return componentClass;
}

function getComponentTemplate(componentClass) {
  return componentClass.__template__;
}

class Foo {}
class Bar extends Foo {}
class Baz extends Bar {}

class Bat {}

// USAGE

setComponentTemplate(template(&quot;foo template&quot;), Foo);
setComponentTemplate(template(&quot;baz template&quot;), Baz);

getComponentTemplate(Foo); // =&gt; foo template
getComponentTemplate(Bar); // =&gt; foo template (inherited)
getComponentTemplate(Baz); // =&gt; baz template (overridden)

getComponentTemplate(Bat); // =&gt; undefined
</code></pre>
<p>In an actual implementation, we would probably want to avoid polluting the
component class with a string key (<code>__template__</code> in this example) and use a
<code>Symbol</code> or <code>WeakMap</code> based strategery.</p>
<p>For performance reason, changing the template is not allowed once set. It is
also illegal to call <code>setComponentTemplate</code> on a component class that has
already been rendered, or once <code>getComponentTemplate</code> has been called on it.
Together, these rules ensure the results from calling <code>getComponentTemplate</code>
can be reliably cached, either by the internals of <code>getComponentTemplate</code>
itself or by one of its callers.</p>
<p>While the default export of a component's JavaScript file is usually a class,
it is not a strict requirement with custom component managers. To accommodate
this, <code>setComponentTemplate</code> can be passed any JavaScript <code>Object</code>.</p>
<h3 id="build-time-transformations"><a class="header" href="#build-time-transformations">Build-time transformations</a></h3>
<p>The low-level <code>setComponentTemplate</code> and <code>getComponentTemplate</code> APIs are not
intended to be called by end-users directly, even though they will be public
and part of our semver stability guarantee. Instead, they are meant to be used
primarily in the output emitted by build tools. At build time, any template
files found in <code>{app,addon}/components</code> will be inlined into the component's
JavaScript file and removed from the build output. For example, given these
files on disk:</p>
<pre><code class="language-js">// app/components/foo-bar.js

import Component from &quot;@ember/component&quot;;

export default Component.extend({
  // ...
});
</code></pre>
<pre><code class="language-hbs">{{!-- app/components/foo-bar.hbs --}}

foo bar!
</code></pre>
<p>The build output will be something to the effect of this JavaScript file:</p>
<pre><code class="language-js">// app/components/foo-bar.js

import Component, { setComponentTemplate } from &quot;@ember/component&quot;;

// output of compiling &quot;foo bar!&quot; with ember-cli-htmlbars
const TEMPLATE = Ember.HTMLBars.template({
  id: &quot;...&quot;,
  block: &quot;...&quot;,
  meta: { moduleName: &quot;app/components/foo-bar&quot; }
});

const CLASS = Component.extend({
  // ...
});

export default setComponentTemplate(TEMPLATE, CLASS);
</code></pre>
<p>The variables are named here for clarity, but the actual build output would
be careful to avoid introducing hygiene issues and other observable semantic
changes to the JavaScript file.</p>
<p>One caveat here is that each component JavaScript file should export a value
that is unique to that file. For example, this should be <strong>avoided</strong>:</p>
<pre><code class="language-js">// app/components/foo-bar.js

import MyParentComponent from &quot;./my-parent&quot;;

// BAD: don't do this!
export default MyParentComponent;
</code></pre>
<p>This is problematic because <code>setComponentTemplate</code> will be called on
<code>MyParentComponent</code> directly, affecting the parent component and all of its
descendants. This can be avoided by subclassing, even when no customization is
required:</p>
<pre><code class="language-js">// app/components/foo-bar.js

import MyParentComponent from &quot;./my-parent&quot;;

// GOOD: do this instead!
export default class extends MyParentComponent {}
</code></pre>
<p>Most cases of this problem can be linted against easily.</p>
<h3 id="template-only-components-2"><a class="header" href="#template-only-components-2">Template-only components</a></h3>
<p>For template-only components, we propose to introduce the following low-level
API:</p>
<ul>
<li>The <code>templateOnlyComponent</code> function takes no arguments and produces a unique
value that can be used to represent a template-only component.</li>
</ul>
<p>Again, this function, though public, is not intended to be called by users
directly. It is primarily used in the output emitted by build tools. When a
template is found in <code>{app,addon}/components</code> but without a corresponding
JavaScript file, the build output will be something similar to the following:</p>
<pre><code class="language-js">// app/components/foo-bar.js

import Component, { setComponentTemplate } from &quot;@ember/component&quot;;
import templateOnlyComponent from &quot;@ember/component/template-only&quot;;

// output of compiling &quot;foo bar!&quot; with ember-cli-htmlbars
const TEMPLATE = Ember.HTMLBars.template({
  id: &quot;...&quot;,
  block: &quot;...&quot;,
  meta: { moduleName: &quot;app/components/foo-bar&quot; }
});

const CLASS = templateOnlyComponent();

export default setComponentTemplate(TEMPLATE, CLASS);
</code></pre>
<p>In addition to build tooling, addon authors may also find this function
useful. Currently, the only way to create a &quot;true&quot; template-only component
is by enabling an optional feature in the app. Since addons cannot assume the
value of that flag in the consuming app, they currently cannot take advantage
of the feature. By providing this function, addon authors can work around this
problem by explicitly defining a JavaScript file with <code>templateOnlyComponent()</code>
as the default export.</p>
<p>On the other hand, app developers, should <em>not</em> have any reason to use this
function directly in their app, since they could just as easily enable the
optional feature across the board.</p>
<h3 id="codemod-1"><a class="header" href="#codemod-1">Codemod</a></h3>
<p>A codemod will be provided to seamlessly migrate component templates.</p>
<p>Such a &quot;codemod&quot; will essentially just merges <code>app/templates/components</code> into
<code>app/components</code>. For a quick &quot;taste test&quot; of what the resulting tree will look
like in your app, the following commands give a close approximation:</p>
<pre><code class="language-bash">$ rsync --archive --remove-source-files app/templates/components/ app/components/
$ rm -rf app/templates/components/
</code></pre>
<p>Of course, the resulting output won't &quot;work&quot;, but it can be useful for getting
a sense of what it's like to work with the new layout on editors, Github, etc.</p>
<h3 id="generator"><a class="header" href="#generator">Generator</a></h3>
<p>We propose to make some updates to the components generator to accompany this
change.</p>
<ol>
<li>
<p>It should accept a <code>--component-class</code> option. This controls which base
class is used for that component and whether native classes are used. The
legal values for this option are <code>@glimmer/component</code> (aliased as <code>-gc</code>),
<code>@ember/component</code> (aliased as <code>-cc</code>), <code>@ember/component/template-only</code>
(aliased as <code>-tc</code>) or an empty string (aliased as <code>--no-component-class</code> and
<code>-nc</code>).</p>
<p>The latter two differ in that <code>@ember/component/template-only</code> would
generate an explicit JavaScript file with <code>templateOnlyComponent()</code> as the
default export, which is useful for addons, whereas <code>--no-component-class</code>
would skip generating a JavaScript file altogether.</p>
<p>This option may be extended in the future to allow other custom components
to provide their own blueprints, but for now, passing anything other than
the allowed values will result in an error.</p>
</li>
<li>
<p>It should accept a <code>--component-structure</code> option.</p>
<p>When this option is set to <code>flat</code> (aliased as <code>-fs</code>), the component's JavaScript and template files will both be generated at the root of
<code>{app,addon}/components</code>.</p>
<p>When this option is set to <code>nested</code> (aliased as <code>-ns</code>), a folder will be
generated for the component in <code>{app,addon}/components</code>, and the component's
JavaScript and template files will be generated as <code>index.{js,hbs}</code> inside
the folder.</p>
<p>When this option is set to <code>classic</code> (aliased as <code>-cs</code>), the component's
template file will be generated in <code>{app,addon}/templates/components</code>. For
addons, when used with <code>--component-class=@ember/component</code>, this will also
emit the <code>layout</code> property workaround.</p>
<p>When this option is set to <code>pods</code> (aliased as <code>--pods</code>), it will generate
<code>{app,addon}/components/$name/{component.js,template.hbs}</code>.</p>
</li>
<li>
<p>Thses options will default to <code>--component-class=@ember/component</code> and
<code>--component-structure=classic</code> for backwards compatibility.</p>
<p>However, the default values can be overridden in <code>.ember-cli</code> as usual, and
teams are encouraged to do so as they see fit. Due to a limitation in how
the system works, the names for these options are chosen such that they are
unlikely to conflict with options on other <code>ember</code> commands, which is why
they are a bit verbose.</p>
<p>For Octane apps, the default app blueprint will include a <code>.ember-cli</code> file
that defaults to <code>--no-component-class</code> and <code>--component-structure=flat</code>.
The guides and documentation will assume these settings going forward.</p>
</li>
</ol>
<h2 id="how-we-teach-this-94"><a class="header" href="#how-we-teach-this-94">How we teach this</a></h2>
<p>As mentioned above, we will update the learning resources to assume the &quot;flat&quot;
co-located layout. Throughout the Ember Guides, the Tutorials, and the CLI
Addon Tutorial, we would update the file paths in all component examples. Since
we assume the classic layout today, in most cases only the template paths would
need to be updated. The prose describing the location of files would also need
to change.</p>
<p>The API documentation will describe the full set of file layout options
supported in the major version of Ember. A section should also be added to the
CLI guides, which describes how to properly import components from addons that
have a mix of layout types. We will not cover blending file layouts in the
Ember Guides, since they represent the happy path for an app, but we could link
to the CLI Guides explanation.</p>
<p>With this layout, it should be much easier for new users to form a mental model
around components. We can start by teaching that the most basic component is
just a reusable piece of markup (template-only components), but can &quot;upgraded&quot;
to have dynamic content by taking arguments using the <code>@name</code> syntax, and
further &quot;upgraded&quot; to keep internal states by creating a JavaScript file next
to the template and finally add interactivity with element modifiers.</p>
<p>Because template-only component is such a light-weight concept, it is arguably
not necessary to separate out the topic of &quot;templates&quot; from &quot;components&quot; in the
guides, but this can be addressed in a future revision of the guides.</p>
<p>We will teach that the <code>templates</code> folder is used for route templates. This can
be introduced in the Guides at the same time as the <code>routes</code> and <code>controllers</code>
folders/topics, which come later in the Table of Contents.</p>
<h2 id="drawbacks-116"><a class="header" href="#drawbacks-116">Drawbacks</a></h2>
<p>Another drawback is that it only address the co-location issue for components,
not other related types like [[route, controller, route template]] and [[model,
adapter, serializer]], or even co-location of tests. However, we believe the
situation with components is unique enough (see the motivation section) that
they are not merely <em>related</em>, but <em>coupled</em>. That, along with the fact that
components are much more common, sets them apart from the rest and justifies
solving the problem first.</p>
<p>There is a small risk that we will subject the community to another migration
when we finalize the replacement of Module Unification (the &quot;New File Layout&quot;).
However, we feel pretty confident that regardless of where the collection of
components will end up on disk (e.g. <code>src/ui/components</code>), the internal
structure of that collection will closely match what is proposed in this RFC.
Ultimately, we expect there to be automatic migrators for these kinds of
changes anyway, so the cost of the possible churn is contained.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-04-28
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/486
Tracking: https://github.com/emberjs/rfc-tracking/issues/54</p>
<hr />
<h1 id="deprecate-support-for-mouseenterleavemove-ember-events"><a class="header" href="#deprecate-support-for-mouseenterleavemove-ember-events">Deprecate support for mouseEnter/Leave/Move Ember events</a></h1>
<h2 id="summary-126"><a class="header" href="#summary-126">Summary</a></h2>
<p>Deprecate support for <code>mouseenter</code>, <code>mouseleave</code> and <code>mousemove</code> events in Ember's EventDispatcher. This affects
the corresponding event handler methods (<code>mouseEnter() {}</code>) in Ember components and 
<code>{{action &quot;some&quot; on=&quot;mouseenter&quot;}}</code>. </p>
<h2 id="motivation-126"><a class="header" href="#motivation-126">Motivation</a></h2>
<p>Ember's EventDispatcher handles &quot;Ember events&quot; by attaching listeners to the app's root element
and relying on the events bubbling up to that element (aka event delegation). There they 
are processed and invoke any matching <code>Ember.Component</code> event handler method with 
the same (camel-cased) method as the event type. Same for element-space <code>{{action}}</code> 
modifiers.</p>
<blockquote>
<p>Note: for a &quot;Deep Dive on Ember Events&quot; and how they differ from &quot;native events&quot; I refer to 
Marie Chatfield's excellent 
<a href="https://medium.com/square-corner-blog/deep-dive-on-ember-events-cf684fd3b808">blog post</a>
or <a href="https://youtu.be/G9hXjjHFJVs">EmberConf talk</a></p>
</blockquote>
<p>This works fine in general, but <code>mouseenter</code>/<code>mouseleave</code> events are special as they do
not bubble. In the past it still worked nevertheless as jQuery transparently handled this
for us, as it had special support for event delegation for these events, essentially by using 
(bubbling) <code>mouseover</code> events to replicate the semantics of <code>mouseenter</code>/<code>mouseleave</code> events.</p>
<p>When support for jQuery-less apps was introduced, this <a href="https://github.com/emberjs/ember.js/issues/16591">left a hole</a>
in the jQuery-less EventDispatcher implementation. But as support for those events was and
still is part of Ember's pubic API, we had no chance other than to <a href="https://github.com/emberjs/ember.js/pull/16603">implement support
for jQuery-less apps</a> using the same 
<code>mouseover</code> based approach.</p>
<p>This however comes with a cost: besides an <a href="https://github.com/emberjs/ember.js/issues/17228">unresolved issue</a>
the implementation has some performance drawbacks, as it has to process every <code>mouseover</code> event on 
<em>any</em> element, create fake <code>mouseenter</code>/<code>mouseleave</code> events and try to dispatch them, even when 
not a single component/action needs them.</p>
<p>Deprecating support for <code>mousemove</code> is also proposed, which is a (bubbling) event that does not have the higher 
implementation cost as <code>mouseenter</code>/<code>mouseleave</code>, but nevertheless requires the EventDispatcher to optimistically handle
these extremely high-volume events.</p>
<p>While efforts to make this more &quot;pay as you go&quot; are <a href="https://github.com/emberjs/ember.js/pull/17911">possible</a>, 
the trade-off of keeping support around still seems unfavorable, as these events fire so
frequently, while they are (most certainly) very rarely used.</p>
<p>This is even more so given that Glimmer Components with their outerHTML semantics do not 
work with event handler methods, and <code>{{action}}</code> will eventually fade away in favor of
<code>{{on}}</code> using native <code>addListener()</code>.</p>
<h2 id="transition-path-17"><a class="header" href="#transition-path-17">Transition Path</a></h2>
<h4 id="embercomponent-1"><a class="header" href="#embercomponent-1">Ember.Component</a></h4>
<p>When a component with a <code>mouseEnter</code>, <code>mouseLeave</code> or <code>mouseMove</code> method is created, a deprecation warning will be issued.</p>
<p>The linked migration guide will cover these examples:</p>
<p>Before:</p>
<pre><code class="language-js">import Component from '@ember/component';

export default class MyComponent extends Component {
  mouseEnter(e) {
    // do something
  }
}
</code></pre>
<p>After:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { action } from '@ember/object';

export default class MyComponent extends Component {
  @action
  handleMouseEnter(e) {
    // do something
  }
  
  didInsertElement() {
    super.didInsertElement(...arguments);
    this.element.addEventListener('mouseenter', this.handleMouseEnter);
  }
  
  willDestroyElement() {
    super.willDestroyElement(...arguments);
    this.element.removeEventListener('mouseenter', this.handleMouseEnter);
  }
}
</code></pre>
<p>An alternative to attaching the event listener in the component class is to opt into outer HTML semantics by making the
component tag-less and using the <code>{{on}}</code> modifier in the template:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { action } from '@ember/object';

export default class MyComponent extends Component {
  tagName = '';
  
  @action
  handleMouseEnter(e) {
    // do something
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;div {{on &quot;mouseenter&quot; this.handleMouseEnter}}&gt;
  ...
&lt;/div&gt;
</code></pre>
<h4 id="action-modifier"><a class="header" href="#action-modifier"><code>{{action}}</code> modifier</a></h4>
<p>Similarily a deprecation warning will be shown when an instance of <code>{{action}}</code> is rendered in a template that listens
to one of the deprecated events, and will link to a deprecation guide with the following migration example:</p>
<p>Before:</p>
<pre><code class="language-hbs">&lt;button {{action &quot;handleMouseEnter&quot; on=&quot;mouseEnter&quot;}}&gt;Hover&lt;/button&gt;
</code></pre>
<p>After (based on <a href="https://github.com/emberjs/rfcs/blob/master/text/0471-on-modifier.md">RFC471</a>):</p>
<pre><code class="language-hbs">&lt;button {{on &quot;mouseenter&quot; this.handleMouseEnter}}&gt;Hover&lt;/button&gt;
</code></pre>
<h2 id="how-we-teach-this-95"><a class="header" href="#how-we-teach-this-95">How We Teach This</a></h2>
<p>The deprecation guide should explain the transition path as shown above.</p>
<p>The references to <code>mouseenter</code>, <code>mouseleave</code> and <code>mousemove</code> should be removed from the Guide's 
<a href="https://guides.emberjs.com/release/components/handling-events/#toc_event-names">Handling Events</a> section and the API 
docs for <a href="https://api.emberjs.com/ember/release/classes/Component">Components events</a>.</p>
<p>Other than that, no changes are required, as the replacement APIs are all available and
well established, and this RFC does not introduce anything new. Also having certain event
types not be supported by the EventDispatcher is not something new, as other high-volume
events like <code>mouseover</code> or <code>scroll</code> are also not supported (by default).</p>
<h2 id="drawbacks-117"><a class="header" href="#drawbacks-117">Drawbacks</a></h2>
<p>It requires refactoring existing code that relies on support for these events. But given that
these events are (presumably) rarely used, and the alternatives are easy to implement, this
should not be a major issue.</p>
<h2 id="alternatives-119"><a class="header" href="#alternatives-119">Alternatives</a></h2>
<p>We could keep support in place, and eventually work on optimizations that minimize the 
performance impact.</p>
<h2 id="unresolved-questions-78"><a class="header" href="#unresolved-questions-78">Unresolved questions</a></h2>
<p>None at this point.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-05-09
Relevant Team(s): data
RFC PR: https://github.com/emberjs/rfcs/pull/487
Tracking: https://github.com/emberjs/rfc-tracking/issues/53</p>
<hr />
<h1 id="custom-model-class-rfc"><a class="header" href="#custom-model-class-rfc">Custom Model Class RFC</a></h1>
<h2 id="summary-127"><a class="header" href="#summary-127">Summary</a></h2>
<p>This RFC is a follow-up RFC for #293 RecordData and replaces <a href="https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor">https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor</a></p>
<p>Create a way for addons and user to define their own implementation of a model class. Adds an <code>instantiateRecord</code> method to <code>Store</code> which would allow addons and ED itself to offer a clean replacement the default DS.Model with a custom Model class. </p>
<h2 id="motivation-127"><a class="header" href="#motivation-127">Motivation</a></h2>
<ul>
<li>Allowing Addons to experiment with replacing the default DS.Model implementation (<a href="https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor">https://github.com/runspired/rfcs/blob/ember-data-custom-records/text/0000-ember-data-model-factory-for.md#ember-data--modelfactoryfor</a>)</li>
<li>Currently Ember Data conflates schema information and record implementation together as part of properties defined on <code>DS.Model</code>.
DS.Model both defines the schema, that is the attributes and relationships present on a type, and the model implementation, that is the
actual class which is exposed to the app containing those properties. This has several disadvantages:</li>
<li>it makes it hard to optimize the schema information, and ties to a definition of a JS class</li>
<li>it makes it hard to statically analyze the schema</li>
<li>it requires a 1-1 correspondence between the number of backing types in the system and the number of model classes, resulting
in an app sometimes having to ship a much higher number of models than it otherwise would have.</li>
</ul>
<p>This RFC represents the first step in separating the record implementation from schema information.</p>
<h2 id="detailed-design-109"><a class="header" href="#detailed-design-109">Detailed design</a></h2>
<p>After the work in <a href="https://github.com/emberjs/rfcs/pull/465">Record Data Errors RFC</a>,  <a href="https://github.com/emberjs/rfcs/pull/463">Record Data State RFC</a>, and <a href="https://github.com/emberjs/rfcs/pull/466">Request State Service RFC</a> we have enough coverage in public apis that we can implement the entire DS.Model class with just a few changes to Store APIs. </p>
<p>We will need five separate changes: </p>
<ul>
<li>A way to instantiate custom Records and for them to be able to access underlying record data</li>
<li>A way for those records to be notified of changes in Record Data</li>
<li>A way to access schema information from the store and not from the DS.Model static properties</li>
<li>Replacement of a few store methods that take DS.Models</li>
<li>Deprecate passing DS.Model classes to adapter/serializers/exposing them on Snapshots</li>
</ul>
<h2 id="instantiating-and-destroying-custom-records"><a class="header" href="#instantiating-and-destroying-custom-records">Instantiating and destroying custom Records</a></h2>
<p>We need to make the following changes:</p>
<ul>
<li>expose a method on the store for instantiating a record</li>
<li>add a hook to be notified when a record is being destroyed for potential cleanup</li>
<li>a way for the record to get notified when RecordData values change</li>
</ul>
<p>The following interface shows the interface of these methods:</p>
<pre><code class="language-ts">interface RecordDataWrapper { // proxies a subset of RD methods and hides the rest
  getAttr(identifier: RecordIdentifier, key: string)
  isAttrDirty(identifier: RecordIdentifier, key)
    
  changedAttributes(identifier: RecordIdentifier)
  hasChangedAttributes(identifier: RecordIdentifier)
  rollbackAttributes(identifier: RecordIdentifier)
  
  getRelationship(identifier: RecordIdentifier, key: string)
  
  setRecordId(identifier: RecordIdentifier, id: string): void;
  
  getErrors(identifier: RecordIdentifier)
  getMeta(identifier: RecordIdentifier)
  
  isNew(identifier: RecordIdentifier): boolean;
  isDeleted(identifier: RecordIdentifier): boolean;

  setDirtyAttribute(identifier, key: string, value: any): void;

  addToHasMany(key: string, identifiers: Identifier[], idx?: number): void;
  removeFromHasMany(key: string, identifiers: Identifier[]): void;
  setDirtyHasMany(key: string, identifiers: Identifier[]): void;

  setDirtyBelongsTo(name: string, identifier: Identifier | null): void;
}
  
interface RecordDataFor {
  (identifier: RecordIdentifier): RecordDataWrapper
}
    
class Store {
  instantiateRecord(
    identifier: RecordIdentifier, 
    createRecordArgs: { [key: string]: any }, // args passed in to store.createRecord() and processed by recordData to be set on creation
    recordDataFor: RecordDataFor, 
    notificationManager: NotificationManager): unknown
    
  teardownRecord(record): void
}
</code></pre>
<p>Instead of passing the entire RecordData Class to <code>instantiateRecord</code>, we pass in a lookup method that returns a record data wrapper which exposes only the local facing methods and hide the server/adapter facing methods that the Model should not have access to.</p>
<p>We also expose <code>teardownRecord</code>, which will get called whenever a record is getting unloaded, or otherwise disposed of (if we add future ways of destroying records that are uncoupled from unloading) from the identity map, thus giving addons an opportunity to perform cleanup. </p>
<h2 id="change-notification"><a class="header" href="#change-notification">Change Notification</a></h2>
<p>In order for the record class to learn about changes to the underlying data, it will be passed a <code>NotificationManager</code> as a constructor argument, which will allow it to
subscribe and unsubscribe to notifications of underlying changes to the data. Once <code>RecordData</code> calls one of the notification methods, the notification manager will call 
any registered callback for the given identifier, and pass in the type of the notification, allowing the record the opportunity to repull the data if needed. There are no guarantees around the timing of the notification callback being called after <code>RecordData</code> informs the store of changes. We expect that in a modern Ember app with tracked properties, this wouldn't be the common path for tracking changes. </p>
<pre><code class="language-ts">function unsubscribe(token: UnsubscribeToken)

interface NotificationCallback {
  (identifier: Identifier, notificationType: 'attributes' | 'relationships' | 'errors'  | 'meta'  | 'unload'): void;
}
    
interface NotificationManager {
  subscribe(identifier, NotificationCallback): UnsubscribeToken
 }
</code></pre>
<h2 id="exposing-schema-information"><a class="header" href="#exposing-schema-information">Exposing schema information</a></h2>
<p>We currently keep schema information on <code>DS.Model</code> class. In order to allow for custom Model implementations we need to allow lookup of schema info from the store. We already have specified a schema api that RecordData consumes: <code>attributesDefinitionFor</code> and <code>relationshipDefinitionFor</code>. We would define on a schema interface that the store would expose and addons could use. <strong>The schema methods are not ergonomic on purpose.</strong> They match the current Record Data apis and are designed as a stepping stone on the way of having a better, user facing schema APIs. Addons could provide their own <code>SchemaDefinitionService</code> by calling <code>registerSchemaDefinitionService</code>. We would initially not allow calling <code>registerSchemaDefinitionService</code> more than once, but this constraint could potentially be relaxed in the future. The schema info is currently primarily geared towards being used by the internal relationship handling layer, the serializer/adapter layers and the DebugAdapter. Schema methods support both static and dynamic schema computation. For static schemas, the method can always respond with a schema definition based on the type passed, and for dynamic changing schemas, it can look up the underlying data by the identifer which is passed in. We would also add a method called <code>doesTypeExist</code>, which would return <code>true</code> if ED knew that a given string is a model type and <code>false</code> otherwise.</p>
<pre><code class="language-ts">export interface RelationshipDefinition {
  kind: 'hasMany'| 'belongsTo';
  type: string;
  options: { [key: string]: any } ;
  name: string;
}
    
interface RelationshipsDefinition {
  [key: string]: RelationshipDefinition
}
    
interface AttributeDefinition {
  name: string;
  options: { [key: string]: any };
  type: string;
}

interface AttributesDefinition {
  [key: string]: AttributeDefinition
}
    
interface SchemaDefinitionService {
  // Following the existing RD implementation 
  attributesDefinitonFor(identifier: RecordIdentifier | type: string): AttributesDefiniton
  
  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier: RecordIdentifier | type: string): RelationshipsDefinition

  doesTypeExist(type: string): boolean
}

class Store {
  registerSchemaDefinitionService(schema: SchemaDefinitionService): void

  getSchemaDefinitionService(): SchemaDefinitionService
}
</code></pre>
<h2 id="adding-store-methods-for-manipulating-records"><a class="header" href="#adding-store-methods-for-manipulating-records">Adding store methods for manipulating records</a></h2>
<p>Currently there exist methods on DS.Model that call into <code>internalModel</code> for it's functionality. In order for a parallel implementation
to be possible, we need to expose that functionality through public methods on the store.</p>
<pre><code class="language-ts">class Store {
  saveRecord(record): Promise // equivalent of currently doing record.save()
  serializeRecord(record): any // equivalent of currently doing record.serialize()
  relationshipReferenceFor(identifier: RecordIdentifier, key: string): RelationshipReference
}
</code></pre>
<p>this would allow you to have a custom model class like this: </p>
<pre><code class="language-ts">class CustomModel {
  save() {
    return this._store.saveRecord(this);
  }
}
</code></pre>
<h3 id="record-arrays"><a class="header" href="#record-arrays">Record Arrays</a></h3>
<p>Currently Ember Data manages live Record Arrays which are returned as a response to query methods such as <code>findAll</code> or <code>queryRecords</code>. Because ED can track records which are returned from <code>instantiateRecord</code>, it will be able to seamlessly manage custom models which are part of Ember Data record arrays and clean them up correctly. </p>
<p>If an addon implements it's own record array like structures, it will be able to manage membership of Ember Data default records by subclassing <code>teardownRecord</code>, which gives it a convinient place to listen for a record being destroyed.</p>
<h2 id="deprecating-dsmodel-being-passed-to-serializers-and-adapters-and-storemodelfor"><a class="header" href="#deprecating-dsmodel-being-passed-to-serializers-and-adapters-and-storemodelfor">Deprecating DS.Model being passed to serializers and adapters and store.modelFor</a></h2>
<p>Currently some adapter/serializer methods get the underlying class passed in. For example:</p>
<pre><code class="language-ts">// Adapter
createRecord(store, type, snapshot)
findRecord(store, type, id, snapshot)

// Serializer
normalizeResponse(store, primaryModelClass, payload, id, requestType)

// Store
modelFor(modelName)
</code></pre>
<h3 id="serializing"><a class="header" href="#serializing">Serializing</a></h3>
<p>When serializing we already have a <code>Snapshot</code> passed in as an argument which has all of the information that a <code>ModelClass</code> provides. We would deprecate the class argument being passed in, and instruct the user to refactor towards using the <code>Snapshot</code>.</p>
<p>For example: </p>
<pre><code class="language-ts">createRecord(store, type, snapshot) {
  let url = `/api/${type.modelName}`;
}
</code></pre>
<p>would become</p>
<pre><code class="language-ts">createRecord(store, type, snapshot) {
  let url = `/api/${snapshot.modelName}`;
}
</code></pre>
<p>For backwards compatibility, we would still lookup the class from the registry, and if we found a class we would return it but would no longer error if null was returned. If we did not find the class, we would create a shim class that exposed a deprecated <code>modelName</code>. We would deprecate accessing the properties on the class when passed to serializer/adapter by wrapping it in a proxy in dev mode. Currently Snapshots contain all of the data that is available on the Model class which would be needed for serializing/normalizing.</p>
<h3 id="normalizing"><a class="header" href="#normalizing">Normalizing</a></h3>
<p>While <code>Snapshot</code> roughly corresponds to a <code>Request</code> like object to be used while serializing, and we intend to in the future refactor it to be a request object, we don't have a similar construct when normalizing. In the future, normalizing will have a corresponding <code>Response</code> like object exposed, but for the time being we can still deprecate using the <code>primaryModelClass</code> argument for anything other than <code>modelName</code>, <code>eachAttribute</code>, <code>eachRelationship</code>. If a user accesses any other property on the <code>primaryModelClass</code> they will receive a deprecation.</p>
<p>If there was a custom model instance provided, and we had no corresponding class to pass in to <code>normalizeResponse</code> we would pass in a shim class that only exposed the <code>modelName</code> property, and <code>eachAttribute</code> and <code>eachRelationship</code> methods which would proxy to the underlying schema methods, thus allowing the normalization layers to continue working with custom model classes.</p>
<pre><code class="language-ts">interface ClassSchemaShim {
  modelName: string;
  eachAttribute( (name: string, attr: AttributeDefinition): void ): void;
  eachRelationship( (name: string, attr: AttributeDefinition): void ): void;
}
</code></pre>
<h2 id="how-we-teach-this-96"><a class="header" href="#how-we-teach-this-96">How we teach this</a></h2>
<p>This is a very addon/very power user specific api, and would be inappropriate for the default guides. We would document it in the Api docs and potentially if there was a guide for Ember Data addon developers.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-05-20
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/491</p>
<hr />
<h1 id="deprecate-disconnectoutlet"><a class="header" href="#deprecate-disconnectoutlet">Deprecate <code>disconnectOutlet</code></a></h1>
<h2 id="summary-128"><a class="header" href="#summary-128">Summary</a></h2>
<p>This RFC deprecates <code>Route#disconnectOutlet</code> because it has no use case given <a href="https://github.com/emberjs/rfcs/pull/418">#418</a>.</p>
<h2 id="motivation-128"><a class="header" href="#motivation-128">Motivation</a></h2>
<p><code>Route#disconnectOutlet</code> is intended to be used in conjunction with <code>Route#render</code>. When we wrote <a href="https://github.com/emberjs/rfcs/pull/418">#418</a> we should have also deprecated <code>Route#disconnectOutlet</code> because it is primarily used to teardown named outlets setup by <code>Route#render</code>. For all intensive this is just an addendum to #418.</p>
<h2 id="transition-path-18"><a class="header" href="#transition-path-18">Transition Path</a></h2>
<p>The transition path is the same to the one outlined in <a href="https://github.com/emberjs/rfcs/blob/master/text/0418-deprecate-route-render-methods.md#transition-path">#418</a>. Since the migration path for the named outlets is to use components, a developer would need to wrap the component in a conditional if they want to control the destruction.</p>
<p>Given:</p>
<pre><code class="language-js">// app/routes/checkout.js

class CheckoutRoute extends Route {
  // ...

  @action
  showModal() {
    this.render('modal', {
      outlet: 'modal',
      into: 'application'
    });
  }

  @action
  hideModal() {
    this.disconnectOutlet('modal');
  }
}
</code></pre>
<pre><code class="language-hbs">{{! app/templates/checkout.hbs}}

&lt;button {{action 'showModal'}}&gt;Show Modal&lt;/button&gt;
&lt;button {{action 'closeModal'}}&gt;Close Modal&lt;/button&gt;
</code></pre>
<pre><code class="language-hbs">{{! app/templates/application.hbs}}
{{outlet &quot;modal&quot;}}

&lt;main&gt;
  {{outlet}}
&lt;/main&gt;
</code></pre>
<p>This can transitioned to:</p>
<pre><code class="language-js">// app/controller/checkout.js

class CheckoutController extends Controller {
  // ...
  @tracked isModalOpen = false;

  init() {
    super.init();
    this.modalElement = document.getElementById('modal');
  }

  @action
  showModal() {
    this.isModalOpen = true;
  }

  @action
  closeModal() {
    this.isModalOpen = false;
  }
}
</code></pre>
<pre><code class="language-hbs">{{! app/templates/checkout.hbs}}

&lt;button {{action 'showModal'}}&gt;Show Modal&lt;/button&gt;
&lt;button {{action 'closeModal'}}&gt;Close Modal&lt;/button&gt;

{{#if this.isModalOpen}}
  {{#in-element this.modalElement}}
    &lt;Modal /&gt;
  {{/in-element}}
{{/if}}
</code></pre>
<pre><code class="language-hbs">{{! app/templates/application.hbs}}
&lt;div id=&quot;modal&quot;&gt;&lt;/div&gt;

&lt;main&gt;
  {{outlet}}
&lt;/main&gt;
</code></pre>
<p>The above example will conditionally append the modal component into <code>div#modal</code> whenever the user toggles the modal.</p>
<h2 id="how-we-teach-this-97"><a class="header" href="#how-we-teach-this-97">How We Teach This</a></h2>
<p>Once deprecated, developers will be presented with the following deprecation warning:</p>
<pre><code>&quot;disconnectOutlet&quot; has been deprecated for disconnecting outlets.
</code></pre>
<p>This deprecation message will also link to the transition guide. The transition guide will cover how to migrate named outlets to components. In addition, the guides should be updated to remove any usage of these APIs.</p>
<h2 id="drawbacks-118"><a class="header" href="#drawbacks-118">Drawbacks</a></h2>
<p>N/A. This addendum to <a href="https://github.com/emberjs/rfcs/pull/418">#418</a>.</p>
<h2 id="alternatives-120"><a class="header" href="#alternatives-120">Alternatives</a></h2>
<p>N/A. This addendum to <a href="https://github.com/emberjs/rfcs/pull/418">#418</a>.</p>
<h2 id="unresolved-questions-79"><a class="header" href="#unresolved-questions-79">Unresolved questions</a></h2>
<blockquote>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-05-30
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/494</p>
<hr />
<h1 id="async-observers"><a class="header" href="#async-observers">Async Observers</a></h1>
<h2 id="summary-129"><a class="header" href="#summary-129">Summary</a></h2>
<p>Add a way to specify whether or not observers should fire synchronously -
that is, immediately after the property they are observing has changed - or
asynchronously during the next runloop, along with an optional feature to
specify whether observers should default to sync or async.</p>
<h2 id="motivation-129"><a class="header" href="#motivation-129">Motivation</a></h2>
<p>Observers have been run synchronously in Ember since before v1.0 was released,
and for about as long it has been an intention of the core team to eventually
make them asynchronous. There are a two main reasons for why triggering
observers asynchronously would be better overall:</p>
<ul>
<li>They promote better programming practices. Synchronous observers can be used
in a lot of ways to interact with the code they are observing, which puts more
code on the &quot;hot-path&quot; and is prone to create a mess of intertangled, loosely
related code filled with <a href="https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)">spooky action at a distance</a>.</li>
<li>It would allow us to clean up a significant chunk of code within Ember
itself. There is non-trivial amount of code dedicated to sending change
signals synchronously, and that code has been slowly replaced by an
alternative system that is lazy. Asynchronous observers would allow us to
remove legacy code and tech debt.</li>
</ul>
<p>We implemented this change behind a feature flag, and several community members
tested it out in their applications. In testing, we found that this was
unfortunately too much of a breaking change to do all at once - like it or not,
the timing semantics of observers are public API.</p>
<p>The proposed solution now is to provide a method for users to specify whether an
observer should be sync or async. In existing apps, observers can be converted
incrementally to be async, giving them a path forward. In addition, an optional
feature will be made which sets observers to be async by default, allowing users
to set the default once their whole app has been converted, and allowing new
apps to prevent/discourage sync observers in the first place. In the long run,
synchronous observers will be deprecated and removed.</p>
<h2 id="detailed-design-110"><a class="header" href="#detailed-design-110">Detailed design</a></h2>
<h3 id="new-apis-1"><a class="header" href="#new-apis-1">New APIs</a></h3>
<p>A new <code>sync</code> boolean argument will be added to both <code>addObserver</code> and
<code>removeObserver</code>:</p>
<pre><code class="language-ts">export function addObserver(
  obj: any,
  path: string,
  target: object | Function | null,
  method?: string | Function,
  sync = SYNC_DEFAULT
): void;

export function removeObserver(
  obj: any,
  path: string,
  target: object | Function | null,
  method?: string | Function,
  sync = SYNC_DEFAULT
): void;
</code></pre>
<p>The argument needs to be added to both because sync and async observers are
tracked separately, so we need to know where to look for the observer when
removing it. Attempting to add both a sync and async observer will throw an
error.</p>
<p>In addition, a new overloaded form of <code>observer</code> will allow users to specify
whether or not the observer should be sync or async:</p>
<pre><code class="language-ts">type ObserverDefinition = {
  dependentKeys: string[];
  fn: Function;
  sync: boolean;
};

export function observer(...args: (string | Function)[]): Function;
export function observer(definition: ObserverDefinition): Function;
</code></pre>
<p>Users will have to provide a full <code>ObserverDefinition</code> to set <code>sync</code>, which will
prevent us from having to do any more argument munging to figure out what the
user wants.</p>
<h3 id="synchronous-observer-implementation"><a class="header" href="#synchronous-observer-implementation">Synchronous Observer Implementation</a></h3>
<p>Since chains are removed, the only way to check if observers should fire is to
cycle through all of them. This means that on every <code>notifyPropertyChange</code>, we
will cycle through <em>all</em> active synchronous observers and fire any that have
dirtied.</p>
<p>In apps that are observer heavy, this could lead to performance impacts.
Unfortunately, there isn't much we can do about this. We will try to minimize
the impact as much as possible, but in the end it will be up to individual
applications to migrate away from synchronous observers over time.</p>
<h3 id="tracked-properties-and-dependentkeycompat"><a class="header" href="#tracked-properties-and-dependentkeycompat">Tracked Properties and <code>@dependentKeyCompat</code></a></h3>
<p>Tracked properties and <code>@dependentKeyCompat</code> marked getters/setters will <em>not</em>
fire observers synchronously, since they do not use <code>notifyPropertyChange</code> or
the old change tracking system at all. In this way, they will encourage users to
convert to async observers, or away from observers entirely.</p>
<h3 id="optional-feature"><a class="header" href="#optional-feature">Optional Feature</a></h3>
<p>The name of the feature will be <code>default-async-observers</code>. Enabling it will
default all observers to be async, but still allow users to set observers to be
synchronous manually. This flag will be enabled by default in Ember Octane.</p>
<h2 id="how-we-teach-this-98"><a class="header" href="#how-we-teach-this-98">How we teach this</a></h2>
<h3 id="api-docs"><a class="header" href="#api-docs">API Docs</a></h3>
<p>(To be added at the <a href="https://github.com/emberjs/ember.js/blob/4a98e1610b795edb544513f10a8870af1375141d/packages/%40ember/-internals/runtime/lib/mixins/observable.js#L359">end of the current API docs</a>)</p>
<h4 id="sync"><a class="header" href="#sync"><code>sync</code></a></h4>
<p>By default in new Ember applications, observers are asynchronous. They can be
marked as <em>synchronous</em> instead by using the <code>sync</code> option. Synchronous
observers will run immediately when the property they are observing changes,
instead of being scheduled to run later.</p>
<p>Each synchronous observer has a performance impact for every property change, so
you should generally avoid using synchronous observers.</p>
<p>In older applications, observers are synchronous by default. You can use the
<code>sync</code> option to make them asynchronous instead and convert them over time. You
can also enable the <code>default-async-observers</code> optional feature to make them
asynchronous by default, once you are sure that they will continue to function
if they are asynchronous.</p>
<h3 id="guides-1"><a class="header" href="#guides-1">Guides</a></h3>
<p>Observers are not discussed in the post-Octane guides, since we don't want to
encourage their use. It may make sense to include a section on them in the
upgrade guide instead.</p>
<h3 id="upgrade-guides"><a class="header" href="#upgrade-guides">Upgrade Guides</a></h3>
<p>We should make a note in the Octane upgrade guides that sync observers are
discouraged and probably not very performant. We should be up front that this
will likely be a performance hit, but that we decided it was worth the benefits
of the change.</p>
<h2 id="drawbacks-119"><a class="header" href="#drawbacks-119">Drawbacks</a></h2>
<p>The biggest potential drawback is in performance. While we haven't been able to
do any testing on apps that have observers, its possible that these changes will
have an impact on them, especially apps that have many observers.</p>
<p>In theory, this shouldn't impact the majority of Ember apps since observers have
been discouraged so heavily for such a long time. The impact should also
decrease in time, as users transition away from observers entirely and toward
tracked properties.</p>
<h2 id="alternatives-121"><a class="header" href="#alternatives-121">Alternatives</a></h2>
<ul>
<li>We could release Ember v4, and ship asynchronous observers as a breaking
change. We currently believe this would be a breaking change that would
prevent many users from adopting Octane or transitioning forward to tracked
properties, which would be problematic and could divide the community.</li>
</ul>
<h2 id="unresolved-questions-80"><a class="header" href="#unresolved-questions-80">Unresolved questions</a></h2>
<p>What is the exact performance impact? Can we test it out in an application that
represents a typical Ember app that uses observers?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-02-14
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/496</p>
<hr />
<h1 id="handlebars-strict-mode"><a class="header" href="#handlebars-strict-mode">Handlebars Strict Mode</a></h1>
<h2 id="summary-130"><a class="header" href="#summary-130">Summary</a></h2>
<p>In this RFC, we propose a set of changes to Ember's variant of Handlebars that
are aimed at codifying best practices, improving clarity and simplifying the
language. Together, these changes are bundled into a &quot;strict mode&quot; that Ember
developers can opt-into. In contrast, the non-strict mode (i.e. what developers
are using today) will be referred to as &quot;non-strict mode&quot; in this RFC.</p>
<p>This RFC aims to introduce and define the semantics of the Handlebars strict
mode, as well as the low-level primitive APIs to enable it. However, it does
not introduce any new user-facing syntax or conveniences for opting into this
mode.</p>
<p>The intention is to unlock experimentation of features such as template
imports and single-file components, but those features will require further
design and iterations before they can be proposed and recommended to Ember
users.</p>
<h2 id="motivation-130"><a class="header" href="#motivation-130">Motivation</a></h2>
<p>Ember has been using Handlebars since it was released 7 years ago (!). Over
time, we have evolved, adapted and in some case repurposed the Handlebars
language significantly (remember &quot;context-shifting&quot; <code>{{#each}}</code>?). This RFC
proposes to provide a &quot;strict mode&quot; opt-in to remedy some of Handlebars' design
decisions that we have come to regret over the years, or are otherwise not a
good fit for Ember. We believe this will make the Handlbars language easier to
learn, understand and implement, as well as enable better tooling to support
common development workflows for Ember developers.</p>
<p>We propose the following changes:</p>
<ol>
<li>No implicit globals</li>
<li>No implicit <code>this</code> fallback</li>
<li>No implicit invocation of argument-less helpers</li>
<li>No dynamic resolution</li>
<li>No evals (no partials)</li>
</ol>
<h3 id="1-no-implicit-globals"><a class="header" href="#1-no-implicit-globals">1. No implicit globals</a></h3>
<p>Today, Ember implicitly introduces a set of implicit globals into a template's
scope, such as built-in helpers, components, modifiers. Apps and addons also
have the ability to introduce additional implicit globals by placing files into
the <code>app</code> folder or broccoli tree. It is also possible to further influence
this behavior by using the intimate resolver API (such as the alternative
&quot;pods&quot; layout).</p>
<p>This adds a fair amount of dynamism, ambiguity and confusion when reading
templates. When an identifier is encountered, it's not always clear where this
value comes from or what kind of value it may be. This problem is especially
acute for the &quot;ambigious content&quot; position, i.e. <code>&lt;div&gt;{{foo-bar}}&lt;/div&gt;</code>,
which could be a local variable <code>foo-bar</code>, a global component or a helper named
<code>foo-bar</code> provided by the app or an addon, or <code>{{this.foo-bar}}</code> (see the next
section). This problem is even worse when there is a custom resolver involved,
as the resolver may return a component or helper not found in the &quot;expected&quot;
location at runtime.</p>
<p>Not only is this confusing for the human reader, it also makes it difficult for
the Glimmer VM implementation as well as other ecosystem tooling. For example,
if the developer made a typo, <code>{{food-bar}}</code>, it would be impossible to issue
a static error (build time error, inline error in IDEs) because the value may
be resolvable at runtime. It is also difficult, and in some cases impossible,
to implement IDE features such as &quot;Jump to definition&quot; without running code.</p>
<p><a href="https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals">RFC #432</a>
described some additional issues with the current implicit globals semantics.</p>
<p>We propose to remove support for implicit globals in strict mode. All values
must be explicitly brought into scope, either through block params or defined
in the &quot;ambient scope&quot; (see <a href="0496-handlebars-strict-mode.html#detailed-design">Detailed design</a> section).</p>
<h3 id="2-no-implicit-this-fallback"><a class="header" href="#2-no-implicit-this-fallback">2. No implicit <code>this</code> fallback</a></h3>
<p>Today, when Ember sees a path like <code>{{foo}}</code> in the template, after exhausting
the possibilities of implicit globals, it falls back to <code>{{this.foo}}</code>. This
adds to the same confusion outlined above. More details about the motivation
can be found in the accepted <a href="https://github.com/emberjs/rfcs/pull/308">RFC #308</a>.</p>
<p>We propose to remove support for implicit <code>this</code> fallback in strict mode. The
explicit form <code>{{this.foo}}</code> must be used to refer to instance state, otherwise
it will trigger the same errors mentioned in the previous section.</p>
<p>It is worth mentioning that <a href="https://github.com/emberjs/rfcs/pull/432">RFC #432</a>
laid out a transition path towards a world where &quot;everything is a value&quot;.
Between this and the previous restriction, we essentially have completed that
transition. To recap, here is a list of the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals">outstanding issues</a>:</p>
<ol>
<li>Not possible to reference globals outside of invocation positions</li>
<li>Invocation of global helpers in angle bracket named arguments positions</li>
<li>Naming collisions between global components, helpers and element modifiers</li>
</ol>
<p>All of these problems are all related to implicit globals and/or implicit
<code>this</code> fallback. Since neither of these features are supported in strict mode,
they are no longer a concern for us.</p>
<h3 id="3-no-implicit-invocation-of-argument-less-helpers"><a class="header" href="#3-no-implicit-invocation-of-argument-less-helpers">3. No implicit invocation of argument-less helpers</a></h3>
<p>In the contextual helpers RFC, we discussed <a href="https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals">an issue</a>
regarding the invocation of arguments-less helpers in invocation argument
positions.</p>
<p>In today's semantics, if there is a global helper named <code>pi</code>, the following
template will result it the helper being invoked, and the result of the helper
invocation will be passed into the component.</p>
<pre><code class="language-hbs">&lt;MyComponent @value={{pi}} /&gt;
</code></pre>
<p>This is not desirable behavior in the value-based semantics proposed in that
RFC, because it makes it impossible to pass helpers around as values, just as
it is possible to pass around contextual components today.</p>
<p>The contextual helper RFC proposed to deprecate this behavior and require
mandatory parentheses to invoke the helper.</p>
<pre><code class="language-hbs">{{!-- passing the helper pi to the component --}}
&lt;MyComponent @value={{pi}} /&gt;

{{!-- passing the result of invoking the helper pi to the component --}}
&lt;MyComponent @value={{(pi)}} /&gt;
</code></pre>
<p>In strict mode, the current, soon-to-be-deprecated behavior will be removed,
and the parentheses syntax will be mandatory.</p>
<p>Note that this only affects arguments-less helpers, which are exceedingly rare,
as most helpers perform self-contained computations based on the provided
arguments. It also only affect argument positions. In content and attribute
positions, the intent is clear as it does not make sense to &quot;pass a helper into
the DOM&quot;. The parentheses-less form will continue to work in those positions,
although the explicit parentheses are also permitted.</p>
<h3 id="4-no-dynamic-resolution"><a class="header" href="#4-no-dynamic-resolution">4. No dynamic resolution</a></h3>
<p>Today, Ember supports passing strings to the <code>component</code> helper (as well as the
<code>helper</code> and <code>modifier</code> helpers proposed in <a href="https://github.com/emberjs/rfcs/pull/432">RFC #432</a>).
This can either be passed as a literal <code>{{component &quot;foo-bar&quot;}}</code> or passed as a
runtime value <code>{{component this.someString}}</code>. In either case, Ember will
attempt to <em>resolve</em> the string as a component.</p>
<p>It shares some of the same problems with implicit globals (where did this come
from?), but the dynamic form makes the problem more acute, as it is difficult
or impossible to tell which components a given template is dependent on. As
usual, if it is difficult for the human reader, the same is true for tools as
well. Specifically, this is hostile to &quot;tree shaking&quot; and other forms of static
(build time) dependency-graph analysis, since the dynamic form of the component
helper can invoke <em>any</em> component available to the app.</p>
<p>We propose to remove support for these forms of dynamic resolutions in strict
mode. Specifically, passing a string to the <code>component</code> helper (as well as the
<code>helper</code> and <code>modifier</code> helpers), whether as a literal or at runtime, will
result in an error.</p>
<p>In practice, it is almost always the case that these dynamic resolutions are
switching between a small and bounded number of known components. For this
purpose, they can be replaced by patterns similar to this.</p>
<pre><code class="language-js">import Component from '@glimmer/component';
import { First, Second, Third } from './contextual-components';

class ProviderComponent extends Component {
  get selectedComponent() {
    switch(this.args.selection) {
      case &quot;first&quot;:
        return First;
      case &quot;second&quot;:
        return Second;
      case &quot;third&quot;:
        return Third;
    }
  }
}
</code></pre>
<pre><code class="language-hbs">{{yield this.selectedComponent}}
</code></pre>
<p>This will make it clear to the human reader and enable tools to perform
optimizations, such as tree-shaking, by following the explict dependency graph.</p>
<h3 id="5-no-evals-no-partials"><a class="header" href="#5-no-evals-no-partials">5. No evals (no partials)</a></h3>
<p>Ember currently supports the <code>partial</code> feature. It takes a template name, which
can either be passed as a literal <code>{{partial &quot;foo-bar&quot;}}</code> or passed as a
runtime value <code>{{partial this.someString}}</code>. In either case, Ember will resolve
the template with the given name (with a prefix dash, like <code>-foo-bar.hbs</code>) and
render its content <em>as if</em> they were copy and pasted into the same position.</p>
<p>In either case, the rendered partials have full access to anything that is &quot;in
scope&quot; in the original template. This includes any local variables, instance
variables (via implicit <code>this</code> fallback or explicitly), implicit globals, named
arguments, blocks, etc.</p>
<p>This feature has all of the same problems as above, but worse. In addition to
the usual sources (globals, <code>this</code> fallback etc), each variable found in a
partial template could also be coming from the &quot;outer scope&quot; from the caller
template. Conversely, on the caller side, &quot;unused&quot; variables may not be safe
to refactor away, because they may be consumed in a nested partial template.</p>
<p>Not only do these make it difficult for humans to follow, the same is true for
tools as well. For example, linters cannot provide accurate undefined/unused
variables warning. Whenever the Glimmer VM encounter partials, it has to emit
a large amount of extra metadata just so they can be &quot;wired up&quot; correctly at
runtime.</p>
<p>This feature has already been deprecated, and we propose to remove support for
partials completely in strict mode. Until the feature has been removed from
Ember itself, invoking the <code>{{partial ...}}</code> keyword in strict mode will be a
static (build time) error.</p>
<p>The use case of extracting pieces of a template into smaller chunks can be
replaced by <a href="https://github.com/emberjs/rfcs/pull/278">template-only components</a>.
While this requires any variables to be passed explicitly as arguments, it also
removes the ambiguity and confusions.</p>
<p>It should also be mentioned that the <code>{{debugger}}</code> keyword also falls into the
category of &quot;eval&quot; in today's implementation, since it will be able to access
any variable available to the current scope, including <code>this</code> fallback and when
nested inside a partial template. However, with the other changes proposed in
this RFC, we will be able to statically determine which variables the debugger
will have access to. Therefore we would still be able to support debugger usage
in strict mode without a very high performance penalty.</p>
<h2 id="detailed-design-111"><a class="header" href="#detailed-design-111">Detailed design</a></h2>
<p>This RFC aims to introduce and define the semantics of the Handlebars strict
mode, as well as the low-level primitive APIs to enable it. However, it does
not introduce any new user-facing syntax or conveniences for opting into this
mode.</p>
<p>The intention is to unlock experimentation of features such as template
imports and single-file components, but those features will require further
design and iterations before they can be proposed and recommended to Ember
users.</p>
<p>During this phase of experimentation, these low-level APIs will also enable
other build tools (such as <a href="https://github.com/ember-cli/ember-cli-htmlbars">ember-cli-htmlbars</a>)
to provide their own API for users to opt-in. In addition, once this RFC is
approved and implemented in Ember, these low-level APIs will have the same
semver guarentees as any other APIs in Ember, allow these experimentations to
be built on stable grounds.</p>
<h3 id="low-level-apis"><a class="header" href="#low-level-apis">Low-level APIs</a></h3>
<p>We propose to add an option to Ember's template compiler to enable strict mode
compilation.</p>
<p>There are three primitive APIs involved in compiling Ember templates, <code>precompile</code>,
<code>template</code> and <code>compile</code>.</p>
<p>The <code>precompile</code> function (a.k.a. <a href="https://github.com/ember-cli/ember-rfc176-data"><code>precompileTemplate</code></a>)
is responsible for taking a template string, running AST plugins, checking for
errors and returning the &quot;wire format&quot; representation of the template. The
exact details of this &quot;wire format&quot; is unspecified and changes from time to
time across minor Ember versions. The only guarantee is that it returns a
string whose content is a valid JavaScript expression.</p>
<p>For example:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate('Hello, {{name}}!', {
  moduleName: 'hello.hbs'
}); /* =&gt; `{
  &quot;id&quot;: &quot;AoL2bkKU&quot;,
  &quot;block&quot;: &quot;{\&quot;statements\&quot;:[\&quot;...\&quot;]}&quot;,
  &quot;meta&quot;: {&quot;moduleName&quot;:&quot;hello.hbs&quot;}
}` */
</code></pre>
<p>Again, the exact wire format changes from time to time, but the key is that the
content is valid JavaScript. This allows build tools to take this output and
insert it into any context where JavaScript expressions are allowed.</p>
<p>At runtime, the &quot;wire format&quot; can be &quot;rehydrated&quot; into something consumable by
Ember via the <code>template</code> function (a.k.a. <a href="https://github.com/ember-cli/ember-rfc176-data"><code>createTemplateFactory</code></a>).</p>
<p>Build tools typically compile templates into JavaScript modules by combining
these two pieces. In our example, the <code>hello.hbs</code> template is typically
compiled into a module similar to this:</p>
<pre><code class="language-js">import { createTemplateFactory } from '@ember/template-factory';

export default createTemplateFactory({
  &quot;id&quot;: &quot;AoL2bkKU&quot;,
  &quot;block&quot;: &quot;{\&quot;statements\&quot;:[\&quot;...\&quot;]}&quot;,
  &quot;meta&quot;: { &quot;moduleName&quot;: &quot;hello.hbs&quot; }
});
</code></pre>
<p>Finally, the <code>compile</code> function (a.k.a. <a href="https://github.com/ember-cli/ember-rfc176-data"><code>compileTemplate</code></a>)
is a convenience helper that simply combines the two steps by taking a raw
template string and returning a ready-to-be-consumed template object (the
output of <code>createTemplateFactory</code>), instead of the wire format. This is
mostly used for compiling templates at runtime, which is pretty rare.</p>
<p>We propose to introduce a new <code>strict</code> option to the <code>precompile</code> and <code>compile</code>
functions to enable strict mode compilation:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate('Hello, {{name}}!', {
  moduleName: 'hello.hbs',
  strict: true
});
</code></pre>
<h3 id="the-ambient-scope"><a class="header" href="#the-ambient-scope">The ambient scope</a></h3>
<p>Since there are no implicit globals in strict mode, there has to be an
alternative mechanism to introduce helpers and components into scope.</p>
<p>Whenever the strict mode compiler encounters an undefined reference, i.e. an
identifier that is not a currently in-scope local variable (block param), the
default behavior is to assume that these are references to variables in the
<em>ambient scope</em>. That is, the compiler will emit JavaScript code that contains
JavaScript references to these variables.</p>
<p>For example, consider the following template:</p>
<pre><code class="language-hbs">{{#let this.session.currentUser as |user|}}
  &lt;BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} /&gt;
{{/let}}
</code></pre>
<p>Here, <code>this.session.currentUser</code> is an explicit reference to the component's
instance state, <code>user</code> is a local variable introduced by the <code>#let</code> helper and
<code>@model</code> is a reference to a named argument. They all have obvious semantics.</p>
<p>On the other hand, <code>BlogPost</code> and <code>titleize</code> are undefined references. The
compiler will assume that they are defined in the surrounding <em>ambient scope</em>
at runtime and produce an output like this:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate(`{{#let this.session.currentUser as |user|}}
  &lt;BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} /&gt;
{{/let}}`, {
  moduleName: 'index.hbs',
  strict: true
}); /* =&gt; `{
  &quot;id&quot;: &quot;ANJ73B7b&quot;,
  &quot;block&quot;: &quot;{\&quot;statements\&quot;:[\&quot;...\&quot;]}&quot;,
  &quot;meta&quot;: { &quot;moduleName&quot;: &quot;index.hbs&quot; },
  &quot;scope&quot;: () =&gt; [BlogPost, titleize]
}` */
</code></pre>
<p>Again, the specific format here is unimportant and subject to change. The key
here is that the JavaScript code produced by the compiler contains references
(via the <code>scope</code> closure in this hypothetical compilation) to the JavaScript
variables <code>BlogPost</code> and <code>titleize</code> in the surrounding JavaScript scope.</p>
<p>The build tool is responsible for &quot;linking&quot; these undefined references by
putting the compiled JavaScript code inside a JavaScript context where these
variables are defined. Otherwise, depending on the configuration, the undefined
references will either cause a static (build-time) error from the linter,
transpiler (e.g. babel) or packager (e.g. rollup or webpack), or a runtime
<code>ReferenceError</code> when the code is evaluated by a JavaScript engine.</p>
<p>This low-level, primitive feature is mainly useful for building user-facing
template import and single-file component features. While this RFC does not
propose a user-facing syntax for these features, here is a hypothetical
template import syntax for the illustrative purposes only:</p>
<pre><code class="language-hbs">---
import { titleize } from '@ember/template-helpers';
import BlogPost from './components/blog-post';
---

{{#let this.session.currentUser as |user|}}
  &lt;BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} /&gt;
{{/let}}
</code></pre>
<p>The build tool can compile this into a JavaScript module like this:</p>
<pre><code class="language-js">import { createTemplateFactory } from '@ember/template-factory';
import { titleize } from '@ember/template-helpers';
import BlogPost from './components/blog-post';

export default createTemplateFactory({
  &quot;id&quot;: &quot;ANJ73B7b&quot;,
  &quot;block&quot;: &quot;{\&quot;statements\&quot;:[\&quot;...\&quot;]}&quot;,
  &quot;meta&quot;: { &quot;moduleName&quot;: &quot;index.hbs&quot; },
  &quot;scope&quot;: () =&gt; [BlogPost, titleize]
});
</code></pre>
<p>When this is evaulated by a JavaScript engine, the references in the <code>scope</code>
closure will automatically be &quot;linked up&quot; with the imports, and Ember will be
able to reference these values when rendering the template. Note that these
references are <em>static</em>–the values are essentially &quot;snapshotted&quot; by the
rendering engine whenever the template is instantiated. Updates to these values
in the JavaScript scope will <em>not</em> be observable by the rendering engine, even
in conjunction with <code>Ember.set</code> or <code>@tracked</code>.</p>
<p>Optionally, the build tool can choose to restrict the set of allowed ambient
references by suppling an array of available identifiers to the compiler:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';

precompileTemplate(`{{#let this.session.currentUser as |user|}}
  &lt;BlogPost @title={{titleize @model.title}} @body={{@model.body}} @author={{user}} /&gt;
{{/let}}`, {
  moduleName: 'index.hbs',
  strict: true,
  scope: ['BlogPost', 'titleize']
});
</code></pre>
<p>If the template compiler encounters any undefined references outside of this
allowed list, it will throw an error with the appropiate location info. It also
follows that build tools can choose to disable this feature completely by
passing an empty array.</p>
<h3 id="keywords"><a class="header" href="#keywords">Keywords</a></h3>
<p>While most items should be imported into scope explicitly, some of the existing
constructs in the language are unimportable will be made available as keywords
instead:</p>
<ul>
<li><code>action</code></li>
<li><code>debugger</code></li>
<li><code>each-in</code></li>
<li><code>each</code></li>
<li><code>has-block-params</code></li>
<li><code>has-block</code></li>
<li><code>hasBlock</code></li>
<li><code>if</code></li>
<li><code>in-element</code></li>
<li><code>let</code></li>
<li><code>link-to</code> (non-block form curly invocations)</li>
<li><code>loc</code></li>
<li><code>log</code></li>
<li><code>mount</code></li>
<li><code>mut</code></li>
<li><code>outlet</code></li>
<li><code>query-params</code></li>
<li><code>readonly</code></li>
<li><code>unbound</code></li>
<li><code>unless</code></li>
<li><code>with</code></li>
<li><code>yield</code></li>
</ul>
<p>These keywords do <em>not</em> have to be imported into scope and will always be
ambiently available.</p>
<p>On the other hand, the following built-in constructs will need to be imported
(the current or proposed import paths in parentheses):</p>
<ul>
<li><code>array</code> (<code>import { array } from '@ember/helper</code>)</li>
<li><code>concat</code> (<code>import { concat } from '@ember/helper</code>)</li>
<li><code>fn</code> (<code>import { fn } from '@ember/helper</code>)</li>
<li><code>get</code> (<code>import { get } from '@ember/helper</code>)</li>
<li><code>hash</code> (<code>import { hash } from '@ember/helper</code>)</li>
<li><code>on</code> (<code>import { on } from '@ember/modifier'</code>)</li>
<li><code>Input</code> (<code>import { Input } from '@ember/component</code>)</li>
<li><code>LinkTo</code> (<code>import { LinkTo } from '@ember/routing</code>)</li>
<li><code>Textarea</code> (<code>import { Textarea } from '@ember/component'</code>)</li>
</ul>
<p>In general, built-ins that can be made importable should be imported. The main
difference are that some of the keywords uses internal language features (e.g.
implemented via AST transforms) that requires them to be keywords.</p>
<p>Some of the keywords included in the list are considered legacy, and may be
deprecated in the future via future RFCs. If that happens before strict mode
becomes available in a stable release of Ember, those RFC may propose to drop
support for the legacy keywords in strict mode altogether.</p>
<h3 id="deprecations"><a class="header" href="#deprecations">Deprecations</a></h3>
<p>The following features should be deprecated and removed in non-strict mode:</p>
<ul>
<li>Implicit <code>this</code> fallback, proposed in <a href="https://github.com/emberjs/rfcs/blob/master/text/0308-deprecate-property-lookup-fallback.md">RFC #308</a></li>
<li>Implicit invocation of argument-less helpers, proposed in <a href="https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md">RFC #432</a></li>
<li>Partials, proposed in <a href="https://github.com/emberjs/rfcs/blob/master/text/0449-deprecate-partials.md">RFC #449</a></li>
</ul>
<p>When all of these features are removed, the main difference between non-strict mode
and strict mode will be the precense of globals and the ability to perform
dynamic runtime resolutions.</p>
<h2 id="how-we-teach-this-99"><a class="header" href="#how-we-teach-this-99">How we teach this</a></h2>
<p>Strict mode is intended to become the main way Ember developers author
templates going forward. We anticipate this is going to be a slow transition,
but once the majority of Ember developers have migrated, we expect them to find
it clearer, more intuitive and more productive.</p>
<p>Three of the strict mode restrictions—no implicit <code>this</code> fallback, no implicit
invocation of argument-less helpers and no eval—were already proposed in their
respective RFCs. These features will be deprecated in non-strict mode templates and
can be fixed incrementally. We should continue implementing these deprecatios
as already proposed and encouraged adoption. It is quite likely that by the
time strict mode becomes widely available, these deprecations will have already
been implemented and fixed in most Ember applications.</p>
<p>On the other hand, implicit globals and dynamic resolutions are not going away
anytime soon in non-strict mode. These features are intrinsically tied to non-strict
mode, and we expect developers to migrate to template imports or single-file
components when those over time, which would also opt them into strict mode,
when those features become available.</p>
<p>That being said, this RFC does not propose any user-facing changes and there
will be no official, application-level opt-in to strict mode until either
template imports or single-file components exit the experimental phase and
become adopted as official feature in Ember via a future RFC.</p>
<p>Therefore, we do not recommend making any changes to the guides to document the
strict mode semantics at this stage. Instead, the guides should be updated to
feature template imports or single-file components when they become available.</p>
<p>As for the low-level APIs, we should update the API documentation to cover the
new flags (<code>strict</code> and <code>scope</code>). The documentation should cover the details of
the &quot;ambient scope&quot; feature discussed in this RFC, and emphasize that it is
intended for linking static values such as helpers and components.</p>
<h2 id="drawbacks-120"><a class="header" href="#drawbacks-120">Drawbacks</a></h2>
<p>We could just deprecate without removing <code>this</code> fallback and partials, and let
implicit globals and dynamic resolution co-exist with template imports (the
primary consumer of the proposed strict mode). However, this will create a very
confusing compromise and users will not get most of the benefits of having
template imports in the first place. We will also lose out on the opportunity
to improve on the static guarantees in order to build better tools. Leaving
around implicit globals also has the <a href="https://github.com/emberjs/rfcs/blob/master/text/0432-contextual-helpers.md#relationship-with-globals">issues</a>
discussed in the contextual helpers RFC.</p>
<h2 id="alternatives-122"><a class="header" href="#alternatives-122">Alternatives</a></h2>
<ol>
<li>
<p>Instead of bundling these into a single &quot;strict mode&quot; opt-in, we could
allow developers to opt-in to each of these restrictions individually.</p>
<p>In addition to the teaching and discoverability problems, we will also need
to build additional tooling and configuration mechanism (<code>handlebars.json</code>?)
for this.</p>
<p>By adopting these piecemeal, we will also have to define the interaction and
combined semantics for any possible combinations of these flags, and tooling
will be unable to take advantage of the improved static guarentees without
doing a lot of work to account for all these possibilities.</p>
</li>
<li>
<p>Instead of proposing a standalone strict mode, we could just bundle these
semantics into the templates imports proposal.</p>
<p>That would make it a very long and complex RFC. In addition, other build
tools like <a href="https://github.com/ember-cli/ember-cli-htmlbars-inline-precompile">ember-cli-htmlbars-inline-precompile</a>
will not be able to adopt the same semantics.</p>
</li>
<li>
<p>Switch to HTML attributes by default in strict mode.</p>
<p>Today, Glimmer uses a complicated set of huristics to decide if a bound HTML
&quot;attribute&quot; syntax should indeed be set using <code>setAttribute</code> or set as a
JavaScript property using <code>element[...] = ...;</code>. This does not always work
well in practice, and it causes a lot of confusion and complexity.</p>
<p>We intend to move to an &quot;attributes syntax always mean attributes&quot; (and use
modifiers for the rare cases of setting properties). We briefly considered
grouping that change into the strict mode opt-in, but ultimately decided it
would be too confusing for strict mode to include such a change. It's better
to deprecate the feature and make this an app-wide setting.</p>
</li>
<li>
<p>Fix <code>(action ...)</code> binding semantics in strict mode.</p>
<p>Similarly, there are some not ideal semantics issues with <code>(action ...)</code>
around how the function's <code>this</code> is bound. We similarly considered fixing it
in strict mode but ultimately decided it wouldn't be appropriate.</p>
</li>
</ol>
<h2 id="unresolved-questions-81"><a class="header" href="#unresolved-questions-81">Unresolved questions</a></h2>
<p>None</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-06-21
Relevant Team(s): Ember CLI, Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/507</p>
<hr />
<h1 id="v2-addon-format-embroider-compatibility"><a class="header" href="#v2-addon-format-embroider-compatibility">v2 Addon Format (Embroider Compatibility)</a></h1>
<h2 id="summary-131"><a class="header" href="#summary-131">Summary</a></h2>
<p>This RFC defines a new package format that is designed to make Ember packages (meaning both apps and addons) statically analyzable and more compatible with the rest of the NPM &amp; Javascript ecosystem. This RFC is the first step in stabilizing <a href="https://github.com/embroider-build/embroider">Embroider</a> as our next-generation build system.</p>
<h2 id="motivation-131"><a class="header" href="#motivation-131">Motivation</a></h2>
<p>One of the good things about Ember is that apps and addons have a powerful set of build-time capabilities that allow lots of shared code with zero-to-no manual integration steps for the typical user. We have been doing “zero config” since before it was a cool buzzword (it was just called “convention over configuration”). And we’ve been broadly successful at maintaining very wide backward- and forward-compatibility for a large body of highly-rated community-maintained addons.</p>
<p>But one of the challenging things about Ember is that our ecosystem’s build-time capabilities are more implementation-defined than spec-defined, and the implementation has accumulated capabilities organically while only rarely phasing out older patterns. I believe the lack of a clear, foundational, build-time public API specification is the fundamental underlying issue that efforts like the various packaging / packager RFCs have tried to work around.</p>
<p>The benefits to users for this RFC (and Embroider in general) are:</p>
<ul>
<li>faster builds and faster NPM installs</li>
<li>“zero-config import from NPM — both static and dynamic” as a first-class feature that works for both third-party libraries and Ember addons</li>
<li>support for arbitrary code splitting</li>
<li>tree-shaking of unused modules, components, helpers, etc from the app and all addons</li>
<li>a layered build system with clearly documented APIs between the layers, so it's easier to experiment and contribute</li>
<li>a build system that can take advantage of current and future investments by the wider Javascript ecosystem into code bundling &amp; optimization.</li>
</ul>
<h2 id="key-ideas"><a class="header" href="#key-ideas">Key Ideas</a></h2>
<h3 id="fully-embrace-es-modules"><a class="header" href="#fully-embrace-es-modules">Fully Embrace ES Modules</a></h3>
<p>Ember was one of the earliest adopters of ECMAScript modules, and Ember core team members were directly involved in helping move that features through TC39. Ember’s early experiences with modules influenced the spec itself. <em>Yet we have lagged in truly embracing modules.</em></p>
<p>For example, how do Ember apps express that they depend on a third-party library? The <a href="https://ember-cli.com/user-guide/#javascript-assets">app.import</a> API. This should be ECMA standard <code>import</code>.</p>
<p>Another way to state the problem is that apps and addons all <em>push</em> whatever code they want into the final built app. Whereas ES modules can <em>pull</em> each other into the build as needed.</p>
<h3 id="play-nice-with-npm-conventions"><a class="header" href="#play-nice-with-npm-conventions">Play nice with NPM Conventions</a></h3>
<p>The ECMA module spec by itself doesn’t try to define a module resolution algorithm. But the overwhelmingly most popular convention is the <a href="https://nodejs.org/api/all.html#modules_all_together">node_modules resolution algorithm</a>.</p>
<p>Ember addons do respect node_module resolution for build-time code, but they do not respect it for runtime code. This is an unhelpful distinction.</p>
<h3 id="verbose-static-javascript-as-a-compiler-target"><a class="header" href="#verbose-static-javascript-as-a-compiler-target">Verbose, Static Javascript as a Compiler Target</a></h3>
<p>Ember’s strong conventions mean that many kinds of dependencies can be inferred (including <em>statically</em> inferred) without requiring the developer to laboriously manage them. This is a good thing and I believe the current fad in the wider Javascript ecosystem for making developers hand-write verbose static imports for everything confuses the benefits of having static analysis (which is good) with the benefits of hand-managing those static imports (which is unnecessary cognitive load when you have clear conventions and a compiler).</p>
<p>This design is about compiling today’s idiomatic Ember code into more “vanilla” patterns that leverage ES modules, node_modules resolution, and spec-compliant static and dynamic <code>import</code> to express the structure of an Ember application in a much more “vanilla Javascript” way.</p>
<p>This compile step lets us separate the authoring format (which isn’t changing in any significant way in this RFC) from the packaging format (which can be more verbose and static than we would want in an authoring format).</p>
<h1 id="detailed-design-112"><a class="header" href="#detailed-design-112">Detailed design</a></h1>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p><strong>package</strong>: every addon and app is a <strong>package</strong>. Every &quot;NPM package&quot; is a <strong>package</strong>, but not every <strong>package</strong> is an &quot;NPM package&quot; because we also include in-repo packages. The most important fact about a package is that it’s often the boundary around code that comes from a particular author, team, or organization, so coordination across packages is a more sensitive design problem than coordination within apps.</p>
<p><strong>app</strong>: a package used at the root of a project.</p>
<p><strong>addon</strong>: a package not used at the root of a project. Will be an <strong>allowed dependency</strong> of either an <strong>app</strong> or an <strong>addon</strong>.</p>
<p><strong>allowed dependency</strong>: For <strong>addons</strong>, the <strong>allowed dependencies</strong> are the <strong>packages</strong> listed in <code>dependencies</code> and <code>peerDependencies</code> in <code>package.json</code> plus any in-repo addons. For <strong>apps</strong>, the <strong>allowed dependencies</strong> are the <code>dependencies</code>, <code>peerDependencies</code>, and <code>devDependencies</code> in <code>package.json</code> plus any in-repo addons.</p>
<p><strong>Ember package metadata</strong>: the <code>ember</code> section inside <code>package.json</code>. This already exists in v1 (it's used to set <code>edition</code>), we’re going to extend it.</p>
<p><strong>v2 package</strong>: a package with <code>package.json</code> like:</p>
<pre><code>&quot;keywords&quot;: [ &quot;ember-addon&quot; ],
&quot;ember&quot;: {
  &quot;version&quot;: 2
}
</code></pre>
<p><strong>v1 package</strong>: a package with <code>package.json</code> like:</p>
<pre><code>&quot;keywords&quot;: [ &quot;ember-addon&quot; ]
</code></pre>
<p>and no <code>version</code> key (or version key less than 2) in <strong>Ember package metadata</strong>.</p>
<p><strong>non-Ember package</strong>: a package without <code>keywords: [&quot;ember-addon&quot;]</code></p>
<h2 id="scope-of-this-rfc"><a class="header" href="#scope-of-this-rfc">Scope of this RFC</a></h2>
<p>This RFC is intended as the base level spec for v2 Ember packages. <strong>It does not attempt to cover everything a v1 package can do today</strong>. For example, no provision is made in this RFC for:</p>
<ul>
<li>providing dev middleware</li>
<li>providing commands and blueprints</li>
<li>preprocessing your parent package's code</li>
<li>modifying your parent package's babel config</li>
<li>injecting content into index.html (contentFor)</li>
</ul>
<p>It is understood that all of these are legitimate things for Ember addons to do. Defining these capabilities within v2 packages will be done in followup RFCs. It is simply too much scope to cover in one RFC.</p>
<p>Because we're hyper-focused on backward- and forward-compatibility, there is no harm in progressively converting some addons to v2 (which provides immediate benefits in terms of build performance and reduced fragility under Embroider) while others need to stay as v1 until we offer the features they need.</p>
<p>This RFC is carefully decoupled from other new Ember features (like <a href="https://github.com/emberjs/rfcs/pull/496">strict mode</a> ), but it is understood that the spec created by this RFC will become a living standard that needs to both influence and be influenced by the rest of Ember's design.</p>
<h2 id="package-public-api-overview"><a class="header" href="#package-public-api-overview">Package Public API Overview</a></h2>
<p>The format we are about to describe <em>is a publication format</em>. Not necessarily an authoring format. By separating the two, we make it easier to evolve the authoring format without breaking ecosystem-wide compatibility. The publication format is deliberately more explicit and less dynamic that what we may want for an authoring format.</p>
<p>First, here’s the list of things a v2 package can provide. More detail on each of these will follow:</p>
<ul>
<li><strong>Own Javascript</strong>: javascript and templates under the package’s own namespace (the v1 equivalent is <code>/addon/**/*.{js,hbs}/</code>)</li>
<li><strong>App Javascript</strong>: javascript and templates that must be merged with the consuming app’s namespace (the v1 equivalent is <code>/app/**/*.{js,hbs}</code>). Other RFCs are working to move Ember away from needing this feature, but we are not gated on any of those and fully support <strong>App Javascript</strong>.</li>
<li><strong>Fastboot Javascript</strong>: just like <strong>App Javascript</strong>, but only applies when running in Fastboot.</li>
<li><strong>CSS</strong>: available for <code>@import</code> by other CSS files (both in the same package and across packages) and by ECMA <code>import</code> directives in Javascript modules (both in the same package and across packages).</li>
<li><strong>Implicit Dependencies</strong>: scripts, modules, and stylesheets that should be implicitly included in the app or the app's tests whenever this addon is active. This is a backward-compatibility feature.</li>
<li><strong>Renaming Rules</strong>: allow a package to declare that some of its modules should be available at different import paths than their real, resolvable path. This is a backward-compatibility feature that new addons should not use.</li>
<li><strong>Externals</strong>: allows a package to declare that it imports some things that are not <strong>allowed dependencies</strong>. Instead of being resolved at build time, <strong>externals</strong> are deferred until runtime and get handled by the traditional <code>loader.js</code> <code>require()</code>.</li>
<li><strong>Assets</strong>: any files that must be available in the final built application directory such that they have public URLs (typical examples are images and fonts).</li>
<li><strong>Build Hooks</strong>: code that runs within Node at application build time. The v1 equivalent is an addon's <code>index.js</code> file.</li>
</ul>
<h2 id="own-javascript"><a class="header" href="#own-javascript">Own Javascript</a></h2>
<p>The public <code>main</code> (as defined in <code>package.json</code>) of a v2 package points to its <strong>Own Javascript</strong>. The code is formatted as ES modules that follow the <strong>Ember Language Standard</strong> (which is defined later in this RFC). Addon authors can still author in whatever dialect they want, but they must transpile to Ember Language Standard before publishing to NPM.</p>
<p>Templates are in hbs format. No custom AST transforms are supported. Addon authors can still use custom AST transforms, but those transforms must have already been applied and re-emitted into hbs source text before publication to NPM. This means that only AST transforms whose output are serializable into hbs source text are permitted.</p>
<p>Unlike v1 addons, there is no <code>/app</code> or <code>/addon</code> directory that is magically removed from the runtime paths to the modules. All resolution follows the prevailing Node rules.</p>
<p>The benefit of this design is that it makes our packages understandable by a broader set of tooling. Editors and build tools can follow <code>import</code> statements across packages and end up in the right place.</p>
<p>In v1 packages, <code>main</code> usually points to a build-time configuration file. That file is moving and will be described in the <strong>Build Hooks</strong> section below.</p>
<h3 id="own-javascript-imports"><a class="header" href="#own-javascript-imports">Own Javascript: Imports</a></h3>
<p>Modules in <strong>Own Javascript</strong> are allowed to use ECMA static <code>import</code> and dynamic <code>import()</code> to resolve any <strong>allowed dependency</strong>, causing it to be included in the build whenever the importing module is included. This replaces <code>app.import</code>. Resolution follows prevailing Node rules. (This usually means the node_modules algorithm, but it could also mean Yarn PnP. The difference shouldn't matter if you are correctly declaring all your <strong>allowed dependencies</strong>.)</p>
<p>Notice that a package’s <strong>allowed dependencies</strong> do not include the package itself. This is consistent with how Node resolution works. To import files from within your own package you must use relative paths. This is different from how run-time AMD module resolution has historically worked in Ember Apps. (<code>@embroider/compat</code> implements automatic adjustment for this case when compiling from v1 to v2).</p>
<h3 id="own-javascript-co-located-component-templates"><a class="header" href="#own-javascript-co-located-component-templates">Own Javascript: Co-located Component Templates</a></h3>
<p>Modules in <strong>Own Javascript</strong> get no <em>automatic</em> component template co-location. They should use Ember's <code>setComponentTemplate</code> explicitly. They can access their compiled templates either by importing them or by inlining them via the <code>hbs</code> macro provided by ember-cli-htmlbars.</p>
<p>We're assuming that template co-location will be handled by the build step <em>before</em> an addon is published to NPM in V2 format.</p>
<p>Similarly, template-only components must be explicitly present as Javascript modules that invoke Ember's <code>templateOnlyComponent()</code> and <code>setComponentTemplate</code>.</p>
<h3 id="own-javascript-transpilation-of-imported-modules"><a class="header" href="#own-javascript-transpilation-of-imported-modules">Own Javascript: Transpilation of imported modules</a></h3>
<p>Any module you import, whether from an Ember package or a non-Ember package, gets transpiled by default such that it will support the app's set of browser targets. This ensures that the app's <code>config/targets.js</code> will always be respected and you won't accidentally break your older supported browsers by importing a dependency that uses newer ECMA features.</p>
<p>Today in practice this means everything you import will go through babel-preset-env, and babel-preset-env will use the same configuration that it uses in the app.</p>
<p>There is an explicit per-package opt-out for cases where you're <em>sure</em> that transpilation is not needed and not desirable. (See <strong>Build Hooks</strong> for details on the <code>skipBabel</code> option.)</p>
<h3 id="own-javascript-supported-module-formats-for-non-ember-packages"><a class="header" href="#own-javascript-supported-module-formats-for-non-ember-packages">Own Javascript: Supported module formats for non-Ember packages</a></h3>
<p>As already stated, V2 Ember packages must contain only ES modules. However, non-Ember packages in your <strong>allowed dependencies</strong> are allowed to contain ES modules <em>or</em> CommonJS modules. This provides the best compatibility with general-purpose NPM utilities.</p>
<h3 id="own-javascript-macros"><a class="header" href="#own-javascript-macros">Own Javascript: Macros</a></h3>
<p>The V2 format deliberately eliminates many sources of app-build-time dynamism from addons. Instead, we provide an equivalently-powerful macro system and consider it an always-supported language extension (the macros are always available to every V2 package, ambiently, and we promise to give them their faithful build-time semantics).</p>
<p>See <strong>Macro System</strong> for the full details.</p>
<h2 id="app-javascript"><a class="header" href="#app-javascript">App Javascript</a></h2>
<p>To provide <strong>App Javascript</strong>, a package includes the <code>app-js</code> key in <strong>Ember package metadata</strong>. For example, to duplicate the behavior of v1 packages, you could say:</p>
<pre><code>&quot;ember&quot;: {
  &quot;version&quot;: 2,
  &quot;app-js&quot;: &quot;./app&quot;
}
</code></pre>
<p>Like the <strong>Own Javascript</strong>, the code must be authored as ES modules in <strong>Ember Language Standard</strong>. ECMA static and dynamic imports from any <strong>allowed dependency</strong> are supported. Even though the app javascript will be addressable within the <em>app's</em> module namespace, your own imports still resolve relative to your addon.</p>
<p>By making <code>app-js</code> an explicit key in <strong>Ember package metadata</strong>, our publication format is more durable (you can rearrange the conventional directory structure in the future without breaking the format) and more performant (less filesystem traversal is required to decide whether the package is using the <strong>App Javascript</strong> feature.</p>
<h2 id="fastboot-javascript"><a class="header" href="#fastboot-javascript">Fastboot Javascript</a></h2>
<p>To provide <strong>Fastboot Javascript</strong>, a package includes the <code>fastboot-js</code> key in <strong>Ember package metadata</strong>. This works almost identically to <strong>App Javascript</strong>, except it means the given directory will only be merged into the app's namespace when running in Fastboot (server-side rendering) mode. This key is a backward compatibility feature that allows addons with a <code>fastboot</code> directory to express their needs.</p>
<p>New v2 packages don't need to use <code>fastboot-js</code> because they can use the macro system to branch between browser and server implementations.</p>
<h2 id="css"><a class="header" href="#css">CSS</a></h2>
<p>To provide <strong>CSS</strong>, a package can include any number of CSS files. These files can <code>@import</code> each other via relative paths, which will result in build-time inclusion (as already works in v1 packages).</p>
<p>If any of the <strong>Own Javascript</strong> or <strong>App Javascript</strong> modules depend on the presence of a CSS file in the same package, it should say so explicitly via an ECMA relative import, like:</p>
<pre><code>import '../css/some-component.css';
</code></pre>
<p>This is interpreted as a build-time directive that ensures that before the Javascript module is evaluated, the CSS file's contents will be present in the DOM. ECMA import of CSS files must always include the explicit <code>.css</code> extension.</p>
<blockquote>
<p>Q: Does this interfere with the ability to do CSS-in-JS style for people who like that?</p>
</blockquote>
<blockquote>
<p>A: No, because that would be a preprocessing step before publication. It’s a choice of authoring format, just like TypeScript or SCSS. CSS-in-JS people would compile all their things to ES modules before we deal with it.</p>
</blockquote>
<p>It is also possible for other packages (including the consuming application) to depend on a CSS file in any of its <strong>allowed dependencies</strong>, from either Javascript or CSS. From Javascript it looks like:</p>
<pre><code>// This will resolve the `your-addon` package and find
// './some-component.css' relative to the package root.
// The .css file extension is mandatory
import 'your-addon/some-component.css';
</code></pre>
<p>And from CSS it looks like:</p>
<pre><code>@import 'your-addon/some-component';
</code></pre>
<p>What about SCSS <em>et al</em>? You’re still free to use them as your authoring format, and they should be transpiled to CSS in your publication format. If you want to offer the original SCSS to consuming packages, you’re free to include it in the publication format too. Since we’re making all packages resolvable via normal node rules, it’s now dramatically easier to implement a preprocessor that supports inter-package dependencies. (The same logic applies to TypeScript.)</p>
<h2 id="implicit-dependencies"><a class="header" href="#implicit-dependencies">Implicit Dependencies</a></h2>
<p>Within <strong>Ember package metadata</strong> we support several flavors of implicit dependencies:</p>
<ul>
<li>implicit-modules</li>
<li>implicit-scripts</li>
<li>implicit-styles</li>
<li>implicit-test-modules</li>
<li>implicit-test-scripts</li>
<li>implicit-test-styles</li>
</ul>
<p>Each one is a list of package-relative paths to files within the package.</p>
<p>Whenever your package is active, all of its implicit dependencies will be included in the build. The <code>-test-</code> variants will be included only in test suites, and the non-<code>-test-</code> variants are always included.</p>
<p><code>implicit-modules</code> and <code>implicit-test-modules</code> mean that the app should be built as if someone has explicitly typed ECMA import statements for each of the listed modules.</p>
<p><code>implicit-scripts</code> and <code>implicit-test-scripts</code> are for Javascript in a script context. Script context is different from module context (as defined by the ECMA spec). This is how an addon can push things into the equivalent of the traditional <code>vendor.js</code>, which is in script context.</p>
<p><code>implicit-styles</code> and <code>implicit-test-styles</code> are for stylesheets. This is how an addon can push things into the equivalent of the traditional vendor.css.</p>
<p>While <strong>Implicit Dependencies</strong> are a fully-supported part of the v2 spec, v2 packages are encouraged to use direct ECMA <code>import</code> or CSS <code>@import</code> instead, whenever possible. A direct <code>import</code> provides finer-grained dependency information: we know exactly <em>which</em> module inside your package actually depends on the thing, rather than needing to assume that your entire package depends on it.</p>
<p>For example, if one of your components depends on a third-party library, you should <code>import</code> that library directly from your component. Then the library will only be included if somebody uses that particular component. Whereas if you use <code>implicit-scripts</code>, the library will always be included, even if nobody uses the component that needs the library.</p>
<h2 id="renaming-rules"><a class="header" href="#renaming-rules">Renaming Rules</a></h2>
<p>V1 Addons have multiple ways (at least five that I've found so far!) of emitting modules that escape the addon's own package namespace. Examples:</p>
<ul>
<li><code>ember-lodash</code> remaps all of its modules to the package name <code>lodash</code></li>
<li><code>@ember/test-helpers</code> provides some modules under its true name, but also some modules under <code>ember-test-helpers</code>.</li>
</ul>
<p>In order for Embroider compile these packages to valid V2 packages, we give V2 packages the ability to express renaming rules using the following properties in <strong>Ember package metadata</strong>:</p>
<ul>
<li>
<p><code>renamed-packages</code>: a map from the package name a user would type to the real package name that provides it. Example:</p>
<pre><code class="language-js">{
  &quot;renamed-packages&quot;: {
    &quot;lodash&quot;: &quot;ember-lodash&quot;
  }
}
</code></pre>
</li>
<li>
<p><code>renamed-modules</code>: a map from modules that a user may try to import to the real paths where those modules live:</p>
<pre><code class="language-js"> &quot;renamed-modules&quot;: {
  &quot;ember-test-helpers/index.js&quot;: &quot;@ember/test-helpers/ember-test-helpers/index.js&quot;
 }
</code></pre>
<p>When Embroider compiles a V1 package like <code>@ember/test-helpers</code> it ensures that the modules that would have &quot;escaped&quot; the package end up <em>inside</em> the package, so that this kind of renaming works.</p>
<p>The renaming rules allow these addons to adopt V2 format without breaking their public API. New addons <em>should not</em> use renaming rules because it's confusing when the imports people type don't align with their real dependencies.</p>
</li>
</ul>
<h2 id="externals"><a class="header" href="#externals">Externals</a></h2>
<p>The <code>externals</code> property in <strong>Ember package metadata</strong> allows a V2 addon to declare specific imported modules that should not be resolved at build time. Instead they will be resolved at runtime using the traditional <code>loader.js</code> <code>require()</code>.</p>
<p>When Embroider compiles V1 packages to V2 it does automatic externals detection.</p>
<p>When publishing a native V2 package, any externals need to be listed explicitly in <strong>Ember package metadata</strong>.</p>
<p>An example of when you may need <code>externals</code> is when you need to consume a script (not a module) that contains arbitrary <code>define()</code> statements. The modules defined by those statements aren't resolvable, in general, at build time. So attempts to import them will generate build errors. By listing them in externals, you can defer them until runtime where they will work.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>To provide <strong>Assets</strong>, a package includes the <code>public-assets</code> key in <strong>Ember package metadata</strong>. It's a mapping from local paths to app-relative URLs that should be available in the final app. For example:</p>
<pre><code>&quot;name&quot;: &quot;my-addon&quot;,
&quot;ember&quot;: {
  &quot;version&quot;: 2,
  &quot;public-assets&quot;: {
    &quot;./public/image.png&quot;: &quot;/my-addon/image.png&quot;
  }
}
</code></pre>
<p>with:</p>
<pre><code>my-addon
└── public
    └── image.png
</code></pre>
<p>will result in final build output:</p>
<pre><code>dist
└── my-addon
    └── image.png
</code></pre>
<p>Notice that we’re <em>not</em> choosing to include assets via explicit ECMA <code>import</code>. The reason is that fine-grained inclusion of asset files is not critical to runtime performance. Any assets that your app doesn’t actually need, it should never fetch. Assets are always things with their own URLs.</p>
<p>If two V2 packages try to emit assets with the same public URL, that's a build error.</p>
<blockquote>
<p>Q: Should we just automatically namespace them instead?
A: That was considered, but it makes backward compatibility harder, and public URLs are not always free to choose/change.</p>
</blockquote>
<h2 id="build-hooks"><a class="header" href="#build-hooks">Build Hooks</a></h2>
<p>In today’s v1 addon packages, the <code>index.js</code> file is the main entrypoint that allows an addon to integrate itself with the overall ember-cli build pipeline. The same idea carries forward to v2, with some changes.</p>
<p>It is no longer the <code>main</code> entrypoint of the package (see <strong>Own Javascript</strong>). Instead, it’s located via the <code>build</code> key in <strong>Ember package metadata</strong>, which should point at a Javascript file. <code>build</code> is optional — if you don’t have anything to say, you don’t need the file.</p>
<p>It is now an ECMA module, not a CJS file. The default export is a class that implements your build hooks (there is no required base class).</p>
<p>Here is a list of build hooks, each of which will have its own section below.</p>
<ul>
<li>configure</li>
<li>configureDependencies</li>
<li>skipBabel</li>
</ul>
<p>I will describe the hooks using TypeScript signatures for precision. This does not imply anything about us actually using TypeScript to implement them. Each package has two type variables:</p>
<ul>
<li><code>PackageOptions</code> is the interface for what options you accept from packages that depend on you. It's your package's build-time public API.</li>
<li><code>OwnConfig</code> is the interface for the configuration that you want to send to your own code, which your code can access via the <code>getOwnConfig</code> macro. This is how you influence your runtime code from the build hooks.</li>
</ul>
<h3 id="build-hook-configure"><a class="header" href="#build-hook-configure">Build Hook: configure</a></h3>
<pre><code class="language-ts">interface ConfigurationRequest&lt;PackageOptions&gt; = {
  options: PackageOptions,
  fromPackageName: string,
  fromPackageRoot: string,
};
configure&lt;PackageOptions, OwnConfig&gt;(
  requests: ConfigurationRequest&lt;PackageOptions&gt;[]
): OwnConfig
</code></pre>
<p>The configure hook receives an array of configuration requests. Each request contain the <code>PackageOptions</code> that a package that depends on this addon has sent to this addon. It also includes the <code>fromPackageName</code> and <code>fromPackageRoot</code> (the full path on disk to the requesting package) so that any configuration errors can blame the proper source.</p>
<p><code>configure</code> deals with an array because multiple packages may depend on a single copy of our package. But our package can only be configured in one way (for example, we are either going to include some extra code or strip it out via the macro system, but we can't do both).</p>
<p>Addons are encouraged to merge configuration requests intelligently to try to satisfy all requesters. If it's impossible to do so, you can throw an error that explains the problem.</p>
<p>The <code>OwnConfig</code> return value must be JSON-serializable. It becomes available to your <strong>Own Javascript</strong> via the <code>getOwnConfig</code> macro, so that it can influence what code is conditionally compiled out of the build.</p>
<h3 id="build-hook-configuredependencies"><a class="header" href="#build-hook-configuredependencies">Build Hook: configureDependencies</a></h3>
<pre><code class="language-ts">configureDependencies(): {
  [dependencyName: string]: PackageOptionsForDependency | &quot;disabled&quot;
}
</code></pre>
<p>The <code>configureDependencies</code> hook is how you send configuration down to your own dependencies. For each package in your <strong>allowed dependencies</strong> you may return either the <code>PackageOptions</code> expected by that package, or the string <code>&quot;disabled&quot;</code>.</p>
<p>Any dependencies that you don't mention are considered active, but don't receive any configuration from you.</p>
<p>Any dependency for which you provide <code>PackageOptions</code> is active, and will receive those <code>PackageOptions</code> in its own <code>configure</code> hook.</p>
<p>If you set a package to <code>&quot;disabled&quot;</code>, it will not become active <em>because of your addon</em>. It may still become active if another package depends on it and leave it active.</p>
<p>When and only when a package is active:</p>
<ul>
<li>all standard Ember module types (<code>your-package/components/*.js</code>, <code>your-package/services/*.js</code>, etc) from its <strong>Own Javascript</strong> <em>that cannot be statically ruled out as unnecessary</em> are included in the build as if some application code has <code>import</code>ed them. (What counts as “cannot be statically ruled out” is free to change as apps adopt increasingly static practices. This doesn’t break any already published packages, it just makes builds that consume them more efficient.)</li>
<li>all of the package's <strong>Implicit Dependencies</strong> are included in the build.</li>
<li>all <strong>App Javascript</strong> is included in the build.</li>
<li>all <strong>Assets</strong> are included in the build.</li>
<li>the package's <strong>Active Dependencies</strong> become active recursively.</li>
</ul>
<p>Whether or not a package is active:</p>
<ul>
<li>directly-imported <strong>Own Javascript</strong> and <strong>CSS</strong> are available to any other package as described in those sections. The rationale for allowing <code>import</code> of non-active packages is that (1) we follow node module resolution and node module resolution doesn’t care about our notion of “active”, and (2) <code>import</code> is an explicit request to use the module in question. It’s not surprising that it would work, it would be more surprising if it didn’t.</li>
</ul>
<p>The <code>configureDependencies</code> hook is the <em>only</em> way to disable child packages. The package hooks are implemented as a class with no base class. There is no <code>super</code> to manipulate to interfere with your children’s hooks.</p>
<h3 id="build-hook-skipbabel"><a class="header" href="#build-hook-skipbabel">Build Hook: skipBabel</a></h3>
<pre><code class="language-ts">skipBabel(): { package: string, semverRange?: string }[]
</code></pre>
<p>By default, all imported dependencies (and their recursive imported dependencies) go through the app's babel config. This ensures browser compatibility safety. However, we provide <code>skipBabel</code> as an opt-out to work around transpilation problems in cases where the developer has verified that transpilation of a given package isn't needed.</p>
<p><code>skipBabel</code> returns a list of package names and optionally semver ranges. If no range is included, it defaults to <code>*</code>. This is a place where you're allowed to mentioned packages that are <em>not</em> in your <strong>allowed dependencies</strong> because it may be necessary to talk about deeper dependencies within them. The <code>skipBabel</code> settings for all active addons are combined and if any addon skips babel for a given package &amp; version, that causes the package to not be transpiled.</p>
<p>The semver range is useful to disambiguate if there are multiple versions of the same package involved in the app, and in cases where a developer has manually verified that transpilation isn't needed, it's good practice to use the semver range so that <code>skipBabel</code> doesn't accidentally apply to a future version of the package that may indeed need transpilation.</p>
<h2 id="what-about-test-support"><a class="header" href="#what-about-test-support">What about Test Support?</a></h2>
<p>v1 packages can provide <code>treeForTestSupport</code>, <code>treeForAddonTestSupport</code>, and <code>app.import</code> with <code>type=&quot;test&quot;</code>. All of these features are dropped.</p>
<p>To provide test-support code, make a separate module within your package and tell people to <code>import</code> it from their tests. As long as it is only imported from tests, it will not be present in non-test bundles. (Things get simpler when you respect the module dependency graph.)</p>
<h2 id="macro-system"><a class="header" href="#macro-system">Macro System</a></h2>
<p>v1 packages can run arbitrary Node code that completely alters their runtime code. This makes them impossible to analyze. v2 packages are not allowed to do this. There are no &quot;treeFor*&quot; hooks. Instead, they can influence their runtime code only through the macro system.</p>
<p>It helps to think about the macro system as an extension to Javascript itself that we allow in v2 packages. Because the macros are allowed to appear in any published V2 package, and because the macros are <em>not</em> a dependency that each package can control (you don't get to bring your own separate macro system version with you), it's important that we design a small core that we can support for the long-term. We probably can't make breaking changes to the macro system, we can only introduce new macros.</p>
<p>(I'm proposing the macros live under <code>@ember/macros</code>. The current implementation of them lives in <code>@embroider/macros</code>.)</p>
<p>The Javascript macros are:</p>
<ul>
<li>importSync</li>
<li>getOwnConfig</li>
<li>getConfig</li>
<li>macroCondition</li>
<li>each</li>
<li>moduleExists</li>
<li>dependencySatisfies</li>
<li>failBuild</li>
</ul>
<p>The Handlebars macros are:</p>
<ul>
<li>macroGetOwnConfig</li>
<li>macroGetConfig</li>
<li>macroCondition</li>
<li>macroDependencySatisfies</li>
<li>macroMaybeAttrs</li>
<li>macroFailBuild</li>
</ul>
<p>The difference in naming is because the JS macros get explicitly imported from <code>@ember/macros</code>, whereas the Handlebars macros do not, so they need an appropriate namespace prefix. (If we land template imports, I'm fine with adjusting this RFC to make the names align.)</p>
<h3 id="javascript-macro-importsync"><a class="header" href="#javascript-macro-importsync">JavaScript Macro: importSync</a></h3>
<pre><code class="language-js">import { importSync } from &quot;@ember/macros&quot;;
importSync(&quot;some-dependency&quot;).default;
</code></pre>
<p><code>importSync</code> exists to do a thing that standard Javascript does not do: synchronous dynamic import. Ember historically needs synchronous dynamic import (it's what our runtime AMD <code>require</code> does). Until some future date at which Ember has migrated away from synchronous module resolution we need <code>importSync</code>.</p>
<p><code>importSync</code> is defined as behaving exactly like the standards-compliant <code>import()</code> except instead of returning <code>Promise&lt;Module&gt;</code> it returns <code>Module</code>.</p>
<p>In this RFC we don't state explicitly what <code>importSync</code> compiles to. It compiles to whatever the Javascript bundler we're using supports in order to achieve synchronous dynamic import. For example, if we're internally using Webpack we can compile <code>importSync(&quot;something&quot;)</code> to <code>require(&quot;something&quot;)</code>, because Webpack supports CommonJS <code>require</code> anywhere.</p>
<h3 id="javascript-macro-getownconfig"><a class="header" href="#javascript-macro-getownconfig">JavaScript Macro: getOwnConfig</a></h3>
<pre><code class="language-js">// this example:
import { getOwnConfig } from &quot;@ember/macros&quot;;
const shouldEnableCoolFeature = getOwnConfig().coolFeature;
// might compile to:
const shouldEnableCoolFeature = true;
// assuming your ownConfig is `{ coolFeature: true }`.
</code></pre>
<p><code>getOwnConfig()</code> behaves like a function that returns your <code>OwnConfig</code>, as determined by the return value of your <code>configure</code> <strong>Build Hook</strong>. You're allowed to chain property access and optional property access (including array indices) off of <code>getOwnConfig()</code>. Since the <code>OwnConfig</code> is required to be JSON-serializable, any subset of it can be accessed this way, and we inline that value directly into the code.</p>
<p>You can choose to inline the whole OwnConfig if you want to:</p>
<pre><code class="language-js">// this example:
import { getOwnConfig } from &quot;@ember/macros&quot;;
const myConfig = getOwnConfig();
// might compile to:
const myConfig = { coolFeature: true };
// assuming your ownConfig is `{ coolFeature: true }`.
</code></pre>
<p>Since <code>getOwnConfig</code> accesses the output of your <code>configure</code> build-hook, you have a place to run arbitrary build-time code and inject the results into runtime Javascript.</p>
<h3 id="javascript-macro-getconfig"><a class="header" href="#javascript-macro-getconfig">Javascript Macro: getConfig</a></h3>
<p><code>getConfig</code> can access the <code>OwnConfig</code> of your dependencies.</p>
<pre><code class="language-js">import { getConfig } from &quot;@ember/macros&quot;;
const testSelectorsConfig = getConfig(&quot;ember-test-selector&quot;);
</code></pre>
<p>It supports property chaining the same as <code>getOwnConfig</code>.</p>
<p>This is a low-level power tool. It's mostly useful as a compile target for custom Babel plugins. For example, <code>ember-test-selectors</code> has a custom Babel plugin that <em>sometimes</em> strips test properties out of your components. But if a V2 package is using ember-test-selectors, it needs to run the custom transform <em>before publishing</em>. At that point, it's too soon to decide whether to strip them.</p>
<p>Instead of actually doing the stripping, the ember-test-selector plugin would compile the user's code into code that uses <code>macroCondition</code> and <code>getConfig('ember-test-selectors')</code>. In this way, we get the powerful custom behavior, but only the standard core macros are needed at the time when the app itself is building.</p>
<h3 id="javascript-macro-macrocondition"><a class="header" href="#javascript-macro-macrocondition">JavaScript Macro: macroCondition</a></h3>
<p><code>macroCondition</code> acts like a function that takes a boolean value and returns that same boolean value. But whenever <code>macroCondition</code> appears directly inside the predicate of an <code>if</code> statement or as the predicate of a ternary expression, it tells the macro system to do branch elimination based on the predicate. Here is an example that combines three of the macros we've seen so far:</p>
<pre><code class="language-js">// This example:
import { macroCondition, getOwnConfig, importSync } from &quot;@ember/macros&quot;;

let implementation;

if (macroCondition(getOwnConfig().useNewVersion)) {
  implementation = importSync(&quot;./new-component&quot;);
} else {
  implementation = importSync(&quot;./old-component&quot;);
}

export default implementation;

// ==============
// Could compile down to this if OwnConfig contains { useNewVersion: true }
let implementation;
implementation = importSync(&quot;./new-component&quot;);
export default implementation;

// ===============
// Or compile down to this if OwnConfig contains { useNewVersion: false }
let implementation;
implementation = importSync(&quot;./old-component&quot;);
export default implementation;
</code></pre>
<p>It is a build error if <code>macroCondition</code> cannot statically determine the truth status of its argument. It's a build error if <code>macroCondition</code> appears anywhere other than as the predicate of an if statement or ternary expression.</p>
<p><code>macroCondition</code> supports boolean logic, like <code>macroCondition(getOwnConfig().a &amp;&amp; getOwnConfig().b)</code>.</p>
<p>Here is an example of <code>macroCondition</code> in a ternary expression:</p>
<pre><code class="language-js">// this example:
const flavor = macroCondition(getOwnConfig().prefersChocolate)
  ? &quot;chocolate&quot;
  : &quot;vanilla&quot;;
// could compile down to:
const flavor = &quot;chocolate&quot;;
</code></pre>
<p><code>macroCondition</code> is the foundation that lets us choose which code to include in the build. You can choose to inline two different implementations within the branches of an <code>if</code> statement, or you can keep them in entirely separate modules and import only the correct one via <code>importSync</code>.</p>
<p>It would also be possible (in the future, when top-level await stabilizes) to use <a href="https://github.com/tc39/proposal-top-level-await">top-level await</a> to replace usage of our <code>importSync</code> macro with standards-compliant <code>import()</code>:</p>
<pre><code class="language-js">if (macroConditional(getOwnConfig().x)) {
  await import(&quot;x&quot;);
} else {
  await import(&quot;y&quot;);
}
</code></pre>
<p>Q: Why not allow <code>if (getOwnConfig().thing)</code> instead of <code>if (macroCondition(getOwnConfig().thing))</code>?</p>
<p>A: Because we don't want to leave any confusion over whether branch elimination will be done. Boolean expressions that include a macro like <code>getOwnConfig</code> alongside other runtime-only values are perfectly legal. But those expressions would not allow branch elimination. The ambiguity means you might accidentally defeat branch elimination without noticing. <code>macroCondition</code> is intended to signal -- both to the reader and to the compiler -- that this place absolutely <em>must</em> do branch elimination. It's an error if we can't eliminate one branch or the other.</p>
<h3 id="javascript-macro-each"><a class="header" href="#javascript-macro-each">JavaScript macro: each</a></h3>
<p><code>each</code> allows you to unroll a loop based on an array value provided by another macro. It behaves like the identity function (returning its argument unchanged), but it provides the special guarantee that if you use it as the argument of a <code>for ... of</code> loop, the loop will be unrolled:</p>
<pre><code class="language-js">// This example:
import { getOwnConfig, each, importSync } from &quot;@ember/macros&quot;;
let plugins = [];
for (let plugin of each(getOwnConfig().registeredPlugins)) {
  plugins.push(importSync(plugin).default);
}

// could compile to this, given OwnConfig
// containing { registeredPlugins: ['@bigco/bar-chart', '@bigco/line-chart']}

let plugins = [];
plugins.push(importSync(&quot;@bigco/bar-chart&quot;).default);
plugins.push(importSync(&quot;@bigco/line-chart&quot;).default);
</code></pre>
<p>It is a static error if the argument to <code>each</code> does not evaluate to a statically known array.</p>
<h3 id="javascript-macro-moduleexists"><a class="header" href="#javascript-macro-moduleexists">JavaScript Macro: moduleExists</a></h3>
<p>Allow you to test if an <code>import</code> (or <code>import()</code> or <code>importSync()</code>, since they all accept an argument with identical semantics) would succeed. Always compiles to a boolean literal.</p>
<pre><code class="language-js">import { moduleExists, macroCondition, importSync } from &quot;@ember/macros&quot;;
if (macroCondition(moduleExists(&quot;ember-data&quot;))) {
  const DS = importSync(&quot;ember-data&quot;).default;
  DS.Adapter.extend({
    //
  });
}
</code></pre>
<p>Remember that you're always only allowed to <code>import</code> from your own <strong>allowed dependencies</strong>. So if an addon wants to optionally use another package only if that package is present, that package must be listed as an <strong>Optional Peer Dependency</strong>.</p>
<p><code>moduleExists</code> differs in one respect from all the other macros: there is no reliable build-time polyfill for it in non-Embroider builds. So when you use it in a non-Embroider build, you get a runtime implementation instead (equivalent to today's <code>require.has()</code>. If you need build-time branch elimination, try to use <code>dependencySatisfies</code> instead, which works correctly in both Embroider and non-Embroider builds.</p>
<h3 id="javascript-macro-dependencysatisfies"><a class="header" href="#javascript-macro-dependencysatisfies">JavaScript Macro: dependencySatisfies</a></h3>
<p>Allows you to test if the given <strong>allowed dependency</strong> satisfies the given semver range. Always compiles to a boolean literal.</p>
<pre><code class="language-js">import { dependencySatisfies, macroCondition } from &quot;@ember/macros&quot;;
if (macroCondition(dependencySatisfies(&quot;ember-data&quot;, &quot;^3.0.0&quot;))) {
  // include code here for ember-data 3.0 compat
}
</code></pre>
<p>The package version will be <code>semver.coerce</code>d first, such that non-standard versions like &quot;3.9.0-beta.0&quot; will appropriately satisfy constraints like &quot;&gt; 3.8&quot;.</p>
<h3 id="javascript-macro-failbuild"><a class="header" href="#javascript-macro-failbuild">Javascript Macro: failBuild</a></h3>
<p>Allow you to cause a build failure with a custom error message. If <code>failBuild</code> isn't eliminated by <code>macroCondition</code>'s branch elimination, the build will fail.</p>
<pre><code class="language-js">import { dependencySatisfies, macroCondition, failBuild } from &quot;@ember/macros&quot;;
if (macroCondition(dependencySatisfies(&quot;ember-data&quot;, &quot;^3.0.0&quot;))) {
  // include code here for ember-data 3.0 compat
} else {
  failBuild(`We don't support ember-data versions other than ^3.0.0`);
}
</code></pre>
<h3 id="handlebars-macro-macrogetownconfig"><a class="header" href="#handlebars-macro-macrogetownconfig">Handlebars Macro: macroGetOwnConfig</a></h3>
<p><code>macroGetOwnConfig</code> is very similar to the <code>getOwnConfig</code> JS macro, but it works as a Handlebars helper. Given this <code>OwnConfig</code>:</p>
<pre><code class="language-json">{
  &quot;items&quot;: [{ &quot;score&quot;: 42 }]
}
</code></pre>
<p>Then:</p>
<pre><code class="language-hbs">&lt;SomeComponent @score={{macroGetOwnConfig &quot;items&quot; 0 &quot;score&quot; }} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @score={{42}} /&gt;
</code></pre>
<p>If you don't pass any arguments, you can get the whole thing (although this makes your template bigger, so use arguments when you can):</p>
<pre><code class="language-hbs">&lt;SomeComponent @config={{macroGetOwnConfig}} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @config={{hash items=(array (hash score=42))}} /&gt;
</code></pre>
<h3 id="handlebars-macro-macrogetconfig"><a class="header" href="#handlebars-macro-macrogetconfig">Handlebars Macro: macroGetConfig</a></h3>
<p>The equivalent of the <code>getConfig</code> JS macro as a Handlebars helper. Given a dependency <code>ember-score</code> exposes this config:</p>
<pre><code class="language-json">{
  &quot;items&quot;: [{ &quot;score&quot;: 42 }]
}
</code></pre>
<p>Then:</p>
<pre><code class="language-hbs">&lt;SomeComponent @score={{macroGetConfig &quot;ember-score&quot; &quot;items&quot; 0 &quot;score&quot; }} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @score={{42}} /&gt;
</code></pre>
<h3 id="handlebars-macro-macrocondition"><a class="header" href="#handlebars-macro-macrocondition">Handlebars Macro: macroCondition</a></h3>
<p>Used as a helper within a block <code>{{#if}}</code> or inline <code>{{if}}</code>. Just like the JS <code>macroCondition</code>, it ensures that branch elimination will happen.</p>
<pre><code class="language-hbs">  {{#if (macroCondition (macroGetOwnConfig &quot;shouldUseThing&quot;)) }}
    &lt;Thing /&gt;
  {{else}}
    &lt;OtherThing /&gt;
  {{/if}}

  {{! ⬆️compiles to ⬇️ }}
  &lt;Thing /&gt;
</code></pre>
<h3 id="handlebars-macro-macrodependencysatisfies"><a class="header" href="#handlebars-macro-macrodependencysatisfies">Handlebars Macro: macroDependencySatisfies</a></h3>
<p>Acts like a helper that returns a boolean. Like the <code>dependencySatisfies</code> JS macro, it can only resolve things that are <strong>allowed dependencies</strong>, so the same need for peer dependencies and/or <strong>Optional Peer Dependencies</strong> applies.</p>
<pre><code class="language-hbs">&lt;SomeComponent @canAnimate={{macroDependencySatisfies &quot;liquid-fire&quot; &quot;*&quot;}} /&gt;
{{! ⬆️compiles to ⬇️ }}
&lt;SomeComponent @canAnimate={{true}} /&gt;
</code></pre>
<h3 id="handlebars-macro-macromaybeattrs"><a class="header" href="#handlebars-macro-macromaybeattrs">Handlebars Macro: macroMaybeAttrs</a></h3>
<p>There is one place where <code>{{#if}}</code> doesn't work: within &quot;element space&quot;. If you want to <em>sometimes</em> set an attribute, but sometimes not, this doesn't work:</p>
<pre><code class="language-hbs">&lt;div {{#if this.testing}} data-test-target={{@id}} {{/if}} /&gt;
</code></pre>
<p><code>macroMaybeAttrs</code> exists to conditionally compile away attributes and arguments out of element space:</p>
<pre><code class="language-hbs">&lt;div {{macroMaybeAttrs (macroGetConfig &quot;ember-test-selectors&quot; &quot;enabled&quot;) data-test-target=@id }} /&gt;
</code></pre>
<p>It can be placed on both HTML elements and angle bracket component invocations.</p>
<h3 id="handlebars-macro-macrofailbuild"><a class="header" href="#handlebars-macro-macrofailbuild">Handlebars Macro: macroFailBuild</a></h3>
<p>Like the JS <code>failBuild</code> macro.</p>
<pre><code class="language-hbs">{{#if (macroCondition (macroDependencySatisfies &quot;some-peer-dep&quot; &quot;^3.0.0&quot;)) }}
  &lt;UseTheThing /&gt;
{{else}}
  {{macroFailBuild &quot;You tried to use &lt;MyFancyComponent/&gt; but it requires some-peer-dep ^3.0.0&quot;}}
{{/if}}
</code></pre>
<h3 id="macros-overall-design"><a class="header" href="#macros-overall-design">Macros: Overall Design</a></h3>
<p>All the macros are intended to be valid syntax. They shouldn't break parsing or linting.</p>
<p>While we guarantee that branch elimination will run in production builds, we <em>don't</em> guarantee that in development. The macros are designed so that in development they may have <em>runtime</em> implementations. This is powerful because it lets us produce a single build that works in multiple contexts. For example:</p>
<ul>
<li>
<p>it solves the longstanding problem that when you run your tests by visiting <code>localhost:4200/tests</code> the tests see the <code>development</code> environment, not the <code>test</code> environment. To get the test environment you can't use <code>ember serve</code>, you must use <code>ember test</code>. This has remained unfixed because it's expensive to do the whole build twice for the two environments.</p>
<p>We can solve this problem by producing a <em>single</em> build containing <em>both</em> environments, guarded by the macro system. The macros can evaluate at runtime, allowing each environment to get the right thing. In production builds, test-only or dev-only branches will still be eliminated.</p>
</li>
<li>
<p>it makes Fastboot builds simpler because we can guard the fastboot-only and browser-only code with the macro system. In development, we can run a single build that leaves both branches in and evaluates the macros at runtime.</p>
</li>
</ul>
<p>The macros package (<code>@ember/macros</code> as proposed, <code>@embroider/macros</code> as implemented) will work in both regular ember-cli and in Embroider. And it will work in both V1 and V2 packages.</p>
<h2 id="peer-dependencies"><a class="header" href="#peer-dependencies">Peer Dependencies</a></h2>
<p>V2 packages can only resolve their <strong>allowed dependencies</strong>. This is fundamental rule that we can't break if we want the broadest compatibility with NPM and future compatibility with other strict systems such as <a href="https://github.com/yarnpkg/rfcs/pull/101">Yarn PnP</a>. Node often allows you to resolve things that are not <strong>allowed dependencies</strong> due to hoisting optimizations. But this is not safe or guaranteed, so we forbid relying on it.</p>
<p>This means that many things addons will try to access from their surrounding environment will need to be listed as <code>peerDependencies</code>. For example, addons that want to import <code>ember-data</code> should list <code>ember-data</code> as a <code>peerDependency</code>, so the app can control the <code>ember-data</code> version and the addon is guaranteed to resolve the same copy.</p>
<p>This also applies recursively -- if your addon wants to use an addon that needs <code>ember-data</code>, your addon should also list <code>ember-data</code> as a <code>peerDependency</code>. The clearest documented description of how recursive peerDependencies should work is in the <a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-plug-an-play.md#c-formal-plugnplay-guarantees">Yarn PnP Formal Guarantees</a>.</p>
<p><code>ember-source</code> provides many &quot;virtual&quot; packages like <code>@ember/component</code>. If they were real packages, they would be <code>peerDependencies</code>, but having non-real packages in package.json is likely to result in errors. Pedantically, they can be listed in <strong>externals</strong> instead. In practice, they are a well-known set that we can always handle correctly automatically, so it's not very important whether an addon includes them in <strong>externals</strong>.</p>
<h3 id="optional-peer-dependencies"><a class="header" href="#optional-peer-dependencies">Optional Peer Dependencies</a></h3>
<p>Some addons optionally use another addon if it happens to be available in the app. In order to resolve such a dependency, we really need <strong>Optional Peer Dependencies</strong>.</p>
<p>NPM doesn't have a concept of optional peer dependencies. It has &quot;optional dependencies&quot;, but they are something different and pretty useless.</p>
<p>Yarn did an <a href="https://github.com/yarnpkg/rfcs/blob/master/accepted/0000-optional-peer-dependencies.md">RFC for optional peer dependency support</a>. It is basically compatible with NPM, with the only caveat being that if you use NPM you may see a spurious warning at install time. As non-actionable peerDependency warnings are rife throughout the NPM ecosystem this doesn't seem like a big deal.</p>
<p>V2 Packages are allowed to use optional peer dependencies as described in the Yarn RFC.</p>
<p>Our own tooling, like ember-cli-dependency-checker, we can make sure the warnings respect the Yarn standard.</p>
<h2 id="apps-as-v2-packages"><a class="header" href="#apps-as-v2-packages">Apps as V2 Packages</a></h2>
<p>This RFC is focused heavily on addons, because that is the area that is most critical to standardize. Publishing addons to NPM in V2 format has major benefits:</p>
<ul>
<li>build performance: there is much less work to do at app build time, and many <code>dependencies</code> of addons can become <code>devDependencies</code> of addons, resulting in smaller <code>node_modules</code> and faster <code>npm install</code>.</li>
<li>tool integration: VSCode, Typescript, SCSS, etc will all understand your code better when the dependencies are in V2 format. Things like &quot;jump-to-definition&quot; will work.</li>
<li>Embroider stability: <code>@embroider/compat</code> needs to use heuristics and some addon-specific rules to compile V1 addons into V2. This is necessarily more fragile than having addons published natively in V2. The first step in stabilizing Embroider for mainstream adoption is standardizing on this new addon format.</li>
</ul>
<p>In contrast, apps are not published to NPM. So where would they use V2 publication format?</p>
<p>During the build process for an app, it will first build from its authoring format <em>to the standard v2 package format</em>. At that point, the whole project is just a collection of standard v2 packages with well-defined semantics, and we can confidently treat that stage in the build pipeline as supported public API.</p>
<p>The benefit of this approach is that we can separately evolve authoring formats and last-stage packaging tools, while keeping a stable interface between them. The stable interface is designed to leverage general-purpose ECMA-spec-compliant features wherever practical, which makes it a rich target. For more detail on Embroider's three-stage build pipeline see <a href="https://github.com/embroider-build/embroider/blob/f5181d0d7eab146fd0dfcafdff552ee4fc129f2a/README.md#embroider-a-modern-build-system-for-emberjs-apps">the README</a>.</p>
<p>v2-formatted apps do differ in a few ways from v2-formatted addon, as described in the following sections.</p>
<h3 id="features-that-apps-may-not-use"><a class="header" href="#features-that-apps-may-not-use">Features that Apps May Not Use</a></h3>
<p>Several features in the v2 addon format are designed to be consumed <em>by the app</em>. These features aren’t appropriate in an app, because that is the end of the line — a v2-formatted app should be understandable by general-purpose Javascript tooling and have very little <em>implicit</em> Ember-specific build semantics left.</p>
<p>Features that apps may not use include:</p>
<ul>
<li>the <code>implicit-*</code> keys in <strong>Ember package metadata</strong>.</li>
<li>the <code>app-js</code> key in <strong>Ember package metadata</strong></li>
<li>the <code>build</code> key in <strong>Ember package metadata</strong>. We should consider updating the <em>authoring</em> format so that apps can use a build file with the standard package hooks, because that makes a lot of sense. But it’s not appropriate in the v2 format (which is a <em>publication</em> format), and this change can be a separate RFC, and it will be an easier RFC after landing this one.</li>
<li>automatic inclusion of resolvable types (components, services, etc) from the <strong>Own Javascript</strong> of all <strong>Active Dependencies</strong> and the app itself.</li>
<li>the <code>public-assets</code> key in <strong>Ember package metadata</strong>.</li>
</ul>
<p>All these features can appear in v2 <em>addons</em>, and the <em>app</em> ensures each one is represented by standards-compliant Javascript within the app’s own code. To illustrate with some examples, the V2 format for an app (as already implemented in Embroider) includes:</p>
<ul>
<li><code>&lt;script&gt;</code> tag(s) in index.html and tests/index.html that ensure <code>implicit-scripts</code> and <code>implicit-test-scripts</code> of all active addons are already accounted for.</li>
<li><code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> tag(s) in index.html and tests/index.html that ensure <code>implicit-styles</code> and <code>implicit-test-styles</code> are accounted for.</li>
<li>actual Javascript <code>import</code> statements within the app's code that ensure <code>implicit-modules</code> and <code>implicit-test-modules</code> are accounted for</li>
<li>actual Javascript <code>import</code> statements and AMD <code>define</code> calls that handle automatic inclusion of resolvable types that cannot be statically ruled out.</li>
</ul>
<h2 id="features-that-only-apps-may-use"><a class="header" href="#features-that-only-apps-may-use">Features that only Apps may use</a></h2>
<p>There are also a few V2 package features only supported in apps. These are mostly of interest only to people working within ember-cli and/or embroider to implement new packaging tools. Each of these is a property in <strong>Ember package metadata</strong>:</p>
<ul>
<li>
<p><code>rootURL</code>: has the same meaning as <code>rootURL</code> in <code>config/environment.js</code> in a standard Ember app.</p>
</li>
<li>
<p><code>assets</code>: a list of relative paths to files. The intent of <code>assets</code> is that it declares that each file in the list must result in a valid URL in the final app.</p>
<p>The most important assets are HTML files. All <code>contentFor</code> has already been applied to them. (Remember, we’re talking about the publication format that can be handed to the final stage packager, not necessarily the authoring format.) It is the job of the final stage packager to examine each asset HTML file and decide how to package up all its included assets in a correct and optimal way, emitting a final result HTML file that is rewritten to include the packaged assets.</p>
<p>Note that packagers must respect the HTML semantics of <code>&lt;script type=&quot;module&quot;&gt;</code> vs <code>&lt;script&gt;</code> vs <code>&lt;script async&gt;</code>. For example: don’t go looking for <code>import</code> in <code>&lt;script&gt;</code>, it’s only correct in <code>&lt;script type=&quot;module&quot;&gt;</code></p>
<p>File types other than HTML are allowed to appear in <code>&quot;assets&quot;</code>. The intent is the same (it means these files must end up in the final build such that they’re addressable by URLs). For example, a Javascript file in <code>&quot;assets&quot;</code> implies that you want that JS file to be addressable in the final app (and we will treat it as a script, not a module, because this is for foreign JS that isn’t going through the typical build system. If you actually want a separate JS file as output of your build, use <code>import()</code> instead). This is a catch-all that allows things like your <code>/public</code> folder full of arbitrary files to pass through the final stage packager.</p>
<p>A conventional app will have an <code>&quot;assets&quot;</code> list that include <code>index.html</code>, <code>tests/index.html</code>, and all the files that were copied from <code>/public</code>.</p>
</li>
<li>
<p><code>template-compiler.filename</code>: the relative path to a module that is capable of compiling all the templates. The module exports :</p>
<ul>
<li><code>compile: (moduleName: string, templateContents: string) =&gt; string</code> that converts templates into JS modules.</li>
</ul>
</li>
<li>
<p><code>template-compiler.isParallelSafe</code>: true if the template compiler can be used in other node processes</p>
</li>
<li>
<p><code>babel.filename</code>: the relative path to a module that exports the app's babel config.</p>
</li>
<li>
<p><code>babel.isParallelSafe</code>: true if the <code>babel</code> settings can be used in a new node process.</p>
</li>
<li>
<p><code>babel.majorVersion</code>: the version of babel the app's settings were written for. Only 6 and 7 are supported at this time.</p>
</li>
</ul>
<p>Unlike addons, an app’s <strong>Own Javascript</strong> is not limited to only ES latest features. It’s allowed to use any features that work with the config in <code>babel.filename</code>. This is an optimization — we <em>could</em> logically require apps to follow the same rule as addons and compile down to ES latest before handing off to a final packager. But the final packager is going to run babel anyway, so we allow apps to do all their transpilation in that final single pass.</p>
<h2 id="ember-language-standard"><a class="header" href="#ember-language-standard">Ember Language Standard</a></h2>
<p>This RFC introduces the idea of <code>Ember Language Standard</code> as a way to be explicit about exactly what Javascript dialect we support in shared packages, and exactly what extensions to Javascript are required to understand the complete semantics of Ember apps.</p>
<p>As of this writing, Ember language standard contains the following subset of ECMAScript:</p>
<ul>
<li>all of ECMAScript 2019
<ul>
<li>with the caveat that if you use un-transpile-able features (like <code>Proxy</code>) that aren't supported in all browsers that Ember supports, your package won't support those browsers</li>
</ul>
</li>
<li><a href="https://github.com/tc39/proposal-decorators">decorators proposal</a> currently in TC39 stage 2.</li>
<li><a href="https://github.com/tc39/proposal-optional-chaining">Optional Chaining</a> and <a href="https://github.com/tc39/proposal-nullish-coalescing">Nullish Coalescing</a>, which are stage 4 (completed) proposals slated for inclusion in es2020.</li>
<li>A subset of <a href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a>, a stage 4 (completed) proposal slated for inclusion in es2020, as detailed below.</li>
</ul>
<p>We also incorporate the following extensions to Javascript. Our intent here is that this is the minimal set of things that aren't really expressible, even in principle, using Javascript itself:</p>
<ul>
<li>
<p>handlebars templates may be imported as if they were ES modules. You get back an ES module with a default export containing an opaque value representing the compiled template. The only public-API for <em>consuming</em> the opaque value you get back is to pass it to Ember's <code>setComponentTemplate()</code> or set it as the <code>layout</code> property on an <code>Ember.Component</code>. The <code>.hbs</code> extension has lower priority than <code>.js</code>, so <code>import './foo'</code> will favor <code>./foo.js</code> over <code>./foo.hbs</code>.</p>
</li>
<li>
<p>CSS files may be imported as if they were ES modules. The <code>.css</code> extension is mandatory, unlike <code>.js</code> and <code>.hbs</code> it is never automatically inferred. We define <em>no exported value</em>. The meaning is: if you import a CSS file, the CSS file is guaranteed to be in the DOM before your module evaluates.</p>
<p>The reason we define no exported value is that it's not clear we want to commit to one long-term standard. By not giving CSS a value in JS, we reserve the right to do so in the future if a web standard emerges. Users who want imported CSS to return a value are free to compile their CSS to actual JS modules <em>before</em> publishing their package.</p>
</li>
<li>
<p>JSON files may be imported as if they were ES modules. This is supported in Node and it's enabled by default in popular Javascript bundlers like Webpack, so it's common to encounter code on NPM that expects it to work. We interpret JSON as an ECMA module whose <code>default</code> export is the JSON object.</p>
</li>
</ul>
<h3 id="supported-subset-of-dynamic-import-syntax"><a class="header" href="#supported-subset-of-dynamic-import-syntax">Supported subset of dynamic import syntax</a></h3>
<p><a href="https://github.com/tc39/proposal-dynamic-import">Dynamic import</a> aka <code>import()</code> is supported. However, we choose to support only a subset of possible syntax inside <code>import()</code>. Since we're choosing a strict subset, we can safely expand it later as needed.</p>
<p>First we'll illustrate by examples:</p>
<pre><code class="language-js">// ALLOWED: string literal
import(&quot;./some-module&quot;)

// ALLOWED: template string with a static prefix containing
// a relative path
import(`./locale/${currentLocale}/messages`);

// ALLOWED: template string with a static prefix containing
// a complete package name
import(`some-package/${feature}`);

// ALLOWED: template string with a static prefix that clearly
// contains an absolute URL.
import(`https://example.com/components/${choice}`);

// FORBIDDEN: any syntax that is not a string literal or template string
import(arbitraryExpression());

// FORBIDDEN: template string that does not uniquely identify a package
import(`@ember/${which}`);
</code></pre>
<p>To be more precise, the only supported syntax inside <code>import()</code> is:</p>
<ul>
<li>a string-literal</li>
<li>or a template string that begins with a static prefix which falls into one of these allowed cases:
<ul>
<li>the static prefix matches <code>/(\w+:)?\/\//</code>
<ul>
<li>this detects absolute URLs, both ones with protocols (starting with <code>http://</code>) and ones that are protocol-relative (starting with <code>//</code>).</li>
<li>in this case, Embroider will leave your <code>import()</code> alone so you can access the browser's implementation of <code>import()</code>. You are responsible for the contents of the URL, it is beyond the scope of the Embroider build.</li>
</ul>
</li>
<li>the static prefix starts with <code>@</code> and contains at least two <code>/</code>
<ul>
<li>this detects a namespaced NPM package name. If the package can't be resolved or it contains zero files that match your pattern, we emit a static build error.</li>
</ul>
</li>
<li>the static prefix does not start with <code>@</code> and contains at least one <code>/</code>
<ul>
<li>this covers patterns that start with a non-namespaced NPM package names or a relative path. If the pattern matches zero files, we emit a static build error.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Any other syntax is a static build error.</p>
<p>The rationale for this chosen subset is that we want it to be possible to introduced <em>controlled</em>, <em>intentional</em> dynamism, without accidentally blowing holes in the static analysis of whole programs. For example, if we simply allowed any non-statically-resolvable module specifier to silently become a runtime <code>import()</code>, it would mask many bugs that would otherwise be caught statically at build time. You can opt-in to fully-dynamic runtime <code>import()</code>, but you need to say so in a way that is statically legible so we can distinguish it from accidents.</p>
<h2 id="compatibility-strategy"><a class="header" href="#compatibility-strategy">Compatibility Strategy</a></h2>
<p>The <code>@embroider/compat</code> package exists to compile V1 packages to V2. This allows <code>@embroider/core</code> to always assume V2 packages as input, so we don't need to wait until every addon is natively available in V2 before we start getting the benefits of Embroider. However, there is still an incentive to convert as many addons as possible to V2, because they build faster and they will be more stable (the v1-to-v2 compilation isn't flawless, we need heuristics and package-specific rules to deal with some dynamic addon behaviors).</p>
<p>It also needs to be possible for an addon published as V2 to work in existing apps on existing ember-cli versions. This is enabled by:</p>
<ul>
<li><code>ember-auto-import</code>, which serves as a high-fidelity polyfill for importing directly from NPM. V2 addons natively support importing from NPM, but they should depend on <code>ember-auto-import</code> so those imports will have the same meaning when used in classic ember-cli.</li>
<li><code>@ember/macros</code>, which shall provide correct semantics regardless of whether the package using them is published as V1 or V2 and regardless of whether the build is being done by classic ember-cli or Embroider. Native V2 packages under Embroider can alway use macros, without an explicit dependency on <code>@ember/macros</code>, but they should include the dependency so that macros will work in classic ember-cli.</li>
<li>ember-cli already supports a <code>main</code> property in under <code>ember-addon</code> and has supported it for many versions. This allows an addon to put its classic <code>index.js</code> file in a place other than the package's true <code>main</code>. This means that V2 addons can have their runtime <code>index.js</code> as <code>main</code>, and should point <code>ember-addon.main</code> to a <code>classic.js</code> file. The <code>classic.js</code> file should <code>require</code> and <code>export</code> a compatibility shim library that we will provide. The compatibility shim will have the classic methods like <code>treeForAddon</code>, <code>treeForPublic</code> that take the V2-formatted features and present them in a way that classic ember-cli will understand. Since V2 packages are much more static than V1 packages, this shim is expected to not be very complicated.</li>
</ul>
<h1 id="how-we-teach-this-100"><a class="header" href="#how-we-teach-this-100">How we Teach This</a></h1>
<p>This RFC should have no direct impact on what app authors need to learn. They keep using addons the same way they always have. Future RFCs that take Embroider mainstream <em>will</em> have impact, but that can be discussed then.</p>
<p>The impact on addon authors is more significant. This design is fully backward compatible, and the intention is that all existing addons continue to work (some with worse compatibility hacks than others in the v1-to-v2 compiler). But there will be a demand for addons published in v2 format, since it is expected to result in faster build times. My prediction is that people who are motivated to get their own app build times down will send a lot of PRs to the addons they’re using.</p>
<p>In many cases, converting addons to v2 makes them simpler. For example, today many addons use custom broccoli code to wrap third-party libraries in a fastboot guard that prevents the libraries from trying to load in Node (where they presumably don’t work). In v2, they can drop all that custom build-time code in favor of a macro-guarded <code>importSync</code>.</p>
<p>This design does <em>not</em> advocate loudly deprecating any v1 addon features. Doing that all at once would be unnecessarily disruptive. I would rather rely on the carrot of faster builds and Embroider stability than the stick of deprecation warnings. We can choose to deprecate v1 features in stages at a later time.</p>
<p>We should release an officially-supported package (tentatively named <code>@embroider/addon</code>) that provides tooling for addon authors who want to publish a V2 package that is backward compatible in non-embroider apps. This package's documentation is a natural starting point for teaching developers what to do.</p>
<h1 id="alternative-designs"><a class="header" href="#alternative-designs">Alternative Designs</a></h1>
<p>Embroider effectively supersedes both the <a href="https://github.com/ember-cli/rfcs/blob/master/active/0051-packaging.md">Packager RFC</a> and the <a href="https://github.com/ember-cli/rfcs/pull/118">Prebuilt Addons RFC</a>. So both of those are alternatives to this one.</p>
<p>Packager creates an escape hatch from the existing ember-cli build that is supposed to provide a foundation for many of the same features enabled by this design. The intention was correct, but in my opinion it tries to decompose the build along the wrong abstraction boundaries. It follows the existing pattern within ember-cli of decomposing the build by feature (all app javascript, all addon javascript, all templates, etc) rather than by package (everything from the app, everything from ember-data, everything from ember-power-select, etc), which puts it into direct conflict with the Prebuilt Addons RFC.</p>
<p>The API that packager provides is also incomplete compared with this design. For example, to take the packager output and build it using Webpack, Rollup, or Parcel still requires a significant amount of custom code. Whereas taking a collection of v2 formatted Ember packages and building them with any of those tools requires very little Ember-specific code.</p>
<p>The prebuilt addons RFC addresses build performance by doing the same kind of work-moving as this design. Addons can do much of their building up front, thus saving time when apps are building. But it only achieves a speedup when apps happen to be using the same build options that addons authors happened to publish. This design takes a different approach that preserves complete freedom for app authors to postprocess all addon Javascript, including dead-code-elimination based on the addon features their app is using. The prebuilt addons RFC also doesn’t attempt to specify the contents of the prebuilt trees — it just accepts the current implementation-defined contents. This is problematic because shared builds artifacts are long-lived, so it’s worth trying to align them with very general, spec-compliant semantics.</p>
<h1 id="supporting-references"><a class="header" href="#supporting-references">Supporting References</a></h1>
<ul>
<li>
<p>There is a <a href="https://github.com/embroider-build/embroider/blob/master/SPEC.md">SPEC draft</a> in the Embroider repo that predates this one, but covers a broader scope. Where this document contradicts SPEC.md, this document takes precedence and SPEC.md needs to be updated. But SPEC.md covers a broader scope, including the disposition of the other build hooks that will be handled in future RFCs.</p>
</li>
<li>
<p>The definitive list of <strong>Ember package metadata</strong> fields is declared in <a href="https://github.com/embroider-build/embroider/blob/master/packages/core/src/metadata.ts">AppMeta and AddonMeta interfaces</a>. Each one is documented in an <a href="https://github.com/embroider-build/embroider/blob/master/SPEC.md#appendix-list-of-ember-package-metadata-fields">Appendix in SPEC.md</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-07-29
Heavily Revised: 2020-02-28
Relevant Team(s): All teams
RFC PR: https://github.com/emberjs/rfcs/pull/519</p>
<hr />
<h1 id="ember-2020-roadmap"><a class="header" href="#ember-2020-roadmap">Ember 2020 Roadmap</a></h1>
<h2 id="summary-132"><a class="header" href="#summary-132">Summary</a></h2>
<p>The purpose of the Ember Roadmap process is to rally the community around a number of shared goals. This post documents those goals for 2020.</p>
<p>Since the Ember community cannot predict the future, we cannot be sure that we will achieve all of the individual items enumerated here. Instead, the purpose of this document is to give the community a common purpose to aspire towards.</p>
<p>This year our two headline priorities are:</p>
<ul>
<li>Polish the practical and conceptual details of Octane (tracked properties, Glimmer components, related tooling, accessibility, performance and payload improvements).</li>
<li>Make Ember easier to try and adopt, but also lower barriers for Ember developers when collaborating with the greater JavaScript project. We will do this through improvements and simplifications to the framework, and through focused communication with the greater JavaScript community.</li>
</ul>
<h2 id="motivation-132"><a class="header" href="#motivation-132">Motivation</a></h2>
<p>This document is a distillation of multiple sources:</p>
<ol>
<li>The 2019 Community Survey.</li>
<li>Community #EmberJS2019 blog posts authored in response to our call for posts.</li>
<li>Discussion on <a href="https://discuss.emberjs.com/">https://discuss.emberjs.com</a>, Discord, Twitter, and other public venues.</li>
<li>Deliberations among the Ember core teams.</li>
<li>Your comments and feedback on the roadmap RFC itself.</li>
</ol>
<p>The goal of the RFC is to align the Ember community around a set of shared, achievable goals that balance the needs of existing users with the need to grow and support new users.</p>
<h2 id="detailed-design-113"><a class="header" href="#detailed-design-113">Detailed design</a></h2>
<p>Now that Ember Octane has shipped, it’s time to turn our attention to new efforts in 2020. Our goal is to build on Octane's release and capitalize on that cutting-edge foundation.</p>
<ul>
<li><strong>Invest in Octane.</strong> Octane's mental model and basic components are complete, but a number of practical and conceptual gaps remain. We will close these gaps with work on tooling, by deprecating classic APIs to simplify Ember for new users, and by introducing additional functionality where appropriate.</li>
<li><strong>Modernize our build system.</strong> This year we will prioritize improvements to the Ember application build pipeline, and to Ember itself, which will bring modern optimizations like tree shaking and code splitting to both new applications <em>and</em> existing codebases.</li>
<li><strong>Better a11y by default</strong>. We will better support assistive technologies via updates to the router. Additionally we will provide developers more tools for understanding and improving the accessibility of their Ember applications. Our goal is a great &quot;out of the box&quot; experience with Ember and assistive technologies.</li>
<li><strong>Share Octane outside our community.</strong> Octane's release put Ember in front of a lot of new eyes. We will continue that trend through 2020 by talking about Octane in front of new audiences.</li>
</ul>
<h3 id="invest-in-octane"><a class="header" href="#invest-in-octane">Invest in Octane</a></h3>
<p>Ember Octane put the framework on a strong footing by modernizing its most foundational APIs. Many teams are already productive using Octane, and from their experience have provided a torrent of real-world feedback. We will continue improving the developer experience (DX) of Octane throughout 2020.</p>
<p>Many of the rough edges in Octane aren't on the features themselves, but in the supporting tooling. The usefulness of stack traces from Glimmer, the ability to use TypeScript with Ember templates, how tracked properties and Glimmer components are reflected in the Ember Inspector, and the build speed of our application pipelines are all important parts of Octane's DX. We will invest in these areas of work.</p>
<p>For developers who are new to Ember, the presence of classic non-Octane APIs can be disorienting. We will look for creative solutions that make those features trivial for existing apps to continue using while also making them less expensive (in payload, performance, and mental model) for new adopters.</p>
<p>Finally there are some areas of Octane features which can still benefit from new feature work:</p>
<ul>
<li>The <code>@tracked</code> system, for example, limits the expression of state in an application to defined properties on an object. Real-world codebases often want to maintain state as a list or a map, and we can extend on the well-designed internals of Ember's reactivity model to support these cases.</li>
<li>Modifiers provide a hook into the DOM rendering lifecycle, but Octane has no APIs for hooking into other lifecycles in the rendering and object system. We will create these APIs.</li>
<li>We will continue a push to make Ember templates better analyzable at build time by introducing a strict-mode template and static imports.</li>
<li>We will make it easier to build ergonomic, reusable components by shipping named blocks.</li>
</ul>
<p>We will introduce new features in Ember which improve Octane in these and other areas.</p>
<h3 id="modernize-our-build-system"><a class="header" href="#modernize-our-build-system">Modernize our build system</a></h3>
<p>Last year, we started work on Embroider, an overhaul of the Ember CLI compilation pipeline. This year, we will put the finishing touches on Embroider and start migrating the Ember ecosystem to this modernized build.</p>
<p>Embroider integrates Ember CLI with popular packagers like <a href="https://webpack.js.org/">webpack</a> and <a href="https://rollupjs.org/guide/en/">rollup</a>. It allows Ember apps to trivially import from any dependency published as standard JavaScript modules, and will unblock shipping Ember itself as npm packages in the <code>@ember</code> namespace.</p>
<p>This new approach, through its foundation on common packaging libraries, will also unlock new build time optimizations. These optimizations, like tree-shaking and route-based code-splitting, will allow Embroider to produce smaller asset payloads.</p>
<p>Additionally, we will introduce a system into Ember which allows apps to drop framework code supporting deprecated features unused by an app. This will result in smaller vendor assets for applications which don't rely on deprecated features. For example, a modern Octane application may not require <code>Ember.Component</code>, and can benefit from having the code supporting that API being dropped at build time.</p>
<p>Finally, we will make sure this modernization effort provides benefits to existing applications. If a team has been steadily upgrading their app for years now, they won't need to rewrite it to get the benefits of a modern build packager.</p>
<h3 id="better-a11y-by-default"><a class="header" href="#better-a11y-by-default">Better a11y by default</a></h3>
<p>Ember applications should be accessible to everyone. Unfortunately, even seemingly small mistakes can make your app difficult or impossible to use with assistive technology like screen readers. We will do more to improve the out-of-the-box accessibility of Ember applications, and provide tools to help applications stay accessible as they grow.</p>
<ul>
<li><strong>Fix router accessibility</strong> so that page navigation is correctly announced by screen readers, without needing a third-party addon.</li>
<li>Incorporate <strong>accessibility checks</strong> into the built-in test helpers.</li>
<li><strong>Engage with standards bodies</strong> to help fill the gaps in existing web accessibility APIs.</li>
</ul>
<p>To contribute to this effort see <a href="https://github.com/emberjs/rfcs/issues/595">RFC Issue 595</a> which coordinates the Ember A11y Strike Team.</p>
<h3 id="sharing-octane-outside-our-community"><a class="header" href="#sharing-octane-outside-our-community">Sharing Octane outside our community</a></h3>
<p>There are more people building web applications than ever, and Ember must adapt to their changing needs and expectations in order to stay relevant. Octane better aligns Ember's API with what new users expect from a modern framework. We need to take advantage of that change.</p>
<p>This year, we’ll share with the world how Ember Octane is modern, productive, and <em>fun</em>. Through blog posts, videos, social media, meetups, and conferences, we will share our knowledge and experiences with the wider JavaScript community and encourage them to give Octane a try.</p>
<p>We will continue to make Octane more attractive to new users with a new documentation approach, more effective website, and with clearer communication about the Glimmer.js project.</p>
<h2 id="lowering-barriers-to-adoption-and-collaboration"><a class="header" href="#lowering-barriers-to-adoption-and-collaboration">Lowering barriers to adoption and collaboration</a></h2>
<p>Making Ember more attractive to new users doesn't mean compromising on what has made the framework so very successful for existing codebases and teams.</p>
<p>The most basic value of the Ember project is that we solve problems together. While we intend to grow the number of framework users and modernize the framework in many ways, we won't optimize for growth at the expense of our existing community. Instead, we will collaborate on solutions that come with a curated adoption story.</p>
<p>Because we understand and value the power of collaboration, we know we must lower barriers, technical and non-technical, which not only make new users hesitate to adopt Ember but also discourage Ember developers from participating the greater JavaScript community.</p>
<p>A great example of our progress in this is Octane's embrace of native JavaScript classes: A JavaScript developer starting out with Ember today isn't immediately forced to learn a new, Ember-specific class API before they can get to writing code. On the other hand, a developer who starts off with Ember can also contribute to most OSS JavaScript projects without needing to first un-learn the Ember class system.</p>
<p>By sharing common solutions to common problems with other communities we not only make Ember more approachable, we also benefit from the opportunity to exchange more ideas. Everyone wins.</p>
<p>With our efforts to flesh out Octane, improve the build system and align it with the rest of the JavaScript community, raise the baseline support for accessible applications, and to better communicate in 2020 we will lower barriers to adoption of Ember, but also to our own collaboration with the greater JavaScript project.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-08-29
Relevant Team(s): EmberData
RFC PR: https://github.com/emberjs/rfcs/pull/521</p>
<hr />
<h1 id="data-findrecordpeekrecord-via-identifier"><a class="header" href="#data-findrecordpeekrecord-via-identifier">[DATA] findRecord/peekRecord via Identifier</a></h1>
<h2 id="summary-133"><a class="header" href="#summary-133">Summary</a></h2>
<p>Users should be able to peek or find records based on <code>lid</code>.</p>
<h2 id="motivation-133"><a class="header" href="#motivation-133">Motivation</a></h2>
<p>Apps and Addons making use of <a href="https://github.com/emberjs/rfcs/pull/403">Identifiers</a>
may wish to peek or find the record for a known <code>identifier</code>. This
RFC would allow them to do so.</p>
<h2 id="detailed-design-114"><a class="header" href="#detailed-design-114">Detailed design</a></h2>
<p>A new method signature would be added to <code>findRecord</code>
<code>peekRecord</code> and <code>getReference</code>. The existing signatures would not be
deprecated at this time.</p>
<p>For the case where calling <code>findRecord</code> would result in a request
being necessary but either no <code>type</code> or <code>id</code> information being known
we would error.</p>
<p>This is because there is no meaningful way for the store to create a
network request for a record that does not exist yet (a
<code>NewResourceIdentifierObject</code>), or for one for which the only thing
we know is a locally assigned id (<code>Identifier</code>).</p>
<pre><code class="language-ts">interface Identifier {
  lid: string;
}

export interface ExistingResourceIdentifierObject {
  id: string;
  type: string;
  lid?: string;
}

export interface NewResourceIdentifierObject {
  id: string | null;
  type: string;
  lid: string;
}

export type Peekable =
  | Identifier
  | ExistingResourceIdentifierObject
  | NewResourceIdentifierObject;

class Store {
  peekRecord(type: string, id: string | number): Record | null {}
  peekRecord(identifier: Peekable): Record | null {}

  findRecord(type: string, id: string | number, options?: any): PromiseRecord {}
  findRecord(identifier: Peekable, options?: any): PromiseRecord {}

  getReference(modelName: string, id: string | number): RecordReference {}
  getReference(identifier: Peekable): RecordReference {}
}
</code></pre>
<h2 id="how-we-teach-this-101"><a class="header" href="#how-we-teach-this-101">How we teach this</a></h2>
<p>For existing usage of these methods no migration or changes are necessary. For folks wishing to use the new
APIs an example route is below that both peeks a record and makes a findRecord request.</p>
<p><strong>current style</strong></p>
<pre><code class="language-ts">{
  @service('store') store;

  model({ user_id, post_id }) {
    let user = this.store.peekRecord('user', user_id);

    return hash({
        user,
        post: this.store.findRecord('post', post_id)
    });
  }
}
</code></pre>
<p><strong>using RecordIdentifiers instead</strong></p>
<pre><code class="language-ts">{
  @service('store') store;

  model({ user_id, post_id }) {
    let user = this.store.peekRecord({ type: 'user', id: user_id });

    return hash({
        user,
        post: this.store.findRecord({ type: 'post', id: post_id })
    });
  }
}
</code></pre>
<p>If an <code>lid</code> is known the <code>RecordIdentifier</code> passed to these methods can provide it
in addition to or in place of <code>id</code>.</p>
<h2 id="drawbacks-121"><a class="header" href="#drawbacks-121">Drawbacks</a></h2>
<ul>
<li>It requires the user to create an object as an argument when seeking to use identifiers.
However if the user does not do so we still do ourselves almost immediately, here we are
shaping the object sooner.</li>
</ul>
<h2 id="alternatives-123"><a class="header" href="#alternatives-123">Alternatives</a></h2>
<ul>
<li><code>peekRecord(null, null, lid)</code> rejected for clumsy ergonomics</li>
<li><code>findRecord(identifier)</code> attempting to request with just an lid,
rejected until reconsideration at such time as our request fulfillment doesn't rely heavily on per-type adapters</li>
<li><code>peekRecord(identifier)</code> but no <code>findRecord(identifier)</code> rejected because of the utility in these APIs mirroring each other, especially for relationships.</li>
<li><code>store.recordForIdentifier(identifier)</code> instead of these changes, rejected because we already have a <code>peek</code> API.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-07-27
Relevant Team(s): Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/522</p>
<hr />
<h1 id="deprecate-default-adapter-and-serializer-fallbacks"><a class="header" href="#deprecate-default-adapter-and-serializer-fallbacks">Deprecate default Adapter and Serializer fallbacks</a></h1>
<h2 id="summary-134"><a class="header" href="#summary-134">Summary</a></h2>
<p>As part of Project Trim, https://github.com/emberjs/data/issues/6166, this deprecates the fallback and default adapter and serializer across ember-data including:</p>
<ol>
<li>deprecate -default serializer fallback in Store.serializerFor</li>
<li>deprecate <code>adapter.serializer</code> and <code>adapter.defaultSerializer</code> instance property fallbacks (which currently default to -json-api).</li>
<li>deprecate <code>store.defaultAdapter</code> instance property (which defaults to <code>-json-api</code>) and the <code>-json-api</code> adapter fallback behavior in <code>adapterFor</code>.</li>
<li>deprecate <code>record.toJSON</code> instance method since this relies on the <code>-json</code> serializer.</li>
</ol>
<h2 id="motivation-134"><a class="header" href="#motivation-134">Motivation</a></h2>
<p>The adapter and serializer packages provide reference implementations and base classes that are not required for applications that implement their own following the required interfaces for adapters and serializers as defined in their respective base classes.  Deprecating them allows us to simplify the lookup pattern and remove automatic injection and registration of potentially unused classes.</p>
<p>In addition to removing use of initializer injection, this takes a significant step toward simplifying the mental model for how to determine what adapter/serializer is in use. Removing the defaults forces app developers to be more cognizant about the type of application level concerns vs model-specific concerns; they will now need to explicitly define and use specific adapters/serializers. After this deprecation RFC lands, apps will always use an adapter/serializer explicitly put into your application and the rule will be &quot;the adapter matching modelName falling back to application&quot;.</p>
<h2 id="detailed-design-115"><a class="header" href="#detailed-design-115">Detailed design</a></h2>
<p>The injection of <code>-default</code> and <code>-json-api</code> serializers will be removed in the next major version (4.0). Since this changes some core assumptions we will deprecate the reliance on the existence of the defaults. All deprecation warnings will only be shown in Dev mode.</p>
<h5 id="deprecate--default-serializer-fallback-in-storeserializerfor"><a class="header" href="#deprecate--default-serializer-fallback-in-storeserializerfor">deprecate -default serializer fallback in store.serializerFor</a></h5>
<p>A deprecation warning will be shown when <a href="https://github.com/emberjs/data/blob/67affb0eca7048a1a0edc856af46d1305cd1fc1d/packages/store/addon/-private/system/store.ts#L2909">no model, application or adapter serializer</a> has specified and the default must be used. We will recommend implementing an application serializer.</p>
<h5 id="deprecate-adapterserializer-and-adapterdefaultserializer-fallbacks"><a class="header" href="#deprecate-adapterserializer-and-adapterdefaultserializer-fallbacks">deprecate adapter.serializer and adapter.defaultSerializer fallbacks</a></h5>
<p>A deprecation warning will be shown when accessing the <a href="https://github.com/emberjs/data/blob/67affb0eca7048a1a0edc856af46d1305cd1fc1d/packages/store/addon/-private/system/store.ts#L2896">adapter's defaultSerializer</a>. This will be distinct from the warning about using the application level default. We will recommend implementing an application serializer.</p>
<h5 id="deprecate-storedefaultadapter--json-api-and-the--json-api-adapter-fallback-behavior"><a class="header" href="#deprecate-storedefaultadapter--json-api-and-the--json-api-adapter-fallback-behavior">deprecate store.defaultAdapter (-json-api) and the -json-api adapter fallback behavior</a></h5>
<p>A deprecation warning will be shown when the <a href="https://github.com/emberjs/data/blob/b0cf3225662bfb806cd0c02b55b763e37a319b32/packages/store/addon/-private/system/store.ts#L309">defaultAdapter</a> is accessed.  We will recommend implementing an application adapter.</p>
<h5 id="deprecate-recordtojson"><a class="header" href="#deprecate-recordtojson">deprecate record.toJSON</a></h5>
<p>A deprecation warning will be shown when toJSON is called since it uses a serializer to create a JSON representation of <a href="https://guides.emberjs.com/release/models/customizing-serializers/#toc_customizing-serializers">the model</a>. Users may call record.serialize() or implement their own toJSON instead.</p>
<h2 id="how-we-teach-this-102"><a class="header" href="#how-we-teach-this-102">How we teach this</a></h2>
<p>Today we have extensive documentation about creating custom serializers, but we will need to update the guides to specify the desired serializer in <a href="https://guides.emberjs.com/release/models/customizing-serializers/#toc_customizing-serializers">app/serializers/application.js</a></p>
<p>The deprecation guide app will be updated with examples showing how to
migrate away from relying on the defaults.</p>
<h2 id="drawbacks-122"><a class="header" href="#drawbacks-122">Drawbacks</a></h2>
<p>The drawback to making this change is that apps relying on the default serializer need to add some boilerplate to explicitly set the serializer.</p>
<h2 id="alternatives-124"><a class="header" href="#alternatives-124">Alternatives</a></h2>
<p>We could not do this.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-08-05
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/523</p>
<hr />
<h1 id="provide-model-named-argument-to-route-templates"><a class="header" href="#provide-model-named-argument-to-route-templates">Provide <code>@model</code> named argument to route templates</a></h1>
<h2 id="summary-135"><a class="header" href="#summary-135">Summary</a></h2>
<p>Allow route templates to access the route's model with <code>@model</code> in addition to
<code>this.model</code>.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{!-- The model for this route is the current user --}}

&lt;div&gt;
  Hi &lt;img src=&quot;{{this.model.profileImage}}&quot; alt=&quot;{{this.model.name}}'s profile picture&quot;&gt; {{this.model.name}},
  this is a valid Ember template!
&lt;/div&gt;

{{#if this.model.isAdmin}}
  &lt;div&gt;Remember, with great power comes great responsibility!&lt;/div&gt;
{{/if}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">{{!-- The model for this route is the current user --}}

&lt;div&gt;
  Hi &lt;img src=&quot;{{@model.profileImage}}&quot; alt=&quot;{{@model.name}}'s profile picture&quot;&gt; {{@model.name}},
  this is a valid Ember template!
&lt;/div&gt;

{{#if @model.isAdmin}}
  &lt;div&gt;Remember, with great power comes great responsibility!&lt;/div&gt;
{{/if}}
</code></pre>
<h2 id="motivation-135"><a class="header" href="#motivation-135">Motivation</a></h2>
<p>With the Octane release, templates are taking on a more important role in
idomatic Ember apps. As templates become more self-sufficient, many cases where
a JavaScript class was needed in the past (e.g. to customize the &quot;wrapper&quot;
element) can now be expressed with templates alone. This is a direction we will
continue post-Octane.</p>
<p>We would like to update the learning materials (guides) to focus on teaching
the template-centric component model. For example, components can be introduced
as a way to break up large templates into smaller, named pieces, similar to
refactoring a big function into smaller ones. Then, we can layer on making them
reusable through passing arguments. Next, we can introduce the idea of passing
a block and yielding. Finally, we can introduce the component class when we are
ready to discuss adding behavior to the component.</p>
<p>As you can see, we can accomplish quite a lot with template-only components in
Octane, and focusing on teaching templates first-and-foremost would provide
a gentle learning curve for developers and designers who are comfortable with
HTML but perhaps new to Ember (or even JavaScript). With this flow, the concept
of a component class, and consequently, the idea of a &quot;<code>this</code> context&quot; in a
template comes up quite late.</p>
<p>This presents a problem, as we may want or need to teach route templates before
that was introduced. As the model can only be accessed through <code>this.model</code> in
a route template, we would be forced to introduce that concept (and the contept
of a controller) at an earlier time than would be ideal.</p>
<p>Providing <code>@model</code> to route templates would solve this problem quite elegantly.
We will now be able to introduce the concept of arguments (<code>@name</code>) once and it
can be applied consistently between component and route templates.</p>
<p>This also aligns with the general mental model that arguments are things that
are passed into the template from the outside (which is true in the case of the
route model).</p>
<p>This can also be thought of as a small incremental step in the bigger picture
of reforming route templates and removing controllers from Ember. Specifically,
it moves us a bit closer to the mental model that controllers/route templates
are just a &quot;special&quot; kind of component. We expect to continually unify them and
remove the remaining differences, and this is a step towards that direction.</p>
<h2 id="detailed-design-116"><a class="header" href="#detailed-design-116">Detailed design</a></h2>
<p>Internally, route templates are <em>already</em> modelled as components at the Glimmer
VM layer. To implement this, we would &quot;synthesize&quot; a named argument <code>@model</code>
containing the resolved route model, i.e. the same value as <code>this.model</code> on the
controller instance.</p>
<p>Just like the &quot;reflected&quot; named arguments in classic components, mutating
<code>this.model</code> on the controller instance would <em>not</em> change the value of
<code>@model</code>. In practice, this seems unlikely to be relied upon and probably
considered a bad practice (it does not change the URL, does not affect what is
returned by <code>route.modelFor</code>, etc). In any case, this is consistent with the
general behavior for named arguments, in that they are immutable and should
always reflect what was &quot;passed in&quot; from the caller.</p>
<h2 id="how-we-teach-this-103"><a class="header" href="#how-we-teach-this-103">How we teach this</a></h2>
<p>In the guides, we should teach that <code>@names</code> are for things that are &quot;passed
in&quot;, i.e. arguments to the template.</p>
<p>In the tutorial, basic components concepts (template-only components, invoking
a component with args, using the args with the template, etc) should be taught
before the <code>model</code> hook is encountered. At that point, explaining that <code>@model</code>
is passed into the component from the route, based on the resolution of the
async <code>model</code> hook, will be quite natural.</p>
<p>For reference, here is a relevant section from the <a href="https://github.com/ember-learn/guides-source/pull/1002">work-in-progress Octane
tutorial</a>. For context,
up until this point, we have taught all the basic component concepts above, plus
adding a (Glimmer) component class, adding instance variables and getters to the
component, accessing those with <code>{{this.*}}</code> in the template, etc.</p>
<blockquote>
<p>So far, we've been hard-coding everything into our <code>&lt;Rental&gt;</code> component. But
that's probably not very sustainable, since eventually, we want our data to
come from a server instead. Let's go ahead and move some of those hard-coded
values out of the component in preparation for that.</p>
<p>We want to start working towards a place where we can eventually fetch data
from the server, and then render the requested data as dynamic content from
the templates. In order to do that, we will need a place where we can write
the code for fetching data and loading them into the routes.</p>
<p>In Ember, <a href="todo://"><em>route files</em></a> are the place to do that. We haven't
needed them yet, because all our routes are essentially just rendering static
pages up until this point, but we are about to change that.</p>
<p>Let's start by creating a route file for the index route. We will create a
new file at <code>app/routes/index.js</code> with the following content:</p>
<pre><code class="language-js {data-filename=&quot;app/routes/index.js&quot;}">import Route from '@ember/routing/route';

export default class IndexRoute extends Route {
  async model() {
    return {
      title: 'Grand Old Mansion',
      owner: 'Veruca Salt',
      city: 'San Francisco',
      location: {
        lat: 37.7749,
        lng: -122.4194,
      },
      category: 'Estate',
      type: 'Standalone',
      bedrooms: 15,
      image: 'https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg',
      description: 'This grand old mansion sits on over 100 acres of rolling hills and dense redwood forests.',
    };
  }
}
</code></pre>
<p>There's a lot happening here that we haven't seen before, so let's walk
through this. First, we're importing the <a href="todo://"><em><code>Route</code> class</em></a> into the
file. This class is used as a starting point for adding functionality to a
route, such as loading data.</p>
<pre><code class="language-js">import Route from '@ember/routing/route';
</code></pre>
<p>Then, since we are extending the <code>Route</code> class into our <em>own</em> <code>IndexRoute</code>,
which we are also exporting so that the rest of the application can use it.</p>
<pre><code class="language-js">export default class IndexRoute extends Route {
  // ...snip...
}
</code></pre>
<p>So far, so good. But what's happening inside of this route class? We
implemented a <a href="todo://"><em>async method</em></a> called <code>model()</code>. This method is also
known as the <a href="todo://"><em>model hook</em></a>.</p>
<p>The model hook is responsible for fetching and preparing any data that you
need for your route. Ember will automatically call this hook for when
entering a route, so that you can have an opportunity to do what you need to
get the data you need. The object returned from this hook is known as the
<em>model</em> for the route (surprise!).</p>
<p>Usually, this is where we'd fetch data from a server. Since fetching data is
usually an asynchronous operation, the model hook is marked as <code>async</code>. This
gives us the option of using the <code>await</code> keyword to wait for the data
fetching operations to finish.</p>
<p>We'll get to that bit later on. At the moment, we are just returning the same
hard-coding model data, extracted from the <code>&lt;Rental&gt;</code> component, but in a
JavaScript object (also known as <a href="todo://"><em>POJO</em></a>) format.</p>
<p>So, now that we've prepared some model data for our route, let's use it in
our template. In route templates, we can access the model for the route as
<code>this.model</code>. In our case, that would contain the POJO returned from our
model hook.</p>
<p>To test that this is working, let's modify our template and try to render
the <code>title</code> property from our model:</p>
<pre><code class="language-handlebars {data-filename=&quot;app/templates/index.hbs&quot;}">&lt;h1&gt;{{this.model.title}}&lt;/h1&gt;

&lt;div class=&quot;rentals&quot;&gt;
  &lt;ul class=&quot;results&quot;&gt;
    &lt;li&gt;&lt;Rental /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;Rental /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;Rental /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>If we look at our page in the browser, we should see our model data reflected
as a new header.</p>
<!-- TODO: screenshot -->
<p>Awesome! Looking good.</p>
<!-- TODO: Update the below if https://github.com/emberjs/rfcs/pull/523 is merged. -->
<blockquote>
<p>Zoey says...</p>
<p>The <code>this</code> in <code>this.model</code> does <em>not</em> refer to the route object. You
<em>cannot</em> add instance variables or getters on the route class and have
access to them here. It's a good idea to keep your route template simple
and minimal — if you need to add state or getters, just add a
component and call it from your route template!</p>
</blockquote>
<p>Ok, now that we know that we have a model to use at our disposal, let's
remove some of the hard-coding that we did earlier! Instead of explicitly
hard-coding the rental information into our <code>&lt;Rental&gt;</code> component, we can pass
the model object to our component instead.</p>
<p>Let's try it out. First, let's pass in our model to our <code>&lt;Rental&gt;</code> component
as the <code>@rental</code> argument. We will also remove the extraneous <code>&lt;h1&gt;</code> tag we
added earlier, no that we know things are working:</p>
<pre><code class="language-handlebars {data-filename=&quot;app/templates/index.hbs&quot;}">&lt;div class=&quot;rentals&quot;&gt;
  &lt;ul class=&quot;results&quot;&gt;
    &lt;li&gt;&lt;Rental @rental={{this.model}} /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;Rental @rental={{this.model}} /&gt;&lt;/li&gt;
    &lt;li&gt;&lt;Rental @rental={{this.model}} /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>...snip...</p>
</blockquote>
<p>As you can see, there are some awkwardness explaining <code>this.model</code> at this
point. Knowing that there is a <code>this</code> context on the template, it is only
natural to inquire what <em>is</em> the <code>this</code> we are referring to here.</p>
<p>Up until this point in the tutorial, the only place where we have access to a
<code>this</code> object in the template is a component with a class. Since the route
class is the only related class we made at this point, and it happens to have
a <code>model</code> property (a method) on it, one natural conclusion is to think that
<code>this</code> refers to the route instance, and <code>this.model</code> refers to the model hook.</p>
<blockquote>
<p>Note: you don't always have a <code>this</code> context in templates. Template-only
components <em>do not</em> have a <code>this</code> context. Since template-only components
make up roughly half of the components in the tutorials so far, <em>having</em> a
<code>this</code> from the template is a notable thing that stands out.</p>
</blockquote>
<p>But that completely the wrong mental model! To avoid that, we put in a &quot;Zoey
says...&quot; sidebar that explicitly denies that incorrect mental model, stating
what it <em>is not</em>, without really explaining what it <em>is</em>.</p>
<p>To fully explain what is going on, we would have to pause and take a detour to
explain everyone's least favourite part of the Ember programming model –
controllers. This would be extremely disruptive to the teaching flow, to say
the least, but also serves no purpose at all.</p>
<p>We opted to avoid going down that rabit hole and just treated it as a
boilerplate syntax you have to type.</p>
<p>If we are able to explain this using <code>@model</code> instead, it would make things a
lot smoother here.</p>
<p>We wouldn't have to go into the details of <em>how</em> things get invoked internally.
At the end of the day, it is still just a piece of syntax you type to get the
job done, but at least it is consistent with the general mental model that
<code>@names</code> means that thing was passed in, and it does not trigger the questions
about what <code>this</code> is.</p>
<p>It is also <em>not</em> inconsistent with the fact that there is, in fact, a <code>this</code>
context on the template. The usage and preference of using <code>@names</code> does not
preclude the existance of a class (which provides the <code>this</code> context), as in
the case of <code>@ember/components</code>.</p>
<p>As for the concrete changes that need to be made in the documentation:</p>
<ul>
<li>
<p>We will explain that <code>@model</code> is passed into the component from the route.
For example, in the <code>Route</code> class' <code>model</code> hook documentation, we can say
something like:</p>
<blockquote>
<p>The model hook is responsible for fetching and preparing any data that you
need for your route. Ember will automatically call this hook for when
entering a route, so that you can have an opportunity to do what you need to
get the data you need. The object returned from this hook is known as the
<em>model</em> for the route.</p>
<p>Note that since this is an <code>async</code> hook, if a promise is returned, it will
be automatically <code>await</code>ed by Ember, and the <em>resolved value</em> of the
promise, as opposed to the promise object itself, will become the model of
the route.</p>
<p>The model object can be accessed from the route's template as using the
<code>@model</code> argument. By default, the controller can also accessed the route's
model from <code>this.model</code>. The latter behavior is customizable, see the
<em>setupController</em> method for details.</p>
<p>The model of a route should be treated as read-only. For example, the
controller <em>should not</em> mutate its <code>this.model</code> property, as doing so will
cause it to get out of sync with the rest of the system. Specifically,
doing so will <em>not</em> update the current URL, the <code>@model</code> argument in the
template, the router service, etc. Instead, a <em>route transition</em> should be
performed.</p>
</blockquote>
</li>
<li>
<p>Guides and API docs should be updated to prefer <code>@model</code> in route templates.</p>
</li>
<li>
<p>API docs will still document the <code>model</code> property.</p>
</li>
<li>
<p>We will remove any examples that uses <code>{{this.model}}</code> in templates, or replace them with <code>{{@model}}</code>. i.e. we won’t be documenting using <code>this.model</code> in templates, even thought it would “work”.</p>
</li>
</ul>
<h2 id="drawbacks-123"><a class="header" href="#drawbacks-123">Drawbacks</a></h2>
<p>In some applications, developers have developed a pattern to override the
<code>setupController</code> method to assign the model to a different property on the
controller other than the default <code>model</code> naming convention.</p>
<p>Since this RFC does not provide any way to customize the name of the argument,
developers using this pattern will have to choose between one of the following
two options:</p>
<ol>
<li>
<p>Refactor/revert to the default behavior of <code>setupController</code> and use the
default <code>model</code> property. This makes it cognitively easy to understand the
<code>@model</code> usages in the route templates.</p>
</li>
<li>
<p>Stick with the alternative names and avoid using <code>@model</code> in the route
templates, until there is a way to customize both names at the same time.</p>
</li>
</ol>
<p>Technically, it is also possible to use one name in the controller and
<code>@model</code> in the template. This doesn't cause any issues for the system, but
maybe confusing for the developers.</p>
<p>In the future, we expect to generalize the <code>model</code> hook and <code>@model</code> into
allowing passing arbitrary arguments into the template, perhaps replacing
the <code>model</code> hook with something like an <code>args</code> hook that returns a POJO of
arguments to pass.</p>
<h2 id="alternatives-125"><a class="header" href="#alternatives-125">Alternatives</a></h2>
<p>We can do nothing.</p>
<h2 id="unresolved-questions-82"><a class="header" href="#unresolved-questions-82">Unresolved questions</a></h2>
<p>None?</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-11-08
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/554</p>
<hr />
<h1 id="deprecate-getwithdefault"><a class="header" href="#deprecate-getwithdefault">Deprecate getWithDefault</a></h1>
<h2 id="summary-136"><a class="header" href="#summary-136">Summary</a></h2>
<p>Deprecate support for <code>getWithDefault</code> in Ember's Object module (@ember/object) – both the <a href="https://api.emberjs.com/ember/release/functions/@ember%2Fobject/getWithDefault">function</a> and the <a href="https://api.emberjs.com/ember/release/classes/EmberObject/methods/getWithDefault?anchor=getWithDefault">class method</a> – because its expected behaviour is confusing to Ember developers.</p>
<h2 id="motivation-136"><a class="header" href="#motivation-136">Motivation</a></h2>
<p>The problem with <code>getWithDefault</code> is that its behaviour is confusing to Ember developers. The API will only return the default value when the value of the property retrieved is <code>undefined</code>. This behaviour is often overlooked when using the function where a developer might expect that <code>null</code> or other <em>falsy</em> values will also return the default value.</p>
<p>Given the JavaScript language will soon (currently in Stage 3) give us the appropriate tool for this use case using the <a href="https://github.com/tc39/proposal-nullish-coalescing">Nullish Coalescing Operator <code>??</code></a>, we can deprecate usage of <code>getWithDefault</code> and use that instead.</p>
<h2 id="transition-path-19"><a class="header" href="#transition-path-19">Transition Path</a></h2>
<p>Ember will start logging deprecation messages for <code>getWithDefault</code> usage. </p>
<p>We can codemod our current usage of <code>getWithDefault</code> with the equivalent behaviour using plain JavaScript. The migration guide will cover this example:</p>
<p>Before:</p>
<pre><code class="language-js">import { getWithDefault } from '@ember/object';

let result = getWithDefault(obj, 'some.key', defaultValue);
</code></pre>
<p>After:</p>
<pre><code class="language-js">import { get } from '@ember/object';

let result = get(obj, 'some.key');
if (result === undefined) {
  result = defaultValue;
}
</code></pre>
<h4 id="using-nullish-coalescing-operator"><a class="header" href="#using-nullish-coalescing-operator">Using Nullish Coalescing Operator</a></h4>
<p>We cannot codemod directly into the nullish coalescing operator since the expected behaviour of <code>getWithDefault</code> is to only return the default value if it is strictly <code>undefined</code>. The nullish coalescing operator accepts either <code>null</code> or <code>undefined</code> to show the default value.</p>
<p>The function <code>getWithDefault</code> <strong>will not return</strong> the default value if the provided value is <code>null</code>. The function will <strong>only return</strong> the default value for <code>undefined</code>:</p>
<pre><code class="language-js">let defaultValue = 1;
let obj = {
  nullValue: null,
  falseValue: false,
};

// Returns defaultValue 1, undefinedKey = 1
let undefinedValue = getWithDefault(obj, 'undefinedKey', defaultValue);

// Returns null, nullValue = null
let nullValue = getWithDefault(obj, 'nullValue', defaultValue);

// Returns obj's falseValue, falseValue = false
let falseValue = getWithDefault(obj, 'falseValue', defaultValue);
</code></pre>
<p>The nullish coalescing operator (<code>??</code>) <strong>will return</strong> the default value when the provided value is <code>undefined</code> or <code>null</code>:</p>
<pre><code class="language-js">let defaultValue = 1;
let obj = {
  nullValue: null,
  falseValue: false,
};

// Returns defaultValue 1, undefinedKey = 1
let undefinedValue = get(obj, 'undefinedKey') ?? defaultValue;

// Returns defaultValue 1, nullValue = 1
let nullValue = get(obj, 'nullValue') ?? defaultValue;

// Returns obj's falseValue, falseValue = false
let falseValue = get(obj, 'falseValue') ?? defaultValue;
</code></pre>
<p>This can be an option if we are aware that either <code>null</code> or <code>undefined</code> should return the default value.</p>
<p>Tooling Support:</p>
<ul>
<li>
<p><a href="https://babeljs.io/">Babel</a> already supports the <a href="https://babeljs.io/docs/en/next/babel-plugin-proposal-nullish-coalescing-operator.html">nullish coalescing operator</a> so we can use that for future use cases where we need to check if a property is <code>null</code> or <code>undefined</code> before applying a default value.</p>
</li>
<li>
<p><a href="https://github.com/microsoft/TypeScript">TypeScript</a>, similarly, as of <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing">version 3.7</a> also supports the operator so we will not be breaking that flow either.</p>
</li>
</ul>
<h4 id="using-object-destructuring-with-defaults"><a class="header" href="#using-object-destructuring-with-defaults">Using Object Destructuring With Defaults</a></h4>
<p>If we would like to return the default value if the existing value is <code>undefined</code> we can also use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">object destructuring</a> with defaults.</p>
<p>Object destructuring with defaults <strong>will return</strong> the default value when the provided value is <code>undefined</code>:</p>
<pre><code class="language-js">let defaultValue = 1;
let obj = {
  nullValue: null,
  falseValue: false,
};

// Returns defaultValue 1, undefinedKey = 1
let { undefinedKey = defaultValue } = obj;

// Returns defaultValue 1, nullValue = null
let { nullValue = defaultValue } = obj;

// Returns obj's falseValue, falseValue = false
let { falseValue = defaultValue } = obj;
</code></pre>
<h2 id="how-we-teach-this-104"><a class="header" href="#how-we-teach-this-104">How We Teach This</a></h2>
<p>Add the transition path to the <a href="https://deprecations.emberjs.com/">Ember Deprecation Guide</a>.</p>
<p>The references to <code>getWithDefault</code> will need to be removed from the <a href="https://api.emberjs.com/ember/release/functions/@ember%2Fobject/getWithDefault">API docs</a>. </p>
<p>There are no changes needed for the <a href="https://guides.emberjs.com/release/">Ember Guides</a> since we do not use it anywhere.</p>
<h2 id="drawbacks-124"><a class="header" href="#drawbacks-124">Drawbacks</a></h2>
<p>The downside to deprecating <code>getWithDefault</code> would be an increase to the line length of component files that use it. This change will also cause some deprecation noise but could be mitigated with a codemod.</p>
<h2 id="alternatives-126"><a class="header" href="#alternatives-126">Alternatives</a></h2>
<h3 id="adding-null-as-a-condition"><a class="header" href="#adding-null-as-a-condition">Adding <code>null</code> as a condition</a></h3>
<p>We could add <code>null</code> as a condition alongside <code>undefined</code> which would return the default value provided. This is similar to what is proposed in <a href="https://github.com/tc39/proposal-nullish-coalescing">Nullish Coalescing for JavaScript</a>. This would however still be a breaking change since people who are depending on <code>getWithDefault</code> to work the way it does for <code>null</code> today will be broken if we change it.</p>
<h3 id="do-nothing-1"><a class="header" href="#do-nothing-1">Do nothing</a></h3>
<p>We could keep support in place, and provide more guidance around using it. There are already <a href="https://dockyard.com/blog/2016/03/18/get-with-default">some</a> articles cautioning usage of <code>getWithDefault</code> when dealing with <code>null</code> or <em>falsy</em> values.</p>
<h2 id="unresolved-questions-83"><a class="header" href="#unresolved-questions-83">Unresolved questions</a></h2>
<p>None at the moment.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2019-11-20
Relevant Team(s): Ember.js, Ember CLI, Ember Data
RFC PR: https://github.com/emberjs/rfcs/pull/558</p>
<hr />
<h1 id="edition-detection"><a class="header" href="#edition-detection">Edition detection</a></h1>
<h2 id="summary-137"><a class="header" href="#summary-137">Summary</a></h2>
<p>Introduces a mechanism that an application can use to specify which Edition of
Ember it intends to target. This RFC will define:</p>
<ul>
<li>How to specify the edition that the application is using</li>
<li>How other packages (addons, codemods, etc) can detect the applications intended edition</li>
<li>What the edition should be used for</li>
</ul>
<h2 id="motivation-137"><a class="header" href="#motivation-137">Motivation</a></h2>
<p>As Ember approaches its first edition (see
<a href="https://github.com/emberjs/rfcs/pull/364">emberjs/rfcs#364</a>) various addons
need to modify their behavior based on the edition that is being used. An
initial implementation (done without RFC) used the <code>setEdition</code> method from
<code>@ember/edition-utils</code> inside the application or addon's <code>.ember-cli.js</code>
file to specify which edition to use. That implementation worked well
enough throughout the intial preview period, but a number of major issues were
(rightfully!) surfaced by the community:</p>
<ol>
<li>it seems unnecessary/redundant</li>
<li>it's not clear what this flag actually does (likely due to having no RFC!)</li>
<li>it's not statically analyzable (and therefore cannot be used by things like codemods)</li>
</ol>
<p>This RFC will review these issues in light of the updated implementation,
showing how each of the concerns have been met.</p>
<h2 id="detailed-design-117"><a class="header" href="#detailed-design-117">Detailed design</a></h2>
<h3 id="specifying-the-edition"><a class="header" href="#specifying-the-edition">Specifying the edition</a></h3>
<p>A new entry will be added to the project's <code>package.json</code>:</p>
<pre><code class="language-js">{
  &quot;name&quot;: &quot;project-name&quot;,
  // ...snip
  &quot;ember&quot;: {
    &quot;edition&quot;: &quot;octane&quot;
  }
}
</code></pre>
<p>The value will be expected to be one of the valid edition names (currently
<code>classic</code> and <code>octane</code>). Using the <code>package.json</code> for this allows us to ensure
that the value is statically analyzable and easy to discover.</p>
<p>For applications specifying <code>ember: { edition: 'octane' }</code> in <code>package.json</code> is
generally all that is needed. In an addon this new property would be specifying
the edition that the addons own dummy app uses. However, many addons may want
to test against <em>multiple</em> editions that they support. In order to support
this, ember-try will be updated to allow specifying (and merging) the <code>ember</code>
property in the <code>package.json</code> from their <code>config/ember-try.js</code> scenarios.</p>
<h3 id="valid-use-of-the-edition-value"><a class="header" href="#valid-use-of-the-edition-value">Valid use of the edition value</a></h3>
<p>The edition flag should only be used by addons to determine what blueprint
output to generate and to provide helpful warnings (or errors) at build time.</p>
<p>Note that the above definition does <strong>not</strong> allow for an addon to detect the
edition configuration and change its fundamental implementation. This is quite
intentional!</p>
<p>Instead, addons should rely on feature detection techniques like the following
to alter implementations:</p>
<ul>
<li>Check to see if given methods/properties exist (this is essentially like how
browser polyfills work)</li>
<li>Use a tool like
<a href="https://github.com/pzuraq/ember-compatibility-helpers">ember-compatibility-helpers</a>'s
<code>gte</code> method (e.g. <code>if (gte('ember-source', '3.14.0')) { }</code>)</li>
<li>Use
<a href="https://github.com/emberjs/ember-optional-features">@ember/optional-features</a>'s
<a href="https://github.com/emberjs/ember-optional-features#at-build-time-from-an-addon"><code>isFeatureEnabled</code>
method</a></li>
</ul>
<h3 id="detecting-the-edition"><a class="header" href="#detecting-the-edition">Detecting the edition</a></h3>
<p>The existing <code>@ember/edition-utils</code> package will still be used by addons to
detect which edition is in use, but it will be updated to check the new
location (instead of relying on folks leveraging <code>setEdition</code>).</p>
<p>The API documentation for <code>@ember/edition-utils</code> would be:</p>
<pre><code class="language-ts">module '@ember/edition-utils' {
  /**
    Determine if the application that is running is running under a given Ember
    Edition.  When the edition in use is _newer_ than the requested edition it
    will return `true`, and if the edition in use by the application is _older_
    than the requested edition it will return `false`.

    @param {string} requestedEditionName the Edition name that the application/addon is requesting
    @param {string} [projectRoot=process.cwd()] the base directory of the project
  */
  has(requestedEditionName: string, projectRoot?: string): boolean;

  /**
    Sets the Edition that the application should be considered a part of.
    This method is deprecated, and will be phased out in the next major release.

    @deprecated
  */
  setEdition(editionName: string): void;
}
</code></pre>
<p>For a period of time the <code>@ember/edition-utils</code> package will continue to
support existing users of <code>setEdition</code> when an edition is not detected via the
new mechanism. This allows users that have been testing out Ember Octane
(either via the <code>@ember/octane-app-blueprint</code> or manually using <code>setEdition</code> in
their <code>.ember-cli.js</code>) a period of time in order to migrate.</p>
<h2 id="how-we-teach-this-105"><a class="header" href="#how-we-teach-this-105">How we teach this</a></h2>
<p>The official guides at <code>https://guides.emberjs.com/release/configuring-ember/</code>
will be updated to include documentation of the new <code>package.json</code>
configuration and clearly explain what the edition flag is used for (warnings
and blueprints).</p>
<p>This will not be a difficult concept to teach to folks (most users won't
care, and will get upgraded as part of a future <code>ember-cli</code> blueprint update).</p>
<h2 id="drawbacks-125"><a class="header" href="#drawbacks-125">Drawbacks</a></h2>
<blockquote>
<p>Changing existing app and addon usage of the prior flag will cause churn.</p>
</blockquote>
<p>This is significantly mitigated by ensuring that <code>@ember/edition-utils</code>
continues to support users of <code>setEdition</code> API as a fallback (with a
deprecation), and that the existing <code>has</code> API continues to work (defaulting the
project root to the current working directory).</p>
<h2 id="alternatives-127"><a class="header" href="#alternatives-127">Alternatives</a></h2>
<h3 id="use-emberedition-in-packagejson"><a class="header" href="#use-emberedition-in-packagejson">Use <code>emberEdition</code> in <code>package.json</code></a></h3>
<p>Some folks may prefer to use a single new property in <code>package.json</code> (vs the
<code>&quot;ember&quot;: { &quot;edition&quot;: &quot;octane&quot; }</code> setup proposed above). I personally think it
makes more sense to start with an <code>&quot;ember&quot;:</code> key, as there are additional
possible usages (e.g. moving <code>&quot;ember-addon&quot;</code> configuration to be within
<code>&quot;ember&quot;</code>) and migrating from <code>emberEdition</code> to the nested syntax would be
needless churn.</p>
<h3 id="use-ember-cli-instead-of-packagejson"><a class="header" href="#use-ember-cli-instead-of-packagejson">Use <code>.ember-cli</code> instead of <code>package.json</code></a></h3>
<p>Instead of adding the <code>emberEdition</code> value to the <code>package.json</code> we could add
it to the existing <code>.ember-cli</code> file. However, doing this would <strong>not</strong> satisfy
the static analysis constraint mentioned in the motivation section (because
<code>.ember-cli.js</code> is transparently supported by <code>ember-cli</code>'s build system).
In addition, any values that are included in <code>.ember-cli</code> are automatically
passed in to every command invocation which would be both unintended (we don't
want commands to access the edition in this way) and possibly breaking (if the
command already accepted an option with whatever value we chose).</p>
<h2 id="unresolved-questions-84"><a class="header" href="#unresolved-questions-84">Unresolved questions</a></h2>
<p>TBD?</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2019-12-08</li>
<li>Relevant Team(s): (fill this in with the <a href="README.html#relevant-teams">team(s)</a> to which this RFC applies)</li>
<li>RFC PR: https://github.com/emberjs/rfcs/pull/560</li>
<li>Tracking: (leave this empty)</li>
</ul>
<h1 id="adding-equality-operators-to-templates"><a class="header" href="#adding-equality-operators-to-templates">Adding Equality Operators to Templates</a></h1>
<h2 id="summary-138"><a class="header" href="#summary-138">Summary</a></h2>
<p>Add new built-in template <code>{{eq}}</code> and <code>{{neq}}</code> helpers to perform basic equality operations in templates, similar to those included in <code>ember-truth-helpers</code>.</p>
<p>This RFC is a subset of the changes proposed in #388.</p>
<h2 id="motivation-138"><a class="header" href="#motivation-138">Motivation</a></h2>
<p>It is a very common need in any sufficiently complex Ember app to perform some equality operations and often the most convenient place to do it is right in the templates.
Because of that, <a href="https://github.com/jmurphyau/ember-truth-helpers">ember-truth-helpers</a> is one of the most installed addons out there, either directly by apps or indirectly by
other addons that those apps consume.</p>
<p>The fact that <code>ember-truth-helpers</code> is so popular is a good signal that this it is filling a perceived gap in Ember's functionality.</p>
<p>A second reason is that it might help make Ember more approachable to newcomers that have some experience in other frameworks.
Most if not all web frameworks have some way of comparing values in the templates and it's surprising that Ember requires an third party package to perform
even the most basic operations.</p>
<h2 id="detailed-design-118"><a class="header" href="#detailed-design-118">Detailed design</a></h2>
<p>Add <code>{{eq}}</code> and <code>{{neq}}</code> helpers.</p>
<h4 id="eq"><a class="header" href="#eq"><code>{{eq}}</code></a></h4>
<p>Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> === <arg2>
This is identical to the <code>eq</code> helper in <code>ember-truth-helpers</code></p>
<h4 id="neq"><a class="header" href="#neq"><code>{{neq}}</code></a></h4>
<p>Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> !== <arg2>
This is identical to the <code>not-eq</code> helper in <code>ember-truth-helpers</code>, except for the name.</p>
<p>This RFC intentionally leaves the implementation details unspecified, those could be implemented in Glimmer VM or
in a higher level in Ember itself.</p>
<h2 id="how-we-teach-this-106"><a class="header" href="#how-we-teach-this-106">How we teach this</a></h2>
<p>While the introduction of these helpers doesn't introduce new concepts, as helpers like these could be
written and in fact were written for a long time, it might affect slightly how we frame some concepts in the guides.</p>
<p>Previously users were encouraged to put computed properties in the javascript file of the components, even for
the most simple tasks like negating a comparing two values using <code>computed.eq</code>.</p>
<p>With the addition of these helpers users don't have to resort to computed properties for simple operations, which sometimes
forced users to create javascript files for what could have been template-only components.</p>
<p>In addition to documenting the new helpers in the API docs, the Guides should be updated to favour the usage of helpers
over computed properties where it makes more sense, adding illustrative examples and stressing out where
the definition of truthiness of handlebars differs from the one of Javascript.</p>
<h3 id="note-on-object-equality"><a class="header" href="#note-on-object-equality">Note on Object Equality</a></h3>
<p>We should also add an additional section to the guides or API docs which discusses using object equality in templates.
In general, object equality in JavaScript can be tricky. There are times when it makes perfect sense, for instance finding
out if an item is the currently selected item in a list:</p>
<pre><code class="language-js">class MySelect extends Component {
  items = [{ value: 1 }, { value: 2 }, { value: 3 }];

  @tracked selectedItem = this.items[0];

  isSelected(item) {
    item === this.selectedItem;
  }
}
</code></pre>
<p>The <code>{{eq}}</code> helper can be used in a similar way in templates:</p>
<pre><code class="language-hbs">&lt;select&gt;
  {{#each this.items as |item|}}
    &lt;option selected={{eq item this.selectedItem}}&gt;
      {{item.value}}
    &lt;/option&gt;
  {{/each}}
&lt;/select&gt;
</code></pre>
<p>There are many valid use cases for object equality. However, there are also times when object equality is not guaranteed,
especially in cases where it would have been in Classic Ember. Consider this component:</p>
<pre><code class="language-js">class MyComponent extends Component {
  @computed('foo')
  get someObj() {
    return { foo: this.foo }
  }

  checkEqual() {
    return this.someObj === this.someObj;
  }
}
</code></pre>
<p><code>checkEqual</code> will return <code>true</code>, because <code>@computed</code> <em>caches</em> the object itself, and returns the same object every time unless <code>foo</code>
changes. With Ember Octane, though, by default getters are not cached:</p>
<pre><code class="language-js">class MyComponent extends Component {
  get someObj() {
    return { foo: this.foo }
  }

  checkEqual() {
    return this.someObj === this.someObj;
  }
}
</code></pre>
<p>Now, the <code>someObj</code> getter will rerun every time the property is accessed, returning a <em>new</em> object every time. <code>checkEqual</code> will
now always return <code>false</code>, since the objects are not equal to each other.</p>
<p>Now, we can do the same thing in a template with <code>eq</code>:</p>
<pre><code class="language-js">{{eq this.someObj this.someObj}}
</code></pre>
<p>And the result depends here on Ember template's caching strategy. Ember only accesses a given property <em>once</em>, and then it caches
the result, so this will return <code>true</code>. However, the semantics of template caches are not guaranteed, and in time may change, so relying
on object equality in this way is not generally a good pattern.</p>
<p>Even if the semantics do not change, there are still observable ways that users can trigger the getter twice and generate another object.
For instance:</p>
<pre><code class="language-js">class MyComponent extends Component {
  get someObj() {
    return { foo: this.foo }
  }

  get someObjAlias() {
    return this.someObj;
  }
}
</code></pre>
<pre><code class="language-hbs">{{eq this.someObj this.someObjAlias}}
</code></pre>
<p>Overall, the point here is that if users expect an object generated by a getter or helper to remain <em>stable</em> between accesses, such that
object equality or state can be valid, then the user should explicitly cache that value themselves. This can be accomplished in a number
of ways, one option being the proposed <code>@cached</code> decorator:</p>
<pre><code class="language-js">class MyComponent extends Component {
  @cached
  get someObj() {
    return { foo: this.foo }
  }
}
</code></pre>
<h2 id="drawbacks-126"><a class="header" href="#drawbacks-126">Drawbacks</a></h2>
<p>Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.</p>
<h2 id="alternatives-128"><a class="header" href="#alternatives-128">Alternatives</a></h2>
<p>One alternative path is don't do anything and let users continue to define their own helpers (or install <code>ember-truth-helpers</code>).</p>
<h2 id="unresolved-questions-85"><a class="header" href="#unresolved-questions-85">Unresolved questions</a></h2>
<ul>
<li>If an app already use <code>ember-truth-helpers</code>, the <code>{{eq}}</code> helper will conflict with the one proposed here. How do we
update <code>ember-truth-helpers</code> to make sure the helper of the same name doesn't collide with the built-in one?</li>
<li>The inequality helper proposed in this RFC is <code>{{neq}}</code> while the one in ember-truth-helpers is <code>{{not-eq}}</code>. It is
worth considering the benefits that keeping the same name might have in helping apps and addon migrate to the built-in helper.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2019-12-08
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/561</h2>
<h1 id="adding-comparison-operators-to-templates"><a class="header" href="#adding-comparison-operators-to-templates">Adding Comparison Operators to Templates</a></h1>
<h2 id="summary-139"><a class="header" href="#summary-139">Summary</a></h2>
<p>Add new built-in template <code>{{lt}}</code>, <code>{{lte}}</code>, <code>{{gt}}</code>, and <code>{{gte}}</code> keywords to perform basic numeric comparison operations in templates, similar to those included in <code>ember-truth-helpers</code>.</p>
<p>This RFC is a subset of the changes proposed in #388.</p>
<h2 id="motivation-139"><a class="header" href="#motivation-139">Motivation</a></h2>
<p>It is a very common need in any sufficiently complex Ember app to perform some numeric comparison operations and often the most convenient place to do it is right in the templates.
Because of that, <a href="https://github.com/jmurphyau/ember-truth-helpers">ember-truth-helpers</a> is one of the most installed addons out there, either directly by apps or indirectly by
other addons that those apps consume.</p>
<p>The fact that <code>ember-truth-helpers</code> is so popular is a good signal that this it is filling a perceived gap in Ember's functionality.</p>
<p>A second reason is that it might help make Ember more approachable to newcomers that have some experience in other frameworks.
Most if not all web frameworks have some way of comparing numbers in the templates and it's surprising that Ember requires an third party package to perform
even the most basic operations.</p>
<h2 id="detailed-design-119"><a class="header" href="#detailed-design-119">Detailed design</a></h2>
<p>The new comparison operators will be made keywords, so they are easily accessible in current and future templates without needing to be imported.</p>
<h4 id="lt"><a class="header" href="#lt"><code>{{lt}}</code></a></h4>
<p>Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> &lt; <arg2>
This is identical to the <code>{{lt}}</code> helper in <code>ember-truth-helpers</code></p>
<h4 id="lte"><a class="header" href="#lte"><code>{{lte}}</code></a></h4>
<p>Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <arg1> &lt;= <arg2>
This is identical to the <code>{{lte}}</code> helper in <code>ember-truth-helpers</code></p>
<h4 id="gt"><a class="header" href="#gt"><code>{{gt}}</code></a></h4>
<p>Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <code>&lt;arg1&gt; &gt; &lt;arg2&gt;</code>
This is identical to the <code>{{gt}}</code> helper in <code>ember-truth-helpers</code>.</p>
<h4 id="gte"><a class="header" href="#gte"><code>{{gte}}</code></a></h4>
<p>Binary operation. Throws an error if not called with exactly two arguments.
Equivalent of <code>&lt;arg1&gt; &gt;= &lt;arg2&gt;</code>.
This is identical to the <code>{{gte}}</code> helper in <code>ember-truth-helpers</code>.</p>
<h2 id="how-we-teach-this-107"><a class="header" href="#how-we-teach-this-107">How we teach this</a></h2>
<p>While the introduction of these helpers doesn't introduce new concepts, as helpers like these could be written and in fact were written for a long time, it might affect slightly how we frame some concepts in the guides.</p>
<p>Previously users were encouraged to put computed properties in the JavaScript file of the components, even for the most simple tasks like comparing if a value is less than another using <code>computed.lt</code>.</p>
<p>With the addition of these helpers users don't have to resort to computed properties for simple operations, which sometimes forced users to create JavaScript files for what could have been template-only components.</p>
<p>In addition to documenting the new helpers in the API docs, the Guides should be updated to favour the usage of helpers over computed properties where it makes more sense, adding illustrative examples and stressing out where the definition of truthiness of handlebars differs from the one of Javascript.</p>
<h3 id="api-docs-1"><a class="header" href="#api-docs-1">API Docs</a></h3>
<h4 id="lt-1"><a class="header" href="#lt-1"><code>{{lt}}</code></a></h4>
<p>The <code>{{lt}}</code> helper can be used to compare two values in a template. It returns <code>true</code> if the first value is
less than the second value, and <code>false</code> otherwise. It is equivalent to the <code>&lt;</code> operator in JavaScript.</p>
<pre><code class="language-hbs">{{#if (lt @number 5)}}
  The number is less than 5!
{{/if}}
</code></pre>
<h4 id="lte-1"><a class="header" href="#lte-1"><code>{{lte}}</code></a></h4>
<p>The <code>{{lte}}</code> helper can be used to compare two values in a template. It returns <code>true</code> if the first value is
less than or equal to the second value, and <code>false</code> otherwise. It is equivalent to the <code>&lt;=</code> operator in JavaScript.</p>
<pre><code class="language-hbs">{{#if (lte @number 5)}}
  The number is less than or equal to 5!
{{/if}}
</code></pre>
<h4 id="gt-1"><a class="header" href="#gt-1"><code>{{gt}}</code></a></h4>
<p>The <code>{{gt}}</code> helper can be used to compare two values in a template. It returns <code>true</code> if the first value is
greater than the second value, and <code>false</code> otherwise. It is equivalent to the <code>&gt;</code> operator in JavaScript.</p>
<pre><code class="language-hbs">{{#if (gt @number 5)}}
  The number is greater than 5!
{{/if}}
</code></pre>
<h4 id="gte-1"><a class="header" href="#gte-1"><code>{{gte}}</code></a></h4>
<p>The <code>{{gte}}</code> helper can be used to compare two values in a template. It returns <code>true</code> if the first value is
greater than or equal the second value, and <code>false</code> otherwise. It is equivalent to the <code>&gt;=</code> operator in JavaScript.</p>
<pre><code class="language-hbs">{{#if (gte @number 5)}}
  The number is greater than or equal to 5!
{{/if}}
</code></pre>
<h2 id="drawbacks-127"><a class="header" href="#drawbacks-127">Drawbacks</a></h2>
<p>Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.</p>
<h2 id="alternatives-129"><a class="header" href="#alternatives-129">Alternatives</a></h2>
<p>One alternative path is don't do anything and let users continue to define their own helpers (or install <code>ember-truth-helpers</code>).</p>
<h2 id="unresolved-questions-86"><a class="header" href="#unresolved-questions-86">Unresolved questions</a></h2>
<ul>
<li>The proposed version of those helpers mimic the behavior of the <code>&lt;</code> and <code>&gt;</code> operators in Javascript. While this is the
least surprising thing to do, one could argue that we could add extra logic to protect users from the usual pitfalls
and edge cases of those operators, <strong>like throwing exceptions if any of the values is <code>NaN</code> or a value other than a number</strong>.</li>
<li>We must decide if it's worth adding <code>{{lte}}</code> and <code>{{gte}}</code> helpers, equivalent to <code>&lt;=</code> and <code>&gt;=</code> respectively.</li>
<li><code>BigInt</code> support. The BigInt proposal has recently reached stage 4 and will be part of ECMASCRIPT 2020. According to
the spec comparisons using <code>&lt;</code> and <code>&gt;</code> work as expected and I don't anticipate problems, but ensure we explicitly
test for those numbers.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2019-12-08
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/562</h2>
<h1 id="adding-logical-operators-to-templates"><a class="header" href="#adding-logical-operators-to-templates">Adding Logical Operators to Templates</a></h1>
<h2 id="summary-140"><a class="header" href="#summary-140">Summary</a></h2>
<p>Add new built-in template <code>{{and}}</code>, <code>{{or}}</code> and <code>{{not}}</code> helpers to perform basic logical operations in templates, similar to those included in <code>ember-truth-helpers</code>.</p>
<p>This RFC is a subset of the changes proposed in #388.</p>
<h2 id="motivation-140"><a class="header" href="#motivation-140">Motivation</a></h2>
<p>It is a very common need in any sufficiently complex Ember app to perform some logical comparison operations and often the most convenient place to do it is right in the templates.
Because of that, <a href="https://github.com/jmurphyau/ember-truth-helpers">ember-truth-helpers</a> is one of the most installed addons out there, either directly by apps or indirectly by
other addons that those apps consume.</p>
<p>The fact that <code>ember-truth-helpers</code> is so popular is a good signal that this it is filling a perceived gap in Ember's functionality.</p>
<p>A second reason is that it might help make Ember more approachable to newcomers that have some experience in other frameworks.
Most if not all web frameworks have some way of performing logical operations in the templates and it's surprising that Ember requires an third party package to perform
even the most basic operations.</p>
<p>A third reason, this time technical, is that by implementing those helpers at a lower-level, we can make them more performant by making them short-circuit.
Right now helpers implemented using public APIs like those in <code>ember-truth-helpers</code> eagerly consume their arguments. In the case of logical operations like <code>{{and a b}}</code>,
once the first argument (<code>a</code>) is evalued to <em>falsey</em>, the second argument (<code>b</code>) is irrelevant. Sometimes arguments can be expensive properties to calculate,
and by short-circuiting we can avoid computing them at all sometimes.</p>
<h2 id="detailed-design-120"><a class="header" href="#detailed-design-120">Detailed design</a></h2>
<p>Add <code>{{and}}</code>, <code>{{or}}</code> and <code>{{not}}</code> helpers.</p>
<h4 id="and"><a class="header" href="#and"><code>{{and}}</code></a></h4>
<p>Takes at least two positional arguments. Raises an error if invoked with less than two arguments.
It evaluates arguments left to right, returning the first one that is not <em>truthy</em> (<strong>by handlebar's definition of truthiness</strong>)
or the right-most arguments if <strong>all</strong> evaluate to <em>truthy</em>.
This is <em>NOT</em> equivalent to the <code>{{and}}</code> helper from <code>ember-truth-helpers</code> because unlike this proposed helper, the one in <code>ember-truth-helpers</code>
uses Javascript's definition of truthiness.</p>
<h4 id="or"><a class="header" href="#or"><code>{{or}}</code></a></h4>
<p>Takes at least two positional arguments. Raises an error if invoked with less than two arguments.
It evaluates arguments left to right, returning the first one that is <em>truthy</em> (<strong>by handlebar's definition of truthiness</strong>) or the
right-most argument if all evaluate to <em>falsy</em>.
This is <em>NOT</em> equivalent to the <code>{{or}}</code> helper from <code>ember-truth-helpers</code> because unlike this proposed helper, the one in <code>ember-truth-helpers</code>
uses Javascript's definition of truthiness.</p>
<h4 id="not"><a class="header" href="#not"><code>{{not}}</code></a></h4>
<p>Unary operator. Raises an error if invoked with more than one positional argument. If the given value evaluates to a <em>truthy</em> value (<strong>by handlebar's definition of truthiness</strong>),
the <code>false</code> is returned. If the given value evaluates to a <em>falsy</em> value (<strong>by handlebar's definition of truthiness</strong>) then it returns <code>true</code>.
This is <em>NOT</em> equivalent to the <code>{{not}}</code> helper from <code>ember-truth-helpers</code> because unlike this proposed helper, the one in <code>ember-truth-helpers</code>
uses Javascript's definition of truthiness.</p>
<h4 id="handlebars-definition-of-truthiness"><a class="header" href="#handlebars-definition-of-truthiness">Handlebar's definition of truthiness</a></h4>
<p>This is the most important detail of this proposal because it's where it deviates from <code>ember-truth-helpers</code>.
Handlebars has its own definition of <em>truthyness</em>, which is similar to Javascripts except that empty arrays are
considered <strong>falsy</strong>, while in JS are considered <strong>truthy</strong>.</p>
<p>This RFC intentionally leaves the implementation details unspecified, but one can think of those helpers as macros that
expand to combinations of <code>if</code>s.</p>
<h5 id="and-1"><a class="header" href="#and-1"><code>{{and}}</code></a></h5>
<ul>
<li><code>{{and a b}}</code> is equivalent to <code>{{if a b a}}</code></li>
<li><code>{{and a b c}}</code> is equivalent to  <code>{{if a (if b c b) a}}</code></li>
<li>and so on</li>
</ul>
<h5 id="or-1"><a class="header" href="#or-1"><code>{{or}}</code></a></h5>
<ul>
<li><code>{{or a b}}</code> is equivalent to <code>{{if a a b}}</code></li>
<li><code>{{or a b c}}</code> is equivalent to  <code>{{if a a (if b b c)}}</code></li>
<li>and so on</li>
</ul>
<h5 id="not-1"><a class="header" href="#not-1"><code>{{not}}</code></a></h5>
<ul>
<li><code>{{not a}}</code> is equivalent to <code>{{if a false true}}</code></li>
</ul>
<h2 id="how-we-teach-this-108"><a class="header" href="#how-we-teach-this-108">How we teach this</a></h2>
<p>While the introduction of these helpers doesn't introduce new concepts, as helpers like these could be
written and in fact were written for a long time, it might affect slightly how we frame some concepts in the guides.</p>
<p>Previously users were encouraged to put computed properties in the javascript file of the components, even for
the most simple tasks like negating a boolean condition using <code>computed.not</code> or adding them with <code>computed.and</code>.</p>
<p>With the addition of these helpers users don't have to resort to computed properties for simple operations, which sometimes
forced users to create javascript files for what could have been template-only components.</p>
<p>In addition to documenting the new helpers in the API docs, the Guides should be updated to favour the usage of helpers
over computed properties where it makes more sense, adding illustrative examples and stressing out where
the definition of truthiness of handlebars differs from the one of Javascript.</p>
<h2 id="drawbacks-128"><a class="header" href="#drawbacks-128">Drawbacks</a></h2>
<p>Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.</p>
<h2 id="alternatives-130"><a class="header" href="#alternatives-130">Alternatives</a></h2>
<p>One alternative path is to not take any action and let users continue to define their own helpers (or install <code>ember-truth-helpers</code>).
Additionally the core could explore ways of making helpers not consume arguments eagerly to allow the implementation
of short-circuiting helpers in userland.</p>
<h2 id="unresolved-questions-87"><a class="header" href="#unresolved-questions-87">Unresolved questions</a></h2>
<ul>
<li>Consider following Javascript's definition of truthiness. This would also help with the transition from <code>ember-truth-helpers</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2019-12-22
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/566</h2>
<h1 id="cached"><a class="header" href="#cached">@cached</a></h1>
<h2 id="summary-141"><a class="header" href="#summary-141">Summary</a></h2>
<p>Add a <code>@cached</code> decorator for memoizing the result of a getter based on
autotracking. In the following example, <code>fullName</code> would only recalculate if
<code>firstName</code> or <code>lastName</code> is updated.</p>
<pre><code class="language-js">class Person {
  @tracked firstName = 'Jen';
  @tracked lastName = 'Weber';

  @cached
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<h2 id="motivation-141"><a class="header" href="#motivation-141">Motivation</a></h2>
<p>One of the major differences between computed properties and tracked properties
with autotracking in Octane is that native, autotracked getters do not
automatically cache their values, where computed properties were cached by
default. This was an intentional design choice, as the memoization logic for
computed properties was actually more costly, on average, than rerunning the
getter in the first place. This was especially true given that computed
properties would usually only ever be calculated and used once or twice per
render before being updated.</p>
<p>However, there are absolutely cases where getters <em>are</em> expensive, and their
values are used repeatedly, so memoization would be very helpful. Strategic,
opt-in memoization is a useful tool that would help Ember developers optimize
their apps when relevant, without adding extra overhead unless necessary.</p>
<h2 id="detailed-design-121"><a class="header" href="#detailed-design-121">Detailed design</a></h2>
<p>The <code>@cached</code> decorator will be exported from <code>@glimmer/tracking</code>, alongside
<code>@tracked</code>. It can be used on native getters to memoize their return values
based on the tracked state they consume while being calculated.</p>
<pre><code class="language-js">import { tracked, cached } from '@glimmer/tracking';

class Person {
  @tracked firstName = 'Jen';
  @tracked lastName = 'Weber';

  @cached
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
</code></pre>
<p>In this example, the <code>fullName</code> getter will be memoized whenever it is called,
and will only be recalculated the next time the <code>firstName</code> or <code>lastName</code>
properties are set. This would apply to any autotracking tags consumed while
calculating the getter, so changes to <code>EmberArray</code>s and other tracked
primitives, for instance, would also cause invalidations.</p>
<p>If used on a non-getter, <code>@cached</code> will throw an error in <code>DEBUG</code> modes.
Properties can also include a setter, but it won't affect the memoization of the
getter (except by potentially setting the state that was tracked in the first
place).</p>
<h3 id="invalidation"><a class="header" href="#invalidation">Invalidation</a></h3>
<p><code>@cached</code> will propagate invalidations whenever any of the properties it is
entangled with are invalidated, causing any downstream state that has consumed
to be invalidated at the same time.</p>
<p>This is necessary in order to have the memoized value be pulled on again in
general. There is no way to, for instance, only propagate changes if the
memoized value has changed, since we must calculate the memoized value first to
know what it's new value is, and we must propagate the change in order to ensure
that it will be recalculated.</p>
<h3 id="cycles"><a class="header" href="#cycles">Cycles</a></h3>
<p>Cycles will not be allowed with <code>@cached</code>. The cache will only be activated
<em>after</em> the getter has fully calculated, so any cycles will cause infinite
recursion (and eventually, stack overflow), just like un-memoized getters. If a
cycle is detected in <code>DEBUG</code> mode, it will throw an error.</p>
<h2 id="how-we-teach-this-109"><a class="header" href="#how-we-teach-this-109">How we teach this</a></h2>
<p><code>@cached</code> is not an essential part of the reactivity model, so it shouldn't be
covered during the main component/reactivity guide flow. Instead, it should be
covered in the intermediate/in-depth guides, and in any performance related
guides. We should also note that the decorator should not be sprinkled around
carelessly or defensively - instead, it should only be used when the computation
being cached is confirmed to be computationally expensive.</p>
<h3 id="api-docs-2"><a class="header" href="#api-docs-2">API Docs</a></h3>
<p>The <code>@cached</code> decorator can be used on getters in order to cache the return
value of the getter. This is useful when a getter is expensive and used very
often. For instance, in this guest list class, we have the <code>sortedGuests</code>
getter that sorts the guests alphabetically:</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class GuestList {
  @tracked guests = ['Zoey', 'Tomster'];

  get sortedGuests() {
    return this.guests.slice().sort()
  }
}
</code></pre>
<p>Every time <code>sortedGuests</code> is accessed, a new array will be created and sorted,
because JavaScript getters do not cache by default. When the guest list is
small, like the one in the example, this is not a problem. However, if the guest
list were to grow very large, it would mean that we would be doing a large
amount of work each time we accessed <code>sortedGetters</code>. With <code>@cached</code>, we can
cache the value instead:</p>
<pre><code class="language-js">import { tracked, cached } from '@glimmer/tracking';

class GuestList {
  @tracked guests = ['Zoey', 'Tomster'];

  @cached
  get sortedGuests() {
    return this.guests.slice().sort()
  }
}
</code></pre>
<p>Now the <code>sortedGuests</code> getter will be cached based on <em>autotracking</em>. It will
only rerun and create a new sorted array when the <code>guests</code> tracked property is
updated.</p>
<p>In general, you should avoid using <code>@cached</code> unless you have confirmed that the
getter you are decorating is computationally expensive. <code>@cached</code> adds a small
amount of overhead to the getter, making it more expensive. While this overhead
is small, if <code>@cached</code> is overused it can add up to a large impact overall in
your app. Many getters and tracked properties are only accessed once, rendered,
and then never rerendered, so adding <code>@cached</code> when it is unnecessary can
negatively impact performance.</p>
<h2 id="drawbacks-129"><a class="header" href="#drawbacks-129">Drawbacks</a></h2>
<ul>
<li>
<p>Adds extra complexity when programming (whether or not a value should be
memoized is now a decision that has to be made). In general, we should make
sure this is not an issue by recommending that memoization idiomatically <em>not</em>
be used <em>unless</em> it is absolutely necessary.</p>
</li>
<li>
<p>Adds extra overhead for each memoized getter. This again should be addressed
by teaching that it should be avoided when possible. The cost tradeoff should
be noted in documentation in particular to emphasize this, and discourage
overuse.</p>
</li>
<li>
<p><code>@cached</code> may rerun even if the values themselves have not changed, since
tracked properties will always invalidate even if their underlying value did
not change. Unfortunately, this is not really something that <code>@cached</code> can
circumvent, since there's no way to tell if a value has actually changed, or
to know which values are being accessed when the memoized value is accessed
until the getter is run.</p>
<p>Instead, we should be sure that the rules of property invalidation are clear,
and in performance sensitive situations we recommend diff checking when
assigning the property:</p>
<pre><code class="language-js">if (newValue !== this.trackedProp) {
  this.trackedProp = newValue;
}
</code></pre>
</li>
</ul>
<h2 id="alternatives-131"><a class="header" href="#alternatives-131">Alternatives</a></h2>
<ul>
<li>
<p><code>@memo</code> or <code>@memoized</code> could be alternative names. Initially <code>@memo</code> was used,
but it was decided to switch to <code>@cached</code>.</p>
</li>
<li>
<p><code>@cached</code> could receive arguments of the keys to memoize based on. This would
bring us back to the ergonomics of computed properties, however, and would not
be ideal. It also would bring no actual benefits, except being able to exclude
certain values from recalculation.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-01-10
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/580</p>
<hr />
<h1 id="destroyables"><a class="header" href="#destroyables">Destroyables</a></h1>
<h2 id="summary-142"><a class="header" href="#summary-142">Summary</a></h2>
<p>Adds an API for registering destroyables and destructors with Ember's built in
destruction hierarchy.</p>
<pre><code class="language-js">class MyComponent extends Component {
  constructor() {
    let timeoutId = setTimeout(() =&gt; console.log('hello'), 1000);

    registerDestructor(this, () =&gt; clearTimeout(timeoutId));
  }
}
</code></pre>
<p>The API will also enable users to create and manage their own destroyables, and
associate them with a parent destroyable.</p>
<pre><code class="language-js">class TimeoutManager {
  constructor(parent, fn, timeout = 1000) {
    let timeoutId = setTimeout(fn, timeout);

    associateDestroyableChild(parent, this);
    registerDestructor(this, () =&gt; clearTimeout(timeoutId));
  }
}

class MyComponent extends Component {
  manager = new TimeoutManager(this, () =&gt; console.log('hello'));
}
</code></pre>
<h2 id="motivation-142"><a class="header" href="#motivation-142">Motivation</a></h2>
<p>Ember manages the lifecycles and lifetimes of many built in constructs, such as
components, and does so in a hierarchical way - when a parent component is
destroyed, all of its children are destroyed as well. This is a well established
software pattern that is useful for many applications, and there are a variety
of libraries, such as <a href="https://github.com/ember-lifeline/ember-lifeline">ember-lifeline</a>
and <a href="https://github.com/machty/ember-concurrency">ember-concurrency</a>, that would
benefit from having a way to extend this hierarchy, adding their own &quot;children&quot;
that are cleaned up whenever their parents are removed.</p>
<p>Historically, Ember has exposed this cleanup lifecycle via <em>hooks</em>, such as the
<code>willDestroy</code> hook on components. However, methods like these have a number of
downsides:</p>
<ol>
<li>
<p>Since they are named, they can have collisions with other properties. This is
historically what led to the actions hash on classic components, in order to
avoid collisions between actions named <code>destroy</code> and the <code>destroy</code> lifecyle
hook.</p>
</li>
<li>
<p>On a related note, relying on property names means that all framework classes
<em>must</em> implement the <code>willDestroy</code> function (or another name), making it very
difficult to change APIs in the future.</p>
</li>
<li>
<p>Methods are difficult for <em>libraries</em> to instrument. For instance,
<code>ember-concurrency</code> currently replaces the <code>willDestroy</code> method on any class
with a task, with logic that looks similar to:</p>
<pre><code class="language-js">let PATCHED = new WeakSet();

function patchWillDestroy(obj) {
  if (PATCHED.has(obj)) return;

  let oldWillDestroy = obj.willDestroy;

  obj.willDestroy = function () {
    if (oldWillDestroy) oldWillDestroy.call(this);

    teardownTasks(this);
  };

  PATCHED.add(obj);
}
</code></pre>
<p>This logic becomes especially convoluted if <em>multiple</em> libraries are
attempting to patch <code>willDestroy</code> in this way.</p>
</li>
<li>
<p>Finally, since this isn't a standard, it's difficult to add <em>layers</em> of new
destroyable values that can interoperate with one another. For instance,
there is no way for <code>ember-concurrency</code> to know how to destroy tasks on
non-framework classes that users may have added themselves.</p>
</li>
</ol>
<p>This RFC proposes a streamlined API that disconnects the exact implementation
from any interface, allows for multiple destructors per-destroyable, and
maximizes interoperability in general.</p>
<h2 id="detailed-design-122"><a class="header" href="#detailed-design-122">Detailed design</a></h2>
<p>The API consists of 6 main functions, imported from <code>@ember/destroyable</code>:</p>
<pre><code class="language-ts">declare function associateDestroyableChild&lt;T extends object&gt;(parent: object, child: T): T;

declare function registerDestructor&lt;T extends object&gt;(
  destroyable: T,
  destructor: (destroyable: T) =&gt; void
): (destroyable: T) =&gt; void;

declare function unregisterDestructor&lt;T extends object&gt;(
  destroyable: T,
  destructor: (destroyable: T) =&gt; void
): void;

declare function destroy(destroyable: object): void;
declare function isDestroying(destroyable: object): boolean;
declare function isDestroyed(destroyable: object): boolean;
</code></pre>
<p>In addition, there is a debug-only mode function used for testing:</p>
<pre><code class="language-ts">declare function assertDestroyablesDestroyed(): void;
</code></pre>
<p>For the remainder of this RFC, the terms &quot;destroyable&quot; and &quot;destroyable object&quot;
will be used to mean any object which is a valid <code>WeakMap</code> key
(e.g. <code>typeof obj === 'object' || typeof obj === 'function'</code>). Any JS object
that fulfills this property can be used with this system.</p>
<h4 id="associatedestroyablechild"><a class="header" href="#associatedestroyablechild"><code>associateDestroyableChild</code></a></h4>
<p>This function is used to associate a destroyable object with a parent. When the
parent is destroyed, all registered children will also be destroyed.</p>
<pre><code class="language-js">class CustomSelect extends Component {
  constructor() {
    // obj is now a child of the component. When the component is destroyed,
    // obj will also be destroyed, and have all of its destructors triggered.
    this.obj = associateDestroyableChild(this, {});
  }
}
</code></pre>
<p>Returns the associated child for convenience.</p>
<ul>
<li>Attempting to associate a parent or child that has already been destroyed
or is being destroyed should throw an error.</li>
</ul>
<h5 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h5>
<p>Attempting to associate a child to multiple parents should currently throw an
error. This could be changed in the future, but for the time being multiple
inheritance of destructors is tricky and not scoped in. Instead, users can add
destructors to accomplish this goal:</p>
<pre><code class="language-js">let parent1 = {},
  parent2 = {},
  child = {};

registerDestructor(parent1, () =&gt; destroy(child));
registerDestructor(parent2, () =&gt; destroy(child));
</code></pre>
<p>The exact timing semantics here will be a bit different, but for most use cases
this should be fine. If we find that it would be useful to have multiple
inheritance baked in in the future, it can be added in a followup RFC.</p>
<h4 id="registerdestructor"><a class="header" href="#registerdestructor"><code>registerDestructor</code></a></h4>
<p>Receives a destroyable object and a destructor function, and associates the
function with it. When the destroyable is destroyed with <code>destroy</code>, or when its
parent is destroyed, the destructor function will be called.</p>
<pre><code class="language-js">import { registerDestructor } from '@ember/destroyable';

class Modal extends Component {
  @service resize;

  constructor() {
    this.resize.register(this, this.layout);

    registerDestructor(this, () =&gt; this.resize.unregister(this));
  }
}
</code></pre>
<p>Multiple destructors can be associated with a given destroyable, and they can be
associated over time, allowing libraries like <code>ember-lifeline</code> to dynamically
add destructors as needed. <code>registerDestructor</code> also returns the associated
destructor function, for convenience.</p>
<p>The destructor function is passed a single argument, which is the destroyable
itself. This allows the function to be reused multiple times for many
destroyables, rather than creating a closure function per destroyable.</p>
<pre><code class="language-js">import { registerDestructor } from '@ember/destroyable';

function unregisterResize(instance) {
  instance.resize.unregister(instance);
}

class Modal extends Component {
  @service resize;

  constructor() {
    this.resize.register(this, this.layout);

    registerDestructor(this, unregisterResize);
  }
}
</code></pre>
<ul>
<li>Registering a destructor on a destroyed object or object that is being destroyed should throw an error.</li>
<li>Attempting to register the same destructor multiple times should throw an
error.</li>
</ul>
<h4 id="unregisterdestructor"><a class="header" href="#unregisterdestructor"><code>unregisterDestructor</code></a></h4>
<p>Receives a destroyable and a destructor function, and de-associates the
destructor from the destroyable.</p>
<pre><code class="language-js">import { unregisterDestructor } from '@ember/destroyable';

class Modal extends Component {
  @service modals;

  constructor() {
    this.modals.add(this);

    this.modalDestructor = registerDestructor(this, () =&gt; this.modals.remove(this));
  }

  @action pinModal() {
    unregisterDestructor(this, this.modalDestructor);
  }
}
</code></pre>
<ul>
<li>Calling <code>unregisterDestructor</code> on a destroyed object should throw an error.</li>
<li>Calling <code>unregisterDestructor</code> with a destructor that is not associated with
the object should throw an error.</li>
</ul>
<h4 id="destroy"><a class="header" href="#destroy"><code>destroy</code></a></h4>
<p><code>destroy</code> initiates the destruction of a destroyable object. It runs all
associated destructors, and then destroys all children recursively.</p>
<pre><code class="language-js">let obj = {};

registerDestructor(obj, () =&gt; console.log('destroyed!'));

destroy(obj); // this will schedule the destructor to be called

// ...some time later, during scheduled destruction

// destroyed!
</code></pre>
<p>Destruction via <code>destroy()</code> follows these steps:</p>
<ol>
<li>Mark the destroyable such that <code>isDestroying(destroyable)</code> returns <code>true</code></li>
<li>Schedule calling the destroyable's destructors</li>
<li>Call <code>destroy()</code> on each of the destroyable's associated children</li>
<li>Schedule setting destroyable such that <code>isDestroyed(destroyable)</code> returns <code>true</code></li>
</ol>
<p>This algorithm results in the entire tree of destroyables being first marked as
destroying, then having all of their destructors called, and finally all being
marked as <code>isDestroyed</code>. There won't be any in between states where some items
are marked as <code>isDestroying</code> while destroying, while others are not.</p>
<p>Calling <code>destroy</code> multiple times on the same destroyable is safe. It will not
throw an error, and will not take any further action.</p>
<p>Calling <code>destroy</code> with a destroyable that has no destructors or associated children
will not throw an error, and will do nothing.</p>
<h4 id="isdestroying-1"><a class="header" href="#isdestroying-1"><code>isDestroying</code></a></h4>
<p>Receives a destroyable, and returns <code>true</code> if the destroyable has begun
destroying. Otherwise returns false.</p>
<pre><code class="language-js">let obj = {};
isDestroying(obj); // false
destroy(obj);
isDestroying(obj); // true
// ...sometime later, after scheduled destruction
isDestroyed(obj); // true
isDestroying(obj); // true
</code></pre>
<h4 id="isdestroyed-1"><a class="header" href="#isdestroyed-1"><code>isDestroyed</code></a></h4>
<p>Receives a destroyable, and returns <code>true</code> if the destroyable has finished
destroying. Otherwise returns false.</p>
<pre><code class="language-js">let obj = {};

isDestroyed(obj); // false
destroy(obj);

// ...sometime later, after scheduled destruction

isDestroyed(obj); // true
</code></pre>
<h4 id="assertdestroyablesdestroyed"><a class="header" href="#assertdestroyablesdestroyed"><code>assertDestroyablesDestroyed</code></a></h4>
<p>This function asserts that all objects which have associated destructors or
associated children have been destroyed at the time it is called. It is meant to
be a low level hook that testing frameworks like <code>ember-qunit</code> and <code>ember-mocha</code>
can use to hook into and validate that all destroyables have in fact been
destroyed.</p>
<h3 id="built-in-destroyables"><a class="header" href="#built-in-destroyables">Built In Destroyables</a></h3>
<p>The root destroyable of an Ember application will be the instance of the owner.
All framework managed classes are destroyables, including:</p>
<ul>
<li>Components</li>
<li>Services</li>
<li>Routes</li>
<li>Controllers</li>
<li>Helpers</li>
<li>Modifiers</li>
</ul>
<p>Any future classes that are added and have a container managed lifecycle should
also be marked as destroyables.</p>
<h2 id="how-we-teach-this-110"><a class="header" href="#how-we-teach-this-110">How we teach this</a></h2>
<p>Destroyables are not a very commonly used primitive, but they are fairly core to
Ember applications. Most destruction lifecycle hooks will be rationalized as
destroyables under the hood, and and it is key to how the application manages
lifecycles. As such, destroyables should be covered in an <em>In-Depth Guide</em> in
the Core Concepts section of the guides.</p>
<h3 id="guide-outline"><a class="header" href="#guide-outline">Guide Outline</a></h3>
<p>The guide should start by discussing lifecycle, in particular focusing on in the
existing lifecycle hooks that users will already know about, such as
<code>willDestroy</code> on components. It should cover how at a high level, every
framework concept exists in a <em>lifecycle tree</em>, where children are tied to the
lifecyles of their parents. When something in the tree is destroyed, like a
component so are all of its children.</p>
<p>The destroyable APIs can then be brought in to discuss how one might add to the
tree, if they have concepts whose lifecycles would logically belong to it. This
should be done primarily through examples. Some ideas for possible examples
include:</p>
<ol>
<li>A simple remote data fetcher. The request needs to be cancelled if the parent
is destroyed, which is a perfect use case for a destroyable.</li>
<li>A task manager that manages a variety of long lived tasks.</li>
<li>Possibly another example where a completely independent tree is made, for
some sort of library that would be otherwise external to Ember.</li>
</ol>
<p>The rest of the guide could show in detail how the user would use the APIs to
accomplish this goal, and how it would be better and more scalable than doing it
with lifecycle hooks.</p>
<p>There should also be a section on <em>when</em> to use the low-level destroyable APIs,
vs the standard lifecycle hooks.</p>
<h3 id="api-docs-3"><a class="header" href="#api-docs-3">API Docs</a></h3>
<p>The descriptions of the APIs above in the RFC are sufficient detail for the bulk
of API documentation, with some light editing.</p>
<h2 id="drawbacks-130"><a class="header" href="#drawbacks-130">Drawbacks</a></h2>
<ul>
<li>Adds another destruction API which may conflict with the existing destruction
hooks. Since this is a low-level API, it shouldn't be too problematic - most
users will be guided toward using the standard lifecycle hooks, and this API
will exist for libraries like <code>ember-concurrency</code> and <code>ember-lifeline</code>.</li>
</ul>
<h2 id="alternatives-132"><a class="header" href="#alternatives-132">Alternatives</a></h2>
<ul>
<li>Continue using existing lifecycle hooks for public API, and don't provide an
independent API.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-01-14
RFC PR: https://github.com/emberjs/rfcs/pull/581</p>
<hr />
<h1 id="summary-143"><a class="header" href="#summary-143">Summary</a></h1>
<p>Test waiters have been around in Ember in one form or another since version 1.2.0, and provide a way for developers to signal to the testing framework system that async operations are currently active, when to keep waiting, and when those async operations have completed. This allows the active test to wait during the test in a deterministic fashion, and only proceed once the active async is completed.</p>
<p>The current test waiters implementation has a simple but confusing API, and the test waiters themselves lack some key features. This RFC proposes replacing them with a new test waiters system: <a href="https://github.com/rwjblue/ember-test-waiters">ember-test-waiters</a>.</p>
<h1 id="motivation-143"><a class="header" href="#motivation-143">Motivation</a></h1>
<p>Recently, an updated replacement for the original test waiters API was created. This new library, ember-test-waiters, seeks to provide an easy-to-use API that can be used to interleave unmanaged async behaviors with Ember’s test framework. Using a test waiter can help mark begin and end points for your async operations, allowing the test to deterministically pause during execution.</p>
<p>The new system will provide a few benefits:</p>
<ol>
<li>A new API that removes the existing foot guns (e.g. &quot;Do I return <code>false</code> or <code>true</code> if I want to continue waiting?&quot;)</li>
<li>A more robust way to gather debugging information for the test waiter</li>
<li>Default test waiters with the ability to author your own, more complex test waiters</li>
</ol>
<h1 id="detailed-design-123"><a class="header" href="#detailed-design-123">Detailed design</a></h1>
<p>Ember’s test framework has an internal concept of settledness, that is used by all of its internal helpers. Settledness can be defined as <strong><em>all known active async operations have completed, and there’s no outstanding work to be done</em></strong>. This is codified in the <a href="https://github.com/emberjs/ember-test-helpers/blob/master/API.md#settled">settled</a> helper.</p>
<p>The settled helper, as noted, wires itself up to known asynchronous behaviors. Those include whether there</p>
<ul>
<li>is an active runloop (more on the runloop)</li>
<li>are any pending timers within the runloop (run.later, run.debounce, run.throttle)</li>
<li>are any pending test waiters (more on waiters later!)</li>
<li>are any pending <code>jQuery.ajax</code> requests</li>
<li>are any pending route transitions.</li>
</ul>
<p>The settled check returns a Promise that is fulfilled when all of the above behaviors return <code>false</code>, indicating all async for each behavior is completed. These cover a vast number of async behaviors that are typical in our applications.</p>
<p>An enhancement was added to <a href="https://github.com/emberjs/ember-qunit"><code>ember-qunit</code></a> that allowed for detecting a lack of settledness at the end of a test. This enhancement, <a href="https://github.com/emberjs/ember-qunit/blob/master/docs/TEST_ISOLATION_VALIDATION.md">test isolation validation</a>, evaluated the settled state once a test was considered done and reported to the user whether there were active async operations pending. This helped developers quickly identify and fix known asynchronous leaks in their tests, allowing for a more deterministic test suite.</p>
<p>During the development of the test isolation validation feature, we discovered that most asynchronous operations used in the settled check provided good debug information that could be provided to the end user, with the exception of the existing test waiters. Those waiters only provided rudimentary information that could be exposed, specifically whether there were any active test waiters pending, but nothing more.</p>
<p>To address this, a new addon was written to experiment on a new test waiter system that would provide a number of things (as noted above):</p>
<ol>
<li>A new API that's <em>explicit</em> and <em>straightforward</em></li>
<li>A more robust way to gather debugging information for the test waiter</li>
<li>Default test waiters with the ability to author your own, more complex test waiters</li>
</ol>
<p>This allows developers to utilize <code>ember-test-waiters</code> to annotate their asynchronous operations that are not tracked by an <code>await settled()</code> check, and for those annotations to provide useful debugging information in the event their async extended past the expected duration of the test.</p>
<h2 id="comparison-of-old-waiters-system-to-new"><a class="header" href="#comparison-of-old-waiters-system-to-new">Comparison of old waiters system to new</a></h2>
<p>In the old test waiters system, you would do the following:</p>
<pre><code class="language-js">import { registerWaiter } from '@ember/test';

registerWaiter(function() {
  return myPendingTransactions() === 0;
});
</code></pre>
<p>While reading the above is straightforward, when writing a test waiter using the old system it's easy to forget what the expected return value is: <code>true</code> or <code>false</code>. Additionally, it's a bit more cognitive overhead to derive what the intended result of the particular boolean return value is: does returning <code>true</code> result in the test waiter waiting or not?</p>
<p>As mentioned before, there's no additional information provided via <code>registerWaiter</code>, and capturing stack traces at the call site is currently not implemented. Unmanaged async that 'hangs' can cause your tests to stall and ultimately timeout. Not having stack traces is particularly problematic when trying to identify which of many test waiters has caused this timeout, as it's like looking for a needle in a haystack.</p>
<p>The new system captures an error object when the waiter's <code>beginAsync</code> method is called (more on <code>beginAsync</code> later), but evaluates the <code>stack</code> property lazily, when this value is processed by <code>@ember/test-helpers</code>' <code>getSettledState</code>. This allows for identifying the offending code more easily.</p>
<p>The new test waiters system looks like this:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { buildWaiter } from 'ember-test-waiters';

let waiter = buildWaiter('friend-waiter');

export default class Friendz extends Component {
  didInsertElement() {
    let token = waiter.beginAsync();

    someAsyncWork()
      .then(() =&gt; {
        //... some work
      })
      .finally(() =&gt; {
        waiter.endAsync(token);
      });
  }
}
</code></pre>
<p>In the above example, a new test waiter is built that is identified via a <code>name</code> string passed into the <code>buildWaiter</code> function. This allows the waiter to be identifiable, and that name is ultimately used with test isolation validation to help developers narrow down problems in their tests.</p>
<h2 id="new-test-waiters-design"><a class="header" href="#new-test-waiters-design">New Test Waiters Design</a></h2>
<p>The new test waiters addon is built using low-level primitives that are complimented with some convenience utilities.</p>
<h3 id="waiter"><a class="header" href="#waiter"><code>Waiter</code></a></h3>
<p>At its core, the addon uses an <code>Waiter</code> interface defined as follows:</p>
<pre><code class="language-ts">export type WaiterName = string;
export type Token = unknown;

export interface Waiter {
  name: WaiterName;
  waitUntil(): boolean;
  debugInfo(): TestWaiterDebugInfo[];
}
</code></pre>
<ul>
<li><code>name</code>: The name of the test waiter, which is used to help identify it in test isolation validation output.</li>
<li><code>waitUntil</code>: Used to determine if the waiter system should still wait for async
operations to complete. The <code>waitUntil</code> method will return <code>true</code> to signal completion.</li>
<li><code>debugInfo</code>: Returns the <code>debugInfo</code> for each item tracking async operations in a waiter. The <code>debugInfo</code> for each waiter item is ultimately used in <code>@ember/test-helpers</code>' <code>getSettledState</code> function, which is used for test isolation validation output.</li>
</ul>
<p>This allows for maximum flexibility when creating your own waiter implementations.</p>
<h3 id="testwaiter"><a class="header" href="#testwaiter"><code>TestWaiter</code></a></h3>
<p>The <code>Waiter</code> interface is built upon to create a more specific interface for a test waiter, <code>TestWaiter</code>:</p>
<pre><code class="language-ts">export interface TestWaiter&lt;T extends object | Primitive | unknown = Token&gt;
  extends Waiter {
  beginAsync(token?: T, label?: string): T;
  endAsync(token: T): void;
  reset(): void;
}
</code></pre>
<ul>
<li><code>beginAsync</code>: Should be used to signal the beginning of an async operation that
is to be waited for. Invocation of this method should be paired with a subsequent
<code>endAsync</code> call to indicate to the waiter system that the async operation is completed.</li>
<li><code>endAsync</code>: Should be used to signal the end of an async operation. Invocation of this
method should be paired with a preceding <code>beginAsync</code> call, which would indicate the
beginning of an async operation.</li>
<li><code>reset</code>: Resets the waiter state, clearing items tracking async operations in this waiter.</li>
</ul>
<p>This interface is used for the concrete <code>TestWaiter</code> type. This type forms the basis for the addon, and will likely satisfy the majority of use cases.</p>
<p>The most common practice is to import and invoke the <code>buildWaiter</code> function to create a new test waiter. The recommendation is to do so at the module level, which allows a single waiter to be created per type (this should likely be enforced via a lint rule added to <code>eslint-plugin-ember</code>). A single waiter is then usable across multiple instances.</p>
<pre><code class="language-ts">function buildWaiter(name: string): TestWaiter;
</code></pre>
<p>In anything but a production build, this function will return a <code>TestWaiter</code> instance. When in production mode, we make this instance <em>inert</em> and essentially no cost to invoke. Since test waiters are intended to be called from application or addon code, but are only required to be <em>active</em> when in tests, this process of making the instance <em>inert</em> is important. Even though code is still invoked, this has a negligible impact on performance.</p>
<h3 id="using-the-testwaiter-class"><a class="header" href="#using-the-testwaiter-class">Using the <code>TestWaiter</code> class</a></h3>
<p>After building a test waiter, most users interact with a limited set of methods within this class, namely <code>beingAsync</code> and <code>endAsync</code>.</p>
<p>The API used to signal whether an asynchronous operation has begun and ultimately ended is through the <strong><em>paired</em></strong> calls of <code>beginAsync</code> and <code>endAsync</code>: begin to denote the start of the asynchronous operation, and end to denote the end. Unique instances of async operations are identified using a <code>token</code> returned from <code>beginAsync</code>, which is subsequently provided to the <code>endAsync</code> call.</p>
<p>To annotate the example provided above:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { buildWaiter } from 'ember-test-waiters';

// Creates a test waiter with the name 'friend-waiter' that
// is usable by all instances of the `Friendz` component.
let waiter = buildWaiter('friend-waiter');

export default class Friendz extends Component {
  didInsertElement() {
    // Alerts the test waiter system that an async operation has started,
    // storing the resulting unique token to be used to notify the test
    // waiter system that the operation has ended.
    let token = waiter.beginAsync();

    someAsyncWork()
      .then(() =&gt; {
        //... some work
      })
      .finally(() =&gt; {
        // Notifies the test waiter system that
        // this unique async operation has ended.
        waiter.endAsync(token);
      });
  }
}
</code></pre>
<h3 id="waitforpromise"><a class="header" href="#waitforpromise"><code>waitForPromise</code></a></h3>
<p>The <code>waitForPromise</code> utility provides a convenience wrapper around the <code>TestWaiter</code> class for use with promises. It ensures the <code>endAsync</code> call is invoked in the <code>finally</code> of the configured promise.</p>
<pre><code class="language-js">import Component from '@ember/component';
import { waitForPromise } from 'ember-test-waiters';

export default class MoreFriendz extends Component {
  didInsertElement() {
    waitForPromise(someAsyncWork).then(() =&gt; {
      doOtherThings();
    });
  }
}
</code></pre>
<p>This new test waiters system has been through multiple iterations of refinement, and is in use and integrated with the test isolation validation system.</p>
<h2 id="rename-of-ember-test-waiters-to-embertest-waiters"><a class="header" href="#rename-of-ember-test-waiters-to-embertest-waiters">Rename of <code>ember-test-waiters</code> to <code>@ember/test-waiters</code></a></h2>
<p>We should consider renaming the <code>ember-test-waiters</code> repository to <code>@ember/test-waiters</code>, which would relocate it to the Ember org and scope it more explicitly.</p>
<h2 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h2>
<p>The <code>ember-test-waiters</code> addon is backwards compatible with the old test waiters system, allowing applications and addons to gradually migrate to using the new system.</p>
<p>Specifically:</p>
<ul>
<li><code>registerWaiter</code> continues to work, and is not deprecated</li>
<li>addons using <code>ember-test-waiters</code> work <em>even if consumed in applications that do not use a new enough <code>ember-test-helpers</code> version</em> (they won't get additional output via test isolation validation such as test waiter names or stack traces)</li>
</ul>
<p>The old test waiters system ultimately should be deprecated in its own deprecation RFC.</p>
<h2 id="rollout"><a class="header" href="#rollout">Rollout</a></h2>
<ul>
<li>Rename <code>ember-test-waiters</code> to <code>@ember/test-waiters</code>, moving it to the <code>emberjs</code> org</li>
<li>Add <code>@ember/test-waiters</code> to the default app and addon blueprints</li>
<li>Add new optional lint rule to <code>eslint-plugin-ember</code> that flags usage of legacy test waiters, recommending the new waiters as a replacement</li>
<li>Open a new RFC proposing deprecation of legacy test waiters</li>
</ul>
<h1 id="how-we-teach-this-111"><a class="header" href="#how-we-teach-this-111">How We Teach This</a></h1>
<p>API documentation should be available at <code>api.emberjs.com</code>.</p>
<h2 id="new-testing-section-in-ember-guides---handling-async"><a class="header" href="#new-testing-section-in-ember-guides---handling-async">New Testing Section in Ember Guides - &quot;Handling Async&quot;</a></h2>
<p>This new test waiters system should be included in the Ember guide's testing section. Information and examples should be provided to allow users to correctly author asynchronous code that can be correctly managed by the testing system.</p>
<p>Specifically, calling this out in a separate section will allow readers to understand the intent of the test waiters system from a high level, as test waiters apply broadly to all the associated types in the testing section.</p>
<p>There are a few concepts that we should focus on:</p>
<ol>
<li>What patterns of asynchronous code can lead to issues in testing</li>
<li>How to utilize test waiters to address those asynchronous patterns</li>
<li>How to leverage the built-in test waiters utilities</li>
</ol>
<h2 id="new-testing-section-in-ember-cli-guides---handling-async-for-addon-authors"><a class="header" href="#new-testing-section-in-ember-cli-guides---handling-async-for-addon-authors">New Testing Section in Ember CLI Guides - &quot;Handling Async (for Addon Authors)&quot;</a></h2>
<p>The important requirement that addon authors need to know about is that when using <code>ember-test-waiters</code>, that package should be added as a <code>dependency</code>.</p>
<p>Specifically for addon authors, we want to encourage the use of test waiters to prevent async leaks in tests due to unmanaged async. A special section directed at addon authors should be added to help them understand the value to their consumers by adding test waiters, or providing test helpers via <code>addon-test-support</code> integrated with test waiters.</p>
<h1 id="drawbacks-131"><a class="header" href="#drawbacks-131">Drawbacks</a></h1>
<ul>
<li>the new test waiters system ships code to production bundles, though this is quite small</li>
</ul>
<h1 id="alternatives-133"><a class="header" href="#alternatives-133">Alternatives</a></h1>
<ul>
<li>the existing test waiters system could be left in place</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-01-27
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/585</p>
<hr />
<h1 id="improved-ember-registry-apis"><a class="header" href="#improved-ember-registry-apis">Improved Ember Registry APIs</a></h1>
<h2 id="summary-144"><a class="header" href="#summary-144">Summary</a></h2>
<p>Introduce a new, object-based API for all registry APIs; deprecate the current string-based microsyntax registry APIs; and introduce a <code>capabilities</code> property to the resolver to safely support existing resolvers. Extend the new API for service and controller injections, and deprecate their microsyntax for namespaced injections.</p>
<p>Today the registry APIs are all of shapes roughly like this:</p>
<pre><code class="language-js">getOwner(this).lookup('service:session');
</code></pre>
<p>This RFC proposes that they would instead be written like this:</p>
<pre><code class="language-js">getOwner(this).lookup({ type: 'service', name: 'session' })
</code></pre>
<p>Service and controller injections which include a namespace currently look like this:</p>
<pre><code class="language-js">class Example {
  @service('global@session')
  session;
}
</code></pre>
<p>This RFC proposes that these would instead be written like this:</p>
<pre><code class="language-js">class Example {
  @service({ namespace: 'global', name: 'session' })
  session;
}
</code></pre>
<h3 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h3>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#summary">Summary</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#table-of-contents">Table of Contents</a></li>
</ul>
</li>
<li><a href="0585-improved-ember-registry-apis.html#motivation">Motivation</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#microsyntax-problems">Microsyntax problems</a></li>
<li><a href="0585-improved-ember-registry-apis.html#typescript-problems">TypeScript problems</a></li>
<li><a href="0585-improved-ember-registry-apis.html#performance-benefits">Performance benefits?</a></li>
</ul>
</li>
<li><a href="0585-improved-ember-registry-apis.html#detailed-design">Detailed design</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#identifier-types"><code>Identifier</code> types</a></li>
<li><a href="0585-improved-ember-registry-apis.html#resolver"><code>Resolver</code></a></li>
<li><a href="0585-improved-ember-registry-apis.html#owner-apis">Owner APIs</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#options">Options</a></li>
<li><a href="0585-improved-ember-registry-apis.html#factory-and-factorymanager"><code>Factory</code> and <code>FactoryManager</code></a></li>
<li><a href="0585-improved-ember-registry-apis.html#owner-api-diff"><code>Owner</code> API diff</a></li>
</ul>
</li>
<li><a href="0585-improved-ember-registry-apis.html#service-and-controller-injections">Service and Controller Injections</a></li>
<li><a href="0585-improved-ember-registry-apis.html#codemod">Codemod</a></li>
<li><a href="0585-improved-ember-registry-apis.html#deprecation-messaging">Deprecation messaging</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#guide">Guide</a></li>
<li><a href="0585-improved-ember-registry-apis.html#in-app">In-app</a></li>
</ul>
</li>
<li><a href="0585-improved-ember-registry-apis.html#rollout">Rollout</a></li>
</ul>
</li>
<li><a href="0585-improved-ember-registry-apis.html#how-we-teach-this">How we teach this</a></li>
<li><a href="0585-improved-ember-registry-apis.html#drawbacks">Drawbacks</a></li>
<li><a href="0585-improved-ember-registry-apis.html#alternatives">Alternatives</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#supply-just-schema-instead-of-capabilities">Supply just <code>schema</code> instead of <code>capabilities</code></a></li>
<li><a href="0585-improved-ember-registry-apis.html#a-new-string-based-api">A new String-based API</a></li>
<li><a href="0585-improved-ember-registry-apis.html#string-based-api-as-sugar">String-based API as “sugar”</a></li>
<li><a href="0585-improved-ember-registry-apis.html#object-based-api">Object-based API</a></li>
<li><a href="0585-improved-ember-registry-apis.html#do-nothing">Do nothing</a></li>
</ul>
</li>
<li><a href="0585-improved-ember-registry-apis.html#unresolved-questions">Unresolved questions</a></li>
<li><a href="0585-improved-ember-registry-apis.html#appendix-typescript">Appendix: TypeScript</a>
<ul>
<li><a href="0585-improved-ember-registry-apis.html#typescript-motivation">TypeScript motivation</a></li>
<li><a href="0585-improved-ember-registry-apis.html#proposed-type-definitions">Proposed type definitions</a></li>
</ul>
</li>
</ul>
<h2 id="motivation-144"><a class="header" href="#motivation-144">Motivation</a></h2>
<p>There are two primary motivations here: replacing the string-based microsyntax with an idiomatic JavaScript API, and making the API more amenable to correct types for TypeScript users.</p>
<h3 id="microsyntax-problems"><a class="header" href="#microsyntax-problems">Microsyntax problems</a></h3>
<p>The current design has worked well enough for a long time, but it adds conceptual overhead to learning how to use Ember. JavaScript has a lightweight and easy way of defining sets of related data: plain old JavaScript objects. By contrast, the existence of this Ember-specific microsyntax requires users to learn a new string-based syntax (which is <em>not</em> used elsewhere in the JavaScript community) and internalize how it works when they first encounter the registry APIs.</p>
<p>This need often comes relatively early in the learning process: the first time a user needs to write a unit test for a service. We currently devote <a href="https://guides.emberjs.com/release/applications/dependency-injection/#toc_factory-registrations">an entire section of the guides</a> to explaining how factory registrations work, including a paragraph devoted to explaining the microsyntax. A normal JavaScript API would simplify this entire section.</p>
<p>Changing to a normal JavaScript-object-based API means tooling can provide in-editor benefits around autocompletion for the API, which is simply not possible for the microsyntax. Finally, a non-microsyntax API will be more amenable to future codemods if this should need to change in the future.</p>
<h3 id="typescript-problems"><a class="header" href="#typescript-problems">TypeScript problems</a></h3>
<p>For TypeScript users, the current API is not type-safe, and can be made so only with considerable extra work by developers and the Typed Ember maintainers. Blueprint maintenance and end users’ mental overhead associated with existing solutions for Ember’s stringly-typed APIs would effectively have to <em>double</em> to provide type safety for today’s registry APIs. For details, see <a href="0585-improved-ember-registry-apis.html#appendix-typescript"><strong>Appendix: Typescript</strong></a>.</p>
<h3 id="performance-benefits"><a class="header" href="#performance-benefits">Performance benefits?</a></h3>
<p>Finally, there <em>may</em> be some very small performance wins here, since in this schema there is no need to parse a string. This is not considered to be a significant motivator, however, since the tradeoffs between object allocation (memory utilization) and string parsing (CPU utilization) are likely to be largely irrelevant in practice for this API.</p>
<h2 id="detailed-design-124"><a class="header" href="#detailed-design-124">Detailed design</a></h2>
<p>Every registry API will be updated to take a new <code>Identifier</code> type in place of the string microsyntax, while maintaining backwards compatibility by introducing versioning to the resolver. A codemod will be provided to allow users to migrate directly to the new API. The legacy resolver APIs are deprecated until Ember 4.0.</p>
<p>(TypeScript consumers should see <a href="0585-improved-ember-registry-apis.html#proposed-type-definitions"><strong>Proposed Type Definitions</strong></a> in the appendix for additional details on type safety and resolution.)</p>
<p><i><strong>Note:</strong> the diff views used throughout are meant to highlight the new APIs compared to the old, <em>not</em> to indicate the removal of the deprecated items. They will only be removed at Ember 4.0.</i></p>
<h3 id="identifier-types"><a class="header" href="#identifier-types"><code>Identifier</code> types</a></h3>
<p>The core new type in the design of the API is an <em>identifier</em>, which is always passed as the first argument to resolver APIs. There are three kinds of identifiers: <code>FactoryIdentifier</code> and <code>FactoryTypeIdentifier</code> (discussed here), and <code>InjectionIdentifier</code> (discussed below in <a href="0585-improved-ember-registry-apis.html#service-and-controller-injections"><strong>Session and Controller Injections</strong></a>).</p>
<pre><code class="language-ts">interface FactoryIdentifier {
  type: string;
  name: string;
  namespace?: string;
}
</code></pre>
<p>Here the <code>type</code> corresponds to the prefix component of the legacy API, and <code>name</code> to the postfix component of the legacy API: <code>service:foo</code> becomes <code>{ type: 'service', name: 'foo' }</code>.</p>
<p>The <code>namespace</code> field allows for identifiers to be restricted to a particular namespace, as in looking up a resolution from an addon. It is optional since it is not required in normal usage, as is the case in the microsyntax today, where it may be provided via a prefix and delimited with <code>@</code>: <code>&lt;namespace&gt;@&lt;type&gt;:&lt;name&gt;</code>. This also supports experimental tools which namespace lookups for addons (e.g. <a href="https://github.com/rwjblue/ember-holy-futuristic-template-namespacing-batman">ember-holy-futuristic-template-namespacing-batman</a>).</p>
<p>We also introduce <code>FactoryTypeIdentifier</code> to distinguish between injections for <em>all factories of a given type</em> (<code>FactoryTypeIdentifier</code>) and <em>specific factories</em> (<code>Identifier</code>):</p>
<pre><code class="language-ts">interface FactoryTypeIdentifier {
  type: string;
}
</code></pre>
<p>As is the case in the microsyntax-based design, these factory type injections may not be namespaced.</p>
<h3 id="resolver"><a class="header" href="#resolver"><code>Resolver</code></a></h3>
<p>Ember’s <code>Resolver</code> function is public API, designed to be customized and overridden. To support backwards compatibility with existing custom resolvers, and following the lead of the <a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md#capabilities">Custom Components RFC (#0213)</a> and the <a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md#capabilities">Element Modifiers RFC (#0373)</a>, we introduce a <code>capabilities</code> property to the <code>Resolver</code> API, which may be <code>undefined</code> or the return value of a new <code>capabilities</code> function, which defines a <code>Capabilities</code> type.</p>
<p>The <code>capabilities</code> function is a public export of the <code>@ember/application</code> module:</p>
<pre><code class="language-ts">interface OptionalCapabilities {
  modulesBased?: boolean;
  disableMicrosyntax?: boolean;
}

export function capabilities(compatVersion: '3.18', capabilities?: OptionalCapabilities): unknown;
</code></pre>
<p>The return type of <code>capabilities</code> is <code>unknown</code> for public consumers; the actual return type is private API and should not be relied on by implementors of custom resolvers.</p>
<p>The <code>modulesBased</code> capability rationalizes the existing <code>moduleBasedResolver</code> property on the <code>Resolver</code> class, integrating it into the new <code>capabilities</code> API.</p>
<p>During the 3.x Ember series, if <code>capabilities</code> is <code>undefined</code>, the legacy behavior of the resolver is maintained. The signature of the <code>Resolver</code> type is therefore:</p>
<pre><code class="language-ts">interface Resolver {
  capabilities?: Capabilities;
  resolve(identifier: string | FactoryIdentifier);
}
</code></pre>
<p>After Ember 4.0, the type a custom resolver must implement will be updated so that <code>capabilities</code> will be required and <code>resolve</code> will only accept a <code>FactoryIdentifier</code>:</p>
<pre><code class="language-ts">interface Resolver {
  capabilities: Capabilities;
  resolve(identifier: FactoryIdentifier);
}
</code></pre>
<p>This design is completely backwards compatible: it continues working exactly as it does today. (See <a href="0585-improved-ember-registry-apis.html#rollout"><strong>Detailed Design &gt; Rollout</strong></a> below for details.) Until 4.0, both apps and addons will be able to use the microsyntax-based API <em>or</em> the new identifier-based API. It also allows for clean interop for existing custom resolvers.</p>
<p>Besides the recent use of capabilities in the modifier and component managers, there is also some prior art for this kind of versioning applied to the resolver specifically: <a href="https://github.com/emberjs/ember.js/pull/9994">a similar “stamp”</a> was used for accomodating different behaviors when using the modules-based resolver vs. not (back in 2014)!</p>
<h3 id="owner-apis"><a class="header" href="#owner-apis">Owner APIs</a></h3>
<p>The owner APIs all change to use <code>Identifier</code> (or <code>FactoryTypeIdentifier</code> as appropriate) instead of strings. </p>
<p>Throughout, for the purposes of registration lookup, we use deep object value equality, <em>not</em> object identity. This specifically applies to:</p>
<ul>
<li><code>Owner.factoryFor</code></li>
<li><code>Owner.lookup</code></li>
<li><code>Owner.registerOptions</code></li>
<li><code>Owner.registerOptionsForType</code></li>
<li><code>Owner.registeredOption</code></li>
<li><code>Owner.registeredOptions</code></li>
<li><code>Owner.registeredOptionsForType</code></li>
<li><code>Owner.resolveRegistration</code></li>
</ul>
<h4 id="options"><a class="header" href="#options">Options</a></h4>
<p>Some <code>Owner</code> registry APIs take lookup or registration options. This RFC does not propose changing these options in any way, but their definitions are provided here for completeness:</p>
<pre><code class="language-ts">export interface LookupOptions {
  singleton?: boolean;
  instantiate?: boolean;
}

interface RegisterOptions {
  singleton?: boolean;
  instantiate?: boolean;
}
</code></pre>
<h4 id="factory-and-factorymanager"><a class="header" href="#factory-and-factorymanager"><code>Factory</code> and <code>FactoryManager</code></a></h4>
<p>Some APIs refer to <em>factories</em> and <em>factory managers</em>. The API for these classes adds a new <code>identifier</code> field and deprecates the <code>fullName</code> and <code>normalizedName</code> fields:</p>
<pre><code class="language-diff"> interface FactoryClass {
   positionalParams?: string | string[] | undefined | null;
 }
 
 interface Factory&lt;T, C extends FactoryClass | object = FactoryClass&gt; {
   class?: C;
-  fullName?: string; // DEPRECATED
-  normalizedName?: string; // DEPRECATED
+  identifier: FactoryIdentifier;
   create(props?: { [prop: string]: any }): T;
 }
 
 interface FactoryManager&lt;T = object&gt; {
   readonly class: Factory&lt;T&gt;;
-  readonly fullName?: string; // DEPRECATED
-  readonly normalizedName?: string; // DEPRECATED
+  identifier: FactoryIdentifier;
   create(props?: object): T;
 }
</code></pre>
<h4 id="owner-api-diff"><a class="header" href="#owner-api-diff"><code>Owner</code> API diff</a></h4>
<pre><code class="language-diff"> interface Owner {
-  factoryFor(fullName: string, options: LookupOptions): FactoryManager;
+  factoryFor(identifier: FactoryIdentifier, options: LookupOptions): FactoryManager;

-  hasRegistration(fullName: string): boolean;
+  hasRegistration(identifier: FactoryIdentifier): boolean;

-  inject(factoryNameOrType: string, property: string, injectionName: string): void;
+  inject(factory: FactoryIdentifier | FactoryTypeIdentifier, property: string, injection: FactoryIdentifier): void;

-  lookup(fullName: string, options?: LookupOptions): any;
+  lookup(identifier: FactoryIdentifier, options?: LookupOptions): any;

-  register(fullName: string, factory: any, options?: RegisterOptions): void;
+  register(identifier: FactoryIdentifier, factory: any, options?: RegisterOptions): any;

-  registerOptions(fullName: string, options: RegisterOptions): void;
+  registerOptions(identifier: FactoryIdentifier, options: RegisterOptions): any;

-  registerOptionsForType(fullName: string, options: RegisterOptions): void;
+  registerOptionsForType(identifier: FactoryTypeIdentifier, options: RegisterOptions): any;

-  registeredOption(fullName: string, optionName: string): RegisterOptions;
+  registeredOption(identifier: FactoryIdentifier, optionName: string): RegisterOptions;

-  registeredOptions(fullName: string): RegisterOptions;
+  registeredOptions(identifier: FactoryIdentifier): RegisterOptions;

-  registeredOptionsForType(type: string): RegisterOptions;
+  registeredOptionsForType(type: FactoryTypeIdentifier): RegisterOptions;

-  resolveRegistration(type: string): Factory;
+  resolveRegistration(identifier: FactoryIdentifier): Factory;

-  unregister(fullName: string): void;
+  unregister(identifier: FactoryIdentifier): void;
 }
</code></pre>
<h3 id="service-and-controller-injections"><a class="header" href="#service-and-controller-injections">Service and Controller Injections</a></h3>
<p>The other major examples of registry interactions are service and controller injections. This RFC proposes to normalize both to support the same identifier-based lookup as the <code>Owner</code> APIs.</p>
<p>We introduce an <code>InjectionIdentifier</code> type, representing the service or controller to be injected:</p>
<pre><code class="language-ts">interface InjectionIdentifier {
  name: string;
  namespace?: string;
}
</code></pre>
<p>The <code>inject</code> (whether <code>as service</code> or <code>as controller</code>) function now accepts <em>either</em> a string representing the local injection name (sans namespace) <em>or</em> an <code>InjectionIdentifier</code>:</p>
<ul>
<li>
<p><strong>Service:</strong></p>
<pre><code class="language-ts">export function inject(name: string): Service;
export function inject(identifier: InjectionIdentifier): Service;
</code></pre>
</li>
<li>
<p><strong>Controller:</strong></p>
<pre><code class="language-ts">export function inject(name: string): Controller;
export function inject(identifier: InjectionIdentifier): Controller;
</code></pre>
</li>
</ul>
<p>The <code>'&lt;namespace&gt;@&lt;name&gt;'</code> form is deprecated and will be removed at 4.0. The no-argument form, and the name-only string form are still allowed. Users <em>may</em> invoke using <code>{ name: '&lt;name&gt;' }</code> but are not required to.</p>
<ul>
<li>
<p><strong>Good</strong> (using services as an example):</p>
<pre><code class="language-js">import { inject as service } from '@ember/service';

export default class Example {
  @service foo;
  
  @service('bar')
  barRenamed;
  
  @service({ name: 'quux' })
  quuxViaIdentifier;
  
  @service({ namespace: 'baz', name: 'neato' })
  neatoNamespaced;
}
</code></pre>
</li>
<li>
<p><strong>Deprecated:</strong></p>
<pre><code class="language-js">import { inject as service } from '@ember/service';

export default class Example {
  @service('baz@neato') neatoNamespaced;
}
</code></pre>
</li>
</ul>
<h3 id="codemod-2"><a class="header" href="#codemod-2">Codemod</a></h3>
<p>All existing <em>static</em> microsyntax invocations can be straightforwardly migrated to the new syntax with a codemod. Some dynamic invocations will not be possible to migrate this way.</p>
<p>For example, this (in a test) is migrate-able:</p>
<pre><code class="language-diff">- this.owner.lookup('service:session');
+ this.owner.lookup({ type: 'service', name: 'session' });
</code></pre>
<p>But this is not:</p>
<pre><code class="language-js">function buildLookup(type, name) {
  return `${type}:${name}`;
}

this.owner.lookup(buildLookup('service', 'session'));
</code></pre>
<p>The majority of uses are likely to be codemoddable, but not <em>all</em> will.</p>
<h3 id="deprecation-messaging"><a class="header" href="#deprecation-messaging">Deprecation messaging</a></h3>
<h4 id="guide"><a class="header" href="#guide">Guide</a></h4>
<blockquote>
<h4 id="deprecate-registry-string-based-microsyntax"><a class="header" href="#deprecate-registry-string-based-microsyntax">Deprecate registry string-based microsyntax</a></h4>
<h5 id="until-400"><a class="header" href="#until-400">until: 4.0.0</a></h5>
<h5 id="id-ember-resolverstring-based-microsyntax"><a class="header" href="#id-ember-resolverstring-based-microsyntax">id: ember-resolver.string-based-microsyntax</a></h5>
<p>Ember has historically supported a string-based microsyntax of the format <code>'&lt;namespace&gt;@&lt;type&gt;:&lt;name&gt;'</code> (where both <code>&lt;namespace&gt;@</code> and <code>:&lt;name&gt;</code> are optional) for registering, resolving, looking up, and injecting items into Ember’s dependency injection container. These have been replaced with an object-based API where each part of the registry identifier is named explicitly.</p>
<p>You should replace calls using the string-based microsyntax with the new API. For example, these lookups in a test context:</p>
<pre><code class="language-js">this.owner.lookup('service:session');
this.owner.register(
  'shared@service:clipboard',
  class Clipboard {
    copyToClipboard(source) {/* no-op */}
  }
)
this.owner.inject('controller', 'session', 'service:session');
</code></pre>
<p>Should be changed to:</p>
<pre><code class="language-js">this.owner.lookup({ type: 'service', name: 'session' });
this.owner.register(
  { namespace: 'shared', type: 'service', name: 'clipboard' },
  class Clipboard {
    copyToClipboard(source) {/* no-op */}
  }
);
this.owner.inject(
  { type: 'controller' },
  'session',
  { type: 'service', name: 'session' }
);
</code></pre>
</blockquote>
<h4 id="in-app"><a class="header" href="#in-app">In-app</a></h4>
<p>Invocation of v0 resolver APIs which require a <code>FactoryIdentifier</code> will trigger the following deprecation message (using <code>lookup</code> as an example):</p>
<blockquote>
<p>You invoked <code>Owner.lookup</code> with a <code>string</code> full name: <code>'&lt;type&gt;:&lt;name&gt;'</code>. This usage is deprecated and will be removed in Ember 4.0. Instead, pass an object identifier: <code>{ type: '&lt;type&gt;', name: '&lt;name&gt;' }</code>.</p>
</blockquote>
<p>Here, the message should substitute the <em>actual</em> passed type and name. For example, if the user tried to look up a service named <code>session</code> by invoking <code>lookup('service:session')</code> the deprecation will read:</p>
<blockquote>
<p>You invoked <code>Owner.lookup</code> with a string full name: <code>'service:session'</code>. This usage is deprecated and will be removed in Ember 4.0. Instead, pass an identifier object: <code>{ type: 'service', name: 'session' }</code>.</p>
</blockquote>
<p>If the user tried to look up a service named <code>session</code> from the <code>shared</code> namespace by invoking <code>lookup('shared@service:session')</code> the deprecation will read:</p>
<blockquote>
<p>You invoked <code>Owner.lookup</code> with a string full name: <code>'shared@service:session'</code>. This usage is deprecated and will be removed in Ember 4.0. Instead, pass an identifier object: <code>{ namespace: 'shared', type: 'service', name: 'session' }</code>.</p>
</blockquote>
<p>For methods which require a <code>FactoryTypeIdentifier</code>, the wording is adjusted appropriately:</p>
<blockquote>
<p>You invoked <code>Owner.lookup</code> with a string type name: <code>'service'</code>. This usage is deprecated and will be removed in Ember 4.0. Instead, pass a factory type identifier object: <code>{ type: 'service' }</code>.</p>
</blockquote>
<p>Methods which support either <code>Identifier</code>s or <code>FactoryTypeIdentifier</code>s should display the appropriate variant of the message according to what the user actually supplied.</p>
<h3 id="rollout-1"><a class="header" href="#rollout-1">Rollout</a></h3>
<p>The rollout will be phased. For both Ember’s <code>Resolver</code> API and the default resolver supplied with <code>ember-resolver</code>:</p>
<ul>
<li>
<p>The new API will be introduced in a minor release as normal, <em>without</em> introducing the deprecation warning for the microsyntax-based design, and <em>including</em> the two codemods required for this API change: one for all Ember users, and one for TypeScript users (see <a href="0585-improved-ember-registry-apis.html#proposed-type-definitions"><strong>Proposed Type Definitions</strong></a> in the <a href="0585-improved-ember-registry-apis.html#appendix-typescript"><strong>TypeScript Appendix</strong></a> below.)</p>
</li>
<li>
<p>After <em>at least</em> one minor version, the deprecation message will be introduced. This will give addons time to adopt the new API <em>before</em> their consumers start experience deprecation noise from addon usage.</p>
</li>
</ul>
<p>For Ember only:</p>
<ul>
<li>We will supply a polyfill for the new behavior, supporting <em>at least</em> the current LTS. The behavior here can be polyfilled to many if not all existing LTS releases; we would likely limit this slightly, but would support <em>many</em> LTS releases.</li>
</ul>
<h2 id="how-we-teach-this-112"><a class="header" href="#how-we-teach-this-112">How we teach this</a></h2>
<ul>
<li>
<p><strong>New concepts:</strong> this RFC introduces the concept of an identifier through the <code>FactoryIdentifier</code>, <code>FactoryTypeIdentifier</code>, and <code>InjectionIdentifier</code> types. These define the arguments to the various registry functions. The basic shapes of these objects, and perhaps their names (as inline text like “factory identifier,” “factory type identifier,” and “injection identifier”) will need to be integrated into the guides and API docs. See also <a href="0585-improved-ember-registry-apis.html#unresolved-questions"><strong>Unresolved Questions</strong></a>: there may be other names which work better.</p>
</li>
<li>
<p>The existing documentation about dependency injection can unchanged apart from simplifications in certain key areas. Paragraphs explaining the microsyntax can be eliminated or simplified by showing the identifier object types. New Ember users will continue to benefit from the detailed introduction to the concepts in the guides, but will have one fewer concept to learn along the way.</p>
</li>
<li>
<p>All instances of the API documentation will need to be updated to reflect the changes to their signatures.</p>
</li>
<li>
<p>The deprecation message must be added to Ember’s deprecation page and tooling.</p>
</li>
<li>
<p>For the duration of Ember 3.x releases, the Guides and API docs will need explanations of the previous, deprecated APIs. These explanations should be brief, focused on how to migrate away from them preferably via the supplied codemod, rather than diving into the details of how the legacy system worked.</p>
</li>
</ul>
<h2 id="drawbacks-132"><a class="header" href="#drawbacks-132">Drawbacks</a></h2>
<ul>
<li>
<p>The existing APIs have served Ember well for a long time. Introducing any new change involves some risk, particularly in areas so core to how Ember behaves.</p>
</li>
<li>
<p>The proposed API here deprioritizes brevity in favor of clarity, readability, maintainability, tooling support, and being “normal” JavaScript. <code>'service:session'</code> is many fewer characters to type than <code>{ type: 'service', name: 'session' }</code>. (While many people highly value brevity and we should avoid overly verbose APIs, long experience suggests that <em>reading</em> and <em>changing</em> are more important than <em>first writing</em> code.)</p>
</li>
</ul>
<h2 id="alternatives-134"><a class="header" href="#alternatives-134">Alternatives</a></h2>
<h3 id="supply-just-schema-instead-of-capabilities"><a class="header" href="#supply-just-schema-instead-of-capabilities">Supply just <code>schema</code> instead of <code>capabilities</code></a></h3>
<p>Instead of the manager-inspired <code>capabilities</code> API, we could implement a simpler design with simply supplies a <code>schemaVersion</code> (or just <code>schema</code>) property on the <code>Resolver</code> type. This is less flexible, but also simpler.</p>
<pre><code class="language-ts">interface ResolverV0 {
  schemaVersion?: 0;
  resolve(fullName: string);
}
</code></pre>
<p>If <code>schemaVersion</code> is <code>1</code>, the <code>resolve</code> function has a new signature, using the <code>FactoryIdentifier</code> type introduced above:</p>
<pre><code class="language-ts">interface ResolverV1 {
  schemaVersion: 1;
  resolve(identifier: FactoryIdentifier)
}
</code></pre>
<p>The public API is <em>either</em> of the Resolver variants:</p>
<pre><code class="language-ts">type Resolver = ResolverV0 | ResolverV1;
</code></pre>
<p>The other registry API changes may also be implemented in terms of the new resolver <code>schemaVersion</code> check.</p>
<h3 id="a-new-string-based-api"><a class="header" href="#a-new-string-based-api">A new String-based API</a></h3>
<p>Instead of providing an object-based API, we could provide a new string-based API. The <code>lookup</code> method, then, would have a signature like this:</p>
<pre><code class="language-ts">interface Owner {
  lookup(type: string, name: string, options: Options);
}
</code></pre>
<p>This has the advantage of being a smaller diff from today’s world, and cutting down on the extra typing of the new API design:</p>
<pre><code class="language-diff">- lookup('service:foo')
+ lookup('service', 'foo')
</code></pre>
<p>vs.</p>
<pre><code class="language-diff">- lookup('service:foo');
+ lookup({ type: 'service', name: 'foo' })
</code></pre>
<p>This is a less flexible proposal, and—more importantly—it has a significant downside for usability beyond the simplest case. Supporting namespaces here would require <em>another</em> string argument, and functions with multiple arguments of the same type are notoriously easy to misuse. (“Wait, what’s the order? Namespace first or type first? Does namespace come after type, or after name?” etc.)</p>
<h3 id="string-based-api-as-sugar"><a class="header" href="#string-based-api-as-sugar">String-based API as “sugar”</a></h3>
<p>While this RFC recommends the object-based API as the <em>primary</em> API, we could supply the string-based API outlined above for the simple and most common case, so that this—</p>
<pre><code class="language-js">lookup('service', 'foo')
</code></pre>
<p>—would be equivalent to this:</p>
<pre><code class="language-js">lookup({ type: 'service', name: 'foo'})
</code></pre>
<p>This could be nice from an ergonomics perspective, and introduces only a small amount of extra complexity in the implementation: the resolver <code>capabilities</code> key still allows the implementation to distinguish between the <code>lookup('&lt;type&gt;:&lt;name&gt;')</code> form and the <code>lookup(type, name)</code> form.</p>
<p>However, it does require introspection on the arguments passed to the functions (extra implementation overhead), and it comes with confusion and arguments about which form to use: should users prefer the string based version where it is possible, or default to the object version for consistency? It would also means changes (e.g. to introduce a namespace) would become large and more error prone. Finally, as with the alternative where this is the <em>only</em> API, it is still less explicit and clear; users have to <em>remember</em> that <code>type</code> precedes <code>name</code>, whereas the object-form eliminates that issue.</p>
<h3 id="object-based-api"><a class="header" href="#object-based-api">Object-based API</a></h3>
<p>Another brief syntax might use the type as the key and the name as its value:</p>
<pre><code class="language-js">lookup({ service: 'foo' })
</code></pre>
<p>While this initially seems nice from the perspective of the consumer of the API, it muddies the API substantially and makes the implementation worse as well. </p>
<p>On the API front, for example, what would this mean?</p>
<pre><code class="language-js">lookup({ service: 'foo', route: 'bar' });
</code></pre>
<p>The API proposed by the RFC avoids this confusing scenario entirely!</p>
<p>As far as implementation goes, this would be more complex and have much worse performance: the lookup would have to iterate over all keys on the object passed every time, mapping those keys to the <em>known</em> identifer interface and then checking the others against the registry. This also makes the TypeScript implementation considerably more difficult, for similar reasons to the runtime implementation, but at compile time. (Implementer concerns should not be <em>primary</em>, but they are important, and here they have performance implications that, while not dramatic, can easily be avoided by other proposals.)</p>
<h3 id="do-nothing-2"><a class="header" href="#do-nothing-2">Do nothing</a></h3>
<p>Leaving the API as it is remains an option, with both the upsides and downsides of the <em>status quo</em>.</p>
<h2 id="unresolved-questions-88"><a class="header" href="#unresolved-questions-88">Unresolved questions</a></h2>
<ul>
<li>
<p>Is <code>@ember/application</code> the appropriate home for the new exports? Or should they liver somewhere else, such as <code>@ember/resolver</code> or <code>@ember/application/resolver</code>?</p>
</li>
<li>
<p>Is <code>FactoryIdentifier</code> the right name for the primary identifier interface? <code>Identifier</code> is shorter but overlaps with the notion of identifiers from Ember Data and is perhaps overly generic. We could use any of a number of other names:</p>
<ul>
<li><code>RegistrationIdentifier</code></li>
<li><code>RegistryIdentifier</code></li>
<li><code>FactoryId</code></li>
<li><code>RegistryId</code></li>
<li><code>RegistrationId</code></li>
<li>etc.</li>
</ul>
</li>
<li>
<p>Similarly, is <code>FactoryTypeIdentifier</code> the correct name? Alternatives might be:</p>
<ul>
<li><code>FactoryRegistrationIdentifier</code></li>
<li><code>FactoryTypeRegistrationIdentifier</code></li>
<li><code>FactoryRegistryIdentifier</code></li>
<li><code>FactoryTypeRegistryIdentifier</code></li>
<li><code>FactoryIdentifier</code> (mutually exclusive with using it as a replacement for <code>Identifier</code></li>
<li><code>FactoryRegistryId</code></li>
<li><code>FactoryTypeRegistryId</code></li>
<li>etc.</li>
</ul>
</li>
<li>
<p>Are <code>identifier</code> and <code>type</code> the right names for the arguments in the new design?</p>
</li>
</ul>
<h2 id="appendix-typescript"><a class="header" href="#appendix-typescript">Appendix: TypeScript</a></h2>
<p>This design is motivated in part by a desire for the API to better support type-safe TypeScript usage. This appendix explains the motivation and design as it impacts the declarations maintained by the Typed Ember team. The big idea here is to make registry lookups type-safe, including support for autocomplete and refactoring, while not making the boilerplate situation <em>worse</em> (eliminating it entirely is unfortunately not yet possible).</p>
<h3 id="typescript-motivation"><a class="header" href="#typescript-motivation">TypeScript motivation</a></h3>
<p>The type definitions for Ember currently make use of a pattern we call a “type registry”: a mapping of <em>strings</em> to <em>types</em>. This allows the types to safely represent string-based lookups like <code>story.findRecord('some-model')</code> or <code>service('session')</code>.</p>
<p>For example, to make service lookups work with the classic API, users had to write something like this:</p>
<pre><code class="language-ts">import Service from '@ember/service';

export default class Session extends Service {
  login(email: string, password: string) {
    // ...
  }
  
  logout() {
    // ...
  }
}

declare module '@ember/service' {
  interface Registry {
    session: Session;
  }
}
</code></pre>
<p>Then, users could write fairly idiomatic Ember and have the types resolve correctly:</p>
<pre><code class="language-ts">import Component from '@ember/component';
import { inject as service } from '@ember/service';

export default Component.extend({
  session: service('session'), // type: `Session`
})
</code></pre>
<p>The Typed Ember blueprints generate that boilerplate for users, which (hopefully) minimizes the pain of working with these definitions. However, to make this work for the registry APIs, users (and therefore the blueprints) would have to add <em>another</em> declaration to the bottom of the file:</p>
<pre><code class="language-diff">  import Service from '@ember/service';
  
  export default class Session extends Service {
    login(email: string, password: string) {
      // ...
    }
    
    logout() {
      // ...
    }
  }
  
  declare module '@ember/service' {
    interface Registry {
      session: Session;
    }
  }
  
+ declare module 'TBD-some-registry-spot' {
+   interface Registry {
+     'service:session': typeof Session;
+   }
+ }
</code></pre>
<p>This <em>works</em>, but is additional boilerplate and, more importantly, <em>duplication of information</em>, which can get out of sync. Both of these problems are avoided by the new design proposed by this RFC. With the new design, users would still need the same boilerplate required today, but the types for <code>lookup</code> and other registry APIs can be extended in a way transparent to users so that they “just work” with <em>zero</em> additional effort, as covered in the next section.</p>
<h3 id="proposed-type-definitions"><a class="header" href="#proposed-type-definitions">Proposed type definitions</a></h3>
<p>If we were to ship this, we would make one significant change to the <em>existing</em> types on DefinitelyTyped, supplying a codemod for ember-cli-typescript users. Where today, the various type registries refer to the class types, we would update them to refer to the <em>constructor</em> type for the class. For example, for the service registry:</p>
<pre><code class="language-diff"> interface Registry {
-  session: Session;
+  session: typeof Session;
 }
</code></pre>
<p>This single change unlocks the ability to rigorously and exhaustively supply types for the API proposed above, with no further changes to existing user code.</p>
<p>We would introduce the following types at DefinitelyTyped for the new API, along with rigorous type tests to guarantee they provide the guarantees they specify. (A basic working demo of this is available on <a href="https://www.typescriptlang.org/play/index.html#code/PTAEFpM0BcE8AOBTUBXGBLANhzSDOEU4oIAUGfMqAMID2AdvjAE6oDGMdLAgiwOb4APABUAfKAC8oEaCQAPGEgYATQgyQB3UAAoAdAYCGA-AC5QGBgDMkLUAFUAlFImoGAawZ1NDUAH4HUHMNADdbAG4KKhQASSYYQwZ2JAB5K1EJaVkFJVV1LV0DPWNBc0S4Z0kJSxs7ACV-UAbgpDCWSLIQIihQBBYkcAUMZkt+UH7+YdY4WEQCUE1cAAtQQwQ+uj6MQyVQdiXE-nniEnIySyUWK0Nk0ABlWxCMZLqkSeYWGYBvMlBQfAI+AwjHM0ToVnugOBDEiAF8KBdbNdbvQGKw6FgsLZXu9pqAfn81ggcOwdtDQXNwaAeOsSWTGKj0ZiImR4ec0UibigRHMcVNPvjfv9Hs8kOYHiwni83vy4JE-uxGEysSxzIyWBiVXyPnLWRQuidZshCFwLABbYlIM3KGCwJbDJoAMRo3WgZ0RVy5oEdNy4nxiKhtGCsGFsQiFPOoOWUalA7iQcCpkaQ2umABohQA5QzWuSKGOEeOJiHJ1OfADayYAumQJASjWKZHN5aAGDnG9nrS229b8AguX5zB9RnCERzPbcfZxuHBkwGgyGw8m87lY0Wk7yZTq60LouZk6P2ZdkSgJVKkHEAFZITjQ+do4OhlhCTsoaN5OMJqln0VluA7v4ew7dtu3bPsByHVgRz1TowAUBBuCUFRVkIAADSxr04VC01bdtkNQgFJVFVDQCWWwUCsbg9kYMIGFDJIkDIQN2CwYwKLcW9GGFIjkhfdsVwLT9i0hHiUy3aYxB0IDzFfRxzDiZhEmSNIhB-aVcQrV8qzESJmNY-pQCsDjMC4wjzz43N3zXL8ITUsSNP-HQhQwQMH0XVURPPK8bxMhh70wdyLKQMQyDk0AFISBiVLsv9yy0nSx2PL11U1WxvM4vzXICp8goEj91whFLmRYP8ANw60ZJAoUgPA5JB3+KCGH4Q89LYwzjOhai0Q1YrcqswsbNoJUeq1cTPkk6TQFk+T4iU1J0iK0aHLi9ttN0m99PYpJfK65Uw1fPLrOExbsTGxznKyx9bDVYbUpYdLfP8q7n1fEKwoiuaVJOkqzpW601v1OD5AQlgkJQ0B0IYTCYGw8qkHwxVurukiyIMyi7ER2j6OSCh4MQixxxPUAABk6DodxUAQFIEF8wh6yBJqsS4Bh6oAIzJrFEhbSxFIfHYkDZjmkC5oV8DoVAWDqyCWGgwCwP7KWGplprDw9InU1sanacFP4Gf4JnGEFjFhZhZzZr5pQjc5022TVr0pz9OAAFlEkMI5nxoVj8HwMqWMMb21S9-AW3Yfp+acv4-ksXBtiwAA1QwsFQAh6vrSPQHLABpAmhKpD6ooWoOxCrer8+Uwv-Z9rOqxbP54T+d7zfLoRPcrhLbcJ+3fRnFui51vYg8DyuQ7DpQI8j6PMEThOk5T8w08jrOc4K8Km-m3u25Lmbeeb1vvbEava9AevQEbnf173n3Vc724Uh8Wx++RR3HW4cN0+Xfrc5LTcHIzdODs-ivUsv1qxCkkkKKOl13LmAdjOJ6gVkw4Ven-SOmxab1VJuTSmWtoT4CFGFWBnwXZtndqIH+spKxzCrH9JAAMhQHHwGWekDA36Rw-vmfKg1gG-wgVNfigCuHkJ1JQ5ANY-jgPTi5BcT4YHd39FAnKiC+HWhCg3cw7NjYizNtDVhfx2GrgGsJbhsoUF-AARwo6G5kCxVAeI8efwn4zlkdOeR0ilxzCQe2CQAAfb0cjZxzHgYouYYhTG9A1MgUGcBpajDCRhHy5I-EuLgEE9xyBPEqPweYEIdAXIdD+FgMmFMEC6KbFGCxhirH2RMbw8xBiv5lOqcI2xoAJETwUddJJjtUnPiUcg3haDcEYKKdgmmuCsmr3PipYxzSqE0LoX8CYUwwy8P0YJIBQj0y1P4RUhpMzpgiNoWA+xFgOkeUISks5ZD0nKOCmExxnwygMDgGEwZjB8D1Q1iwHB7yJk5LyRQRZ4lNZjPeaUtZnCjGbM+GEup6zBHWJAVQ45vCpFuRkV0uBVy+leNeaCpg5gvk-KYH83JKh8njGBd8-F+AX4sGTNct8uyNmIocm0yBbjzn+LnNikJeLaaEqpcSvBajQD-PJYCyluJyIqGJeCuYh1Knf1ZTU-+Oz6ksqaQc6sYTiVwshVSIlNKUWSLOc47pvKbn9PTm8hgr5zB6vbBMgACs8dwQgjW0xwo6lRFKlnMBlcK+V5SNUIq1TC7ZllmVhpsciuxqKzWYtceitJSAMnBQmZ63BfqqXw2FXShlELLHKvDeddOe4k0BOQD0xlqjT6CuldS2mOaxZYDCEw3ywamWhqhSqnUsL1Xwt7aWw5YjWknLRdlTpFya04syaKi5jLY2iPmQlIUbh-WXC7YqvZ0KXmRu7UOqpy6jnxtNZy81WLOWMvTXWsK4rDwGmIA2Qg6NQCBjNHQV0pxgAUD9t7SE3tOr1kRh8DgfodBbBCPzUA3gNAeTvvB5wXw2QFLoJMBgOhUCEXtUrWJvRK6aG4CoGJTUwrOo1GaYYSAhDirKkCmAEtfAUboFRgEeh+itrCDoL4aAcPthwv2b2RGWDIVhI4PQMAyKYZ0JUejkdQPGz0IU-gOgABE+AODJG9gAQjU44I+4mWyob47YVOvDsO2Fw8OFWQpYSHn-YQGkxJnjMO+v3VqBlP2BiwPPVswsuDqKFokY+LUNptSZrB++CHouREiwCIDjALlSCi-BvQDy4B0p4w2cwGmRTJDUzhSaeXEsMDU8fAzZBIsPFK5fFLCWgRJf8XoRzcWkC2ga9CAAmkgBAKWNDaBq41hgl8dBwdsJV+LUJGCZk2CgaQA3APDdGwZ0gYAAAkABRYGPlNssA1CwKr7XhSlc22aVmtgsAzGkJ1prySWujyQDx9dhF54Wf4xVUAan2aszU3Z1kEmVOWB0AAch+yDnCIOhP4BEyoEHlWyDjZYMpkZCBssVrU4jPaLBCtw1y5eYwrMsT4HK0ZtboAts7c4Htg7FAkccdzbK-F49eMY6xyNWwuPitEjpL5UnKC1M80ilPJQf2JNC8SCLpAHR6eFKwWj1ncxctmVFFz9syvptlYqyjjD6mfu47U9D2H+nIiy9R+jpXX32d3TV59tTPPXN8+195pAWBTfRYZ1x8NzCLfIFy9b4qtvGz29pI76EpOJOhwC09+sLvfP90AgFugoI2CMTrgDmXHu5fFN942EHAeVQQ7x6AEHDvSS+RBxVunHuN1Utzxr0SQeNelYjx0FXyRQe3YYPDyI7eY-F5B13yvRmyB9+y5NQfmui81QVnn-WdBWaJ2HwjgvthQdl+YT3sgq+WDj-VyXjfFeKuRB33vz7pfQ-l+hNP+WXJzCD9YwMZQGGkDL8iEAA">this TypeScript playground</a>.)</p>
<p><strong>Note:</strong> the injection types for service and controller are <em>slightly</em> simplified here to demonstrate how they work in practice; in fact they will include the appropriate <code>PropertyDecorator</code> semantics (as they do today).</p>
<pre><code class="language-ts">// ----- type utilities ----- //

type ConstructorArgs&lt;T&gt; = T extends new (...args: infer U) =&gt; unknown ? U : never;

type InstanceOf&lt;T&gt; = T extends new (...args: any) =&gt; infer R ? R : never;

// ----- types to implement this RFC ----- //

// NOTE: some of these lookups will be newly defined as part of this
//       project, e.g. the registries for routes and components.
interface TypeRegistry {
  service: import('@ember/service').Registry;
  controller: import('@ember/controller').Registry;
  route: import('@ember/routing/route').Registry;
  component: import('@typed-ember/component').Registry;
  adapter: import('ember-data/types/registries/adapter').default;
  model: import('ember-data/types/registries/model').default;
  serializer: import('ember-data/types/registries/serializer').default;
  transform: import('ember-data/types/registries/transform').default;
}

interface FactoryIdentifier&lt;
  Type extends keyof TypeRegistry,
  Name extends keyof TypeRegistry[Type]
&gt; {
  type: Type;
  name: Name;
  namespace?: string;
}

interface FactoryTypeIdentifier&lt;Type extends keyof TypeRegistry&gt; {
  type: Type;
}

export interface LookupOptions {
  singleton?: boolean;
  instantiate?: boolean;
  source?: string;
  namespace?: string;
}

interface RegisterOptions {
  singleton?: boolean;
  instantiate?: boolean;
}

interface FactoryManager&lt;Class&gt; {
  class: Class;
  create(
    initialValues?: {
      [K in keyof InstanceOf&lt;Class&gt;]?: InstanceOf&lt;Class&gt;[K];
    }
  ): InstanceOf&lt;Class&gt;;
}

interface Factory&lt;Class&gt; {
  class: Class;
  create(
    initialValues?: {
      [K in keyof InstanceOf&lt;Class&gt;]?: InstanceOf&lt;Class&gt;[K];
    }
  ): InstanceOf&lt;Class&gt;;
}

interface Owner {
  factoryFor&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;,
    options?: LookupOptions
  ): FactoryManager&lt;TypeRegistry[Type][Name]&gt;;

  hasRegistration&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;
  ): boolean;

  inject&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    factory: FactoryIdentifier&lt;Type, Name&gt; | FactoryTypeIdentifier&lt;Type&gt;,
    property: string,
    injection: FactoryIdentifier&lt;Type, Name&gt;
  ): void;

  lookup&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;,
    options?: LookupOptions
  ): InstanceOf&lt;TypeRegistry[Type][Name]&gt;;

  register&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;,
    factory: any,
    options?: RegisterOptions
  ): void;

  registerOptions&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;,
    options: RegisterOptions
  ): void;

  registerOptionsForType&lt;Type extends keyof TypeRegistry&gt;(
    identifier: FactoryTypeIdentifier&lt;Type&gt;,
    options: RegisterOptions
  ): void;

  registeredOption&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type],
    OptionName extends keyof RegisterOptions
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;,
    optionName: OptionName
  ): Pick&lt;RegisterOptions, OptionName&gt;;

  registeredOptions&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;
  ): RegisterOptions;

  registeredOptionsForType&lt;Type extends keyof TypeRegistry&gt;(
    type: FactoryTypeIdentifier&lt;Type&gt;
  ): RegisterOptions;

  resolveRegistration&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;
  ): Factory&lt;TypeRegistry[Type][Name]&gt;;

  unregister&lt;
    Type extends keyof TypeRegistry,
    Name extends keyof TypeRegistry[Type]
  &gt;(
    identifier: FactoryIdentifier&lt;Type, Name&gt;
  ): void;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-04-17
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/615</p>
<hr />
<h1 id="autotracking-memoization"><a class="header" href="#autotracking-memoization">Autotracking Memoization</a></h1>
<h2 id="summary-145"><a class="header" href="#summary-145">Summary</a></h2>
<p>Provides a low-level primitive for memoizing the result of a function based on
autotracking, allowing users to create their own reactive systems that can
respond to changes in autotracked state.</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { createCache, getValue } from '@glimmer/tracking/primitives/cache';

let computeCount = 0;

class Person {
  @tracked firstName = 'Jen';
  @tracked lastName = 'Weber';

  #fullName = createCache(() =&gt; {
    ++computeCount;
    return `${this.firstName} ${this.lastName}`;
  })

  get fullName() {
    return getValue(this.#fullName);
  }
}

let person = new Person();

console.log(person.fullName); // Jen Weber
console.log(count); // 1;
console.log(person.fullName); // Jen Weber
console.log(count); // 1;

person.firstName = 'Jennifer';

console.log(person.fullName); // Jennifer Weber
console.log(count); // 2;
</code></pre>
<h2 id="motivation-145"><a class="header" href="#motivation-145">Motivation</a></h2>
<p>Autotracking is the fundamental reactivity model within Ember Octane, and has
been highly successful so far in its usage and adoption. However, users today
can only integrate with autotracking via the <code>@tracked</code> decorator, which allows
them to <em>create</em> tracked root state. There is no way to write code that responds
to changes in that root state directly - the only way to do so is indirectly via
Ember's templating layer.</p>
<p>An example of where users might want to do this is the <a href="https://github.com/emberjs/rfcs/pull/566"><code>@cached</code></a>
decorator for getters. This decorator only reruns its code when the tracked
state it accessed during its previous computation changes. Currently, it would
be quite difficult and error prone to build this decorator with public APIs.</p>
<p>For a more involved example, we can take a look at <a href="http://ember-concurrency.com/">ember-concurrency</a>,
which allows users to define async tasks. Ember Concurrency has an <code>observes()</code>
API for tasks, which allows tasks to rerun when a property changes. This API is
not documented or encouraged, and instead lifecycle hooks are recommended to
rerun tasks. However, in Octane, lifecycle hooks on components are no longer
available, removing that as an option. A more ergonomic, autotracked version of
concurrency tasks could be created if users had a way to react to changes in
autotracked state.</p>
<p>Data layers like Ember Data could also benefit from this capability. These
layers tend to have to keep state in sync between multiple levels of caching,
which traditionally was done with computed properties and eventing systems. The
ability to use autotracking to replace these systems, and to define their own
reactive semantics, could help complex libraries and data layers out immensely.</p>
<h2 id="detailed-design-125"><a class="header" href="#detailed-design-125">Detailed design</a></h2>
<p>This RFC proposes four functions to be added to Ember's public API:</p>
<pre><code class="language-ts">interface Cache&lt;T = unknown&gt; {}

function createCache&lt;T&gt;(fn: () =&gt; T): Cache&lt;T&gt;;

function getValue&lt;T&gt;(cache: Cache&lt;T&gt;): T

function isConst(cache: Cache): boolean;
</code></pre>
<p>These functions are exposed as exports of the <code>@glimmer/tracking/primitives/cache</code>
module:</p>
<pre><code class="language-ts">import {
  createCache,
  getValue,
  isCache,
  isConst,
} from '@glimmer/tracking/primitives/cache';
</code></pre>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<p><code>createCache</code> receives a function, and returns a cache instance for that function.
Users can call <code>getValue()</code> with the cache instance as an argument to run the
function and get the value of its output. The cache will then return the same
value whenever <code>getValue</code> is called again, until one of the tracked values that
was <em>consumed</em> while it was running previously has been <em>dirtied</em>.</p>
<pre><code class="language-ts">class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() =&gt; {
  // consume the state
  state.value;

  return ++computeCount;
});

getValue(counter); // 1
getValue(counter); // 1

state.value = 'foo';

getValue(counter); // 2
</code></pre>
<p>Getting the value of a cache also <em>consumes</em> the cache. This means caches can be
nested, and whenever you use a cache inside of another cache, the outer cache
will dirty if the inner cache dirties.</p>
<pre><code class="language-ts">let inner = createCache(() =&gt; { /* ... */ })

let outer = createCache(() =&gt; {
  /* ... */

  inner();
});
</code></pre>
<p>This can be used to break up different parts of a execution so that only the
pieces that changed are rerun.</p>
<h3 id="constant-caches"><a class="header" href="#constant-caches">Constant Caches</a></h3>
<p>Caches will only recompute if any of the tracked inputs that were consumed
previously change. If there <em>were</em> no consumed tracked inputs, then they will
never recompute.</p>
<pre><code class="language-ts">let computeCount = 0;

let counter = createCache(() =&gt; {
  return ++computeCount;
});

getValue(counter); // 1
getValue(counter); // 1
getValue(counter); // 1

// ...
</code></pre>
<p>When this happens, it often means that optimizations can be made in the code
surrounding the computation. For instance, in the Glimmer VM, we don't emit
updating bytecodes if we detect that a memoized function can never change, because
it means that this piece of DOM will never update.</p>
<p>In order to check if a memoized function is constant or not, users can use the
<code>isConst</code> function:</p>
<pre><code class="language-ts">import { createCache, getValue, isConst } from '@glimmer/tracking/primitives/cache';

class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() =&gt; {
  // consume the state
  state.value;

  return ++computeCount;
});


let constCounter = createCache(() =&gt; {
  return ++computeCount;
});

getValue(counter);
getValue(constCounter);

isConst(counter); // false
isConst(constCounter); // true
</code></pre>
<p>It is not possible to know whether or not a cache is constant before its
first usage, so <code>isConst</code> will throw an error if the cache has never been
accessed before.</p>
<pre><code class="language-ts">
let constCounter = createCache(() =&gt; {
  return count++;
});

isConst(constCounter); // throws an error, `constCounter` has not been used
</code></pre>
<p>This helps users avoid missing optimization opportunities by mistake, since most
optimizations happen on the first run only. If a user calls <code>isConst</code> on the
function prior to the first run, they may assume that the function is
non-constant on accident.</p>
<h2 id="how-we-teach-this-113"><a class="header" href="#how-we-teach-this-113">How we teach this</a></h2>
<p>This topic is one that is meant for advanced users and library authors. It
should be covered in detail in the Autotracking In-Depth guide in the Ember
guides.</p>
<p>This guide should cover how memoization works, and various techniques for using
memoization. It should cover a variety of ways to use memoization to accomplish
common tasks of other reactivity systems. Pull-based reactivity is unfamiliar to
many programmers, so we should try to familiarize them with as many common
examples as possible.</p>
<p>Some possibilities include:</p>
<ul>
<li>Building the <code>@cached</code> decorator from scratch.</li>
<li>Building a data layer that syncs changes to models to localStorage or a
backend in real time, as the changes occur (note: requires polling of some
kind, or a component to do this).</li>
<li>Building a <code>RemoteData</code> implementation, a helpful wrapper that sends a fetch
request to a remote url and loads data whenever the url input changes.</li>
</ul>
<h3 id="api-docs-4"><a class="header" href="#api-docs-4">API Docs</a></h3>
<h4 id="createcache"><a class="header" href="#createcache"><code>createCache</code></a></h4>
<p>Receives a function, and returns a wrapped version of it that memoizes based on
<em>autotracking</em>. The function will only rerun whenever any tracked values used
within it have changed. Otherwise, it will return the previous value.</p>
<pre><code class="language-ts">import { tracked } from '@glimmer/tracking';
import { createCache, getValue } from '@glimmer/tracking/primitives/cache';

class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() =&gt; {
  // consume the state. Now, `counter` will
  // only rerun if `state.value` changes.
  state.value;

  return ++computeCount;
});

getValue(counter); // 1

// returns the same value because no tracked state has changed
getValue(counter); // 1

state.value = 'foo';

// reruns because a tracked value used in the function has changed,
// incermenting the counter
getValue(counter); // 2
</code></pre>
<h4 id="getvalue"><a class="header" href="#getvalue"><code>getValue</code></a></h4>
<p>Gets the value of a cache created with <code>createCache</code>.</p>
<pre><code class="language-ts">import { tracked } from '@glimmer/tracking';
import { createCache, getValue } from '@glimmer/tracking/primitives/cache';

let computeCount = 0;

let counter = createCache(() =&gt; {
  return ++computeCount;
});

getValue(counter); // 1
</code></pre>
<h4 id="isconst"><a class="header" href="#isconst"><code>isConst</code></a></h4>
<p>Can be used to check if a memoized function is <em>constant</em>. If no tracked state
was used while running a memoized function, it will never rerun, because nothing
can invalidate its result. <code>isConst</code> can be used to determine if a memoized
function is constant or not, in order to optimize code surrounding that
function.</p>
<pre><code class="language-ts">import { tracked } from '@glimmer/tracking';
import { createCache, getValue, isConst } from '@glimmer/tracking/primitives/cache';

class State {
  @tracked value;
}

let state = new State();
let computeCount = 0;

let counter = createCache(() =&gt; {
  // consume the state
  state.value;

  return computeCount++;
});


let constCounter = createCache(() =&gt; {
  return computeCount++;
});

getValue(counter);
getValue(constCounter);

isConst(counter); // false
isConst(constCounter); // true
</code></pre>
<p>If called on a cache that hasn't been accessed yet, it will throw an
error. This is because there's no way to know if the function will be constant
or not yet, and so this helps prevent missing an optimization opportunity on
accident.</p>
<h2 id="alternatives-135"><a class="header" href="#alternatives-135">Alternatives</a></h2>
<ul>
<li>
<p>Stick with higher level APIs and don't expose the primitives. This could lead
to an explosion of high level complexity, as Ember tries to provide every type
of construct for users to use, rather than a low level primitive.</p>
</li>
<li>
<p>Expose a more functional or more object-oriented API. This would be a somewhat
higher level API than the one proposed here, which may be a bit more
ergonomic, but also would be less flexible. Since this is a new primitive and
we aren't sure what features it may need in the future, the current design
keeps the implementation open and lets us experiment without foreclosing on a
possible higher level design in the future.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-04-22
Relevant Team(s): All teams
RFC PR: https://github.com/emberjs/rfcs/pull/617</p>
<hr />
<h1 id="rfc-stages"><a class="header" href="#rfc-stages">RFC Stages</a></h1>
<h2 id="summary-146"><a class="header" href="#summary-146">Summary</a></h2>
<p>Ember's users should be able to look at an RFC and know more about how close it is to being part of a stable release. This proposal introduces explicit stages for RFCs, covering the steps from the initial draft to the shipped result. Inspired by TC39, these stages are a communication and collaboration tool. They can give the community greater visibility into Ember's development, encourage participation, and improve cross-team coordination. This RFC does not aim to substantially change the existing process, but rather apply labels to what already happens informally.</p>
<h2 id="motivation-146"><a class="header" href="#motivation-146">Motivation</a></h2>
<p>It can be difficult for both users and contributors of Ember to know the status of a new feature. Has it been approved? Is it a work in progress? What still needs to be done? Which version of Ember did it ship in?</p>
<p>We can see that stages are needed when we consider the following:</p>
<ol>
<li>Community feedback that it was difficult to follow along with the progression of Ember Octane's features</li>
<li>Challenges uncovered in the existing RFC Tracking process</li>
<li>The long-standing, but stagnant goal of providing a public-facing status board</li>
<li>Confusion about what it means for an RFC to be merged. There is a common myth that a merged RFC indicates that a feature will be in the next release, when instead it is a green flag for implementation work to begin.</li>
</ol>
<p>To understand the problem, it is helpful to think of the informal stages a merged RFC already can progress through: We have RFCs for which we have needed to indicate a change in direction (<a href="https://emberjs.github.io/rfcs/0143-module-unification.html">MU</a>), RFCs that have needed to be clarified/replaced (<a href="https://emberjs.github.io/rfcs/0226-named-blocks.html">Named Blocks</a>), RFCs waiting to be implemented, and RFCs whose features have been included in a stable release. Each of these scenarios was handled in a thoughtful manner, but they were difficult for users to follow along with.</p>
<p>This proposal aims to build on the success of RFC 300, <a href="%5Bhttps://github.com/emberjs/rfcs/blob/master/text/0300-rfc-process-update.md%5D(https://github.com/emberjs/rfcs/blob/master/text/0300-rfc-process-update.html">RFC (Request for Comments) Process Update</a>.</p>
<h2 id="detailed-design-126"><a class="header" href="#detailed-design-126">Detailed design</a></h2>
<h3 id="current-process"><a class="header" href="#current-process">Current Process</a></h3>
<p>For details of the current RFC process, see the current <a href="https://github.com/emberjs/rfcs/blob/2a7b9e8605a56277a4dd515bf8e192d9ac09c12f/README.md">README of the RFCs repo</a>:</p>
<h3 id="stages"><a class="header" href="#stages">Stages</a></h3>
<p>A successful RFC can move through the following sequential stages. Whenever an RFC moves to the next stage, there is a PR to update it.</p>
<table><thead><tr><th>Stage</th><th>Description</th><th>Requires FCP to enter?</th></tr></thead><tbody>
<tr><td><a href="0617-rfc-stages.html#Proposed">0 - Proposed</a></td><td>A proposal for a change to Ember or its processes that is offered for community and team evaluation.</td><td>no</td></tr>
<tr><td><a href="0617-rfc-stages.html#Exploring">1 - Exploring</a></td><td>An RFC deemed worth pursuing but in need of refinement.</td><td>no</td></tr>
<tr><td><a href="0617-rfc-stages.html#Accepted">2 - Accepted</a></td><td>A fully specified RFC. Waiting for or in the process of implementation.</td><td>yes</td></tr>
<tr><td><a href="0617-rfc-stages.html#Ready-for-Release">3 - Ready for Release</a></td><td>The implementation of the RFC is complete, including learning materials.</td><td>yes</td></tr>
<tr><td><a href="0617-rfc-stages.html#Released">4 - Released</a></td><td>The work is published. If it is codebase-related work, it is in a stable version of the relevant package(s).</td><td>no</td></tr>
<tr><td><a href="0617-rfc-stages.html#Recommended">5 - Recommended</a></td><td>The feature/resource is recommended for general use.</td><td>yes</td></tr>
</tbody></table>
<p>There are two additional statuses for RFCs that will not move forward:</p>
<ul>
<li><strong><a href="0617-rfc-stages.html#Discontinued">Discontinued</a></strong> - a previously Accepted RFC that is either in conflict with Ember's evolving programming model or is superseded by another active RFC.</li>
<li><strong><a href="0617-rfc-stages.html#Closed">Closed</a></strong> - Proposed RFCs that will not be moved into the next stage.</li>
</ul>
<h4 id="proposed"><a class="header" href="#proposed">Proposed</a></h4>
<p>Proposed RFCs are opened as pull requests to the RFC repository. Anybody may 
create an RFC. The format should follow the templates in the RFC repository. 
There is currently a default template and a deprecation RFC template. This 
process is discussed in depth in the RFCs repo README.</p>
<p>An RFC's number is the number of it's original proposal PR.</p>
<p>From &quot;Proposed&quot; an RFC may move to <a href="0617-rfc-stages.html#Exploring">Exploring</a>,
or <a href="0617-rfc-stages.html#Closed">Closed</a> stages.
To move to <a href="0617-rfc-stages.html#Closed">Closed</a> an FCP is required as in the existing process.
A &quot;Proposed&quot; RFC may be moved to &quot;Exploring&quot; by consensus of the relevant
team(s) without an FCP. See <a href="0617-rfc-stages.html#Exploring">Exploring</a>.</p>
<h4 id="exploring"><a class="header" href="#exploring">Exploring</a></h4>
<p>An Exploring RFC is one the Ember team believes should be pursued, but the RFC 
may still need some more work, discussion, answers to open questions, 
and/or a champion before it can move to the next stage. </p>
<p>An RFC is moved into Exploring with consensus of the relevant teams. The 
relevant team expects to spend time helping to refine the proposal. The
RFC remains a PR and will have an <code>Exploring</code> label applied.</p>
<p>An Exploring RFC that is successfully completed can move to <a href="0617-rfc-stages.html#Accepted">Accepted</a> 
with an FCP is required as in the existing process.</p>
<h4 id="accepted"><a class="header" href="#accepted">Accepted</a></h4>
<p>An RFC that has been &quot;accepted&quot; has complete prose and has successfully passed
through an &quot;FCP to Accept&quot; period in which the community has weighed in and consensus 
has been achieved on the direction. The relevant teams believe that the 
proposal is well-specified and ready for implementation. 
The RFC has a champion within one of the relevant teams. </p>
<p>This is equivalent to today's RFCs being merged.</p>
<p>If there are unanswered questions, we have outlined them and expect that they 
will be answered before <a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a>.</p>
<p>When an RFC is merged and moved to &quot;Accepted&quot;, a new PR will be opened to move 
it to <a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a>. This PR should be used to track 
the implementation progress and gain consensus to move to that next stage.</p>
<h4 id="ready-for-release"><a class="header" href="#ready-for-release">Ready for Release</a></h4>
<p>The implementation is complete according to plan outlined in the RFC, 
and is in harmony with any changes in Ember that have occurred since the RFC was first written.
This includes any necessary learning materials.
At this stage, features or deprecations may be available for use behind a feature flag,
or with an optional package, etc. 
The team reviews the work to determine when it can be included in a stable release.
For codebase changes, there are no open questions that are anticipated to require
breaking changes; the Ember team is ready to commit to the stability of any 
interfaces exposed by the current implementation of the feature.
Today, this would be the &quot;go/no-go&quot; decision by a particular team. </p>
<p>This stage should include a list of criteria for determining when the proposal 
can be considered <a href="0617-rfc-stages.html#Recommended">Recommended</a> after being <a href="0617-rfc-stages.html#Released">Released</a>. </p>
<p>A PR is opened on the repo (see <a href="0617-rfc-stages.html#Accepted">Accepted</a>) to move an accepted RFC 
into this stage. An FCP is required to move into this stage.</p>
<p>Each Ember core team will be requested as a reviewer on the PR to move into this stage. 
A representative of each team adds a review. If a team does not respond to the 
request, and after the conclusion of the FCP, it is assumed that the release may proceed.</p>
<h4 id="released"><a class="header" href="#released">Released</a></h4>
<p>The work is published. If it is codebase-related work, it is in a stable version 
of the relevant package(s). If there are any critical deviations from the original RFC, 
they are briefly noted at the top of the RFC.</p>
<p>If the work for an RFC is spread across multiple releases of Ember or other packages, 
the RFC is considered to be in the Released stage when all features are available in
stable releases and those packages and versions are noted in the RFC frontmatter.</p>
<p>Ember's RFC process can be used for process and work plans that are not about code. 
Some examples include Roadmap RFCs, this RFC itself, and changes to learning resources.
When such an RFC is a candidate for Released, the work should be shipped as described, 
and the result should presented to the team with the intent of gathering feedback 
about whether anything is missing. If there is agreement that the work is complete, 
the RFC may be marked &quot;Released&quot; and a date is provided instead of a version.</p>
<p>An RFC is moved into &quot;Released&quot; when the above is verified by consensus of the 
relevant team(s) via PR to update the stage.</p>
<h4 id="recommended"><a class="header" href="#recommended">Recommended</a></h4>
<p>The &quot;Recommended&quot; stage is the final milestone for an RFC. It provides a signal 
to the wider community to indicate that a feature has been put through its 
ecosystem paces and is ready to use.</p>
<p>The &quot;Recommended&quot; stage is most important for suites of features that are designed 
as a number of separate RFCs. It allows the Ember maintainers to stabilize individual 
features once they are technically feature complete, an important goal for maintaining 
technical velocity.</p>
<p>To reach the &quot;Recommended&quot; stage, the following should be true:</p>
<ul>
<li>If appropriate, the feature is integrated into the tutorial and the guides prose.
API documentation is polished and updates are carried through to other areas of 
API docs that may not directly pertain to the feature.</li>
<li>If the proposal replaces an existing feature, the addon ecosystem has largely
updated to work with both old and new features. </li>
<li>If the proposal updates or replaces an existing feature, high-quality codemods are 
available</li>
<li>If needed, Ember debugging tools as well as popular IDE support have been
updated to support the feature.</li>
<li>If the feature is part of a suite of features that were designed to work together
for best ergonomics, the other features are also ready to be &quot;Recommended&quot;.</li>
<li>Any criteria for &quot;Recommended&quot; for this proposal that were established in the 
<a href="0617-rfc-stages.html#Ready-for-Release">Ready For Release</a> stage have been met.</li>
</ul>
<p>An RFC is moved into &quot;Recommended&quot; via PR to update the stage. An FCP is required
to enter this stage. Multiple RFCs may be moved as a batch into &quot;Recommended&quot; with
the same PR.</p>
<h4 id="closed"><a class="header" href="#closed">Closed</a></h4>
<p>A <a href="0617-rfc-stages.html#Proposed">Proposed</a> RFC may be closed after an FCP period. This is the same 
as the existing process. A closed RFC is discontinued.</p>
<h4 id="discontinued"><a class="header" href="#discontinued">Discontinued</a></h4>
<p>An previously <a href="0617-rfc-stages.html#Accepted">Accepted</a> RFC may be discontinued at any point. The RFC
may be superseded, out-of-date, or no longer consistent with the direction of 
Ember. </p>
<h3 id="editing-merged-rfcs"><a class="header" href="#editing-merged-rfcs">Editing merged RFCs</a></h3>
<p>A merged RFC may be edited via a Pull Request process. Edits may include things like:</p>
<ul>
<li>Updating the stage</li>
<li>An optional note at the top that summarizes minor adjustments to the RFC design, at the time that the RFC's work became available for general use. This note can be very brief, and link out to other resources like a blog post. For example, an update might simply say &quot;See <code>&lt;blog post&gt;</code> for more information about this feature.&quot; This note is not intended to be updated across time.</li>
<li>Updating any part of the RFC prose, in order to keep a written record of the changes and rationale.</li>
</ul>
<p>Today, these types of changes do happen. We just don't write them down. So, merge criteria should be very loose.</p>
<p>Major changes should have a new RFC. The old RFC is later marked &quot;Discontinued&quot; when the replacement is merged. </p>
<h3 id="changes-to-rfc-meta"><a class="header" href="#changes-to-rfc-meta">Changes to RFC meta</a></h3>
<p>RFC meta (&quot;frontmatter&quot;) is the block of text at the start of an RFC that includes data about its stage, links to relevant info, etc.</p>
<p>Before:</p>
<pre><code>- Start Date: (fill me in with today's date, YYYY-MM-DD)
- Relevant Team(s): (fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies)
- RFC PR: (after opening the RFC PR, update this with a link to it and update the file name)
- Tracking: (leave this empty)
</code></pre>
<p>After:</p>
<pre><code>- Stage: Proposed (later updated to other stages)
- Start Date: (fill me in with today's date, YYYY-MM-DD)
- Release date: Unreleased (later update with YYYY-MM-DD)
- Release Versions: (Include any package with work necessary for the feature, n/a for non-code RFCs)
  - ember-source: vX.Y.Z
  - ember-data: vX.Y.Z 
- Relevant Team(s): (fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies)
- RFC PR: (after opening the Propsoal RFC PR, update this with a link to it and update the file name)
</code></pre>
<p>For RFCs that have moved through to at least the <a href="0617-rfc-stages.html#Accepted">Accepted</a> stage, 
this data will be used to add and update a block at the top of the RFC prose to
indicate the current stage, with a brief explanation of that stage. It should 
link to any open PRs to update the stage of the RFC. </p>
<p>We will make use of automation to add/update a section to the RFC with links to 
each PR that caused the RFC to move to a new stage.</p>
<p><code>Tracking</code> will be removed for new RFCs. Links that would have appeared here should
be found on the PR to move the RFC to <a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a>.</p>
<h3 id="reconciling-past-rfcs"><a class="header" href="#reconciling-past-rfcs">Reconciling past RFCs</a></h3>
<p>For codebase-related RFCs that have already been merged, the release version is only required to be added to RFCs whose implementation was released after February 1st, 2018 (near the release of Ember 3). This is to preserve the time and effort of our contributors and volunteers.</p>
<p>A stage will be applied to all previously merged RFCs.</p>
<h3 id="non-code-rfcs"><a class="header" href="#non-code-rfcs">Non-code RFCs</a></h3>
<p>The names of the stages make the most sense with RFCs that propose features in 
Ember, with code that will follow a release process. For many non-code RFCs, 
such as this one, those names, especially of later stages, may seem &quot;off&quot;. 
However, it is still  valuable to have a stage for every RFC where the teams and 
community agree that the RFC has been implemented (<a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a>) and a 
stage where the community agree that the RFC has been polished (<a href="0617-rfc-stages.html#Recommended">Recommended</a>).
We may further refine this in a future RFC as we learn more. </p>
<h2 id="how-we-teach-this-114"><a class="header" href="#how-we-teach-this-114">How we teach this</a></h2>
<ul>
<li>The Stages section above will be added to the README of the RFCs repository.</li>
<li>Frontmatter will be added to the template for new RFCs (see below)</li>
<li>A blog post will announce the updates to the RFC process</li>
<li>Past RFCs should be updated to include their stage and release version, following the description in &quot;Reconciling past RFCs.&quot;</li>
<li>We will use automation to add helpful links and guidance to the RFC files themselves.</li>
</ul>
<h3 id="stages-as-communication-tool"><a class="header" href="#stages-as-communication-tool">Stages as communication tool</a></h3>
<p>Additionally, this RFC would unlock our ability to create a status board where everyone can easily see the progress of RFC. Today, if you need to know when an RFC feature was available in a stable release, you need to comb through release blog posts. Instead, we could use the frontmatter as data that powers the app. This app is not a requirement for this RFC, but rather an example of how we could use the information provided by stages.</p>
<h3 id="non-goals-2"><a class="header" href="#non-goals-2">Non-goals</a></h3>
<p>This RFC does not intend to:</p>
<ul>
<li>substantially alter the functional process for RFCs</li>
<li>speed up the RFC process</li>
<li>change the timing of when a feature is released</li>
<li>exhaustively cover all steps and processes</li>
</ul>
<h2 id="case-study"><a class="header" href="#case-study">Case study</a></h2>
<p>Here is how we could have applied this model to Tracked Properties, which was split across two RFCs: <a href="https://github.com/emberjs/rfcs/blob/master/text/0410-tracked-properties.md">#410</a> and <a href="https://github.com/emberjs/rfcs/blob/master/text/0478-tracked-properties-updates.md">#478</a>.</p>
<h3 id="0---proposed"><a class="header" href="#0---proposed">0 - Proposed</a></h3>
<p>A PR is opened to the RFCs repo for Tracked Properties. The framework team talks 
about the RFC in the weekly meetings, and there's general agreement to pursue the 
idea. The RFC moves to <a href="0617-rfc-stages.html#Exploring">Exploring</a>. A label is added to the PR to 
indicate that stage.</p>
<h3 id="1---exploring"><a class="header" href="#1---exploring">1 - Exploring</a></h3>
<p>@pzuraq keeps adding details to the RFC, explores the design space, and 
collaborates with others to get to the final design. The full story has been 
thought out. @pzuraq expects to have the time resources to work on implementation. 
There were no &quot;known unknowns&quot; questions. The RFC reaches consensus. The RFC 
makes it through a week-long FCP process. The PR is merged and the stage 
is now <a href="0617-rfc-stages.html#Accepted">Accepted</a>. </p>
<h3 id="2---accepted"><a class="header" href="#2---accepted">2 - Accepted</a></h3>
<p>@pzuraq works on implementation. The feature is enabled in canary under feature flag. 
We learn that the feature causes a behavior regression in the interop story. 
@pzuraq works out a new plan to accommodate interop, then opens a PR to update the RFC prose.</p>
<p>The implementation is complete. There are API docs. A PR is opened to move the proposal to 
<a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a>. It includes a list of criteria required 
for this feature to be <a href="0617-rfc-stages.html#Recommended">Recommended</a>.
On the PR to move to [Ready for Release], each Ember team is requested as a reviewer. 
Each team reviews the RFC and implementation, ensuring that any changes to the 
projects they are responsible for have been completed and that the criteria for
<a href="0617-rfc-stages.html#Recommended">Recommended</a> also considers those areas. After a successful FCP 
period, the PR is merged and the stage is now <a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a>.</p>
<h3 id="3---ready-for-release"><a class="header" href="#3---ready-for-release">3 - Ready for Release</a></h3>
<p>The mechanics of releasing the feature proceed. The feature proceeds through 
Ember.js' beta cycle. The next stable of Ember.js is released with the feature
available. The API docs are published. A PR to update the stage to <a href="0617-rfc-stages.html#Released">Released</a>
and the frontmater with release details is opened and merged with the consensus 
of the framework team.</p>
<h3 id="4---released"><a class="header" href="#4---released">4 - Released</a></h3>
<p>The feature is available for use by users of Ember.js. The learning team works to
carry through the concepts of 'Tracked Properties' to the tutorial and guides. Changes
to API doc examples are prepared. Other criteria for moving to Recommended are worked on, as defined
in the <a href="0617-rfc-stages.html#Ready-for-Release">Ready for Release</a> step. This work is documented on
a PR to move the proposal to <a href="0617-rfc-stages.html#Recommended">Recommended</a>. This proposal, along with
several others, are PRed to move to Recommended at the same time, 
as part of Octane around Ember.js 3.14. It is determined that the features are not 
yet polished enough and criteria to get to Recommended has not yet
been met. More work proceeds and the features are again proposed as Recommended
and put into a &quot;FCP for Recommended&quot;, it succeeds and the stages of several 
proposals are updated to Recommended as part of the Octane Edition.</p>
<h3 id="5---recommended"><a class="header" href="#5---recommended">5 - Recommended</a></h3>
<p>The feature is released and suggested for use by the wider Ember community. They
should encounter a polished feature that has ecosystem support. The feature should
be well represented in learning materials and the guides, tutorial and API docs 
use the feature in a consistent manner. </p>
<p>How was the actual process different from the imaginary case study above? In reality, there were two separate RFCs needed to land the feature, and there were fewer opportunities for people to follow along, give input, and understand the status.</p>
<h2 id="drawbacks-133"><a class="header" href="#drawbacks-133">Drawbacks</a></h2>
<p>Making updates to past RFCs can generate a lot of  GitHub notifications for people who watch the repository. We think that the benefit of knowing when an RFC is available in a stable release outweighs this drawback. Additionally, in the future, if an app displays the frontmatter data, someone could use that as their main source of information. Lastly, the Ember Times does a great job curating RFC updates, so someone could watch it instead if the RFC repo itself has too much information.</p>
<h2 id="alternativesstate-of-the-art"><a class="header" href="#alternativesstate-of-the-art">Alternatives/State of the Art</a></h2>
<p>This section covers how other projects have handled this type of tracking, and how we have done it in the past.</p>
<h3 id="vue-1"><a class="header" href="#vue-1">Vue</a></h3>
<p><a href="https://github.com/vuejs/rfcs#the-rfc-life-cycle">Vue's stages</a> are concise and to the point. This is worth considering because you don't need to know the process deeply in order to understand it. The lower number of stages equates to less overhead, but also less fidelity.</p>
<ul>
<li><strong>Pending:</strong> when the RFC is submitted as a PR.</li>
<li><strong>Active:</strong> when an RFC PR is merged and undergoing implementation.</li>
<li><strong>Landed:</strong> when an RFC's proposed changes are shipped in an actual release.</li>
<li><strong>Rejected:</strong> when an RFC PR is closed without being merged.</li>
</ul>
<h3 id="tc39"><a class="header" href="#tc39">TC39</a></h3>
<p>TC39 is an interdisciplinary group that is responsible for determining the direction of JavaScript. Staged proposals are greatly inspired by their process and the success. The shorthand provided by stage names helps bring clarity in communication.</p>
<p><a href="https://tc39.es/process-document/">Their process</a> is divided into five numbered stages:</p>
<ol start="0">
<li>
<p>Strawperson</p>
</li>
<li>
<p>Proposal</p>
</li>
<li>
<p>Draft</p>
</li>
<li>
<p>Candidate</p>
</li>
<li>
<p>Finished</p>
</li>
</ol>
<p>This format is not exactly suited to Ember because stages 0-3 are what we already do. What we need to offer is more detail for stages 3-4. However, thanks to TC39, we can see how useful it would be to have clarity and a shared language around the status of a feature.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>The <a href="https://github.com/rust-lang/rfcs#the-rfc-life-cycle">Rust RFC lifecycle</a> is very similar to Ember's, because ours was inspired by it. Following an FCP (Final Comment Period), an RFC is either merged, closed, or postponed. Merged RFCs are considered to be &quot;active.&quot;</p>
<p>The concept of postponed RFCs is relevant to Ember's development, and possibly a good lesson to take:</p>
<ul>
<li>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are
closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is
marked as such because we want neither to think about evaluating the proposal
nor about implementing the described feature until some time in the future, and
we believe that we can afford to wait until then to do so. Historically,
&quot;postponed&quot; was used to postpone features until after 1.0. Postponed pull
requests may be re-opened when the time is right. We don't have any formal
process for that, you should ask members of the relevant sub-team.</li>
<li>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an
informal first round of evaluation, namely the round of &quot;do we think we would
ever possibly consider making this change, as outlined in the RFC pull request,
or some semi-obvious variation of it.&quot; (When the answer to the latter question
is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</li>
</ul>
<p>As of the writing of this RFC, there are over <a href="https://github.com/emberjs/rfcs/pulls">70 open pull requests</a> for Ember's RFCs. Having so many open PRs is confusing for everyone, yet simply closing many of these PRs would not reflect the reality of the wish to bring these good ideas into Ember.</p>
<p>Another aspect of Rust's process that is relevant is the idea of modification, which is already part of Ember's process, but not widely used:</p>
<ul>
<li>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of the process means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of the next major release.</li>
</ul>
<p>Many of Ember's merged RFCs are not implemented exactly as written. Once implementation is underway, new knowledge gained influences design. In other cases, implementation takes so long that some aspects of an RFC no longer apply. These decisions should be captured in writing as part of the process.</p>
<h3 id="yarn-and-react"><a class="header" href="#yarn-and-react">Yarn and React</a></h3>
<p>Both Yarn and React have adopted an RFC process similar to Ember and Rust.</p>
<p>You can see an example of updating a merged RFC in this <a href="https://github.com/reactjs/rfcs/pull/52/files">React RFC Pull Request</a>.</p>
<h3 id="make-no-changes-to-existing-process"><a class="header" href="#make-no-changes-to-existing-process">Make no changes to existing process</a></h3>
<p>Following RFC 300, the <a href="https://github.com/emberjs/rfc-tracking/issues?q=is%3Aopen+is%3Aissue">RFC tracking issue repository</a> was created. This repository contained checklists that were meant to show the general, high-level requirements to ship an RFC in a stable release. Although the issues were helpful to learning resource writers, including the Learning Team, the Ember Times, and contributors, the tracking system did not provide much utility for our broader user community. Tracking issues were rarely updated.</p>
<p>Although it is still helpful to have a detailed view into the work being done, our community's greatest need is to show the overall status of an RFC's implementation in a consistent, reliable way. For this reason, it is necessary that we adopt RFC stages, and not stop at our current process.</p>
<h2 id="unresolved-questions-89"><a class="header" href="#unresolved-questions-89">Unresolved questions</a></h2>
<p>There are some ambiguities because RFCs take many forms. Our process cannot cover 100% of scenarios, but we should strive to find answers that cover the vast majority of RFCs.</p>
<h2 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h2>
<ul>
<li><strong>FCP</strong>: &quot;final comment period&quot; An FCP is an opportunity for the community and 
core team members to weight in before an RFC moves a following stage.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-04-28
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/625</p>
<hr />
<h1 id="helper-managers"><a class="header" href="#helper-managers">Helper Managers</a></h1>
<h2 id="summary-147"><a class="header" href="#summary-147">Summary</a></h2>
<p>Provides a low-level primitive for defining helpers.</p>
<h2 id="motivation-147"><a class="header" href="#motivation-147">Motivation</a></h2>
<p>Helpers are a valuable template construct in Ember. They have a number of
benefits that come from having their lifecycle being managed by the template and
container, including:</p>
<ol>
<li>
<p>Behavior can be <em>self-contained</em>. Some APIs need to run at multiple points in
time based on a template's lifecycle, such as for a plugin that needs to be setup
on initialization and torn down upon destruction. Doing this in components
via lifecycle hooks usually forces users to split their API across multiple
touch points in a component, which requires a lot of boilerplate and can make
it difficult to understand how the whole system works together. Helpers
provide a way for these shared concerns to be contained in a single location.</p>
</li>
<li>
<p>It doesn't require <em>multiple inheritance</em>. Alternatives for sharing behaviors
that touch multiple parts of the lifecycle such as mixins and strategies like
them create complicated inheritance hierarchies that can be difficult to debug.
Helpers do not insert themselves into the inheritance hierarchy of a class,
they are children of the template instead, which is much easier to reason
about in practice.</p>
</li>
<li>
<p>They are highly <em>composable</em>. Helpers, like components, can be used multiple
times in a template and can be used within <code>{{if}}</code> and <code>{{each}}</code> blocks.
Combined with their ability to be hold a self contained lifecycle, this makes
them a powerful tool for composing declarative behavior.</p>
</li>
<li>
<p>They can be <em>destroyed</em>. They tie in naturally to the destruction APIs that
we have recently added to Ember, and that allows their lifecycle to be
managed in a self contained way.</p>
</li>
</ol>
<p>Helpers are currently the only template construct in Ember that do not have a
low-level primitive that is public. With components and modifiers, users can define
component managers and modifier managers respectively to create their own high
level APIs, but for helpers the only option currently is to use the high level
<code>helper()</code> wrapper function, or the <code>Helper</code> base class.</p>
<p>These APIs are beginning to show their age in Ember Octane, and unlocking
experimentation via a helper manager would allow us to begin designing a new
generation of helpers. Some possible areas to explore here would include:</p>
<ul>
<li>Using a native base class for helpers, instead of <code>EmberObject</code></li>
<li>Adding lifecycle hooks, similar to modifiers, to class-based helpers</li>
<li>Adding the ability to inject services to functional helpers</li>
<li>Allowing normal functions to operate as helpers</li>
</ul>
<p>In addition, it would allow us to begin adding new functionality to helpers via
manager capabilities. This RFC proposes one such capability, <code>hasScheduledEffect</code>.</p>
<h3 id="effect-helpers"><a class="header" href="#effect-helpers">Effect Helpers</a></h3>
<p>Usually, template helpers are supposed to return a value. However, if a helper
returns <code>undefined</code> and rendered in a template, it will produce no output. This
can be used to accomplish a <em>side-effect</em>:</p>
<pre><code class="language-js">// app/helpers/title.js
export default helper(([title]) =&gt; {
  window.document.title = title;
});
</code></pre>
<pre><code class="language-hbs">{{title &quot;My Document Title&quot;}}
</code></pre>
<p>Addons such as <a href="https://github.com/adopted-ember-addons/ember-page-title">ember-page-title</a>
use this to make helpers that can be added to the template to specify
<em>app behavior</em> declaratively. This is a much better way to approach certain
types of behavior and APIs, compared to the alternative of using mixins and
lifecycle hooks to manage them.</p>
<p>However, this pattern has some issues today, mostly stemming from the fact that
they execute <em>during</em> render, which is not an ideal time for side-effecting.
They can also be abused to modify app state, which can lead to difficult to
follow code paths reminiscent of observers. These issues stem from a mismatch
between two different goals, the goal of calculating a result or value, and the
goal of triggering side-effects.</p>
<p>The <code>hasScheduledEffect</code> capability would schedule side-effecting helpers to execute
<em>after</em> render, and would <em>disable</em> Ember's state mutations while they were
running. This would ensure that side-effecting helpers run at the optimal time,
and do not enable antipatterns and complicated codepaths.</p>
<h2 id="detailed-design-127"><a class="header" href="#detailed-design-127">Detailed design</a></h2>
<p>This RFC proposes adding the <code>setHelperManager</code> and <code>capabilities</code> APIs,
imported from <code>@ember/helper</code>. Like <code>setComponentManager</code> and
<code>setModifierManager</code>, <code>setHelperManager</code> receives a callback that is passed
the owner, and returns an instance of the helper manager. When a helper
definition is resolved by Ember, it will look up the manager recursively on the
definition's prototype chain until it finds a helper manager. If it does not
find one, it will throw an error.</p>
<pre><code class="language-ts">// object is used here to mean any valid WeakMap key
type HelperDefinition = object;

export declare function setHelperManager(
  factory: (owner: Owner) =&gt; HelperManager,
  definition: HelperDefinition
): HelperDefinition;
</code></pre>
<p>And like the <code>capabilities</code> functions for component and modifier managers, the
<code>capabilities</code> function for helper managers receives a version string as the
first parameter and a options object as the second with optional flags as
booleans. It produces an opaque <code>HelperCapabilities</code> object, which is assigned
to the helper manager.</p>
<pre><code class="language-ts">interface HelperCapabilitiesOptions {
  hasValue?: boolean;
  hasDestroyable?: boolean;
  hasScheduledEffect?: boolean;
}

type HelperCapabilities = Opaque;

export declare function capabilities(
  // to be replaced with the version of Ember this lands in
  version: '3.21.0',
  options: HelperCapabilitiesOptions
): HelperCapabilities;
</code></pre>
<p>Helper managers themselves have the following interface:</p>
<pre><code class="language-ts">interface HelperManager&lt;HelperStateBucket&gt; {
  capabilities: HelperCapabilities;

  createHelper(definition: HelperDefinition, args: TemplateArgs): HelperStateBucket;

  getValue?(bucket: HelperStateBucket): unknown;

  runEffect?(bucket: HelperStateBucket): void;

  getDestroyable?(bucket: HelperStateBucket): object;
}
</code></pre>
<p>Let's dig into these hooks one by one:</p>
<h3 id="hooks"><a class="header" href="#hooks">Hooks</a></h3>
<h4 id="createhelper"><a class="header" href="#createhelper"><code>createHelper</code></a></h4>
<p><code>createHelper</code> is a required hook on the HelperManager interface. The hook is
passed the definition of the helper that is currently being created, and is
expected to return a <em>state bucket</em>. This state bucket is what represents the
current state of the helper, and will be passed to the other lifecycle hooks at
appropriate times. It is not necessarily related to the definition of the
helper itself - for instance, you could return an object <em>containing</em> an
instance of the helper:</p>
<pre><code class="language-js">class MyManager {
  createHelper(Definition, args) {
    return {
      instance: new Definition(args);
    };
  }
}
</code></pre>
<p>This allows the manager to store metadata that it doesn't want to expose to the
user.</p>
<p>This hook is <em>not</em> autotracked - changes to tracked values used within this hook
will <em>not</em> result in a call to any of the other lifecycle hooks. This is because
it is unclear what should happen if it invalidates, and rather than make a
decision at this point, the initial API is aiming to allow as much expressivity
as possible. This could change in the future with changes to capabilities and
their behaviors.</p>
<p>If users do want to autotrack some values used during construction, they can
either create the instance of the helper in <code>runEffect</code> or <code>getValue</code>, or they
can use the <code>cache</code> API to autotrack the <code>createHelper</code> hook themselves. This
provides maximum flexibility and expressiveness to manager authors.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called as discovered during DOM construction</li>
<li>called in definition order in the template</li>
</ul>
<h4 id="getvalue-1"><a class="header" href="#getvalue-1"><code>getValue</code></a></h4>
<p><code>getValue</code> is an optional hook that should return the value of the helper. This
is the value that is returned from the helper and passed into the template.</p>
<p>This hook is called when the value is requested from the helper (e.g. when the
template is rendering and the helper value is needed). The hook is autotracked,
and will rerun whenever any tracked values used inside of it are updated.
Otherwise it does not rerun.</p>
<blockquote>
<p>Note: This means that arguments which are not <em>consumed</em> within the hook will
not trigger updates.</p>
</blockquote>
<p>This hook is only called for helpers with the <code>hasValue</code> capability enabled.
This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called the first time the helper value is requested</li>
<li>called after autotracked state has changed</li>
</ul>
<p><strong>Never</strong></p>
<ul>
<li>called if the <code>hasValue</code> capability is disabled</li>
</ul>
<h4 id="runeffect"><a class="header" href="#runeffect"><code>runEffect</code></a></h4>
<p><code>runEffect</code> is an optional hook that should run the effect that the helper is
applying, setting it up or updating it.</p>
<p>This hook is scheduled to be called some time after render and prior to paint.
There is not a guaranteed, 1-to-1 relationship between a render pass and this
hook firing. For instance, multiple render passes could occur, and the hook may
only trigger once. It may also never trigger if it was dirtied in one render
pass and then destroyed in the next.</p>
<p>The hook is autotracked, and will rerun whenever any tracked values used inside
of it are updated. Otherwise it does not rerun.</p>
<p>The hook is also run during a time period where state mutations are <em>disabled</em>
in Ember. Any tracked state mutation will throw an error during this time,
including changes to tracked properties, changes made using <code>Ember.set</code>, updates
to computed properties, etc. This is meant to prevent infinite rerenders and
other antipatterns.</p>
<p>This hook is only called for helpers with the <code>hasScheduledEffect</code> capability
enabled. This hook is also not called in SSR currently, though this could be
added as a capability in the future. It has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called after the helper was first created, if the helper has not been
destroyed since creation</li>
<li>called after autotracked state has changed, if the helper has not been
destroyed during render</li>
</ul>
<p><strong>Never</strong></p>
<ul>
<li>called if the <code>hasScheduledEffect</code> capability is disabled</li>
<li>called in SSR</li>
</ul>
<h4 id="getdestroyable"><a class="header" href="#getdestroyable"><code>getDestroyable</code></a></h4>
<p><code>getDestroyable</code> is an optional hook that users can use to register a
destroyable object for the helper. This destroyable will be registered to the
containing block or template parent, and will be destroyed when it is destroyed.
See the <a href="https://github.com/emberjs/rfcs/blob/master/text/0580-destroyables.md">Destroyables RFC</a>
for more details.</p>
<p><code>getDestroyable</code> is only called if the <code>hasDestroyable</code> capability is enabled.</p>
<p>This hook has the following timing semantics:</p>
<p><strong>Always</strong></p>
<ul>
<li>called immediately after the <code>createHelper</code> hook is called</li>
</ul>
<p><strong>Never</strong></p>
<ul>
<li>called if the <code>hasDestroyable</code> capability is disabled</li>
</ul>
<h3 id="capabilities-2"><a class="header" href="#capabilities-2">Capabilities</a></h3>
<p>There are three proposed capabilities for helper managers:</p>
<ul>
<li><code>hasDestroyable</code></li>
<li><code>hasValue</code></li>
<li><code>hasScheduledEffect</code></li>
</ul>
<p>Out of these capabilities, one of <code>hasScheduledEffect</code> or <code>hasValue</code> <em>must</em> be
enabled. The other must <em>not</em> be enabled, meaning they are mutually exclusive.</p>
<h4 id="hasdestroyable"><a class="header" href="#hasdestroyable"><code>hasDestroyable</code></a></h4>
<ul>
<li>Default value: false</li>
</ul>
<p>Determines if the helper has a destroyable to include in the destructor
hierarchy. If enabled, the <code>getDestroyable</code> hook will be called, and its result
will be associated with the destroyable parent block.</p>
<h4 id="hasvalue"><a class="header" href="#hasvalue"><code>hasValue</code></a></h4>
<ul>
<li>Default value: false</li>
</ul>
<p>Determines if the helper has a value which can be used externally. The helper's
<code>getValue</code> hook will be run whenever the value of the helper is accessed if this
capability is enabled.</p>
<h4 id="hasscheduledeffect"><a class="header" href="#hasscheduledeffect"><code>hasScheduledEffect</code></a></h4>
<ul>
<li>Default value: false</li>
</ul>
<p>Determines if the helper has a scheduled effect. If enabled, the helper's
<code>runEffect</code> hook will run after render, and will not allow any type of state
mutation when running.</p>
<h3 id="scheduled-helpers-timing"><a class="header" href="#scheduled-helpers-timing">Scheduled Helpers Timing</a></h3>
<p>Scheduled helpers run their effects after render, and after modifiers have been
applied for a given render, but before paint. The exact timing may shift around,
and may or may not correspond to a single rendering pass in cases where there
are multiple rendering passes in a single paint.</p>
<p>In the future different timings may be added as options for scheduling. For
instance, a timing to call the effect using <code>requestIdleCallback</code>, when the
browser has finished rendering and handling higher priority work, could be
added. However, this is out of scope for this RFC.</p>
<h2 id="how-we-teach-this-115"><a class="header" href="#how-we-teach-this-115">How we teach this</a></h2>
<p>Helper managers are a low-level construct that is generally only meant to be
used by experts and addon authors. As such, it will only be taught through API
documentation. In addition, for precision and clarity, the API docs will include
snippets of TypeScript interfaces where appropriate.</p>
<h3 id="api-docs-5"><a class="header" href="#api-docs-5">API Docs</a></h3>
<h4 id="sethelpermanager"><a class="header" href="#sethelpermanager"><code>setHelperManager</code></a></h4>
<p>Sets the helper manager for an object or function.</p>
<pre><code class="language-js">setHelperManager((owner) =&gt; new ClassHelperManager(owner), Helper)
</code></pre>
<p>When a value is used as a helper in a template, the helper manager is looked up
on the object by walking up its prototype chain and finding the first helper
manager. This manager then receives the value and can create and manage an
instance of a helper from it. This provides a layer of indirection that allows
users to design high-level helper APIs, without Ember needing to worry about the
details. High-level APIs can be experimented with and iterated on while the
core of Ember helpers remains stable, and new APIs can be introduced gradually
over time to existing code bases.</p>
<p><code>setHelperManager</code> receives two arguments:</p>
<ol>
<li>A factory function, which receives the <code>owner</code> and returns an instance of a
helper manager.</li>
<li>A helper definition, which is the object or function to associate the factory function with.</li>
</ol>
<p>The first time the object is looked up, the factory function will be called to
create the helper manager. It will be cached, and in subsequent lookups the
cached helper manager will be used instead.</p>
<p>Only one helper manager is guaranteed to exist per <code>owner</code> and per usage of
<code>setHelperManager</code>, so many helpers will end up using the same instance of the
helper manager. As such, you should only store state that is related to the
manager itself. If you want to store state specific to a particular helper
definition, you should assign a unique helper manager to that helper. In
general, most managers should either be stateless, or only have the <code>owner</code> they
were created with as state.</p>
<p>Helper managers must fulfill the following interface (This example uses
<a href="https://www.typescriptlang.org/docs/handbook/interfaces.html">TypeScript interfaces</a>
for precision, you do not need to write helper managers using TypeScript):</p>
<pre><code class="language-ts">interface HelperManager&lt;HelperStateBucket&gt; {
  capabilities: HelperCapabilities;

  createHelper(definition: HelperDefinition, args: TemplateArgs): HelperStateBucket;

  getValue?(bucket: HelperStateBucket): unknown;

  runEffect?(bucket: HelperStateBucket): void;

  getDestroyable?(bucket: HelperStateBucket): object;
}
</code></pre>
<p>The capabilities property <em>must</em> be provided using the <code>capabilities()</code> function
imported from the same module as <code>setHelperManager</code>:</p>
<pre><code class="language-js">import { capabilities } from '@ember/helper';

class MyHelperManager {
  capabilities = capabilities('3.21.0', { hasValue: true });

  // ...snip...
}
</code></pre>
<p>Below is a description of each of the methods on the interface and their
functions.</p>
<blockquote>
<p>The remaining API docs should be copied from the descriptions in the Detailed
Design section of this RFC.</p>
</blockquote>
<h4 id="capabilities-3"><a class="header" href="#capabilities-3"><code>capabilities</code></a></h4>
<p><code>capabilities</code> returns a capabilities configuration which can be used to modify
the behavior of the manager. Manager capabilities <em>must</em> be provided using the
<code>capabilities</code> function, as the underlying implementation can change over time.</p>
<p>The first argument to capabilities is a version string, which is the version of
Ember that the capabilities were defined in. Ember can add new versions at any
time, and these may have entirely different behaviors, but it will not remove
old versions until the next major version.</p>
<pre><code class="language-js">capabilities('3.x');
</code></pre>
<p>The second argument is an object of capabilities and boolean values indicating
whether they are enabled or disabled.</p>
<pre><code class="language-js">capabilities('3.x', {
  hasValue: true,
  hasDestructor: true,
});
</code></pre>
<p>If no value is specified, then the default value will be used.</p>
<h5 id="3x-capabilities"><a class="header" href="#3x-capabilities"><code>3.x</code> capabilities</a></h5>
<blockquote>
<p>The remaining API docs should be copied from the descriptions in the Detailed
Design section of this RFC. 3.x above should be replaced with the version that
helper managers are initially released in.</p>
</blockquote>
<h2 id="drawbacks-134"><a class="header" href="#drawbacks-134">Drawbacks</a></h2>
<ul>
<li>Adds a layer of indirection to helpers, which could add to complexity and
cost in terms of performance. This isn't likely, as we haven't seen this
happen with other managers we've introduced.</li>
</ul>
<h2 id="alternatives-136"><a class="header" href="#alternatives-136">Alternatives</a></h2>
<ul>
<li>
<p>We could continue using the current helper APIs, and try to incrementally
migrate them to only use native classes. This wouldn't match the strategy
we've taken with other template constructs, like components and modifiers, and
would result in less ability for the community to experiment and less
flexibility if we chose to change helpers again in the future.</p>
</li>
<li>
<p>The <code>hasScheduledEffect</code> capability could be broken out into a separate RFC.
It is mostly separable, except for the impact it has on <code>getValue</code>. Value-less
and effect-less helpers don't really make sense, so in isolation <code>getValue</code>
would probably not be an optional hook, and the <code>hasValue</code> capability wouldn't
exist.</p>
<p>Capabilities can change from version to version, so this is still not a major
issue, but it seems like it would be easier to add from the get go.</p>
</li>
</ul>
<h2 id="appendix-1"><a class="header" href="#appendix-1">Appendix</a></h2>
<h3 id="implementation-of-current-helper-apis"><a class="header" href="#implementation-of-current-helper-apis">Implementation of Current Helper APIs</a></h3>
<p>The following is an implementation of the current helper APIs using this manager
API. There are two separate managers, one for class based helpers and one for
functional helpers:</p>
<pre><code class="language-js">import EmberObject from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { setHelperManager, capabilities } from '@ember/helper';

const RECOMPUTE = symbol();

export class Helper extends EmberObject {
  @tracked [RECOMPUTE];

  constructor(...args) {
    super(...args);

    registerDestructor(this, () =&gt; this.destroy());
  }

  recompute() {
    // update the value to force a recompute
    this[RECOMPUTED] = undefined;
  }
}

class ClassHelperManager {
  capabilities = capabilities({
    hasValue: true,
    hasDestroyable: true,
  });

  ownerInjection = {};

  constructor(owner) {
    setOwner(this.ownerInjection, owner);
  }

  createHelper(Definition, args) {
    let helper = Definition.create(this.ownerInjection);

    return { helper, args };
  }

  getValue({ helper, args }) {
    // Consume the RECOMPUTE tag, so if anyone ever
    // calls recompute() it'll force a recompute
    helper[RECOMPUTE];

    return helper.compute(args.positional, args.named);
  }

  getDestroyable({ helper }) {
    return helper;
  }
}

setHelperManager((owner) =&gt; new ClassHelperManager(owner), Helper.prototype);
</code></pre>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';
import { setHelperManager, capabilities } from '@ember/helper';

class FunctionalHelperManager {
  capabilities = capabilities({
    hasValue: true,
  });

  createHelper(fn, args) {
    return { fn, args };
  }

  getValue({ fn, args }) {
    return fn(args.positional, args.named);
  }
}

const FUNCTIONAL_HELPER_MANAGER = () =&gt; new FunctionalHelperManager();

export function helper(fn) {
  setHelperManager(FUNCTIONAL_HELPER_MANAGER, fn);

  return fn;
}
</code></pre>
<h3 id="implementation-of-ember-page-title-using-effects"><a class="header" href="#implementation-of-ember-page-title-using-effects">Implementation of Ember Page Title using Effects</a></h3>
<p>This adapts the <a href="https://adopted-ember-addons.github.io/ember-page-title/">ember-page-title</a>
addon to use the implementation proposed in this RFC. The biggest change to the
public API is that using <code>push</code> and <code>remove</code> directly schedules updates to the
title, so they can in theory be made public. The scheduling could also be moved
back to the helper itself to avoid that issue, this just cleans it up.</p>
<pre><code class="language-js">// ember-page-title/addon/services/page-title-list

import Service, { inject as service } from '@ember/service';
import { getOwner } from '@ember/application';
import { scheduleOnce } from '@ember/run';

export default class PageTitleListService extends Service {
  @service headData;

  tokens = [];

  /**
    The default separator to use between tokens.
    @property defaultSeparator
    @default ' | '
   */
  defaultSeparator = ' | ';

  /**
    The default prepend value to use.
    @property defaultPrepend
    @default true
   */
  defaultPrepend = true;

  /**
    The default replace value to use.
    @property defaultReplace
    @default null
   */
  defaultReplace = null;

  constructor(owner) {
    super(owner);
    this._removeExistingTitleTag();

    let config = getOwner(this).resolveRegistration('config:environment');
    if (config.pageTitle) {
      ['separator', 'prepend', 'replace'].forEach((key) =&gt; {
        if (isPresent(config.pageTitle[key])) {
          set(this, `default${capitalize(key)}`, config.pageTitle[key]);
        }
      });
    }
  }

  applyTokenDefaults(token) {
    let {
      defaultSeparator,
      defaultPrepend,
      defaultReplace,
    } = this

    if (token.separator == null) {
      token.separator = defaultSeparator;
    }

    if (token.prepend == null &amp;&amp; defaultPrepend != null) {
      token.prepend = defaultPrepend;
    }

    if (token.replace == null &amp;&amp; defaultReplace != null) {
      token.replace = defaultReplace;
    }
  }

  inheritFromPrevious(token) {
    let { previous } = token;

    if (previous) {
      if (token.separator == null) {
        token.separator = previous.separator;
      }

      if (token.prepend == null) {
        token.prepend = previous.prepend;
      }
    }
  }

  push(token) {
    let { tokens } = this;
    let tokenForIdIndex = tokens.findIndex(({ id }), token.id === id);

    if (tokenForIdIndex) {
      let tokenForId = tokens[tokenForIdIndex];
      let { previous, next } = tokenForId;

      token.previous = previous;
      token.next = next;

      this.inheritFromPrevious(token);
      this.applyTokenDefaults(token);

      tokens.splice(tokenForIdIndex, 1, token);
      return;
    }

    let previous = tokens.slice(-1)[0];
    if (previous) {
      token.previous = previous;
      previous.next = token;
      this.inheritFromPrevious(token);
    }

    this.applyTokenDefaults(token);

    tokens.push(token);

    scheduleOnce('actions', this, this.updateTitle);
  }

  remove(id) {
    let { tokens } = this;

    let tokenIndex = tokens.findIndex(({ id }), token.id === id);
    let token = tokens[tokenIndex];
    let { next, previous } = token;

    if (next) {
      next.previous = previous;
    }

    if (previous) {
      previous.next = next;
    }

    token.previous = token.next = null;
    tokens.splice(tokenIndex, 1);

    scheduleOnce('actions', this, this.updateTitle);
  }

  updateTitle() {
    if (this.isDestroying || this.isDestroyed) return;

    this.headData.set('title', this.toString());
  }

  get visibleTokens() {
    let { tokens } = this;

    let replaceIndex = tokens.length;

    while (replaceIndex--) {
      if (tokens[replaceIndex].replace) {
        break;
      }
    }

    return tokens.slice(replaceIndex - 1);
  }

  get sortedTokens() {
    let visible = this.visibleTokens;
    let appending = true;
    let group = [];
    let groups = [group];
    let frontGroups = [];
    visible.forEach((token) =&gt; {
      if (token.front) {
        frontGroups.unshift(token);
      } else if (token.prepend) {
        if (appending) {
          appending = false;
          group = [];
          groups.push(group);
        }
        let lastToken = group[0];
        if (lastToken) {
          token = copy(token);
          token.separator = lastToken.separator;
        }
        group.unshift(token);
      } else {
        if (!appending) {
          appending = true;
          group = [];
          groups.push(group);
        }
        group.push(token);
      }
    });

    return frontGroups.concat(
      groups.reduce((E, group) =&gt; E.concat(group), [])
    );


  }

  toString() {
    let tokens = this.sortedTokens;

    return tokens
      .filter(token =&gt; Boolean(token.title))
      .map((token, index) =&gt; {
        if (index + 1 &lt; tokens.length) {
          return token.title + token.separator;
        }

        return token.title;
      })
      .join('');
  }

  /**
   * Remove any existing title tags from the head.
   * @private
   */
  _removeExistingTitleTag() {
    if (this._hasFastboot()) {
      return;
    }

    let titles = document.getElementsByTagName('title');
    for (let i = 0; i &lt; titles.length; i++) {
      let title = titles[i];
      title.parentNode.removeChild(title);
    }
  }

  _hasFastboot() {
    return !!getOwner(this).lookup('service:fastboot');
  }
}
</code></pre>
<pre><code class="language-js">// ember-page-title/addons/helpers/title

import { setOwner } from '@ember/application';
import { inject as service } from '@ember/service';
import { setHelperManager, capabilities } from '@ember/helper';

class TitleHelperManager {
  capabilities = capabilities('3.21', {
    hasScheduledEffect: true,
  });

  constructor(owner) {
    this.owner = owner;
  }

  createHelper(Title, args) {
    return new Title(this.owner, args);
  }

  runEffect(instance) {
    instance.update();
  }

  getDestroyable({ instance }) {
    registerDestructor(instance, () =&gt; instance.teardown());

    return instance;
  }
}


export default class Title {
  @service pageTitleList;

  constructor(owner, args) {
    setOwner(this, owner);
    this.args = args;
    this.pageTitleList.push({ id: guidFor(this) });
  }

  update() {
    let token = assign({}, this.args.named, {
      id: guidFor(this),
      title: this.args.positional.join(''),
    });

    this.pageTitleList.push(token);
  },

  teardown() {
    this.pageTitleList.remove(guidFor(this));
  }
}

setHelperManager((owner) =&gt; new EffectHelperManager(owner), Title);
</code></pre>
<pre><code class="language-hbs">{{title &quot;Blog&quot;}}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-04-30
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/626</p>
<hr />
<h1 id="javascript-helper-invocation-api"><a class="header" href="#javascript-helper-invocation-api">JavaScript Helper Invocation API</a></h1>
<h2 id="summary-148"><a class="header" href="#summary-148">Summary</a></h2>
<p>This RFC proposes a new API, <code>invokeHelper</code>, which can be used to invoke a
helper definition, creating an instance of the helper in JavaScript.</p>
<pre><code class="language-js">// app/components/data-loader.js
import Component from '@glimmer/component';
import Helper from '@ember/component/helper';
import { invokeHelper } from '@ember/helper';

class PlusOneHelper extends Helper {
  compute([number]) {
    return number + 1;
  }
}

export default class PlusOneComponent extends Component {
  plusOne = invokeHelper(this, PlusOneHelper, () =&gt; {
    return {
      positional: [this.args.number],
    };
  });
}
</code></pre>
<pre><code class="language-hbs">{{this.plusOne.value}}
</code></pre>
<h2 id="motivation-148"><a class="header" href="#motivation-148">Motivation</a></h2>
<p>As Ember has evolved, the framework has been developing a model of reactive,
incremental computation. This model is oriented around <em>templates</em>, which map
data and JavaScript business logic into HTML that is displayed to the user.</p>
<p>On the first render, this mapping is fairly similar to standard programming
languages. You can imagine that every component is like a <em>function call</em>,
receiving arguments and data, processing it, and placing it within its own
template, ultimately producing HTML as the &quot;return value&quot; of the component.
Components can use other components, much like functions can call other
functions, resulting in a tree structure of nested components, which is
the application. At the root of our application is a single &quot;main&quot; component
(similar to the main function in many programming languages) which takes
arguments and returns the full HTML of the initial render.</p>
<p>Where Ember's programming model really begins to differ is in <em>subsequent</em>
renders. Rather than re-running the entire program whenever something changes,
producing new HTML as a result, Ember incrementally re-runs the portions of the
program which have changed. It knows about these portions via its change
tracking mechanism, <em>autotracking</em>.</p>
<p>This means fundamentally that the tree of components differs from a tree of
functions because components can <em>live longer</em>. They exist until the portion of
the program that they belong to has been removed by an incremental update, and
as such, they have a <em>lifecycle</em>. Unlike a function, a component can <em>update</em>
over time, and will be <em>destroyed</em> at some unknown point in the future.</p>
<p>Components previously exposed this lifecycle directly via a number of
lifeycle hooks, making components the smallest <em>atom</em> for reactive composition.
This presented an issue for composability in general. In the world of functions,
a piece of code can always be broken out into a new function, giving the user
the ability to extract repeated functionality, abstracting common patterns and
concepts and reducing brittleness. For instance, in the following example we
extract several portions of the <code>myProgram</code> function to make it clearer what
each section is doing, and isolate its behavior.</p>
<pre><code class="language-js">// before
function myProgram(data = []) {
  for (let item of data) {
    // ...
  }

  let values = data.map(() =&gt; {
    // ...
  });

  while (values.length) {
    let value = values.pop();
    // ...
  }
}
</code></pre>
<pre><code class="language-js">// after
function initialProcessing(data) {
  for (let item of data) {
    // ...
  }
}

function extractValues(data) {
  return data.map(() =&gt; {
    // ...
  });
}

function processValues(values) {
  while (values.length) {
    let value = values.pop();
    // ...
  }
}

function myProgram(data = []) {
  initialProcessing(data);

  let values = extractValues(data);

  processValues(values);
}
</code></pre>
<p>Since components are the smallest reactive atom, there often is not a way to do this
transparently, since the only portions of the code that are reactive are the
component hooks themselves. This results in related code being spread across
multiple locations, with the user being forced to keep the relationships between
these bits of code in their head at all times, and understand the interactions
between them.</p>
<p>Consider this search component, which updates performs a cancellable fetch
request and updates the document title whenever the search query is updated:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { fetch, cancelFetch } from 'fetch-with-cancel';

export default class Search extends Component {
  // Args
  query = '';

  @tracked data;

  didReceiveAttrs() {
    // Update the document title
    document.title = `Search Result for &quot;${this.query}&quot;`;

    // Cancel the previous fetch if it's still running
    cancelFetch(this.promise);

    // create a new fetch request, and set the data property to the response
    this.promise = fetch(`www.example.com/search?query=${this.query}`)
      .then((response) =&gt; response.json());
      .then((data) =&gt; this.data = data);
  }

  willDestroy() {
    cancelFetch(this.promise);
  }
}
</code></pre>
<p>This component mixes two separate concerns in its lifecycle hooks - fetching the
data, and updating the document title. We can extract these into utility
functions in some isolated cases, but it becomes difficult when functionality
covers multiple parts of the lifecycle, like with the fetch logic here:</p>
<pre><code class="language-js">import Component from '@ember/component';
import { fetch, cancelFetch } from 'fetch-with-cancel';

function updateDocumentTitle(title) {
  document.title = title;
}

function updateFetch(url, callback, previousPromise) {
  // Cancel the previous fetch if it's still running
  cancelFetch(previousPromise);

  // create a new fetch request, and set the data property to the response
  return fetch(url)
    .then((response) =&gt; response.json());
    .then((data) =&gt; callback(data));
}

function teardownFetch(promise) {
  cancelFetch(promise);
}

export default class Search extends Component {
  // Args
  query = '';

  @tracked data;

  didReceiveAttrs() {
    updateDocumentTitle(`Search Result for &quot;${this.query}&quot;`)

    this.promise = updateFetch(
      `www.example.com/search?query=${this.query}`,
      (data) =&gt; this.data = data,
      this.promise
    );
  }

  willDestroy() {
    teardownFetch(this.promise);
  }
}
</code></pre>
<p>We can see here that we needed to add two separate helper functions to extract
the data fetching functionality, one to handle updating the fetch, and one to
handle tearing it down, because those different pieces of code need to run at
different portions of the component lifecycle. If we want to reuse these
functions elsewhere, this adds a lot of boilerplate to integrate the functions
in each lifecycle hook.</p>
<p>There are a few alternatives that would allow us to extract this functionality
together.</p>
<ol>
<li>
<p>We could use mixins, since they allow us to specify multiple functions and
mix them into a class. Mixins however introduce a lot of complexity in the
inheritance hierarchy and are considered an antipattern, so this is not a
good choice overall.</p>
</li>
<li>
<p>We could extract the functionality out to separate components. Components
have a contained lifecycle, so they can manage any piece of functionality
completely in isolation. This works nicely for the document title, but adds
a lot of complexity for the data fetching, since we need to yield the data
back out via the template:</p>
<pre><code class="language-js">// app/components/doc-title.js
import Component from '@ember/component';

export default class DocTitle extends Component {
  didReceiveAttrs() {
    document.title = this.title;
  }
}
</code></pre>
<pre><code class="language-js">// app/components/fetch-data.js
import Component from '@ember/component';
import { fetch, cancelFetch } from 'fetch-with-cancel';

export default class FetchData extends Component {
  @tracked data;

  didReceiveAttrs() {
    // Cancel the previous fetch if it's still running
    cancelFetch(this.promise);

    // create a new fetch request, and set the data property to the response
    this.promise = fetch(this.url)
      .then((response) =&gt; response.json());
      .then((data) =&gt; this.data = data);
  }

  willDestroy() {
    cancelFetch(this.promise);
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;!-- app/components/fetch-data.hbs --&gt;
{{yield this.data}}
</code></pre>
<pre><code class="language-hbs">&lt;!-- app/components/search.hbs --&gt;
&lt;DocTitle @title='Search Result for &quot;{{@query}}&quot;'/&gt;

&lt;FetchData @url=&quot;www.example.com/search?query={{@query}}&quot; as |data|&gt;
  ...
&lt;/FetchData&gt;
</code></pre>
<p>This structure is also not ideal because the components aren't being used for
templating, they're just being used for logic effectively.</p>
</li>
<li>
<p>We could use other template constructs, such as helpers or modifiers. Both
helpers and modifiers have lifecycles, like components, and can be used to
contain functionality. Modifiers aren't really a good choice here though,
because it would require us to add an element that we don't need. So, helpers
are the better option.</p>
<p>Helpers work, but like components they require us to move some of our logic
into the template, even if that isn't really necessary:</p>
<pre><code class="language-js">// app/helpers/doc-title.js
import { helper } from '@ember/component/helper';

export default helper(([title]) =&gt; {
  document.title = title;
});
</code></pre>
<pre><code class="language-js">// app/helpers/fetch-data.js
import Helper from '@ember/component/helper';
import { fetch, cancelFetch } from 'fetch-with-cancel';

export default class FetchData extends Helper {
  @tracked data;

  compute([url]) {
    if (this._url !== url) {
      this.url = url;

      // Cancel the previous fetch if it's still running
      cancelFetch(this.promise);

      // create a new fetch request, and set the data property to the response
      this.promise = fetch(url)
        .then((response) =&gt; response.json());
        .then((data) =&gt; this.data = data);
    }

    return this.data;
  }

  willDestroy() {
    cancelFetch(this.promise);
  }
}
</code></pre>
<pre><code class="language-hbs">&lt;!-- app/components/search.hbs --&gt;
{{doc-title 'Search Result for &quot;{{@query}}&quot;'}}

{{#let (fetch-data &quot;www.example.com/search?query={{@query}}&quot;) as |data|}}
  ...
{{/let}}
</code></pre>
</li>
</ol>
<p>Out of these options, helpers are the closest to what we want - they produce
computed values directly without a template, and with the recent addition of
effect helpers they can be used side-effect to accomplish tasks like setting the
document title. The only downside is that they can only be invoked in templates,
so they require you to design your components around using them in templates
only. This can be difficult to do in many cases, where the data wants to be
accessed to create derived state for instance.</p>
<p>This RFC proposes adding a way to create helpers within JavaScript directly,
extending the reactive model in a way that allows users to extract common
reactive code and patterns, and reuse them transparently. This will make helpers
the new reactive atom of the system - the reactive equivalent of a &quot;function&quot; in
our incremental model. Like components, they have a lifecycle, and can update
over time. Unlike components, they can exist nested in JavaScript classes <em>and</em>
in templates, and they can produce any type of value, making them much more
flexible.</p>
<pre><code class="language-js">// app/components/search.js
import Component from '@ember/component';

export default class Search extends Component {
  data = invokeHelper(this, FetchData, () =&gt; {
    return {
      positional: [`www.example.com/search?query=${this.query}`],
    };
  });

  constructor() {
    super(...arguments);

    invokeHelper(this, DocTitle, () =&gt; {
      return {
        positional: [`Search Result for &quot;${this.query}&quot;`],
      };
    });
  }
}
</code></pre>
<p>Note how the concerns are completely separated in this version of the component.
The polling logic is self contained, and separated from the data fetching logic.
Both sets of logic are able to contain their lifecycles, updating based on
changes to tracked state, and tearing down when the program destroys them. In
the future, convenience APIs can be added to make invoking them easier to read:</p>
<pre><code class="language-js">export default class Search extends Component {
  @use data = fetchData(() =&gt; `www.example.com/search?query=${this.query}`);

  constructor() {
    super(...arguments);

    use(this, docTitle(() =&gt; `Search Result for &quot;${this.query}&quot;`));
  }
}
</code></pre>
<h2 id="detailed-design-128"><a class="header" href="#detailed-design-128">Detailed design</a></h2>
<p>This RFC proposes adding the <code>invokeHelper</code> function, imported from
<code>@ember/helper</code>. The function will have the following interface (using
TypeScript types for brevity and clarity):</p>
<pre><code class="language-ts">interface TemplateArgs {
  positional?: unknown[],
  named?: Record&lt;string, unknown&gt;
}

type HelperDefinition&lt;T = unknown&gt; = object;

function invokeHelper&lt;T = unknown&gt;(
  parentDestroyable: object,
  definition: HelperDefinition&lt;T&gt;,
  computeArgs?: (context: object) =&gt; TemplateArgs
): Cache&lt;T&gt;;
</code></pre>
<p>Let's step through the arguments to the function one by one:</p>
<h4 id="parentdestroyable"><a class="header" href="#parentdestroyable"><code>parentDestroyable</code></a></h4>
<p>This is the parent for the helper definition. The helper will be associated as a
destroyable to this parent context, using the <a href="https://github.com/emberjs/rfcs/blob/master/text/0580-destroyables.md">destroyables API</a>,
so that its lifecycle is tied to the parent. The only requirement of the parent
is that it is an object of some kind that can be destroyed. If the parent has an
owner, this owner will also be passed to the helper manager that it is invoked on.</p>
<p>This allows helper's lifecycles to be entangled correctly with the parent, and
encourages users to ensure they've properly handled the lifecycle of their
helper.</p>
<h4 id="definition"><a class="header" href="#definition"><code>definition</code></a></h4>
<p>This is the helper definition. It can be any object, with the only requirement
being that a helper manager has been associated with it via the
<a href="https://github.com/emberjs/rfcs/blob/master/text/0625-helper-managers.md#detailed-design"><code>setHelperManager</code> API</a>.</p>
<h4 id="computeargs"><a class="header" href="#computeargs"><code>computeArgs</code></a></h4>
<p>This is an optional function that produces the arguments to the helper. The
function receives the parent context as an argument, and must return an object
with a <code>positional</code> property that is an array and/or a <code>named</code> property that is
an object.</p>
<p>This getter function will be <em>autotracked</em> when it is run, so the process of
retrieving the arguments is autotracked. If any of the values used to create the
arguments object change, the helper will be updated, just like in templates.</p>
<h3 id="return-value"><a class="header" href="#return-value">Return Value</a></h3>
<p>The function returns a Cache instance, as defined in the <a href="https://github.com/emberjs/rfcs/blob/master/text/0615-autotracking-memoization.md#detailed-design">Autotracking Memoization RFC</a>.
This cache returns the most recent value of the helper, and will update whenever
the helper updates. Users can access the value using the <code>getValue</code> function for
caches.</p>
<p>If the helper has a scheduled effect, using <code>getValue</code> on the cache will not run
it eagerly. It will run as scheduled, until the helper is destroyed.</p>
<p>The cache will be also be destroyable, so that using <code>destroy()</code> from the
destroyables API on it will trigger its destruction early. Users can do this to
clean up a helper before the parent context is destroyed.</p>
<h3 id="effect-helper-timing-semantics"><a class="header" href="#effect-helper-timing-semantics">Effect Helper Timing Semantics</a></h3>
<p>Standard helpers that return a value will only be updated when they are used,
either in JavaScript or in the template. The args getter and the relevant helper
manager lifecycle hooks will be called when the <code>value</code> property on the helper
is used.</p>
<p>Side-effecting helpers, by contrast, run their updates specifically when
scheduled. When introduced by the Helper Manager RFC, there was no relative
ordering specified in the scheduling of side-effecting helpers, because there
was no way for them to have <em>children</em>, and we don't generally specify ordering
of siblings. With this RFC, it will be possible to invoke a side-effecting
helper within another side-effecting helper, so they will be able to have
children for the first time.</p>
<p>This RFC proposes modifying the Helper Manager RFC to specify that the
<code>runEffect</code> hook of a helper always runs <em>after</em> the <code>runEffect</code> hooks of its
children. This mirrors the timing semantics of modifier hooks in templates.</p>
<h3 id="ergonomics"><a class="header" href="#ergonomics">Ergonomics</a></h3>
<p>This is a low-level API for invoking helpers and creating instances. The API is
meant to be functional, but not particularly readable or ergonomic. This API can
be wrapped with higher level, more ergonomic APIs in the ecosystem, until we're
sure what the final API should be.</p>
<h2 id="how-we-teach-this-116"><a class="header" href="#how-we-teach-this-116">How we teach this</a></h2>
<p>This API is meant to be a low-level primitive which will eventually be replaced
with higher level wrappers, possibly decorators, that will be much easier to use
and recommend to average app developers. As such, it will only be taught through
API documentation.</p>
<p>Once community addons are built with higher level APIs that are more ergonomic,
we should also add a section in the guides that uses them to demonstrate
techniques for using helpers in JS. This strategy is similar to how modifiers
are documented today.</p>
<h3 id="api-docs-6"><a class="header" href="#api-docs-6">API Docs</a></h3>
<h4 id="invokehelper"><a class="header" href="#invokehelper"><code>invokeHelper</code></a></h4>
<p>The <code>invokeHelper</code> function can be used to create a helper instance in
JavaScript.</p>
<pre><code class="language-js">// app/components/data-loader.js
import Component from '@glimmer/component';
import Helper from '@ember/component/helper';
import { invokeHelper } from '@ember/helper';

class PlusOneHelper extends Helper {
  compute([num]) {
    return number + 1;
  }
}

export default class PlusOneComponent extends Component {
  plusOne = invokeHelper(this, PlusOneHelper, () =&gt; {
    return {
      positional: [this.args.number],
    };
  });
}
</code></pre>
<pre><code class="language-hbs">{{this.plusOne.value}}
</code></pre>
<p>It receives three arguments:</p>
<ul>
<li><code>context</code>: The parent context of the helper. When the parent is torn down and
removed, the helper will be as well.</li>
<li><code>definition</code>: The definition of the helper.</li>
<li><code>computeArgs</code>: An optional function that produces the arguments to the helper.
The function receives the parent context as an argument, and must return an
object with a <code>positional</code> property that is an array and/or a <code>named</code>
property that is an object.</li>
</ul>
<p>And it returns a Cache instance that contains the most recent value of the
helper. You can access the helper using <code>getValue()</code> like any other cache. The
cache is also destroyable, and using the <code>destroy()</code> function on it will cause
the helper to be torn down.</p>
<p>Note that using <code>getValue()</code> on helpers that have scheduled effects will not
trigger the effect early. Effects will continue to run at their scheduled time.</p>
<h2 id="drawbacks-135"><a class="header" href="#drawbacks-135">Drawbacks</a></h2>
<ul>
<li>
<p>Additional API surface complexity. There will be additional ways to use
helpers that we will have to teach users about in general. This is true, but
given it helps to solve a lot of common problems that users have in Octane it
should be worthwhile.</p>
</li>
<li>
<p>This API is a primitive that is not particularly ergonomic or user friendly,
but this is part of the point. It gets the job done, and can be built on top
of to create a better high level API.</p>
</li>
</ul>
<h2 id="alternatives-137"><a class="header" href="#alternatives-137">Alternatives</a></h2>
<ul>
<li>The <a href="https://github.com/emberjs/rfcs/pull/567"><code>@use</code> and Resources RFC</a>
proposes a higher level approach to this problem space, but had a number of
concerns and drawbacks. After much discussion, we decided that it would be
better to ship the primitives to build something like it in user-space, and
prove out the ideas in it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-05-18
Relevant Team(s): Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/628</p>
<hr />
<h1 id="add-prettier"><a class="header" href="#add-prettier">Add Prettier</a></h1>
<h2 id="summary-149"><a class="header" href="#summary-149">Summary</a></h2>
<p>This RFC proposes adding <a href="https://prettier.io/">Prettier</a> to the blueprints
that back <code>ember new</code> and <code>ember addon</code>.</p>
<h2 id="motivation-149"><a class="header" href="#motivation-149">Motivation</a></h2>
<p>Using Prettier removes the ever present and ongoing stylistic debates that tend
to happen on teams. Prettier is incredibly freeing for both developers <strong>and</strong>
reviewers of a codebase. The developer can author in whatever format they find
easiest to type out, avoiding needless wasted time trying to get that
indentation <em>just</em> right, and either setup an automated &quot;format on save&quot;
operation in their editor or use a quick command line invocation to <code>--fix</code> all
files at once.</p>
<p>This dove tails very nicely with Embers deeply ingrained goal of using shared
solutions to solve common problems, and aligns very well with the general trend
to play better with the general JavaScript ecosystem.</p>
<h2 id="detailed-design-129"><a class="header" href="#detailed-design-129">Detailed design</a></h2>
<p>Due to the pre-existing design (and improvements added to the blueprints in
<a href="https://github.com/emberjs/rfcs/blob/master/text/0121-remove-ember-cli-eslint.md">ember-cli/rfcs#121</a>)
implementation is very straight forward. The general idea is that we will
update the <code>app</code> and <code>addon</code> blueprints to add a few Prettier related packages
to the <code>package.json</code>, update the linting configuration to enforce Prettier
styles, and update the other blueprint code to ensure that its output is
Prettier compatible.</p>
<h3 id="packages-1"><a class="header" href="#packages-1">Packages</a></h3>
<p>The following packages will be added to the <code>package.json</code> of both <code>app</code> and <code>addon</code> blueprints:</p>
<ul>
<li><a href="https://www.npmjs.com/package/prettier">prettier</a> - The main package (used by the other packages).</li>
<li><a href="https://www.npmjs.com/package/eslint-config-prettier">eslint-config-prettier</a> - Disables stylistic ESLint rules that would conflict with the Prettier output.</li>
<li><a href="https://www.npmjs.com/package/eslint-plugin-prettier">eslint-plugin-prettier</a> - Enables <code>eslint-config-prettier</code>s <code>recommended</code> set, and adds the <code>prettier/prettier</code> rule to enforce styles.</li>
</ul>
<h3 id="configuration-changes"><a class="header" href="#configuration-changes">Configuration Changes</a></h3>
<h4 id="eslint"><a class="header" href="#eslint">ESLint</a></h4>
<p>The <code>.eslintrc.js</code> that is generated will be updated to add:</p>
<pre><code class="language-js">{
  extends: ['plugin:prettier/recommended'],
}
</code></pre>
<h4 id="prettier"><a class="header" href="#prettier">Prettier</a></h4>
<p>A <code>.prettierrc.js</code> will be added with the following contents:</p>
<pre><code class="language-js">module.exports = {
  singleQuote: true,
};
</code></pre>
<p>There is a <a href="https://prettier.io/docs/en/options.html">small number of configuration
options</a> that can be used in this
file, but we are intentionally avoiding modifying the default values for things
that are not <em>nearly</em> universally agreed on in the Ember ecosystem.</p>
<p>A <code>.prettierignore</code> will be added to match the <code>.eslintignore</code> contents:</p>
<pre><code># unconventional js
/blueprints/*/files/
/vendor/

# compiled output
/dist/
/tmp/

# dependencies
/bower_components/
/node_modules/

# misc
/coverage/
!.*

# ember-try
/.node_modules.ember-try/
/bower.json.ember-try
/package.json.ember-try
</code></pre>
<h4 id="git"><a class="header" href="#git">Git</a></h4>
<p>The <code>.gitignore</code> will be updated to add <code>.eslintcache</code> so that when using
<code>eslint --cache</code> the cache file itself won't be added to the repositories
history.</p>
<h3 id="blueprint-changes"><a class="header" href="#blueprint-changes">Blueprint Changes</a></h3>
<p>In general, it is recommended that all blueprints provided by addons should
satisfy the default linting configuration of a new Ember application. As such
the blueprints provided by <code>ember-cli</code>, <code>ember-source</code>, and <code>ember-data</code> will
be updated to ensure that they satisfy these new linting rules requirements.</p>
<p>In order to ensure blueprint output follows each individual projects custom
stylistic linting settings as much as possible. The following will be updated
to run <code>lint:fix</code> (when available) after their existing functionality:</p>
<ul>
<li><code>ember generate</code></li>
<li><code>ember init</code></li>
<li><code>ember-cli-update</code></li>
</ul>
<h4 id="packagejson-scripts"><a class="header" href="#packagejson-scripts"><code>package.json</code> scripts</a></h4>
<p>The <code>app</code> and <code>addon</code> blueprints will be updated to add the following
additional entries to <code>scripts</code>:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;lint&quot;: &quot;npm-run-all --aggregate-output --continue-on-error --parallel 'lint:!(fix)'&quot;,
    &quot;lint:fix&quot;: &quot;npm-run-all --aggregate-output --continue-on-error --parallel lint:*:fix&quot;,
    &quot;lint:js&quot;: &quot;eslint . --cache&quot;,
    &quot;lint:js:fix&quot;: &quot;eslint . --fix&quot;,
    &quot;lint:hbs:fix&quot;: &quot;ember-template-lint . --fix&quot;
  }
}
</code></pre>
<p>A few callouts here:</p>
<ul>
<li>The <code>lint:fix</code>, <code>lint:js:fix</code>, <code>lint:hbs:fix</code> scripts are new (introduced with this RFC)</li>
<li>The <code>lint</code> script will be updated to ensure that it avoids running the new <code>lint:fix</code> script</li>
<li>The <code>lint:js</code> script will be updated to add caching</li>
</ul>
<p>This configuration is specifically intending to allow users to add additional
linters (e.g. <code>stylelint</code> or <code>markdownlint</code>) by adding scripts for them, and
they would automatically be rolled up into <code>lint:fix</code>.</p>
<h3 id="codemod-3"><a class="header" href="#codemod-3">Codemod</a></h3>
<p>In order to make the migration as simple as possible, a codemod will be created: <code>ember-cli-prettier-codemod</code>.</p>
<p>The codemod will do the following:</p>
<ul>
<li>Install the new/required dependencies</li>
<li>Migrate an application / addon to the new linting configuration</li>
<li>Commit <em>just</em> the configuration changes.</li>
<li>Run the new <code>lint:fix</code> script to update all files to the new format.</li>
<li>Commit just the auto-fixed output.</li>
</ul>
<p>While this seems quite simple (and in fact it is pretty easy), leveraging a
codemod will make it much easier to deal with rebasing large Prettier migration
pull requests. If one of those pull requests gets out of date (e.g. due to a
conflict in one of the files) you can simply re-run the codemod on the branch
and it will replace the previously created commits.</p>
<h2 id="how-we-teach-this-117"><a class="header" href="#how-we-teach-this-117">How we teach this</a></h2>
<p>We do not currently discuss linting or stylistic formatting in either guides.emberjs.com or cli.emberjs.com.</p>
<p>This RFC proposes adding a new subsection that discusses linting under <a href="https://cli.emberjs.com/release/basic-use/"><code>Basic Use</code> section of the CLI guides</a>. In
addition, when this RFC is implemented we should do a throughough audit of the
<code>cli.emberjs.com</code> and <code>guides.emberjs.com</code> content to ensure that all code
snippets are formatted correctly (e.g. using the Prettier specific formatting
introduced here).</p>
<h2 id="drawbacks-136"><a class="header" href="#drawbacks-136">Drawbacks</a></h2>
<blockquote>
<p>The largest drawback is generally the cost of the <em>initial</em> migration to Prettier. That migration tends to be quick, but it can cause pain for folks maintaining long lived branches.</p>
</blockquote>
<h2 id="alternatives-138"><a class="header" href="#alternatives-138">Alternatives</a></h2>
<blockquote>
<p>Why not adopt <a href="https://standardjs.com/">standard</a> instead of Prettier?</p>
</blockquote>
<p>Prettier is <strong>much</strong> more popular with <a href="https://www.npmjs.com/package/prettier">9,249,847 weekly
downloads</a> vs <a href="https://www.npmjs.com/package/standard">265,658 weekly
downloads</a> (we all know these download
numbers don't mean a ton, but the order of magnitude can tell us something),
and (aside from the defaulting of <code>singleQuotes</code>) is much more aligned with the
Ember ecosystems inherent preferences.</p>
<p>Additionally, a very large number of the Ember ecosystem
projects are <em>already</em> using Prettier internally. These include <code>ember-source</code>,
<code>ember-cli</code>, <code>ember-data</code>, <code>@ember/test-helpers</code>, <code>eslint-plugin-ember</code>, the
various packages composing the rendering engine, <code>@glimmer/component</code>,
<code>ember-template-lint</code>, and many more. Additionally a large number of community
maintained addons are also using it already (<a href="https://emberobserver.com/code-search?codeQuery=prettier&amp;fileFilter=package.json&amp;sort=score&amp;sortAscending=false">here is a
listing</a>
using EmberObservers awesome code search feature).</p>
<h2 id="unresolved-questions-90"><a class="header" href="#unresolved-questions-90">Unresolved questions</a></h2>
<blockquote>
<p>In general, users of <code>yarn</code> could be perfectly happy with <code>yarn lint:js --fix</code> / <code>yarn lint:hbs --fix</code> (which works today). Should we still add the <code>lint:js:fix</code>/<code>lint:hbs:fix</code> scripts?</p>
</blockquote>
<p>I went with &quot;yes&quot; here in the initial RFC prose, as I'd general prefer to <em>reduce</em> the differences between users of <code>npm</code> and <code>yarn</code> over time.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-05-23
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/631</p>
<hr />
<h1 id="routerservicerefresh"><a class="header" href="#routerservicerefresh">RouterService#refresh</a></h1>
<h2 id="summary-150"><a class="header" href="#summary-150">Summary</a></h2>
<p>Add a refresh method to the router service that calls refresh on all currently active routes,
or refreshes the descendents of the active route referred to by the pivot route name provided as an argument.</p>
<h2 id="motivation-150"><a class="header" href="#motivation-150">Motivation</a></h2>
<p>We want to be able to call refresh on all currently active routes, or a subset of them,
from a centralized service or from a component.
As a side benefit, we will be able to do this without relying on the send api,
which is being discussed as a possible deprecation in
<a href="https://github.com/emberjs/rfcs/pull/632">RFC 632</a>.
This enables us to get the latest data from the model hook.</p>
<h2 id="detailed-design-130"><a class="header" href="#detailed-design-130">Detailed design</a></h2>
<p>The following pseudocode represents the overall technical design of this method.
This code implementation is not normative.</p>
<pre><code class="language-js">class RouterService {
    refresh(pivotRouteName?: string): Transition {
        let pivotRoute = pivotRouteName &amp;&amp; lookupRoute(pivotRouteName);
        assert(&quot;If an argument provided must be the name of an active route&quot;, !pivotRouteName || isActiveRoute(pivotRoute));
        return this._router._routerMicroLib.refresh(pivotRoute);
    }
}
</code></pre>
<p>where <em>lookupRoute</em> gets the route specified by the pivotRouteName,
and <em>isActiveRoute</em> determines if the specified route is active.
The method optionally takes the route name that will, along with its descendents, be refreshed.
The method will return a promise that resolves when the refresh is complete.</p>
<h2 id="how-we-teach-this-118"><a class="header" href="#how-we-teach-this-118">How we teach this</a></h2>
<p>The following documentation will be added to the method:</p>
<pre><code class="language-js">/**
 * Refreshes all currently active routes, doing a full transition.
 * If a pivotRouteName is provided and refers to a currently active route,
 * it will refresh only that route and its descendents.
 * Returns a promise that will be resolved once the refresh is complete.
 * All resetController, beforeModel, model, afterModel, redirect, and setupController
 * hooks will be called again. You will get new data from the model hook.
 * 
 * @method refresh
 * @param {String} [pivotRouteName] the route to refresh (along with all child routes)
 * @return Transition
 * @public
 */
</code></pre>
<h2 id="drawbacks-137"><a class="header" href="#drawbacks-137">Drawbacks</a></h2>
<p>This is a slight increase in API surface area.</p>
<h2 id="alternatives-139"><a class="header" href="#alternatives-139">Alternatives</a></h2>
<p>We could provide a direct link to the current route via the router service. However,
this would encourage people to use routes to store information and provide methods
that should be idiomatically placed in a service.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-05-29
Relevant Team(s): CLI, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/635
Authors: Joseph Sumner, Ava Wroten, Jamie White, Melanie Sumner</p>
<hr />
<h1 id="ember-new-lang"><a class="header" href="#ember-new-lang">Ember New Lang</a></h1>
<h2 id="summary-151"><a class="header" href="#summary-151">Summary</a></h2>
<p>This RFC introduces the <code>--lang</code> flag as an option for <code>ember new</code>, <code>ember init</code>, and <code>ember addon</code> commands within the Ember CLI. The feature targets the ember-cli build process -- specifically, when generating the file for the application's entry point at <code>app/index.html</code>. If the flag is used with a valid language code, it will assign the <code>lang</code> attribute in the file's root <code>&lt;html&gt;</code> element to that code. The <code>lang</code> attribute is <a href="https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes">formally defined within the current HTML5 specification</a>; it is used to specify the base human language of an element or a document in a way that can be programmatically understood by assistive technology.</p>
<h2 id="motivation-151"><a class="header" href="#motivation-151">Motivation</a></h2>
<p>The overall motivation for this RFC is the viewpoint that brand-new Ember apps should not immediately fail <a href="https://www.lflegal.com/2013/05/gaad-legal/#International-Laws-Regulations-and-Treaties-Impacting-Digital-Accessibility-Partial-Listing">global legal conformance requirements</a> as they pertain to digital accessibility.</p>
<p>The solution presented in this RFC offers the first stage of a resolution to one of the issues documented in the framework's <a href="https://github.com/emberjs/rfcs/issues/595">list of long-standing Technical Accessibility Issues for New Ember Apps</a> -- specifically, <em>“Missing default language declaration”</em> (Section #4). Note: acceptance or implementation of this RFC does not implicitly or explicitly endorse any related RFCs that are related to this issue.</p>
<p>This RFC and its proposed approach have both been developed within the Ember.js Accessibility Strike Team with the explicit objective of helping to ensure that Ember applications achieve <a href="https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html">WCAG Success Criterion 3.1.1: Language of Page</a> from the moment they are created. The state of the <code>lang</code> attribute has a usability impact on the experience of users that require screen-reading assistive technology. When the attribute is properly assigned:</p>
<blockquote>
<p>&quot;Both assistive technologies and conventional user agents can render text more accurately when the language of the Web page is identified. Screen readers can load the correct pronunciation rules. Visual browsers can display characters and scripts correctly. Media players can show captions correctly. <strong>As a result, users with disabilities will be better able to understand the content.</strong>&quot;</p>
<p><strong>Source: <a href="https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html#intent">WCAG Success Criterion 3.1.1: Intent</a></strong></p>
</blockquote>
<p>When the language of the page cannot be identified, the integrity of the above information cannot be guaranteed. 
Consider the following use case:</p>
<ul>
<li>the application developer is unaware that Ember now includes the lang attribute</li>
<li>the application does not require internationalization</li>
<li>the application's content is in a language that is not English</li>
<li>an end-user with a screen reader turned on, whose operating system (OS) is set to a different language, navigates to that page with their screen reader turned on</li>
<li>the screen reader would attempt to read the page in the language that is defined by the lang attribute on the page, but the supporting element information (&quot;button&quot;, &quot;link&quot;, etc) is read out in the language that is set by the operating system.</li>
</ul>
<h3 id="testing-it-out"><a class="header" href="#testing-it-out">Testing it out</a></h3>
<p>To see what happens when this information does not match, we created a new Ember application and created four buttons:</p>
<pre><code class="language-html">&lt;button type=&quot;button&quot;&gt;Click Me&lt;/button&gt;
&lt;button type=&quot;button&quot;&gt;点击我&lt;/button&gt;
&lt;button type=&quot;button&quot;&gt;Haz click en mi&lt;/button&gt;
&lt;button type=&quot;button&quot;&gt;Нажми на меня&lt;/button&gt;
</code></pre>
<h4 id="no-language-defined"><a class="header" href="#no-language-defined">No Language Defined</a></h4>
<p>If no lang attribute is set for the page or the parts:</p>
<ul>
<li>the screen reader defaults to the operating system (OS) language</li>
<li>it reads Spanish in an English accent, and the button element was also still read in English </li>
<li>for the Chinese and Russian letters, it spelled out the letters (i.e., &quot;Cyrillic Letter E&quot;)</li>
</ul>
<h4 id="language-defined"><a class="header" href="#language-defined">Language Defined</a></h4>
<p>We then changed the lang attribute value and listened to these buttons in Chinese(zh), Spanish(es) and Russian(ru). Here's what happened:</p>
<ul>
<li>in each case, the announcer's voice changed for the content </li>
<li>since the OS was set to English, the supporting element information that the assistive tech (AT) announces was in the OS language (English)</li>
<li>when set to Chinese, the AT read the English, Chinese and Spanish well enough to understand, but did not read out the Russian; likewise, Russian behaved similarly (read all of them except the Chinese)</li>
</ul>
<p>We then tested what happens if the <code>lang</code> attribute was explicitly defined on each of the buttons with the app language set to English:</p>
<pre><code class="language-html">&lt;button type=&quot;button&quot;&gt;Click Me&lt;/button&gt;
&lt;button type=&quot;button&quot; lang=&quot;zh&quot;&gt;点击我&lt;/button&gt;
&lt;button type=&quot;button&quot; lang=&quot;es&quot;&gt;Haz click en mi&lt;/button&gt;
&lt;button type=&quot;button&quot; lang=&quot;ru&quot;&gt;Нажми на меня&lt;/button&gt;
</code></pre>
<p>Each were read correctly by AT in their respective languages, followed with the word &quot;button&quot; in the OS language (English).</p>
<p>In this context, it is the users of screen readers, braille translation software, and similar assitive technologies for whom valid page language specifications provide the greatest improvements to user experience and technical operation. It is, however, extremely important to note that that although digital accessibility concerns are the primary motivators for developing formalized page language specifications, achieving WCAG SC-3.1.1 should certainly be considered a global application improvement. The following list contains application use cases that all benefit from having a valid page language specified, but are not strictly tied to digital accessibility requirements or assistive technology:</p>
<ul>
<li>Captions with synchronized media (such as video subtitles)</li>
<li>Correct dictionary lookups for translations</li>
<li>Assisting search engines</li>
<li>Improving typography in certain situations</li>
</ul>
<p>Accordingly, while the primary motivation of this RFC is to address an unresolved digital accessibility issue in Ember, it is expected that a successful implementation of the proposed <code>--lang</code> flag solution will provide additional, non-accessibility-related improvements to the baseline quality of new Ember applications.</p>
<h2 id="detailed-design-131"><a class="header" href="#detailed-design-131">Detailed design</a></h2>
<p>Link to <a href="https://github.com/josephdsumner/ember-cli/compare/master...ember-new-lang-base">candidate implementation</a>.</p>
<p>We have explicitly chosen <code>--lang</code> as the flag (vs <code>--language</code>) for consistency with the HTML attribute itself. </p>
<pre><code class="language-bash">ember new my-app --lang en-US
# -l is also a valid alias
</code></pre>
<p>The above ember-cli command will result in the following <code>index.html</code> header change.</p>
<pre><code class="language-html">&lt;html lang=&quot;en-US&quot;&gt;
</code></pre>
<p>The flag is added to relevant ember-cli help commands, such as the following:</p>
<pre><code class="language-bash">ember help new
ember new &lt;app-name&gt; &lt;options...&gt;
  ...
  --lang (String) (Default: &quot;&quot;) Sets the base human language of the application via index.html
    alias: -l &lt;value&gt;
</code></pre>
<h3 id="misusage-and-error-handling"><a class="header" href="#misusage-and-error-handling">Misusage and Error Handling</a></h3>
<p>Broadly, incorrect usage of the <code>--lang</code> flag covers three use-case categories:</p>
<ul>
<li>The flag has been specified with a programming language as the argument</li>
<li>The flag has been specified with no argument</li>
<li>The flag has been specified with an invalid language code</li>
</ul>
<p>This RFC proposes that these cases cause the build process to halt with a revelant error and help message as opposed to simply reverting to the default value and reporting a message. <strong>The rationale for the recommendation to halt instead of just report is that in these all of these cases, the user has explicitly typed <code>--lang</code> into their CLI tool. This is an unambiguous declaration of intent by the user to use the <code>--lang</code> flag correctly.</strong></p>
<h4 id="invalid-language-codes"><a class="header" href="#invalid-language-codes">Invalid Language Codes</a></h4>
<p>Language codes are verified against <a href="https://www.npmjs.com/package/is-language-code">is-language-code</a>. (see <a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes">examples of valid ISO country codes</a>)</p>
<p>If an invalid language code is given such as <code>--lang en-UK</code> the indended output should be a shell error that will halt the build.</p>
<pre><code class="language-bash">ember new my-app --lang en-UK
Unrecognized language subtag, &quot;uk&quot;.
</code></pre>
<h4 id="no-argument-passed"><a class="header" href="#no-argument-passed">No argument passed</a></h4>
<p>Additionally, if the <code>--lang</code> flag is used but no argument is defined, e.g., <code>ember new my-app --lang</code>, the build will also be halted. An error message and usage info should be shown in these cases:</p>
<pre><code class="language-bash"># Detect trailing option (declared)
ember new my-app --lang --skip-git

An error with the `--lang` flag returned the following message:
  Detected lang specification starting with command flag `-`.
  Is `--skip-git` meant to be an ember-cli command option?
  This issue is likely caused by using the `--lang` flag without a specification.
Information about using the `--lang` flag:
  The `--lang` flag sets the base human language of the app in index.html
  If used, the lang option must specfify a valid language code.
  For default behavior, remove the flag.
  See `ember &lt;command&gt; help` for more information.
</code></pre>
<pre><code class="language-bash"># Detect trailing option (undeclared)
ember new my-app --lang

An error with the `--lang` flag returned the following message:
  Detected lang specification starting with command flag `-`.
  Is `--disable-analytics` meant to be an ember-cli command option?
  This issue is likely caused by using the `--lang` flag without a specification.
Information about using the `--lang` flag:
  The `--lang` flag sets the base human language of the app in index.html
  If used, the lang option must specfify a valid language code.
  For default behavior, remove the flag.
  See `ember &lt;command&gt; help` for more information.
</code></pre>
<h4 id="common-misunderstandings-programming-languages"><a class="header" href="#common-misunderstandings-programming-languages">Common Misunderstandings: Programming Languages</a></h4>
<p>A developer may encounter the flag and make incorrect assumptions about what it can mean. Such as, <code>-l typescript</code> or <code>-l glimmer</code>. Such incorrect assumptions will be manually caught by the implementation and the developer will be shown a friendly error message such as the following:</p>
<pre><code class="language-bash">ember new my-app --lang=typescript

An error with the `--lang` flag returned the following message:
  Trying to set the app programming language to `typescript?`
  This is not the intended usage of the `--lang` flag.
Information about using the `--lang` flag:
  The `--lang` flag sets the base human language of the app in index.html
  If used, the lang option must specfify a valid language code.
  For default behavior, remove the flag.
  See `ember &lt;command&gt; help` for more information.
</code></pre>
<h2 id="how-we-teach-this-119"><a class="header" href="#how-we-teach-this-119">How we teach this</a></h2>
<ol>
<li>Update the <a href="https://ember-cli.com/api/">Ember CLI API documentation</a> to reflect the new flag.</li>
<li>Update the <a href="https://cli.emberjs.com/release/basic-use/cli-commands/">Ember.js CLI Guides</a> to reflect the new flag much like we demonstrate <code>--yarn</code> usage.</li>
<li>Update the Ember CLI <code>--help</code> command so it explains what kind of value is expected to be passed to the <code>--lang</code> flag.</li>
<li>Update the Super Rental tutorial to include updated information.</li>
<li>Update the Guides - specifically the section that discusses the language attribute. </li>
</ol>
<h3 id="for-the-ember-cli-guides"><a class="header" href="#for-the-ember-cli-guides">For the Ember CLI Guides:</a></h3>
<p>The <code>--lang</code> flag can be used to set the spoken language of the app or addon.</p>
<p>To use with a language code only, this is the syntax that would be used: </p>
<pre><code class="language-bash">ember new my-app --lang en
</code></pre>
<p>To use with a language code and a region code:</p>
<pre><code class="language-bash">ember new my-app --lang en-US
</code></pre>
<p>An error will be thrown if the country and region codes are incorrect. Additionally, helpful error text has been added in cases where the developer misunderstands the <code>--lang</code> flag and thinks that it is the programming language rather than the HTML attribute.</p>
<h3 id="for-the-emberjs-guides"><a class="header" href="#for-the-emberjs-guides">For the Ember.js Guides</a></h3>
<p>Specifically, update to https://guides.emberjs.com/release/accessibility/application-considerations/#toc_language-attribute:</p>
<p>Every application must have a primary language declaration. This language declaration is important for assistive technology like screen readers, internationalization tools built into browsers, and search engines.</p>
<p>To indicate the primary language, use the <code>--lang</code> flag when generating a new Ember app. This is inherited by all other elements, and will set a default language for the text in the document head element. If app globalization is desired, then consider using the <code>ember-intl</code> addon.</p>
<p>If there happens to be any content on the page that is in a different language from that declared in the <html> element, the <code>lang</code> attribute can be used on the parent element to indicate a different language.</p>
<p>Note: While an app cannot have multiple language attribute values defined at the same time, the language of specific elements can be defined to be different than the language of an app. For example, a language (e.g., <code>lang=&quot;en&quot;</code>) could be set on the page's HTML element and then a different language (e.g., <code>lang=&quot;es&quot;</code>) could be set on a different element in the page content (if appropriate).</p>
<h3 id="as-this-relates-to-ember-intl"><a class="header" href="#as-this-relates-to-ember-intl">As this relates to ember-intl</a></h3>
<p>The popular <a href="https://github.com/ember-intl/ember-intl">localization library ember-intl</a> does not conflict with the addition of this new Ember CLI flag. The addition of this flag offers some out of the box support where it was previously missing for new Ember apps. It is still recommended that globalized apps leverage <code>ember-intl</code>.</p>
<h2 id="drawbacks-138"><a class="header" href="#drawbacks-138">Drawbacks</a></h2>
<ul>
<li>More flags means more combinations of ways to run <code>ember new</code> which can be hard to test for and is potentially unsustainable.</li>
<li>Users may be confused about whether or not they are supposed to specify a human language or a programming language (i.e. <code>--lang typescript</code>). However, we think we've mitigated this by using the HTML attribute as the flag name, and having helpful error messages that guide developers in the right direction.</li>
</ul>
<h2 id="alternatives-140"><a class="header" href="#alternatives-140">Alternatives</a></h2>
<p>These are the alternative approaches that we are aware of; if more become apparent in discussion, this RFC will be updated to include them. </p>
<ul>
<li>Set the default html lang attribute to <code>en-US</code> (the language of the Ember.js project) and assume users will either change the <code>lang</code> value themselves, or rely exclusively on <code>ember-intl</code> (and not just for apps that require full globalization).
<ul>
<li><a href="https://github.com/emberjs/rfcs/issues/595">Valuable discussion points in this issue</a></li>
</ul>
<blockquote>
<p>The data we already have suggests that most Ember applications are:... in English... use internationalization if other languages are required</p>
</blockquote>
<ul>
<li>We have existing art in other frameworks (Vue sets <code>lang=&quot;en&quot;</code> by default)</li>
<li>It's consistent with the &quot;80%&quot; rule (solve for 80% of the use cases)</li>
<li>We prop up this new default with supporting Ember documentation to describe to users how to use ember-intl to choose another language along with the potential &quot;bug&quot; of an Ember app being interpreted as the wrong language.</li>
</ul>
</li>
<li>Make no flag change
<ul>
<li>By having no <code>lang</code> attribute an Ember app will default to using the system OS language.</li>
<li>Update the Ember documentation to include the pro's and con's of setting a language, along with how to do so.</li>
</ul>
</li>
</ul>
<h2 id="unresolved-questions-91"><a class="header" href="#unresolved-questions-91">Unresolved questions</a></h2>
<p>No unresolved questions currently but if RFC discussion yields additional unresolved questions, we will add them here.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html">Understanding Success Criterion 3.1.1: Language of Page</a></li>
<li><a href="https://www.w3.org/WAI/WCAG21/Techniques/html/H57">Technique H57: Using the language attribute on the HTML element</a></li>
<li><a href="https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes">HTML5 Specification: <code>lang</code> attribute</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-06-01
Relevant Team(s): Ember-CLI
RFC PR: https://github.com/emberjs/rfcs/pull/637</p>
<hr />
<h1 id="facilitate-customization-of-setuptest-functions"><a class="header" href="#facilitate-customization-of-setuptest-functions">Facilitate customization of setupTest* functions</a></h1>
<h2 id="summary-152"><a class="header" href="#summary-152">Summary</a></h2>
<p>Provide a default and convenient way for each project to customize the
<code>setupApplicationTest</code>, <code>setupRenderingTest</code>, and <code>setupTest</code> functions from
<a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC #268</a>
and <a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">RFC #232</a>.
The app and addon blueprints will be updated to create a file at 
<code>tests/helpers/index.js</code> where those functions will be wrapped and exported, 
creating a local place to edit for each type of test setup. Tests generated 
using <code>ember generate</code> will import the setup functions from that file.</p>
<h2 id="motivation-152"><a class="header" href="#motivation-152">Motivation</a></h2>
<p>Projects often need to customize setup for every test. For example, in 
acceptance tests, it is often necessary to override services, mock APIs, etc.
in every test of that type.</p>
<p>A common use-case is <code>ember-cli-mirage</code>, which provides a <code>setupMirage</code> function
to be called after <code>setupApplicationTest</code>. In a project using this, it can be 
necessary to remember to add that call to every test file.</p>
<p>If it is necessary to add new setup to every test (for example, when adding a 
service that must be replaced in test), every test file must be individually 
modified.</p>
<p>For these reasons, many projects create their own <code>setup*Test</code> functions in the 
<code>test/helpers</code> directory, either wrapping the addon-provided <code>setup*Test</code> 
functions or composing with them in each test file.</p>
<p>For example:</p>
<pre><code class="language-js">  import { module, test } from 'qunit';
  import setupTest from 'ember-qunit';
  
  module('Unit | Service | tomster', function(hooks) {
    setupTest(hooks);

    test('this works', function(...
  });
</code></pre>
<p>in a generated test where the setup functions have been wrapped in a helper must
manually be changed to:</p>
<pre><code class="language-js">    import { module, test } from 'qunit';
    import setupTest from 'my-app/tests/helpers';
    
    module('Unit | Service | tomster', function(hooks) {
      setupTest(hooks);
  
      test('this works', function(//...
    });
</code></pre>
<p>or where the setup functions are to be composed, this must be added:</p>
<pre><code class="language-js">    import { module, test } from 'qunit';
    import setupTest from 'ember-qunit';
    import setupMyTest from 'my-app/tests/helpers';
    
    module('Unit | Service | tomster', function(hooks) {
      setupTest(hooks);
      setupMyTest(hooks);

      test('this works', function(//...
    });
</code></pre>
<p>Developers of these projects must remember to change the imports or additionally
call their custom setup in every test file. It is easy to forget to make these 
changes and waste time to debug test failures or weird test side effects.</p>
<h2 id="detailed-design-132"><a class="header" href="#detailed-design-132">Detailed design</a></h2>
<p>When generating tests in an Ember project today, the setup functions in the
generated test are imported from <code>ember-qunit</code> or <code>ember-mocha</code>. This RFC
proposes adding a file at <code>test/helpers/index.js</code> that would look like:</p>
<pre><code class="language-js">import { setupApplicationTest as upstreamSetupApplicationTest } from 'ember-qunit';
export function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);
  // customize here
}
export { setupTest, setupRenderingTest } from 'ember-qunit';
</code></pre>
<p>The current imports in newly generated tests:</p>
<pre><code class="language-js">import { setupApplicationTest } from 'ember-qunit';   
// OR
import { setupRenderingTest } from 'ember-qunit';
// OR
import { setupTest } from 'ember-qunit';
</code></pre>
<p>will change in the relevant generated tests to: </p>
<pre><code class="language-js">import { setupApplicationTest } from 'my-app-name/tests/helpers'; 
// OR
import { setupRenderingTest } from 'my-app-name/tests/helpers';
// OR
import { setupTest } from 'my-app-name/tests/helpers';
</code></pre>
<p><code>ember-qunit</code> has been used for demonstrative purposes, but the blueprints for 
generated tests using <code>ember-mocha</code> are also maintained in <code>ember-source</code> 
and <code>ember-data</code>. Those blueprints will also be updated to use the local test 
helpers. The <code>test/helpers/index.js</code> file will import from the appropriate 
test framework.</p>
<p>We will provide a codemod to update existing tests. @rwjblue has created a 
<a href="https://astexplorer.net/#/gist/ba7e5ae104aac099bc5ca60ef874eb74/fc6cd9ad60df7abf17813136d7cdc75b0f313496">proof-of-concept codemod</a>.</p>
<p>An <code>eslint-plugin-ember</code> lint rule will be created to solely allow the imports
of <code>setup*Test</code> directly from <code>ember-qunit</code>/<code>ember-mocha</code> in the 
<code>test/helpers/index.js</code> file.</p>
<h2 id="how-we-teach-this-120"><a class="header" href="#how-we-teach-this-120">How we teach this</a></h2>
<p>The Ember.js guides extensively cover testing and use the <code>setup*Test</code> functions.
Those guides will need to be updated to reflect the new imports that will be in 
generated tests. Because of this, the guides will need to explain the file at 
<code>test/helpers/index.js</code> as a place for customization.</p>
<p>The tutorial also covers testing, using the <code>setup*Test</code> functions. It will need
to be updated, as other existing Ember apps will, likely by using the codemod.</p>
<p>This change will not substantially alter how a developer new to Ember would 
learn and use the framework.</p>
<h2 id="drawbacks-139"><a class="header" href="#drawbacks-139">Drawbacks</a></h2>
<p>Developers will need to trace imports through the local file before finding the
the bulk of the setup methods come from <code>ember-qunit</code> or <code>ember-mocha</code>. 
Projects without a need to customize the behavior of these test setup functions 
may find that slightly inconvenient. </p>
<h2 id="alternatives-141"><a class="header" href="#alternatives-141">Alternatives</a></h2>
<p>We could leave it to each project, as we do now, to create helpers to customize 
behavior as needed. The downsides of this current state would remain as 
discussed in <a href="0637-customizable-test-setups.html#Motivation">Motivation</a>.</p>
<p>Another alternative would be to create base classes from which test modules could
extend, similar to how it is done within <a href="https://github.com/emberjs/ember.js/blob/master/packages/internal-test-helpers/lib/test-cases/application.js"><code>Ember.js</code></a>.
This would be a much larger change to how we write tests in Ember projects and 
would have many details to be discussed and hashed out. It may be worth exploring 
but the change proposed in this RFC would still provide value until that idea 
were realized.</p>
<h3 id="prior-art-4"><a class="header" href="#prior-art-4">Prior Art</a></h3>
<p>A very similar proposal was discussed in
<a href="https://github.com/ember-cli/ember-cli/pull/7657">a CLI Issue</a>, over two years 
ago.</p>
<h2 id="unresolved-questions-92"><a class="header" href="#unresolved-questions-92">Unresolved questions</a></h2>
<blockquote>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-06-12
Relevant Team(s): ember-cli, framework, learning
RFC PR: https://github.com/emberjs/rfcs/pull/638</p>
<hr />
<h1 id="interactive-new-ember-app-creation"><a class="header" href="#interactive-new-ember-app-creation">Interactive New Ember App Creation</a></h1>
<h2 id="summary-153"><a class="header" href="#summary-153">Summary</a></h2>
<p>As part of the effort to make new Ember apps more conformant for digital accessibility requirements at a global scale, this RFC proposes an interactive workflow for new Ember apps. This will also have the benefit of assisting new users who prefer an interactive model of new app creation. </p>
<h2 id="motivation-153"><a class="header" href="#motivation-153">Motivation</a></h2>
<p>This RFC is the result of <a href="https://github.com/ember-a11y/core-notes/blob/ember-a11y/ember-a11y/2020-05/may-20.md">analysis and discussion in Ember's accessibility strike team</a>. The overall roadmap for addressing this issue is with a series of RFCs that intend to (independently) offer: </p>
<ul>
<li>a partial resolution to ensuring new Ember apps achieve <a href="https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html">WCAG Success Criteria 3.1.1 (language of the page)</a></li>
<li>enhancements to Ember CLI that empower developers to make their applications more accessible-by-default</li>
<li>global improvements to new Ember applications (i.e., improvements gained by achieving WCAG SC-3.1.1 that aren't specifically related to digital accessibility)</li>
</ul>
<p>The underlying motivation for this RFC is the desire to improve the accessibility of new Ember apps as <a href="https://github.com/emberjs/rfcs/issues/595">previously documented in Issue 595/Section 4</a>. Specifically, it aims to prevent new Ember apps from failing legal requirements for accessibility conformance according to <a href="https://w3c.github.io/wcag/21/guidelines/">WCAG 2.1</a>, the standard used by most countries around the world to inform digital accessibility requirements. In that context, this RFC seeks to help new Ember applications achieve <a href="https://www.w3.org/TR/WCAG21/#language-of-page">WCAG Success Criteria 3.1.1: language of page</a> by providing users of <code>ember-cli</code> to specify the base human language of their new application within an interactive setup workflow.</p>
<p>That being said, the overall developer experience improvement is the primary motivation. Interactive app creation helps new developers understand the important decisions they must make, and safely explore the options that they have (as defined in the question options). This provides a learning environment that will help build up the confidence of the new Ember developer by providing them with an interactive environment and helpful feedback during troubleshooting and error handling, thus flattening the learning curve. This will also help more experienced developers move faster; the strong defaults that Ember is known for will make it even easier than before to set up a new repo with the confidence that the important things are not being forgotten. </p>
<h2 id="detailed-design-133"><a class="header" href="#detailed-design-133">Detailed design</a></h2>
<p>The first step of the solution was presented in <a href="https://github.com/emberjs/rfcs/pull/635">RFC 635</a>-- the addition of the <code>--lang</code> flag as a way to add the language attribute to the <code>&lt;html&gt;</code> tag in the <code>index.html</code> file of new Ember apps. As such, successful implementation of <a href="https://github.com/emberjs/rfcs/pull/635">RFC 635</a> (or similar) is a necessary pre-requisite for this RFC, which in turn proposes an interactive workflow that can be initiated in the CLI when creating a new Ember app. With this in mind, this RFC will endeavor to not repeat the information in that RFC, but rather build on it, and reference when appropriate. The intention of <a href="https://github.com/emberjs/rfcs/pull/635">RFC 635</a> was to provide the appropriate underlying mechanism for setting the page language to align new Ember apps with WCAG Success Criteria 3.1.1 (language of the page); the interactive workflow proposed in <strong>this</strong> RFC intends to harness that mechanism.</p>
<h3 id="prior-art-5"><a class="header" href="#prior-art-5">Prior Art</a></h3>
<p>It would be remiss to introduce this RFC without mentioning the prior art that we analyzed for wizard-like app creation. In the Ember community, <a href="https://gist.github.com/gossi">@gossi</a> first introduced this idea with <a href="https://github.com/gossi/ember-cli-create">ember-cli-create</a>. In the wider web community, the Vue community offers this through <code>vue create</code> (<a href="https://cli.vuejs.org/guide/creating-a-project.html#vue-create">see docs</a>).</p>
<h3 id="intro-1"><a class="header" href="#intro-1">Intro</a></h3>
<p>When considering what questions to ask, we considered a few things: </p>
<ol>
<li>What questions do we have to ask ourselves every time we create a new Ember app?</li>
<li>How many questions do we think developers will tolerate?</li>
<li>Should the questions be different if it is an app vs addon?</li>
</ol>
<p>We will also endeavor to provide strong defaults for these questions, based on the results from the community surveys we have been conducting over the past few years and the defaults as stated by Ember itself (either explicitly or implicitly). <strong>If these defaults change over time as the result of community RFCs, the default values or other responses for the interactive questions should be updated as part of those RFCs.</strong></p>
<p>So, how then do we decide which questions to include and which not to include? It became necessary to then develop a rubric by which the proposed list of questions could be measured. </p>
<h3 id="question-rubric"><a class="header" href="#question-rubric">Question Rubric</a></h3>
<p>We intend for this section to be normative; that is, we intend for it to define how questions are evaluated for inclusion both now and in the future. </p>
<p>Evaluating criteria: </p>
<ol>
<li>Is it a choice that is hard (or time-consuming) to change one's mind about later? <em>For example, it's easy to remove the <code>ember-welcome-page</code> addon, so we did not include it. But it's time consuming to change from <code>yarn</code> to <code>npm</code> (or vice-versa) so we made sure to include that.</em> </li>
<li>Is it difficult to discover the option?</li>
<li>What is the maintenance cost? <em>For example, a nice question to add could be something like, Do you want to use a CSS preprocessor? But, because Ember does not deal with SASS, LESS... by default, the interactive workflow will have to install an addon (like <code>ember-cli-less</code>) which would imply that the CLI team will have to ensure it never fails.</em> </li>
<li>Does the question affect another one? <em>For example, the LTS question can affect the CI file generated by the CI question (setup tests on CI with <code>ember-try</code>). Questions that modify the result of other questions too much should be avoided to prevent high maintenance.</em></li>
</ol>
<h3 id="triggering-the-workflow"><a class="header" href="#triggering-the-workflow">Triggering the Workflow</a></h3>
<p>The following commands, and reasonable combinations thereof, should work to enter into the interactive workflow: </p>
<ol>
<li><code>ember new</code></li>
<li><code>ember new --interactive</code></li>
<li><code>ember new -i</code></li>
<li><code>ember new my-app -i</code></li>
</ol>
<h3 id="appaddon"><a class="header" href="#appaddon">App/Addon</a></h3>
<p>Starting a new Ember app or addon as we do now (at the time of this writing) will not change. If a user types <code>ember new my-app</code> they will still get a new Ember app generated in the usual ways. However, if the user types <code>ember new</code> they will enter into an interactive workflow that will ask them a few key questions about their application. </p>
<p>If a user were to type in existing flags that are also questions in the interactive workflow (i.e., <code>ember new my-app --lang en-US --interactive</code>), it will skip the question entirely. </p>
<p>When a user types <code>ember new</code> into their command line, they will be asked these questions (defaults indicated by a <code>&gt;</code>):</p>
<ul>
<li><code>Is this an app or an addon? (use arrow keys)</code>
<ul>
<li><code>&gt; app</code></li>
<li><code>addon</code></li>
</ul>
</li>
<li><code>Please provide the name of your app/addon:</code></li>
<li><code>Please provide the spoken/content language of your app/addon: (use arrow keys)</code>
<ul>
<li><code>&gt; en-US</code></li>
<li><code>my computer's default language</code></li>
<li><code>manually define a different language</code></li>
</ul>
</li>
<li><code>Pick the package manager to use when installing dependencies:  (use arrow keys)</code>
<ul>
<li><code>&gt; NPM</code></li>
<li><code>Yarn</code></li>
<li><code>ignore/skip</code></li>
</ul>
</li>
<li><code>What CI system do you want to use? (use arrow keys)</code>
<ul>
<li><code>&gt; travis-ci</code></li>
<li><code>ignore/skip</code></li>
</ul>
</li>
</ul>
<h4 id="appaddon-name"><a class="header" href="#appaddon-name">App/Addon Name</a></h4>
<p>There will be no default for this question. The user must enter a response. </p>
<h4 id="appaddon-language"><a class="header" href="#appaddon-language">App/Addon Language</a></h4>
<ul>
<li>the default would be <code>en-US</code></li>
<li>if your system has a different language set (which can be confirmed by using the <code>echo $LANG</code> command in the terminal), then <em>that</em> language would be shown as the second option</li>
<li>if your system was already set to the default language, the second option would not be shown. </li>
<li>for &quot;manually define a language&quot;, we will validate the response against the allowed language codes</li>
<li>we have not added a &quot;skip&quot; option here, because the purpose is to focus on improved accessibility in Ember apps.</li>
</ul>
<h4 id="package-manager"><a class="header" href="#package-manager">Package Manager</a></h4>
<ul>
<li>ignore/skip has been added to cover the use case where the developer is in a workspace </li>
</ul>
<h4 id="ci-option"><a class="header" href="#ci-option">CI Option</a></h4>
<p>Separate RFCs should further define more options for CI. </p>
<h3 id="current-limitations"><a class="header" href="#current-limitations">Current Limitations</a></h3>
<p>Explicitly, the goal of this RFC is to only include <code>ember-cli</code> flags that already exist. Any other possibilities should be considered future work.</p>
<p>This interactive workflow will also ignore any ~/.ember-cli settings that already exist. A separate RFC should be written that makes it possible for these to things to co-exist and respect the settings of the other.</p>
<h3 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h3>
<p>An example of a future RFC that could be specific to addons, would be to add a <code>--supported-version</code> flag for addons and add that to the wizard: </p>
<ul>
<li><code>What is the earliest version of Ember that you intend to support? (use arrow keys)</code>
<ul>
<li><code>&gt; recommended (last two LTS)</code></li>
<li><code>last LTS</code></li>
<li><code>manually define a version number</code></li>
</ul>
</li>
</ul>
<h3 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h3>
<p>This section is not normative, but provided for extra context for folks who might be new to this idea in general. We could use something like <a href="https://github.com/SBoudrias/Inquirer.js">inquirer.js</a> to implement this wizard, if the mechanism doesn't already exist within the ember-cli codebase. However, it should be explicitly noted that inquirer is only being used as an example of a library that could be used, and this RFC isn't explicitly defining that inquirer.js should be or will be used. </p>
<h3 id="versioning-and-stability-statement"><a class="header" href="#versioning-and-stability-statement">Versioning and Stability Statement</a></h3>
<p>Because the <code>ember new</code> command only affects new apps, it is not subject to the same semver guarantees that official Ember.js framework libraries currently follow. </p>
<p>The <code>ember new</code> interactive workflow SHOULD NOT be used in other scripts; it is the intent of the design to make this workflow flexible and changeable over time. As such, it should not be considered stable enough to be integrated into other automated tooling. Users should continue to make use of the commands available via <code>ember-cli</code> for any other integration scripts. </p>
<h2 id="how-we-teach-this-121"><a class="header" href="#how-we-teach-this-121">How we teach this</a></h2>
<p>As this is a wholly new idea, it should be documented and added to the guides along with screenshots of the new workflow. Until that prototype exists, this section will largely remain empty. However, we intend to explain it similarly to Vue's documentation for a similar feature (https://cli.vuejs.org/guide/creating-a-project.html#vue-create).</p>
<h2 id="drawbacks-140"><a class="header" href="#drawbacks-140">Drawbacks</a></h2>
<p>It could be considered a drawback to make this not the default for new Ember apps, even if an app name is defined. </p>
<p>The general drawback with wizards is that it can lead to a large number of combinations, which increases the risk for fragmentation. We believe that we have limited this risk by limiting the number of questions asked, but it is still a risk and should be identified as such.</p>
<h2 id="alternatives-142"><a class="header" href="#alternatives-142">Alternatives</a></h2>
<ol>
<li>We could decide on a different list of questions. See the notes from the <a href="https://github.com/ember-a11y/core-notes/blob/ember-a11y/ember-a11y/2020-05/may-20.md">strike team discussion on May 20th</a> to review the other possibilities considered.</li>
<li>We could make this the default for new Ember apps and add it in the appropriate version as a change.</li>
<li>We could have this workflow be opt-in only, via the <code>--interactive</code> flag (e.g., <code>ember new --interactive</code>). Using the <code>ember new</code> command would error and trigger the help workflow (which would be updated to include the <code>--interactive</code> flag).</li>
<li>We could set the default language to US English (the default language of the Ember project) and remove the language question from the interactive workflow.</li>
<li>We could set the default language to US English (the default language of the Ember project) and not have an interactive option at all.</li>
</ol>
<h2 id="unresolved-questions-93"><a class="header" href="#unresolved-questions-93">Unresolved questions</a></h2>
<p>As we identify additional unresolved questions, we will add them here. </p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-06-15
Relevant Team(s): Ember CLI, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/639</p>
<hr />
<h1 id="replace-terms-blacklist--whitelist-in-ember-cli"><a class="header" href="#replace-terms-blacklist--whitelist-in-ember-cli">Replace terms blacklist &amp; whitelist in Ember CLI</a></h1>
<h2 id="summary-154"><a class="header" href="#summary-154">Summary</a></h2>
<p>Ember.js prides itself (rightly) on being an inclusive framework. To further improve on this, we should remove the terms &quot;blacklist&quot; and &quot;whitelist&quot; with more neutral replacements.</p>
<h2 id="motivation-154"><a class="header" href="#motivation-154">Motivation</a></h2>
<p>The terms &quot;blacklist&quot; and &quot;whitelist&quot; can be considered racially insenstive. While the origin of these terms in this context is not in itself racially motivated, the fact that in todays context it <em>can be considered racially insensitive</em> has been discussed frequently - see for example <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6148600/">here</a>, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=981129#c16">here</a> or <a href="https://www.zdnet.com/article/uk-ncsc-to-stop-using-whitelist-and-blacklist-due-to-racial-stereotyping/">here</a>.</p>
<p>Other projects have already taken similar steps, for example <a href="https://go-review.googlesource.com/c/go/+/236857/">Go</a>, <a href="https://android-review.googlesource.com/q/topic:%22soong_inclusive_language%22+(status:open%20OR%20status:merged)">Android</a>, <a href="https://github.com/curl/curl/pull/5546">curl</a> or <a href="https://github.com/sebastianbergmann/phpunit/issues/4275">PHPUnit</a>.</p>
<p>These terms are used in Ember CLI for rather advanced functionality, which should make providing a better alternative naming and deprecating the current one rather easy.</p>
<h2 id="detailed-design-134"><a class="header" href="#detailed-design-134">Detailed design</a></h2>
<p>You can use <code>blacklist</code> and <code>whitelist</code> to include/exclude certain addons from your build:</p>
<p>https://ember-cli.com/user-guide/#whitelisting-and-blacklisting-assets</p>
<p>We should replace these with <code>exclude</code> or <code>include</code>:</p>
<pre><code class="language-js">// Before
let app = new EmberApp(defaults, {
  addons: {
    blacklist: [&quot;fastboot-app-server&quot;],
  },
});

// After
let app = new EmberApp(defaults, {
  addons: {
    exclude: [&quot;fastboot-app-server&quot;],
  },
});

// Before
let app = new EmberApp(defaults, {
  addons: {
    whitelist: [&quot;ember-cli-sass&quot;],
  },
});

// After
let app = new EmberApp(defaults, {
  addons: {
    include: [&quot;ember-cli-sass&quot;],
  },
});
</code></pre>
<p>The old keys (<code>blacklist</code> and <code>whitelist</code>) should be aliased to the new ones. Functionally, they behave the same.</p>
<p>If both keys are used at the same time (so either <code>blacklist</code> AND <code>exclude</code> or <code>whitelist</code> AND <code>include</code>), an error is thrown.</p>
<p>The old keys should be removed at some point - there should be a dedicated deprecation RFC for this (at a later point), ideally in time for them to be removed in the next major release.</p>
<h2 id="how-we-teach-this-122"><a class="header" href="#how-we-teach-this-122">How we teach this</a></h2>
<p>We should update the Ember CLI API docs with the new terms.</p>
<h2 id="drawbacks-141"><a class="header" href="#drawbacks-141">Drawbacks</a></h2>
<p>This might be considered &quot;churn&quot; by some. However, it is a small enough change to not really impact anybody meaningfully, while ensuring that Ember.js feels inclusive to everybody.</p>
<h2 id="alternatives-143"><a class="header" href="#alternatives-143">Alternatives</a></h2>
<p>There are also other possible terms that could be used to replace <code>blacklist</code> and <code>whitelist</code>. For example:</p>
<ul>
<li><code>allowlist</code> / <code>denylist</code></li>
<li><code>allowlist</code> / <code>disallowlist</code></li>
<li><code>allow</code> / <code>deny</code></li>
<li><code>allowed</code> / <code>disallowed</code></li>
<li><code>allowedlist</code> / <code>disallowedlist</code></li>
<li><code>safelist</code> / <code>blockedlist</code></li>
</ul>
<p>For reference, this is how often these terms are used accross the Ember ecosystem according to Ember Observer - all searches done inside of index.js files for easier comparison:</p>
<ul>
<li>blacklist: 16 addons</li>
<li>whitelist: 20 addons</li>
<li>allowlist, allowedlist, denylist, deniedlist, disallowlist, disallowedlist, blockedlist: 0 addons</li>
<li>blocklist: 2 addons</li>
<li>safelist: 1 addon</li>
<li>allow: 4 addons</li>
<li>deny: 1 addon</li>
<li>allowed: 18 addons</li>
<li>disallowed: 1 addon</li>
<li>include: 207 addons</li>
<li>exclude: 101 addons</li>
</ul>
<h2 id="unresolved-questions-94"><a class="header" href="#unresolved-questions-94">Unresolved questions</a></h2>
<ul>
<li>Should we use different replacements than <code>exclude</code>/<code>include</code>?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-06-24
Relevant Team(s): Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/645
Authors: Benjamin Jegard, Melanie Sumner, Ricardo Mendes</p>
<hr />
<h1 id="add-ember-page-title-to-the-app-blueprint"><a class="header" href="#add-ember-page-title-to-the-app-blueprint">Add ember-page-title to the app blueprint</a></h1>
<h2 id="summary-155"><a class="header" href="#summary-155">Summary</a></h2>
<p>Add <a href="https://github.com/adopted-ember-addons/ember-page-title"><code>ember-page-title</code></a> to the default blueprint for new Ember apps as a way to provide improved out-of-the-box (OOB) accessibility for Ember applications.</p>
<h2 id="motivation-155"><a class="header" href="#motivation-155">Motivation</a></h2>
<p>This RFC is part of the work made by the Ember.js Accessibility Strike Team to ensure that newly created ember apps have no accessibility issues.</p>
<p>Users with assistive technology rely on the page title to know if they are on the correct page of a website.
Adding this addon will provide developers a simple solution to achieve the <a href="https://www.w3.org/WAI/WCAG21/Understanding/page-titled.html">WCAG Success Criterion 2.4.2: Page Titled</a>.</p>
<p>While there're other addons that provide the same capabilities it has been decided to go with <a href="https://github.com/adopted-ember-addons/ember-page-title"><code>ember-page-title</code></a> because it's the most aligned with the current and future direction taken Ember, which is the template-based solution.</p>
<h2 id="detailed-design-135"><a class="header" href="#detailed-design-135">Detailed design</a></h2>
<ol>
<li>Make <a href="https://github.com/adopted-ember-addons/ember-page-title"><code>ember-page-title</code></a> an official Ember addon by transferring <code>ember-page-title</code> repo to the <a href="https://github.com/ember-cli">Ember CLI org</a> (it's currently in the <a href="https://github.com/adopted-ember-addons">Adopted Ember Addons org</a>)</li>
<li>Add the dependency to the app blueprint here: https://github.com/ember-cli/ember-cli/blob/master/blueprints/app/files/package.json#L19</li>
<li>Update route blueprint to include <code>{{page-title RouteName}}</code> at the top of the route <a href="https://github.com/emberjs/ember.js/blob/master/blueprints/route/native-files/__root__/__templatepath__/__templatename__.hbs">template.hbs</a> (this <a href="https://github.com/emberjs/ember.js/blob/master/blueprints/route/files/__root__/__templatepath__/__templatename__.hbs">template.hbs</a> too) where <code>RouteName</code> is the name of the route provided to the <code>ember generate route</code> command</li>
</ol>
<h2 id="how-we-teach-this-123"><a class="header" href="#how-we-teach-this-123">How we teach this</a></h2>
<ul>
<li>Update the &quot;Page Title&quot; section in <a href="https://guides.emberjs.com/release/accessibility/page-template-considerations">Page Template Considerations</a> to use <code>ember-page-title</code>.</li>
<li>Update code examples in <a href="https://guides.emberjs.com/release/tutorial/part-1/building-pages/">Building Pages</a> to include uses of <code>{{page-title}}</code>. Also explain that updating the page title with the current page name will help users with assistive technology locate themself on the website.</li>
<li>Update <a href="https://github.com/ember-cli/ember-welcome-page">ember-welcome-page</a> addon and <a href="https://github.com/ember-cli/ember-welcome-page/blob/master/addon/templates/components/welcome-page.hbs">WelcomePage</a> component to explain the contents of the fresh project a bit better. The component should explain the presence of <code>{{page-title}}</code> and link to the &quot;Page Title&quot; section in <a href="https://guides.emberjs.com/release/accessibility/page-template-considerations">Page Template Considerations</a></li>
</ul>
<h2 id="drawbacks-142"><a class="header" href="#drawbacks-142">Drawbacks</a></h2>
<ul>
<li>An additional dependency to new projects. But, no noticeable size differences it's only all +10kb of js for production builds (not gzipped, ~2kb js gzipped)</li>
<li>Add an extra helper <code>{{page-title}}</code> (possible name clashing)</li>
<li>Slightly increases the learning curve. Increases the amount of code in a first-starter project, which could become overwhelming.</li>
<li>The addon will have to be maintained by the <a href="https://github.com/ember-cli">Ember CLI org</a></li>
</ul>
<h2 id="alternatives-144"><a class="header" href="#alternatives-144">Alternatives</a></h2>
<p>N/A</p>
<h2 id="unresolved-questions-95"><a class="header" href="#unresolved-questions-95">Unresolved questions</a></h2>
<p>None</p>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><a href="https://www.w3.org/WAI/WCAG21/Understanding/page-titled.html">WCAG Success Criterion 2.4.2: Page Titled</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-06-18
Relevant Team(s): Ember.js, Learning, Steering, Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/649</p>
<hr />
<h1 id="deprecation-staging"><a class="header" href="#deprecation-staging">Deprecation Staging</a></h1>
<h2 id="summary-156"><a class="header" href="#summary-156">Summary</a></h2>
<p>Establish a staging system for deprecations that allows Ember and other
libraries to roll them out more incrementally. This system will also enable
users to opt-in to a more strict usage mode, where deprecations will assert if
encountered.</p>
<p>The initial stages would be:</p>
<ol>
<li>Available</li>
<li>Enabled</li>
</ol>
<h2 id="motivation-156"><a class="header" href="#motivation-156">Motivation</a></h2>
<p>Ember has a robust deprecation system that has served the community well. However,
there are a number of pain points and use cases that it does not cover very well:</p>
<ul>
<li>
<p><strong>Ecosystem Absorption</strong>: Generally, deprecations need to be absorbed by the
addon ecosystem before they can be absorbed by applications. This is because
apps may see a deprecation that is triggered by addon code, that they have no
control over (other than jumping in and helping out the addon author by reporting
an issue or sending in a pull request). However, today there is no way to add a
deprecation just for
addons - adding a deprecation will make it appear everywhere at once.</p>
<p>This creates pressure to only add deprecations when most of the community has
already transitioned away from the API. However, it also means that we can't
send a strong signal, like a deprecation, to let the community know that it
<em>should</em> begin transitioning. This cyclic dependency can make it difficult to
push the community forward over time.</p>
<p>Deprecation staging would allow deprecations to be added incrementally.
Combined with default settings for apps and addons that enable deprecations at
different stage levels, this would allow incremental rollout throughout the
ecosystem.</p>
</li>
<li>
<p><strong>Pacing</strong>: Currently, deprecations must have their timeline built
directly into the deprecation RFC from the beginning. The deprecation API requires an <code>until</code> version,
and there isn't much flexibility during the rollout process because of this.
Once a deprecation is RFC'd and merged, there isn't much the community can do
to slow down the process.</p>
<p>Staging would give the community multiple checkpoints to decide
whether or not a deprecation was ready to move forward in the process, and to
update the timeline if so. This would allow a deprecation to slow down or
speed up based on real world feedback and absorption.</p>
</li>
<li>
<p><strong>Early Adoption</strong>: Since the current system discourages us from adding
deprecations until we are sure they are ready, it also prevents early adopters
from getting good signals about which patterns are on the way out. This
prevents them from exploring replacements, which means the ecosystem has even
less ability to adapt to deprecations and move forward.</p>
<p>Staging would allow us to introduce deprecations and allow early adopters to
explore them. This would allow us to determine if the new APIs that have been
introduced fully cover the use cases of the APIs that are being deprecated.</p>
</li>
<li>
<p><strong>Restricting Usage/Preventing Backsliding</strong>: Finally, many times deprecations
are fully removed from an Ember app or addon, only to accidentally be added
again in the future. Since deprecations only produce a console warning by default,
it is difficult and unintuitive to prevent this today.</p>
<p>With staging, users will be able to opt-in to deprecations becoming
assertions at a particular stage, in a non breaking way. This will allow users
to prevent backsliding as they incrementally migrate their applications to new
APIs. It will also provide the basis for future RFCs to explore compiling away deprecated features -
if they throw an error when used, they can't be used, so they can also be
removed and the app will continue to work.</p>
</li>
</ul>
<h2 id="detailed-design-136"><a class="header" href="#detailed-design-136">Detailed design</a></h2>
<p>There are two stages that are proposed for deprecations in this RFC:</p>
<ol>
<li>
<p><strong>Available</strong>: Deprecations are initially released in the available stage.
Available deprecations are enabled by default in addons, but not in apps.
This is explained in more detail later.</p>
</li>
<li>
<p><strong>Enabled</strong>: Enabled is the final stage for deprecations. Deprecations
should be moved into Enabled after the replacement APIs have moved into
Recommended in the RFC process, and there is generally high confidence that
the addon ecosystem has absorbed the deprecation for the most part.
Enabled deprecations cannot be disabled.</p>
</li>
</ol>
<p>Deprecations will progress through these stages linearly. In the future, more
stages could be added, but the progression will remain linear. Deprecations that
involve an RFC (as most do), should lay out a plan for how and when a deprecations
will advance to the next stage, but <em>this</em> RFC does not try to prescribe that
progress.</p>
<p>There are two mechanisms that will need new behavior for the proposed staging
system:</p>
<ul>
<li>The <code>deprecate</code> function</li>
<li>The <code>ember</code> config on <code>package.json</code></li>
</ul>
<h3 id="deprecate"><a class="header" href="#deprecate"><code>deprecate</code></a></h3>
<p>The current deprecation function receives the following options:</p>
<pre><code class="language-ts">interface DeprecationOptions {
  id: string;
  until: string;
  url?: string;
}
</code></pre>
<p>This will be updated to the following:</p>
<pre><code class="language-diff">interface DeprecationOptions {
  id: string;
  until: string;
  url?: string;
+ for?: string;
+ since?: {
+   available: string;
+   enabled: string;
+ }
}
</code></pre>
<p>Stepping through the new options individually:</p>
<ul>
<li>
<p><code>for</code>: This is used to indicate the library that the deprecation is for.
<code>deprecate</code> is a public API that can be used by anyone. Now that we intend to
show or hide deprecations based on their stage, we need to have some more
information about what library the deprecation belongs to. It should be the
package name for the library. This can be any string, but in the future, we may
be able to loosen this requirement by using a macro that can get the name of
the package that invokes <code>deprecate()</code>.</p>
</li>
<li>
<p><code>since</code>: This property contains a set of keys corresponding to
each deprecation stage. If a value for a stage if present, the value of all
previous stages must also be present. Each key's value is an exact SemVer
value. To start, only two keys (<code>available</code> and <code>enabled</code>) will
be allowed, and the rest will be ignored.</p>
<p>Any SemVer value can be used here, even if it does not correspond to a published
artifact in a package registry. This is for the sake of simplicity and flexibility,
but it should be noted that creating a deprecation that becomes available in the
future is not recommended.</p>
<p>The highest stage that has a value is considered the stage of the
deprecation is in. Any of the values may be used for deprecation compliance
assertions, depending on the app or addon configuration. This is explained
more below.</p>
<p>If the <code>since</code> key is not provided (as is the case for existing
deprecations), the deprecation is assumed to be <code>enabled</code>.</p>
</li>
</ul>
<p>This RFC also... wait for it... deprecates the usage of the <code>deprecate()</code>
function without the <code>for</code> or <code>since</code> keys. This meta deprecation will be
enabled at the same time as it becomes available like this (using <code>since</code> as the
example):</p>
<pre><code class="language-js">
// 3.21.0 is fabricated here. It will be the next version that is released
// after this RFC is merged / when the work is done.
const NEXT_VERSION = '3.21.0';

deprecate('Calling deprecate() without the \'since\' key is deprecated', false, {
  id: 'ember-source.deprecate',
  until: '4.0.0',
  since: {
    available: NEXT_VERSION,
    enabled: NEXT_VERSION,
  }
})
</code></pre>
<p>At 4.0, both <code>for</code> and <code>since</code> will become required:</p>
<pre><code class="language-diff">interface DeprecationOptions {
  id: string;
  until: string;
  url?: string;
- for?: string;
+ for: string;
- since?: {
+ since: {
    available: string;
    enabled: string;
  }
}
</code></pre>
<h3 id="configuring-apps"><a class="header" href="#configuring-apps">Configuring Apps</a></h3>
<p>Users can configure their application using the <code>ember.deprecations</code>
property in <code>package.json</code>. This property is empty by default, but can be
customized to indicate which versions of an addon the app is compliant with.
This configuration can be described like this:</p>
<pre><code class="language-ts">type DeprecationStage = 'available' | 'enabled';
type Editions = 'classic' | 'octane';

interface AddonDeprecationConfig {
  stage: DeprecationStage;
  version: StrictSemVerString;
  display?: DeprecationStage;
}

interface EmberPackageJSONKey {
  edition?: Editions;
  deprecations?: {
    display?: DeprecationStage;
    addons?: {
      [packageName: string]?: AddonDeprecationConfig;
    }
  }
}
</code></pre>
<p>The new <code>deprecations</code> key has two keys of its own:</p>
<ul>
<li>
<p><code>display</code>: which configures the default stage of deprecations the app owner
wants to see from their app and all addons. If this config is not provided, it defaults to <code>'enabled'</code>.</p>
</li>
<li>
<p><code>addons</code>: which declares which versions of each library the app is compliant with.</p>
<p>Each key points to an object conforming to the <code>AddonDeprecationConfig</code> interface.</p>
<p>Note that while deprecations can be created by applications themselves
(by calling <code>deprecate()</code> in app code), the top level key is still called <code>addons</code>.
The reasoning is that <em>most</em> of the time, Ember does not need to know about
deprecations from applications, as it needs no build-time signaling. These deprecations
will always be displayed and treated as if they are at the <code>enabled</code> stage. Because
there is no compliance config, they will not be promoted to runtime assertions.</p>
</li>
</ul>
<h3 id="addondeprecationconfig"><a class="header" href="#addondeprecationconfig">AddonDeprecationConfig</a></h3>
<p>The keys in each <code>AddonDeprecationConfig</code> are:</p>
<ul>
<li><code>stage</code>: This declares compliance with the addon's deprecations to the stage given.</li>
<li><code>version</code>: This declares compliance with the addon's deprecations to the version given.</li>
<li><code>display</code>: This overrides the root level <code>display</code> config, to allow fine grain control over logged deprecations.</li>
</ul>
<p>The <code>stage</code> and <code>version</code> keys are explained in more detail below.</p>
<h3 id="deprecation-compliance"><a class="header" href="#deprecation-compliance">Deprecation Compliance</a></h3>
<p>Users can opt-in to some deprecations becoming assertions. They do this by
stating that their application is <em>compliant</em> with a given library's
deprecations as of a certain stage and version.</p>
<p>This means that the app is guaranteeing that it does not use <em>any</em> deprecated
APIs that were in <em>the given stage</em> in <em>the given version</em>.
If they <em>do</em> use an API that was deprecated prior to version specified, the invocation of <code>deprecate</code> will
throw an error instead of logging a warning. The error will contain the same
message, with an additional note that the user is encountering this error
because of their deprecation compliance settings.</p>
<p>Deprecation compliance cannot be specified for a version of the
library newer than the one that is installed. Attempting to do this will throw an
error. This is to prevent developers from optimistically declaring compliance with
code that they are not yet running. This also prevents an edge case scenario where
compliance is declared with a version that has not been released yet and accidentally
opting into unknown deprecations when that version <em>does</em> get released.</p>
<h3 id="parsing-compliance-declarations"><a class="header" href="#parsing-compliance-declarations">Parsing Compliance Declarations</a></h3>
<p>Apps can declare compliance with an addon in two ways:</p>
<ul>
<li>by omitting a declaration</li>
<li>by passing an object conforming to the <code>AddonDeprecationConfig</code> interface.</li>
</ul>
<p>If a declaration is omitted, Ember will assume that the app is compliant with
all deprecations in the &quot;enabled&quot; stage, but will not opt the app into any assertions.
This ensures backwards compatibility with apps that do not add this config.</p>
<p>If a <code>AddonDeprecationConfig</code> object is passed, Ember will assume that the app
is compliant with deprecations of the configured <code>stage</code> and later, and the
configured <code>version</code> and earlier. Deprecations that fit this configuration
will also throw assertions in development builds.</p>
<p>Note that <code>AddonDeprecationConfig</code> must have both the
<code>version</code> and the <code>stage</code> properties to be be valid. If both are not provided
a build time error will be thrown.</p>
<h3 id="usage-and-config-example"><a class="header" href="#usage-and-config-example">Usage and Config Example</a></h3>
<p>Let's say that we use <code>deprecate()</code> to add a new deprecation to our library.
Because it's new, we're going to put it in the &quot;available&quot; stage.</p>
<pre><code class="language-js">deprecate('this feature is deprecated!', false, {
  id: 'my-awesome-library.my-awesome-feature',
  for: 'my-awesome-library',
  since: {
    available: '1.2.3'
  },
  until: '2.0.0'
});
</code></pre>
<p>There are a few common variations of compliance config:</p>
<ul>
<li>
<p>No config</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {}
}
</code></pre>
<p>This means that an app may not be compliant with the deprecation from
<code>my-awesome-library</code>. Because Ember doesn't have an explicit declaration,
it will not promote the deprecation to an assertion, regardless of which
version of <code>my-awesome-library</code> is installed.</p>
</li>
<li>
<p>Later stage, current version</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;my-awesome-library&quot;: {
          &quot;stage&quot;: &quot;enabled&quot;,
          &quot;version&quot;: &quot;1.2.3&quot;
        }
      }
    }
  }
}
</code></pre>
<p>This indicates that the app is not compliant with <code>my-awesome-feature</code>
deprecation, so Ember will not promote it to an assertion, regardless of which
version of <code>my-awesome-library</code> is installed.</p>
</li>
<li>
<p>Current stage, but older version.</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;my-awesome-library&quot;: {
          &quot;stage&quot;: &quot;available&quot;,
          &quot;version&quot;: &quot;1.0.0&quot;
        }
      }
    }
  }
}
</code></pre>
<p>This config indicates that the app is not compliant with deprecations added
after 1.0.0, so Ember will not promote the <code>my-awesome-feature</code> deprecation to
an assertion.</p>
</li>
<li>
<p>Matching stage and version</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;my-awesome-library&quot;: {
          &quot;stage&quot;: &quot;available&quot;,
          &quot;version&quot;: &quot;1.2.3&quot;
        }
      }
    }
  }
}
</code></pre>
<p>This indicates that the app <em>is</em> compliant with the <code>my-deprecation-feature</code> and
Ember will throw a runtime assertion if this deprecation is invoked.</p>
</li>
</ul>
<p>Now consider that <code>my-awesome-feature</code> becomes a enabled deprecation in 1.5.0:</p>
<pre><code class="language-diff">deprecate('this feature is deprecated!', false, {
  id: 'my-awesome-library.my-awesome-feature',
  for: 'my-awesome-library',
  since: {
    available: '1.2.3',
+   enabled: '1.5.0',
  },
  until: '2.0.0'
});
</code></pre>
<p>The configurations described above would be affected in the following ways:</p>
<ul>
<li>No config: no change</li>
<li>Later stage, current version: no change, because it was not enabled in 1.2.3</li>
<li>Current stage, older version: no change</li>
<li>Matching stage and version: no change</li>
</ul>
<p>In order to opt-in to an assertion for this enabled config, the app would have
to update their declaration to match the <code>since.enabled</code> value:</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;my-awesome-library&quot;: {
          &quot;stage&quot;: &quot;enabled&quot;,
          &quot;version&quot;: &quot;1.5.0&quot;
        }
      }
    }
  }
}
</code></pre>
<h3 id="configuring-addons"><a class="header" href="#configuring-addons">Configuring Addons</a></h3>
<p>Addons are also able to declare their compliance with other libraries in the same
way as above. A declaration from an addon tells Ember that its <em>parent</em> addon or application
cannot declare compliance to a higher version.</p>
<p>This allows <em>application</em> developers to feel confident that if they declare a
compliance with a <em>high</em> version, Ember's tooling will tell them early that they
have incompatible addons installed.</p>
<p>An addon can specify its deprecation config in the same way as an application,
but there are some notable differences:</p>
<h4 id="limited-to-ember-source"><a class="header" href="#limited-to-ember-source">Limited to ember-source</a></h4>
<p>Addons are recommended to declare compliance <em>only</em> with the <code>ember-source</code> library.
This recommendation does not <em>prevent</em> this mechanism from being used with other libraries,
but the core team would like to exercise this feature before recommending good
patterns and behavior. A warning will be logged in development, if addons declare
compliance with libraries other than <code>ember-source</code>.</p>
<h4 id="declaration-and-defaults"><a class="header" href="#declaration-and-defaults">Declaration and Defaults</a></h4>
<p>While applications must set a <code>StrictSemVerString</code> value for
<code>addons.[packageName].version</code>, addons can additionally set a special
value of <code>&quot;auto&quot;</code>, to indicate that the addon is compliant with
deprecations from the <em>minimum</em> version of the SemVer range specified by the
<code>dependencies</code> or <code>devDependencies</code> in its <code>package.json</code>. The configured stage
would still be used as that stage of declared compliance.</p>
<p>The benefit of these new semantics is that the majority of addon authors don't
have to declare that they are compliant and runtime assertions are not introduced
to apps without any major version updates.</p>
<p>Additionally, this <code>auto</code> keyword would allow addon authors to use automation
(e.g Dependabot) to update their package's dependencies and get valuable CI
feedback about their addon violating new deprecations, without having to update
any compliance config.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>Let's look at a complete example with a real world scenario. In 3.15.0,
Ember deprecated <a href="https://github.com/emberjs/ember.js/blob/master/CHANGELOG.md#v3150-december-9-2019">use of the <code>isVisible</code> property</a> in components. Although
Deprecation Stages did not exist at the time, this is how that deprecation would
be created after this RFC:</p>
<pre><code class="language-js">deprecate('\`isVisble\` is deprecated!', false, {
  id: 'ember-component.is-visible',
  for: 'ember-source', // new property
  until: '4.0.0',
  since: {
    available: '3.15.0',
    enabled: '3.16.0', // this is fabricated for this example
  }
});
</code></pre>
<p>This means that the deprecation for the <code>isVisible</code> property became <em>available</em>
in 3.15, but became enabled in 3.16.</p>
<p>Now let's consider an addon that has a component that uses <code>isVisible</code>, but
doesn't declare any deprecation compliance. In other words, it does not make
any changes or release any new versions. Its <code>package.json</code> config looks like this:</p>
<pre><code class="language-json">{
  &quot;devDependencies&quot;: {
    &quot;ember-source&quot;: &quot;~3.16.0&quot;
  },
  &quot;ember&quot;: {}
}
</code></pre>
<p>Because no compliance is declared, Ember will not make any assumptions about
this addon's compliance. On the other hand, Ember will also not actively
<em>prevent</em> an app from declaring its own compliance. This not only lets apps
use this feature without updating every addon in the ecosystem, it also provides
incentive for the community to add compliance declarations into every addon, so
that they can provide valuable signals to apps and Ember.</p>
<p><strong>TODO</strong>: if the app declares it's compliant with available+3.15 deprecations,
and uses this addon, should Ember promote the deprecation to a runtime assertion?
Pro: apps know immediately that they are not actually compliant when they thought
they were. Con: the only way to &quot;unbreak&quot; an app is to update the addon or to lower
their own compliance config -- both are manual steps.</p>
<p>Next, let's consider that the addon declares its compliance using the <code>auto</code> keyword instead.
(All new addons will have this config from the addon blueprint, so this will be the
next most common scenario.)</p>
<pre><code class="language-json">{
  &quot;devDependencies&quot;: {
    &quot;ember-source&quot;: &quot;~3.16.0&quot;
  },
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;ember-source&quot;: {
          &quot;stage&quot;: &quot;available&quot;,
          &quot;version&quot;: &quot;auto&quot;
        }
      }
    }
  }
}
</code></pre>
<p>Here, the addon is actively declaring that it is compliant with all available
deprecations in <code>ember-source</code> 3.16.0, but not in 3.16.1 and beyond. Because this is an active
declaration, Ember will use it for two things:</p>
<ol>
<li>It will not allow parent addons/apps to declare compliance above 3.16.0.</li>
<li>It will promote usage of <code>isVisible</code> (and other deprecations that fit the same criteria)
to a runtime assertion, assuming that these usages are unexpected.</li>
</ol>
<p>If the addon were to change its devDependencies to <code>~3.17.0</code>, <em>more</em> deprecations
would fall into this category, without the addon author needing to update anything
else. In this way, the <code>&quot;auto&quot;</code> configuration allows addon authors to give parent
apps the best scenario, without having to micromanage another config.</p>
<p>Lastly, the addon can explicitly state that it does <em>not</em> comply with the <code>isVisible</code>
deprecation by setting their compliance to a SemVer version (similar to how an
application would declare the same):</p>
<pre><code class="language-json">{
  &quot;devDependencies&quot;: {
    &quot;ember-source&quot;: &quot;~3.16.0&quot;
  },
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;ember-source&quot;: {
          &quot;stage&quot;: &quot;enabled&quot;,
          &quot;version&quot;: &quot;3.14.3&quot;
        }
      }
    }
  }
}
</code></pre>
<p>In this config, the <code>ember-source</code> version installed in <code>devDependencies</code> is
irrelevant and is ignored.</p>
<p>This config tells Ember that parent apps <em>cannot</em> declare themselves to be in
compliance with even <em>available</em> deprecations in 3.15.0, because they install
a dependency that is not compliant. Ember will throw a build time error for
parent apps that attempt to do this. For example, this config will throw an error:</p>
<pre><code class="language-json">{
  &quot;ember-source&quot;: {
    &quot;stage&quot;: &quot;available&quot;,
    &quot;version&quot;: &quot;3.15.0&quot;
  }
}
</code></pre>
<p>This means that apps that use dependencies that have pinned their compliance to
an older version, must either contribute to the dependency or fork it.</p>
<p>There are some rare cases in which a addon declares its compliance to a version
due to a deprecation it cannot address, but that part of the addon is not used
by the parent app. This RFC does <em>not</em> attempt to solve this use case as deprecation
compliance is namespaced by the name of the package, rather than individual features.</p>
<h3 id="new-apps-and-addons"><a class="header" href="#new-apps-and-addons">New apps and addons</a></h3>
<p>App blueprints will be updated to include the following config:</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;ember-source&quot;: {
          &quot;stage&quot;: &quot;enabled&quot;,
          &quot;version&quot;: &quot;&lt;%= version %&gt;&quot;
        }
      }
    }
  }
}
</code></pre>
<p>Addon blueprints will be updated opt addons into all <code>available</code> deprecations
with this config:</p>
<pre><code class="language-json">{
  &quot;ember&quot;: {
    &quot;deprecations&quot;: {
      &quot;addons&quot;: {
        &quot;ember-source&quot;: {
          &quot;stage&quot;: &quot;available&quot;,
          &quot;version&quot;: &quot;auto&quot;
        }
      }
    }
  }
}
</code></pre>
<h3 id="existing-method-of-handling-deprecations"><a class="header" href="#existing-method-of-handling-deprecations">Existing Method of handling deprecations</a></h3>
<p>Today, apps have three mechanisms for handling deprecations:</p>
<ol>
<li><code>registerDeprecationHandler()</code>: which allows apps a custom way to handle deprecations</li>
<li><code>Ember.ENV.RAISE_ON_DEPRECATION</code> configuration, which promotes deprecations to assertions</li>
<li><code>ember-cli-deprecation-workflow</code> which makes it easier to work on one deprecation at a time</li>
</ol>
<p>This RFC treats these as out of scope, but also should not affect how they work.
Future RFCs may address them individually.</p>
<h2 id="how-we-teach-this-124"><a class="header" href="#how-we-teach-this-124">How we teach this</a></h2>
<p>Advancing a deprecation through stages is conceptually easy to understand.
Application and addon developers who have no knowledge of this RFC should be
able to read a deprecation message and understand both that &quot;available&quot; deprecations
are not urgent and &quot;enabled&quot; deprecations require an action. This should be
reflected in the deprecation message that is logged.</p>
<p>New applications will have a much easier time understanding this as blueprints
will be updated to include some default configurations.</p>
<p>There will need to be new Guides for existing apps to be able to understand
new deprecations more easily. The deprecation message should log links to these
guides.</p>
<p>Some places in the guides that will have to be updated:</p>
<ul>
<li>https://cli.emberjs.com/release/writing-addons/deprecations/</li>
<li>https://guides.emberjs.com/release/configuring-ember/handling-deprecations/</li>
<li>https://guides.emberjs.com/release/configuring-ember/debugging/#toc_dealing-with-deprecations</li>
</ul>
<h2 id="drawbacks-143"><a class="header" href="#drawbacks-143">Drawbacks</a></h2>
<ul>
<li>Confusion about what the config means.</li>
</ul>
<h2 id="alternatives-145"><a class="header" href="#alternatives-145">Alternatives</a></h2>
<p>Not sure.</p>
<h2 id="unresolved-questions-96"><a class="header" href="#unresolved-questions-96">Unresolved questions</a></h2>
<ul>
<li>How does addon config interact with the dummy app, since there is only one package.json?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-08-25
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/659</p>
<hr />
<h1 id="unique-id-helper"><a class="header" href="#unique-id-helper">{{unique-id}} helper</a></h1>
<h2 id="summary-157"><a class="header" href="#summary-157">Summary</a></h2>
<p>Add a new built-in template helper <code>{{unique-id}}</code> for generating unique IDs.</p>
<p>See <a href="https://github.com/emberjs/rfcs/issues/612">pre-RFC issue #612</a></p>
<h2 id="motivation-157"><a class="header" href="#motivation-157">Motivation</a></h2>
<p>When working with HTML it is very common to need to create and reference <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id">DOM IDs that are unique within the HTML document</a>. Classic Ember components provide the <code>elementId</code> attribute which can be used to construct unique ids within classic components, but <code>elementId</code> is not available within Glimmer components or route templates.</p>
<p>There are several common use cases where a developer may need to generate a unique ID for use in a template:</p>
<ol>
<li>Associating <code>label</code> and <code>input</code> elements using the label's <code>for</code> attribute and the input's <code>id</code> attribute.</li>
<li>Using WAI-ARIA attributes to improve accessibility (eg. <code>aria-labelledby</code>, <code>aria-controls</code>)</li>
<li>Integrating 3rd party libraries that attach themselves to DOM elements using DOM IDs (eg. maps, datepickers, jquery plugins, etc)</li>
</ol>
<p>Since providing some faculty for generating unique IDs for DOM elements can reasonably be considered a requirement for most Ember apps wishing to implement an accessible UI (via labelled inputs and/or WAI-ARIA), it is reasonable for Ember to provide this functionality at the framework level. Ember already provides the <code>guidFor</code> utility in javascript, so it is reasonable for Ember to provide similar functionality within templates.</p>
<h2 id="detailed-design-137"><a class="header" href="#detailed-design-137">Detailed design</a></h2>
<p>Add built-in <code>{{unique-id}}</code> template helper.</p>
<h3 id="unique-id"><a class="header" href="#unique-id"><code>{{unique-id}}</code></a></h3>
<p>The <code>unique-id</code> helper can be invoked with no arguments. When invoked this way, the <code>unique-id</code> helper will return a new unique id string for every invocation.</p>
<p>In practice this invocation style would usually be paired with a <code>let</code> block to enable re-use of the unique id generated by <code>{{unique-id}}</code>. </p>
<pre><code class="language-hbs">{{#let (unique-id) as |emailId|}}
  &lt;label for={{emailId}}&gt;Email address&lt;/label&gt;
  &lt;input id={{emailId}} type=&quot;email&quot; /&gt;
{{/let}}

{{#let (unique-id) as |passwordId|}}
  &lt;label for={{passwordId}}&gt;password&lt;/label&gt;
  &lt;input id={{passwordId}} type=&quot;password&quot; /&gt;
{{/let}}
</code></pre>
<p>In the future, an inline or template version of <code>let</code> could enable a single invocation of <code>{{unique-id}}</code> for re-use of the id within a template.</p>
<h3 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h3>
<p>The <code>{{unique-id}}</code> helper can be implemented using the existing mechanisms Ember uses for generating unique ids. An implementation should ideally be designed to prevent id collisions among other ids generated by Ember.</p>
<h2 id="how-we-teach-this-125"><a class="header" href="#how-we-teach-this-125">How we teach this</a></h2>
<h3 id="ember-api-docs-embertemplateshelpers"><a class="header" href="#ember-api-docs-embertemplateshelpers">Ember API docs: Ember.templates.helpers</a></h3>
<p>The Ember API docs can be updated to include the <code>unique-id</code> helper on the page for <a href="https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers">Ember.templates.helpers</a></p>
<blockquote>
<p>Use the <code>{{unique-id}}</code> helper to generate a unique ID string suitable for use as an ID attribute in the DOM.</p>
<pre><code class="language-hbs">&lt;input id={{unique-id}} type=&quot;email&quot; /&gt;
</code></pre>
<p>Each invocation of <code>{{unique-id}}</code> will return a new, unique ID string. You can use the <code>let</code> helper to create an ID that can be reused within a template.</p>
<pre><code class="language-hbs">{{#let (unique-id) as |emailId|}}
  &lt;label for={{emailId}}&gt;Email address&lt;/label&gt;
  &lt;input id={{emailId}} type=&quot;email&quot; /&gt;
{{/let}}
</code></pre>
</blockquote>
<h3 id="ember-guides-associating-labels-and-inputs"><a class="header" href="#ember-guides-associating-labels-and-inputs">Ember Guides: Associating labels and inputs</a></h3>
<p>The Ember guides currently include a section on associating labels and inputs. This section can be updated to use this new <code>{{unique-id}}</code> helper.</p>
<p><a href="https://guides.emberjs.com/release/components/built-in-components/#toc_ways-to-associate-labels-and-inputs">Guides: associating labels and inputs</a></p>
<blockquote>
<p>Every input should be associated with a label. Within HTML, there are several different ways to do this. In this section, we will show how to apply those strategies for Ember inputs.</p>
<p>You can nest the input inside the label:</p>
<pre><code class="language-hbs">&lt;label&gt;
  Ask a question about Ember:
  &lt;Input type=&quot;text&quot; @value={{this.val}} /&gt;
&lt;/label&gt;
</code></pre>
<p>You can associate the label using for and id:</p>
<pre><code class="language-hbs">&lt;label for={{this.myUniqueId}}&gt;
    Ask a question about Ember:
&lt;/label&gt;
&lt;Input id={{this.myUniqueId}} type=&quot;text&quot; @value={{this.val}} /&gt;
</code></pre>
<p>In HTML, each element's id attribute must be a value that is unique within the HTML document. Ember provides the built-in <code>{{unique-id}}</code> helper to assist you with generating unique IDs.</p>
</blockquote>
<blockquote>
<pre><code class="language-hbs">{{#let (unique-id) as |myId|}}
  &lt;label for={{myId}}&gt;
    Ask a question about Ember:
  &lt;/label&gt;
  &lt;Input id={{myId}} type=&quot;text&quot; @value={{this. val}} /&gt;
{{/let}}
</code></pre>
<p>The <code>aria-label</code> attribute enables developers to label an input element with a string that is not visually rendered, but still available to assistive technology.</p>
<pre><code class="language-hbs">&lt;Input id=&quot;site&quot; @value=&quot;How do text fields work?&quot; aria-label=&quot;Ember Question&quot;/&gt;
</code></pre>
<p>While it is more appropriate to use a <label> element, the <code>aria-label</code> attribute can be used in instances where visible text content is not possible.</p>
</blockquote>
<h3 id="accessibility-guides"><a class="header" href="#accessibility-guides">Accessibility guides</a></h3>
<p>This helper will be an important part of Ember's out-of-the-box accessibility story. Future improvements to Ember's accessibility guides will be able to use this helper when discussing how to build forms and how to work with WAI-ARIA attributes such as <code>aria-controls</code> or <code>aria-describedby</code>.</p>
<h2 id="drawbacks-144"><a class="header" href="#drawbacks-144">Drawbacks</a></h2>
<p>Adding new helpers increases the surface area of the framework and the code the core team commits to support long term.</p>
<p>There is nothing about this proposal that could not be instead implemented in an add-on.</p>
<h2 id="alternatives-146"><a class="header" href="#alternatives-146">Alternatives</a></h2>
<ol>
<li>
<p>Do nothing; developers can use backing classes for templates that require an ID, and either use <code>elementId</code> in classic components or import <code>guidFor</code> in glimmer components or via a hand-rolled helper.</p>
</li>
<li>
<p>Introduce a keyword-style syntax that leverages a build-time AST transform to convert this:</p>
</li>
</ol>
<pre><code class="language-hbs">&lt;label for=&quot;{{unique-id}}-toggle&quot;&gt;Toggle&lt;/label&gt;
&lt;input id=&quot;{{unique-id}}-toggle&quot; type=&quot;checkbox&quot;&gt;
</code></pre>
<p>into</p>
<pre><code class="language-hbs">{{#let (unique-id) as |_id|}}
  &lt;label for=&quot;{{_id}}-toggle&quot;&gt;Toggle&lt;/label&gt;
  &lt;input id=&quot;{{_id}}-toggle&quot; type=&quot;checkbox&quot;&gt;
{{/let}}
</code></pre>
<p>This approach is implementable in userland or in add-ons, so it may not be appropriate to consider this alternative for the core primitive introduced into Ember.js itself. </p>
<p>This approach may be slightly more ergonomic but relies on a more magical, non-standard keyword-like API that will need to be specifically taught, and will be a larger maintenance burden.</p>
<h2 id="unresolved-questions-97"><a class="header" href="#unresolved-questions-97">Unresolved questions</a></h2>
<p>none</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-09-26
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/669</h2>
<h1 id="tracked-storage-primitives"><a class="header" href="#tracked-storage-primitives">Tracked Storage Primitives</a></h1>
<h2 id="summary-158"><a class="header" href="#summary-158">Summary</a></h2>
<p>Provide a low level primitive for storing tracked values:</p>
<pre><code class="language-js">let storage = createStorage();

// Set the value of the storage
setValue(storage, 123);

// Get the value of the storage
getValue(storage);
</code></pre>
<h2 id="motivation-158"><a class="header" href="#motivation-158">Motivation</a></h2>
<p>Today, there are two methods for creating a tracked value in Ember apps:</p>
<ol>
<li>The <code>@tracked</code> decorator, which turns class properties into tracked
properties</li>
<li><code>Ember.get</code>, which can be used to track a key on an object so that it updates
if it is set with <code>Ember.set</code>, or dirtied with <code>notifyPropertyChange</code>.</li>
</ol>
<p>The <code>@tracked</code> decorator is good for cases where there are a known set of
mutable values on a class, which is one of the most common use cases in Ember
applications. There are a number of cases, however, where there are unknown,
dynamic, or potentially infinite numbers of decoratable keys. An example of this
is <em>maps</em>.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Maps</a>
are used as key-value stores, typically in cases where the keys are not known
upfront or are dynamic. In many cases, there are many thousands of potential
keys that could be used in a map, even if only a few ever actually are used.
Decorating each and every potential key on a class in these types of cases is
not practical, and if non-alpha-numeric keys are used, not possible.</p>
<p>There are a few different ways that this type of use case can be solved with
public APIs today:</p>
<ol>
<li>
<p>We can use the &quot;immutable pattern&quot;, where the map is duplicated whenever we
wish to change it, the change is applied, and the result is re-assigned to
the tracked property the map is assigned to.</p>
<pre><code class="language-js">@tracked map = new Map();

updateMapValue(key, value) {
  let newMap = new Map(this.map);
  newMap.set(key, value);
  this.map = newMap;
}
</code></pre>
<p>This pattern works nicely when followed rigorously, and was the initial
pattern proposed for <em>all</em> of these types of data structures and operations
(it's even in the official documentation). However, it is fairly unergonomic
without the aid of additional libraries, such as <a href="https://github.com/immerjs/immer">Immer.js</a>,
and it incurs a decent amount of overhead, especially in cases where the data
structures are large.</p>
<p>One solution for that is to re-set the tracked property with the same value,
after the mutation:</p>
<pre><code class="language-js">@tracked map = new Map();

updateMapValue(key, value) {
  this.map.set(key, value);
  this.map = this.map;
}
</code></pre>
<p>This pattern is problematic however, because it's not obvious what the
purpose of re-setting the property is. A developer unfamiliar with Ember may
mistakenly believe this was an error, and remove this statement, causing
bugs. It's not a very google-able pattern either, which makes it more
difficult to learn and to teach. Finally, it's fairly easy this way for the
state to get out of sync with the rest of the system if a developer forgets
to add the extra re-set after mutating the value.</p>
<p>Over time, it's become clear that this pattern is in actuality an antipattern
for these reasons, and something we should begin to discourage in general.</p>
<p>Note that the <em>original</em> immutable pattern, in which state is fully copied,
does not have these problems, and remains a fully valid pattern. However, due
to performance constraints, ergonomics, and personal preferences, it does not
make sense for <em>every</em> Ember application, so we still need to enable
alternative patterns.</p>
</li>
<li>
<p>We can continue to use <code>Ember.get</code> and <code>Ember.set</code> with plain objects.
This pattern works now and will continue to work for the forseeable future,
but does not support using non-string values as keys, so it cannot cover all
the same use cases as Map. In addition, it's not practical for other types of
collections, such as as arrays, since <code>get</code> and <code>set</code> were not built to work
with them.</p>
<p>In addition, it presents a mismatch between the models put forward in Octane,
and the models of Ember classic. In Octane, the idea is that the details of
state tracking are <em>opaque</em> to the user. Using <code>get</code> and <code>set</code> manually means
that every time the object is accessed or updated, the user has to
consciously remember to use these special functions - they have to <em>think</em>
about the details of tracking state. This is a bug-prone process, because it
only takes one mistake in one usage, and the state itself could be used in
many places. In Octane, users should only need to declare reactivity once -
when the state itself is defined.</p>
</li>
<li>
<p>We can use the Cell pattern, as described in <a href="https://www.pzuraq.com/autotracking-case-study-trackedmap/">this blog post</a>.
This pattern is robust, and can be used to make many types of tracked data
structures, as the <a href="https://github.com/pzuraq/tracked-built-ins">tracked-built-ins</a>
library shows. There are a few main downsides to it:</p>
<ul>
<li>Since it is not a formalized pattern, anyone who wants to use it has to
reimplement it. This is not a huge amount of code to add to any given
addon, but it means addon authors have to rederive the pattern themselves
from scratch, which is not ideal. It means there is more overhead overall
to learning these patterns in the first place.</li>
<li>It is not an optimal pattern, because it adds a layer of decoration and an
instance of a class for every cell. This is not a major amount of overhead,
but ideally we wouldn't incur it at all.</li>
<li>It has no potential for future extensibility, particularly with regards to
<em>debug</em> tooling. Ideally, tracked state, even custom tracked state, should
be easy to understand and debug with standard Ember tooling. Currently,
when users look at a stack trace with an issue caused by a cell, they get
something that is very difficult to understand (&quot;why is it telling me
there's an issue with setting <code>value</code> when I'm setting a completely
different key on my TrackedMap?&quot;)</li>
</ul>
</li>
</ol>
<p>Out of these patterns, the Cell pattern is the most robust and most in-line with
state management in Ember Octane. This RFC seeks to formalize it and add it to
the framework, so we can standardize on a common pattern and address the issues
that it currently has.</p>
<h2 id="detailed-design-138"><a class="header" href="#detailed-design-138">Detailed design</a></h2>
<p>This RFC proposes adding the following APIs, exported from
<code>@glimmer/tracking/primitives/storage</code>:</p>
<pre><code class="language-ts">declare function createStorage&lt;T&gt;(
  initialValue?: T,
  isEqual?: (oldValue: T, newValue: T) =&gt; boolean
): Storage&lt;T&gt;;

declare function getValue&lt;T&gt;(storage: Storage&lt;T&gt;): T;

declare function setValue&lt;T&gt;(storage: Storage&lt;T&gt;, value: T): void;
</code></pre>
<h3 id="createstorage"><a class="header" href="#createstorage"><code>createStorage</code></a></h3>
<p>This function creates and returns an instance of a tracked storage. Tracked
storage instances contain one value, which can be read with <code>getValue</code> and set
with <code>setValue</code>. Reading the value consumes it, so that any tracked computations
which are currently active will become entangled with it, and setting value
later will dirty it and cause them to recompute. Creating the value does <em>not</em>
consume it.</p>
<p><code>createStorage</code> can receive an optional initial value as its first parameter.
It also receives an optional <code>isEqual</code> function. This function runs whenever the
value is about to be set, and determines if the value is equal to the previous
value. If it is equal, it does not set the value or dirty it. This defaults to
<code>===</code> equality.</p>
<h3 id="getvalue-2"><a class="header" href="#getvalue-2"><code>getValue</code></a></h3>
<p>This function receives a tracked storage instance, and returns the value it
contains, consuming it so that it entangles with any currently active
autotracking contexts.</p>
<h3 id="setvalue"><a class="header" href="#setvalue"><code>setValue</code></a></h3>
<p>This function receives a tracked storage instance and a value, and sets the
value of the tracked storage to the passed value if it is not equal to the
previous value. If the value is set, it will dirty the storage, causing any
tracked computations which consumed the stored value to recompute. If the value
was <em>not</em> changed, then it does not set the value or dirty it.</p>
<h3 id="re-implementing-tracked-with-storage"><a class="header" href="#re-implementing-tracked-with-storage">Re-implementing <code>@tracked</code> with storage</a></h3>
<p>We can see how the <code>@tracked</code> decorator itself can be re-implemented using
tracked storage.</p>
<pre><code class="language-js">function tracked(target, key, { initializer }) {
  let storages = new WeakMap();

  function getStorage(obj) {
    let storage = storages.get(obj);

    if (storage === undefined) {
      storage = createStorage(initializer.call(this), () =&gt; false);
      storages.set(this, storage);
    }

    return storage;
  };

  return {
    get() {
      return getValue(getStorage(this));
    },

    set(value) {
      return setValue(getStorage(this), value);
    },
  };
}
</code></pre>
<h3 id="a-note-on-this-design"><a class="header" href="#a-note-on-this-design">A note on this design</a></h3>
<p>In general, API design and cohesiveness is an important value in Ember. We work
very hard as a community to develop patterns which are uniform across many
different types of APIs, which in turn leads to a better DX as developers can
generally know what to expect from a given API without even needing to read the
documentation.</p>
<p>The API proposed in this RFC, which uses functions to access and manipulate a
value via an opaque handle, is an unusual API design when compared to most other
Ember APIs. It is a pattern which provides extra flexibility to the implementers
of the API, at the cost of a <em>severe</em> DX penalty for the users of the API,
because of this unusual-ness.</p>
<p>As such this pattern should be used extremely sparingly, on APIs which meet the
following criteria:</p>
<ol>
<li>They are not expected to be used by <em>every</em> Ember developer. If the API will
be used in the Super Rentals tutorial, or the standard non-advanced sections
of the guides, then it should not use this pattern.</li>
<li>They are for extremely core parts of Ember, such as autotracking, where the
primitives underlying them could potentially change significantly in the
future, and maximum flexibility is desired because of this.</li>
<li>They are for extremely performance critical parts of Ember, with usages in
the hundreds of thousands or millions per app, and so maximum flexbility is
desired in order to be able to leverage changes to the primitives for
optimizing performance.</li>
</ol>
<p>In general, most Ember APIs will <em>not</em> meet these requirements, and so this API
design should not be used for them.</p>
<h2 id="how-we-teach-this-126"><a class="header" href="#how-we-teach-this-126">How we teach this</a></h2>
<p>The API docs for this feature can be taken from the descriptions of the
functions in the detailed design section of the RFC. The following guide should
be added to the Autotracking In-Depth guide in the official guides, and the
section on <a href="https://guides.emberjs.com/release/in-depth-topics/autotracking-in-depth/#toc_plain-old-javascript-objects-pojos">POJOs</a>
should be removed.</p>
<h3 id="creating-custom-tracked-data-structures"><a class="header" href="#creating-custom-tracked-data-structures">Creating custom tracked data structures</a></h3>
<p>Tracked properties are a great solution for many different use cases. However,
sometimes they aren't the right tool for the job. For instance, you may need
have a problem that requires you to work with a number of dynamically created
properties, rather than ones that you know up front.</p>
<p>For example, we could make a scoreboard component that keeps score for an
arbitrary number of players, and keep track of the score for each player using
a JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>.</p>
<pre><code class="language-js">// app/components/scoreboard.js
import Component from '@glimmer/component';
import { action } from '@ember/object';

export default class Scoreboard extends Component {
  // Mock data for players - this would eventually be replaced with an argument
  // so players could be passed in
  players = [
    { name: 'Zoey' },
    { name: 'Tomster' },
  ];

  // Create a map from player -&gt; score, with each player's score starting at 0
  scores = new Map(this.players.map(p =&gt; [p, 0]));

  @action
  incrementScore(player) {
    let currentScore = this.scores.get(player);

    this.scores.set(player, currentScore + 1);
  }
}
</code></pre>
<pre><code class="language-hbs">{{#each-in this.scores |player score|}}
  &lt;div&gt;
    {{player.name}}: {{score}}

    &lt;button type=&quot;button&quot; {{on &quot;click&quot; (fn this.incrementScore player)}}&gt;
      +
    &lt;/button&gt;
  &lt;/div&gt;
{{/each-in}}
</code></pre>
<p>This component will loop over the map of scores and show each player's name and
score, along with a button to increment the score. The logic for this component
is all correct, but it won't update when we increment the score because the
<code>scores</code> map is not tracked state. Let's fix that!</p>
<p>Ember provides a set of primitive APIs for creating <em>tracked storage</em>. These
APIs can be used to create higher level tracked data structures. In fact, the
<code>@tracked</code> decorator is <em>implemented</em> using tracked storage, and we can see how
it boils down to tracked storage under the hood in this example.</p>
<pre><code class="language-js">import { tracked } from '@glimmer/tracking';

class Person {
  @tracked name;
}

// could be thought of as:
import {
  createStorage,
  getValue,
  setValue
} from '@glimmer/tracking/primitives/storage';

class Person {
  #name = createStorage();

  get name() {
    return getValue(this.#name);
  }

  set name(value) {
    setValue(this.#name, value);
  }
}
</code></pre>
<p>In this case, we'll create <code>TrackedMap</code>, a class that has the same public API
and behavior as <code>Map</code>, but is integrated with autotracking so that if we read or
update a value in the map our app will correctly rerender.</p>
<p>First off, let's start off with the basics for our class. We want it to have the
same semantics as a standard map, and there's no need to re-implement the wheel.
We can use a standard map as the backing storage for our custom wrapper, and
defer to it directly.</p>
<pre><code class="language-js">// app/utils/tracked-map.js
class TrackedMap {
  #map = new Map();

  constructor(initialValues) {
    for (let [key, value] of initialValues) {
      this.set(key, value);
    }
  }

  get(key) {
    return this.#map.get(key);
  }

  set(key, value) {
    this.#map.set(key, value);
  }

  forEach(fn) {
    this.#map.forEach(fn);
  }

  // Other methods and APIs omitted...
}
</code></pre>
<p>Now, we need to add our tracked storage. We'll use the <code>createStorage</code> API to do
this.</p>
<pre><code class="language-js">// app/utils/tracked-map.js
import {
  createStorage,
  getValue,
  setValue,
} from '@glimmer/tracking/primitives/storage';

class TrackedMap {
  #map = new Map();

  constructor(initialValues) {
    for (let [key, value] of initialValues) {
      this.set(key, value);
    }
  }

  _getStorage(key) {
    let storage = this.#map.get(key);

    if (storage === undefined) {
      storage = createStorage();
      this.#map.set(key, storage);
    }

    return storage;
  }

  get(key) {
    return getValue(this._getStorage(key));
  }

  set(key, value) {
    setValue(this._getStorage(key), value);
  }

  forEach(fn) {
    this.#map.forEach((storage, key) =&gt; fn(getValue(storage, key, this)));
  }

  // Other methods and APIs omitted...
}
</code></pre>
<p>Now, instead of setting values directly in our internal private map, we're
wrapping those values in tracked storage. We create the storage instances with
<code>createStorage</code>, we get the value from them with <code>getValue</code>, and we set
the value in the with <code>setValue</code>. Each tracked storage contains exactly one
value, and whenever we read that value with <code>getValue</code>, it is consumed in any
tracked computations that are currently occuring - just like reading the value
of a tracked property. Likewise, setting the value of a tracked storage instance
with <code>setValue</code> will dirty it, and cause any tracked computations which used it
previously to recompute, just like setting the value of a tracked property.</p>
<p>There's just one issue with this implementation so far - what happens to
<code>forEach</code> if we add a <em>new</em> value to the <code>TrackedMap</code>, one that didn't exist
before? Currently, <code>forEach</code> will consume every <em>existing</em> value and entangle
it, but it will not rerun if we were to add a new key to the map.</p>
<p>Logically, the thing we're trying to represent here is the state of the
collection's iteration. We can do this by creating another storage, and placing
the collection in it.</p>
<pre><code class="language-js">// app/utils/tracked-map.js
import {
  createStorage,
  getValue,
  setValue,
} from '@glimmer/tracking/primitives/storage';

class TrackedMap {
  #map = new Map();
  #collection = createStorage(this, () =&gt; false);

  constructor(initialValues) {
    for (let [key, value] of initialValues) {
      this.set(key, value);
    }
  }

  _getStorage(key) {
    let storage = this.#map.get(key);

    if (storage === undefined) {
      storage = createStorage();
      this.#map.set(key, storage);
    }

    return storage;
  }

  get(key) {
    return getValue(this._getStorage(key));
  }

  set(key, value) {
    // dirty the collection state
    setValue(this.#collection, this);
    setValue(this._getStorage(key), value);
  }

  forEach(fn) {
    // Entangle the collection state
    getValue(this.#collection);
    this.#map.forEach((storage, key) =&gt; fn(getValue(storage, key, this)));
  }

  // Other methods and APIs omitted...
}
</code></pre>
<p>Now we have a storage that we use to represent the value of the collection
itself. We pass a custom equality function to this storage which always returns
<code>true</code>, meaning that whenever we set the value of this storage, it will <em>always</em>
notify, even if the value hasn't changed. We then entangle the collection
storage in <code>forEach</code> by using <code>getValue</code> on it, even though we don't actually
use the value, and we dirty with <code>setValue</code> whenever we <code>set</code> a value. Since we
used a custom equality function that will always notify, we can set it to the
collection itself again.</p>
<p>That should cover all of the basic functionality! If we now use <code>TrackedMap</code> in
our original example instead of <code>Map</code> everything should update and work as
expected:</p>
<pre><code class="language-js">// app/components/scoreboard.js
import Component from '@glimmer/component';
import { action } from '@ember/object';
import TrackedMap from '../utils/tracked-map';

export default class Scoreboard extends Component {
  // Mock data for players - this would eventually be replaced with an argument
  // so players could be passed in
  players = [
    { name: 'Zoey' },
    { name: 'Tomster' },
  ];

  // Create a map from player -&gt; score, with each player's score starting at 0
  scores = new TrackedMap(this.players.map(p =&gt; [p, 0]));

  @action
  incrementScore(player) {
    let currentScore = this.scores.get(player);

    this.scores.set(player, currentScore + 1);
  }
}
</code></pre>
<pre><code class="language-hbs">{{#each-in this.scores |player score|}}
  &lt;div&gt;
    {{player.name}}: {{score}}

    &lt;button type=&quot;button&quot; {{on &quot;click&quot; (fn this.incrementScore player)}}&gt;
      +
    &lt;/button&gt;
  &lt;/div&gt;
{{/each-in}}
</code></pre>
<h2 id="alternatives-147"><a class="header" href="#alternatives-147">Alternatives</a></h2>
<ul>
<li>
<p>Stick with higher level APIs and don't expose the primitives. This could lead
to an explosion of high level complexity, as Ember tries to provide every type
of construct for users to use, rather than a low level primitive.</p>
</li>
<li>
<p>Expose a more functional or more object-oriented API. This would be a somewhat
higher level API than the one proposed here, which may be a bit more
ergonomic, but also would be less flexible. Since this is a new primitive and
we aren't sure what features it may need in the future, the current design
keeps the implementation open and lets us experiment without foreclosing on a
possible higher level design in the future. It also matches with the
previously added primitive APIs.</p>
</li>
</ul>
<h2 id="open-questions-2"><a class="header" href="#open-questions-2">Open Questions</a></h2>
<ul>
<li>
<p>Should we add a <code>peekValue</code> API to check the value without entangling it? This
API is something we've avoided doing for some time because it's very easy to
accidentally cause bugs with it, but it's also something that is possible to
emulate today with a little extra bookkeeping. It's something that has been
asked for a few times as well.</p>
</li>
<li>
<p>Should we add some debug tooling information as the final argument to these
APIs? If so, what should that information be?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-10-02
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/671</p>
<hr />
<h1 id="stop-leaking-implementation-details-of-built-in-components"><a class="header" href="#stop-leaking-implementation-details-of-built-in-components">Stop Leaking Implementation Details of Built-in Components</a></h1>
<h2 id="summary-159"><a class="header" href="#summary-159">Summary</a></h2>
<p>In order to stop leaking implementation details of built-in components, we
propose to:</p>
<ol>
<li>Deprecate importing the following modules
<ol>
<li><code>@ember/component/checkbox</code></li>
<li><code>@ember/component/text-area</code></li>
<li><code>@ember/component/text-field</code></li>
<li><code>@ember/routing/link-component</code></li>
</ol>
</li>
<li>Deprecate accessing the following properties on the <code>Ember</code> global
<ol>
<li><code>Ember.Checkbox</code></li>
<li><code>Ember.LinkComponent</code></li>
<li><code>Ember.TextArea</code></li>
<li><code>Ember.TextField</code></li>
<li><code>Ember.TextSupport</code> (already private, no import path available)</li>
<li><code>Ember.TargetActionSupport</code> (already private, no import path available)</li>
</ol>
</li>
<li>Deprecate calling <code>reopen</code> or <code>reopenClass</code> on the classes and mixins listed
above, whether they were obtained through an import or the <code>Ember</code> global</li>
<li>Deprecate calling <code>reopen</code> or <code>reopenClass</code> on the <code>Ember.Component</code> super
class (which is also the default export of <code>@ember/component</code>), but not when
called on a subclass of <code>Ember.Component</code> other than those listed above</li>
<li>Deprecate calling <code>lookup</code> or <code>factoryFor</code> on an <code>Owner</code> with the following
specifiers
<ol>
<li><code>component:input</code></li>
<li><code>component:link-to</code></li>
<li><code>component:textarea</code></li>
<li><code>component:-checkbox</code> (already considered private)</li>
<li><code>component:-text-field</code> (already considered private)</li>
<li><code>template:component/input</code></li>
<li><code>template:component/link-to</code></li>
<li><code>template:component/textarea</code></li>
<li><code>template:component/-checkbox</code> (already considered private)</li>
<li><code>template:component/-text-field</code> (already considered private)</li>
</ol>
</li>
<li>Deprecate overriding the following factories on an <code>Owner</code>, through placing
files the corresponding locations in the <code>app</code> tree or through any other
means such as runtime registrations or using a custom <code>Resolver</code>
<ol>
<li><code>component:-checkbox</code></li>
<li><code>component:-text-field</code></li>
<li><code>template:component/input</code></li>
<li><code>template:component/link-to</code></li>
<li><code>template:component/textarea</code></li>
<li><code>template:component/-checkbox</code> (already considered private)</li>
<li><code>template:component/-text-field</code> (already considered private)</li>
</ol>
</li>
</ol>
<h2 id="motivation-159"><a class="header" href="#motivation-159">Motivation</a></h2>
<p>The ultimate goal is to stop leaking implementation details of built-in
components and be able to move away from subclassing <code>Ember.Component</code> in their
internal implementations.</p>
<p>This RFC is part of a bigger plan to accomplish this goal, which requires at
least one other follow-up RFC. This section will attempt to provide context for
this overall plan. Please note that this RFC does not attempt to address every
problem mentioned here and should ultimately be evaluated on its own merits.</p>
<h3 id="the-problems"><a class="header" href="#the-problems">The Problems</a></h3>
<p>Ember's built-in components, that is <code>&lt;Input&gt;</code>, <code>&lt;Textarea&gt;</code> and <code>&lt;LinkTo&gt;</code>,
are currently implemented as subclasses of <code>Ember.Component</code>, also known as the
&quot;classic&quot; component API. This made sense historically, as that was the only
component API available in Ember at the time. While this is arguably an
implementation detail, in practice, this aspect of their implementations has
leaked and become relied upon.</p>
<p>Since then, we have identified some design flaws of the <code>Ember.Component</code> API,
which motivated the <a href="0213-custom-components.html">Custom Components</a> and
<a href="0416-glimmer-components.html">Glimmer Components</a> API, the latter of which
became the primary component programming model in modern Ember as of the
<a href="0364-roadmap-2018.html">Octane Edition</a>.</p>
<p>The same design flaws of <code>Ember.Component</code> that impacted Ember app developers
have also had an impact on these built-in components, and we would like to move
away from their legacy implementation for largely the same reason as Ember app
developers.</p>
<hr />
<p>The most concerning aspect of these design flaws was that any named arguments
passed to a classic component during invocation will be set as properties on
the component instance. For example:</p>
<pre><code class="language-hbs">{{!-- This is NOT supported, do not do this! --}}
&lt;Input
  @init={{this.customInit}}
  @willDestroyElement={{this.customWillDestroyElement}}
/&gt;
</code></pre>
<p>Here, the <code>@init</code> and <code>@willDestroyElement</code> arguments will be made available as
<code>instance.init</code> and <code>instance.willDestroyElement</code>, essentially replacing and
overriding the <code>init</code> and <code>willDestroyElement</code> methods on the component class,
which are part of the <code>Ember.Object</code> and <code>Ember.Component</code> API, respectively.</p>
<p>Clearly, this is not something that we intended to support, but it is simply a
consequence that falls out of the design of the <code>Ember.Component</code> API design.</p>
<p>A more likely example of this is the event handling hooks that we inherited
from <code>Ember.Component</code>. In classic components, the way to handle events on the
component's element is to implement hooks like <code>click()</code> and <code>keyDown()</code> on the
component class, which is what the implementation of the component does.</p>
<p>Even though these hooks considered private implementation details (and <a href="https://github.com/emberjs/ember.js/blob/74a99a2971d327783b23a1093cf9564265db1a9d/packages/%40ember/-internals/views/lib/mixins/text_support.js#L299">clearly
marked as such</a>),
developers have observed that they can pass callbacks into arguments of the
same name during invocation, and they will be called when the corresponding
events are dispatched to the components. For example:</p>
<pre><code class="language-hbs">{{!-- This is NOT supported, do not do this! --}}
&lt;Input
  @click={{this.myClickCallback}}
  @focusIn={{this.myFocusInCallback}}
  @keyDown={{this.myKeyDownCallback}}
/&gt;
</code></pre>
<p>This is essentially the same category of bugs as passing <code>@init</code> as an
argument, but it has become relatively common practice and even made it into
the official guides at one point (this is currently being addressed).</p>
<hr />
<p>On top of this, until <a href="0311-angle-bracket-invocation.html">Angle Bracket Invocations</a>
were introduced, there was no convenient way of passing HTML attributes to a
component. Components implemented using the <code>Ember.Component</code> API relied on the
<code>attributeBindings</code> API to map instance properties to HTML attributes.</p>
<p>The built-in components were historically bound by the same constraints, so
they are documented to take <a href="https://github.com/emberjs/ember.js/blob/74a99a2971d327783b23a1093cf9564265db1a9d/packages/%40ember/-internals/glimmer/lib/components/text-field.ts#L62-L122">a large amount of HTML attributes as arguments</a>.</p>
<p>Post-Octane, this has caused some confusion as to what should be passed as
arguments and what should be passed as HTML attributes using the angle bracket
invocation syntax. With a few rare exceptions, the latter should suffice and
the named arguments are mostly obsolete at this point.</p>
<hr />
<p>Similarly, until <a href="0373-Element-Modifier-Managers.html">modifiers</a> were available
<a href="0435-modifier-splattributes.html">with Angle Bracket Invocations</a> and the
<a href="0471-on-modifier.html">{{on}} Modifier</a> was introduced, there was no first-class
API for listening to DOM events on components you do not control. This required
the component authors to enumerate events they want to expose and accept them
as callback arguments, manually dispatching them in the <code>Ember.Component</code>
event-handling hooks.</p>
<p>The built-in components were historically bound by the same constraints here
as well. Before modifiers, the <a href="https://github.com/emberjs/ember.js/blob/74a99a2971d327783b23a1093cf9564265db1a9d/packages/%40ember/-internals/views/lib/mixins/text_support.js#L87-L108">documented way</a>
of handling events on the built-in input components are via the &quot;dasherized&quot;
named arguments, such as <code>&lt;Input @key-down={{this.myAction}} /&gt;</code>.</p>
<p>However, as mentioned above, due to the way arguments are handled, the event
handling hooks inherited from <code>Ember.Component</code> were frequently misused
instead, which would prevent these &quot;dasherized&quot; callbacks from running, as they
would overwrite the re-dispatching logic.</p>
<p>On top of this, there has also been <a href="https://github.com/emberjs/ember.js/pull/18997">a bug</a>
that prevented these callback arguments from working reliably. Unfortunately,
this was not investigated in a timely manner and was only fixed very recently.
This nudged developers towards the incorrect approaches even more and further
propagated the confusion, some of which has made their way into the official
learning materials (this is currently being addressed).</p>
<hr />
<p>In addition, for a variety of historical reasons, the implementation of the
built-in components, that is, the <code>Checkbox</code>, <code>LinkComponent</code>, <code>TextArea</code> and
<code>TextField</code> component classes were documented as public API, as well as the
<code>TextSupport</code> and <code>TargetActionSupport</code> mixins, which are considered private
but are well-documented and accessible through the <code>Ember</code> global.</p>
<p>Because of this, the fact that they are implemented as <code>Ember.Component</code>
subclasses are highly observable. Some common use cases and consequences are:</p>
<ol>
<li>
<p>These classes can be imported for subclassing. For example, an app can
export a custom subclass of <code>TextField</code> at, say, <code>app/components/my-text-field.js</code>
which can then be invoked as <MyTextField>.</p>
</li>
<li>
<p>These classes can be reopened to modify the behavior of the built-in
components. For example, this will add a CSS class to all <code>&lt;Input&gt;</code>
components rendered in the app:</p>
<pre><code class="language-js">import TextField from '@ember/component/text-field';

TextField.reopen({
  classNames: ['i-am-a-text-field']
});
</code></pre>
<p>Likewise, <code>reopenClass</code> can be used to modify the class itself.</p>
</li>
<li>
<p>Similar to the above, reopening the <code>Ember.Component</code> super class will
affect all built-in components as well. For example, this will also add a
CSS class to all built-in components rendered in the app:</p>
<pre><code class="language-js">import Component from '@ember/component';

Component.reopen({
  classNames: ['i-am-a-component']
});
</code></pre>
<p>Likewise, <code>reopenClass</code> can be used to modify the super class itself, which
will be inherited by the built-in component classes.</p>
</li>
<li>
<p>It is possible to lookup (or even replace) the built-in components using the
<code>owner.factoryFor</code> and <code>owner.lookup</code> runtime APIs.</p>
</li>
</ol>
<p>These are all opportunities for the internal implementation to leak, therefore
making changes to how the built-in components are implemented – specifically
stop subclassing from <code>Ember.Component</code> – will likely be a breaking change for
some, even if the new implementations otherwise supported all documented APIs
perfectly.</p>
<h3 id="the-plan"><a class="header" href="#the-plan">The Plan</a></h3>
<p>At their core, the designs of the built-in components are rather simple. Take
the <code>&lt;Input&gt;</code> component for example, its job is to provide a convince on top of
the native <code>&lt;input&gt;</code> element. It accepts <code>@type</code> and <code>@value</code> (or <code>@checked</code>)
as arguments and keeps the underlying <code>&lt;input&gt;</code> element in sync with the given
app state.</p>
<p>That description should cover 90% of what the average developer need to know
about this component. It should feel pretty similar to using any other modern
components in the Ember ecosystem – attributes can be passed in angle bracket
invocation, and native events can be listened to with the <code>{{on}}</code> modifier.</p>
<p>There is a little bit extra this component does – it takes callbacks for some
higher-level &quot;logical events&quot; such as <code>@enter</code> and <code>@escape-press</code>. Arguably
these aren't strictly necessary with the ubiquity of the <code>{{on}}</code> modifier or
specialized addons like <a href="http://adopted-ember-addons.github.io/ember-keyboard/usage">ember-keyboard</a>.
Perhaps we wouldn't have introduced these features today, but since there is
not a direct 1:1 translation to migrate away and there aren't really anything
wrong with them, we are not proposing to remove them to avoid needless churn.</p>
<p>Beyond that, everything else that is now redundant or obselete (such as named
arguments that exists purely for binding HTML attributes and callback arguments
that have corresponding native events) should be deprecated and removed.</p>
<p>Concretely, the plan is to:</p>
<ol>
<li>Deprecate and remove any mechanisms that could leak the implementation</li>
<li>Deprecate and remove any features that are specific to <code>Ember.Component</code></li>
<li>Deprecate and remove any redundant or obselete features</li>
</ol>
<p>This RFC focuses on the first step, and the rest will be proposed separately
in follow-up RFC(s).</p>
<h2 id="detailed-design-139"><a class="header" href="#detailed-design-139">Detailed design</a></h2>
<p>This RFC proposes the following deprecations:</p>
<ol>
<li>Deprecate importing the following modules
<ol>
<li><code>@ember/component/checkbox</code></li>
<li><code>@ember/component/text-area</code></li>
<li><code>@ember/component/text-field</code></li>
<li><code>@ember/routing/link-component</code></li>
</ol>
</li>
<li>Deprecate accessing the following properties on the <code>Ember</code> global
<ol>
<li><code>Ember.Checkbox</code></li>
<li><code>Ember.LinkComponent</code></li>
<li><code>Ember.TextArea</code></li>
<li><code>Ember.TextField</code></li>
<li><code>Ember.TextSupport</code> (already private, no import path available)</li>
<li><code>Ember.TargetActionSupport</code> (already private, no import path available)</li>
</ol>
</li>
<li>Deprecate calling <code>reopen</code> or <code>reopenClass</code> on the classes and mixins listed
above, whether they were obtained through an import or the <code>Ember</code> global</li>
<li>Deprecate calling <code>reopen</code> or <code>reopenClass</code> on the <code>Ember.Component</code> super
class (which is also the default export of <code>@ember/component</code>), but not when
called on a subclass of <code>Ember.Component</code> other than those listed above</li>
<li>Deprecate calling <code>lookup</code> or <code>factoryFor</code> on an <code>Owner</code> with the following
specifiers
<ol>
<li><code>component:input</code></li>
<li><code>component:link-to</code></li>
<li><code>component:textarea</code></li>
<li><code>component:-checkbox</code> (already considered private)</li>
<li><code>component:-text-field</code> (already considered private)</li>
<li><code>template:component/input</code></li>
<li><code>template:component/link-to</code></li>
<li><code>template:component/textarea</code></li>
<li><code>template:component/-checkbox</code> (already considered private)</li>
<li><code>template:component/-text-field</code> (already considered private)</li>
</ol>
</li>
<li>Deprecate overriding the following factories on an <code>Owner</code>, through placing
files the corresponding locations in the <code>app</code> tree or through any other
means such as runtime registrations or using a custom <code>Resolver</code>
<ol>
<li><code>component:-checkbox</code></li>
<li><code>component:-text-field</code></li>
<li><code>template:component/input</code></li>
<li><code>template:component/link-to</code></li>
<li><code>template:component/textarea</code></li>
<li><code>template:component/-checkbox</code> (already considered private)</li>
<li><code>template:component/-text-field</code> (already considered private)</li>
</ol>
</li>
</ol>
<p>The first two sets of deprecations removes the classes themselves from being
public APIs.</p>
<p>In order to support apps that have implemented custom components by subclassing
these built-in classes, the current implementations of the <code>Ember.Checkbox</code>,
<code>Ember.LinkComponent</code>, <code>Ember.TextArea</code> and <code>Ember.TextField</code> classes will be
moved to a legacy addon and remain &quot;frozen&quot; in there. Future versions of Ember
will stop basing the built-in components on these legacy implementations, but
custom subclasses will continue to work. The deprecation message should provide
information about the legacy addon, or link to the deprecation details page
with the relevant information.</p>
<p>The private mixins, on the other hand, will be deprecated without replacement.</p>
<p>Note that in accordance with <a href="0496-handlebars-strict-mode.html">RFC #496</a>, the
following import paths will be made available for use in strict mode:</p>
<ul>
<li><code>Input</code> (<code>import { Input } from '@ember/component</code>)</li>
<li><code>LinkTo</code> (<code>import { LinkTo } from '@ember/routing</code>)</li>
<li><code>Textarea</code> (<code>import { Textarea } from '@ember/component'</code>)</li>
</ul>
<p>However, unlike the deprecated import paths in group 1, these modules provide
opaque values that are intended for use in templates only. Since they do not
expose the implementation details of the built-in components, these new import
paths do not have the same issue described in this RFC.</p>
<p>The third and forth prevents globally modifiying the behavior of built-in
components. Users are encouraged to create wrapper components for use in their
apps or create custom subclasses using the legacy addon.</p>
<p>The fifth deprecation prevents leakage of the classes to runtime code, which is
complimentary to the first two sets of deprecations.</p>
<p>The last group of deprecation prevents partially replacing the built-in
components, such as replacing only the template but not the class.</p>
<p>Notably, the last group of deprecation does not prevent replacing the built-in
components in general, by defining a component with the same name. While this
is not necessarily <em>encouraged</em> and would certainly be confusing for developers
and tools alike, we do not intend to &quot;reserve&quot; the built-in component names, so
if an app provides a component with the same name, they will take precedence
over the built-in components.</p>
<h2 id="transition-path-20"><a class="header" href="#transition-path-20">Transition Path</a></h2>
<h3 id="importing-and-accessing-globals-for-subclassing"><a class="header" href="#importing-and-accessing-globals-for-subclassing">Importing and Accessing Globals For Subclassing</a></h3>
<p>Example deprecation message:</p>
<pre><code>Using Ember.Checkbox or importing from '@ember/component/checkbox' has been
deprecated, install the `@ember/legacy-built-in-components` addon and use
`import { Checkbox } from '@ember/legacy-built-in-components';` instead.
</code></pre>
<hr />
<p>Example that causes deprecation:</p>
<pre><code class="language-js">import Checkbox from '@ember/component/checkbox';
//                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Using Ember.Checkbox or importing from '@ember/component/checkbox' has been
// deprecated, install the `@ember/legacy-built-in-components` addon and use
// `import { Checkbox } from '@ember/legacy-built-in-components';` instead.

export class MyCheckbox extends Checkbox {
  // ...
}
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-js">import { Checkbox } from '@ember/legacy-built-in-components';

export class MyCheckbox extends Checkbox {
  // ...
}
</code></pre>
<hr />
<p>Alternative example that triggers the deprecation:</p>
<pre><code class="language-js">export function initialize(owner) {
  owner.register(
    'component:my-checkbox',
    Ember.Checkbox.extend({ /* ... */ })
//  ~~~~~~~~~~~~~~
// Using Ember.Checkbox or importing from '@ember/component/checkbox' has been
// deprecated, install the `@ember/legacy-built-in-components` addon and use
// `import { Checkbox } from '@ember/legacy-built-in-components';` instead.
  );
}
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-js">import { Checkbox } from '@ember/legacy-built-in-components';

export function initialize(owner) {
  owner.register(
    'component:my-checkbox',
    Checkbox.extend({ /* ... */ })
  );
}
</code></pre>
<hr />
<p>Additional prose in the deprecation guide:</p>
<blockquote>
<p>The implementation of the built-in components are no longer based on these
legacy classes, so they are now unused by the framework and will be removed
in the future.</p>
<p>If you have implemented custom subclasses of these components, you can
install the <code>@ember/legacy-built-in-components</code> addon. This addon vendors the
legacy classes and make them available for import. See the addon's README for
more details.</p>
<p>Note that this addon merely makes the legacy classes available, it does not
&quot;restore&quot; the built-in components' implementation to be based on these legacy
classes.</p>
</blockquote>
<h3 id="reopening-legacy-built-in-component-classes"><a class="header" href="#reopening-legacy-built-in-component-classes">Reopening Legacy Built-in Component Classes</a></h3>
<p>Example deprecation message:</p>
<pre><code>Reopening Ember.Checkbox has been deprecated. Consider implementing your own
wrapper component or create a custom subclass.
</code></pre>
<hr />
<p>Example that causes deprecation:</p>
<pre><code class="language-js">import Checkbox from '@ember/component/checkbox';
//                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// This still triggers the deprecation from above

Checkbox.reopen({
//      ~~~~~~~
// Reopening Ember.Checkbox has been deprecated. Consider implementing your own
// wrapper component or create a custom subclass.
  attributeBindings: ['metadata:data-my-metadata'],
  metadata: ''
});
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-hbs">{{!-- app/components/my-checkbox.hbs --}}

&lt;Input
  @type=&quot;checkbox&quot;
  @checked={{@checked}}
  ...attributes
  data-my-metadata={{@metadata}}
/&gt;
</code></pre>
<hr />
<p>Alternative example that triggers the deprecation:</p>
<pre><code class="language-js">import Checkbox from '@ember/component/checkbox';
//                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// This still triggers the deprecation from above

Checkbox.reopen({
//      ~~~~~~~
// Reopening Ember.Checkbox has been deprecated. Consider implementing your own
// wrapper component or create a custom subclass.
  change(...args) {
    console.log('changed');
    this._super(...args);
  }
})
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-js">// app/components/my-checkbox.js

import { Checkbox } from '@ember/legacy-built-in-components';

export default class MyCheckbox extends Checkbox {
  change(...args) {
    console.log('changed');
    super.change(...args);
  }
}
</code></pre>
<hr />
<p>Additional prose in the deprecation guide:</p>
<blockquote>
<p>The implementation of the built-in components are no longer based on these
legacy classes, so reopening them will soon have no effect.</p>
<p>To customize the behavior of these built-in components, create your own
wrapper components as a template-only component and invoke that instead.</p>
<p>Alternatively, you may also implement your own customized version of the
component installing the <code>@ember/legacy-built-in-components</code> addon. This
addon vendors the legacy classes and make them available for subclassing. See
the addon's README for more details.</p>
<p>Note that this addon merely makes the legacy classes available, it does not
&quot;restore&quot; the built-in components' implementation to be based on these legacy
classes. You cannot simply reopen the classes provided by this addon.</p>
</blockquote>
<h3 id="reopening-classic-component-super-class"><a class="header" href="#reopening-classic-component-super-class">Reopening Classic Component Super Class</a></h3>
<p>Example deprecation message:</p>
<pre><code>Reopening the Ember.Component super class itself has been deprecated. Consider
alternatives such as installing event listeners on the document or add the
customizations to specific subclasses.
</code></pre>
<hr />
<p>Example that causes deprecation:</p>
<pre><code class="language-js">import Component from '@ember/component';

Component.reopen({
//       ~~~~~~~
// Reopening the Ember.Component super class itself has been deprecated. Consider
// alternatives such as installing event listeners on the document or add the
// customizations to specific subclasses.
  click() {
    console.log('Clicked on a classic component');
  }
});
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-js">document.addEventListener('click', event =&gt; {
  if (e.target.classList.contains('ember-view')) {
    console.log('Clicked on a classic component');
  }
});
</code></pre>
<hr />
<p>Alternative example that triggers the deprecation:</p>
<pre><code class="language-js">import Component from '@ember/component';

Component.reopen({
//       ~~~~~~~
// Reopening the Ember.Component super class itself has been deprecated. Consider
// alternatives such as installing event listeners on the document or add the
// customizations to specific subclasses.
  attributeBindings: ['metadata:data-my-metadata'],
  metadata: ''
});
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-js">// app/components/base.js

import Component from '@ember/component';

// Subclass from this in your app, instead of subclassing from Ember.Component
export default Component.extend({
  attributeBindings: ['metadata:data-my-metadata'],
  metadata: ''
});
</code></pre>
<hr />
<p>Additional prose in the deprecation guide:</p>
<blockquote>
<p>Reopening a the <code>Ember.Component</code> super class is dangerous and has
far-reaching consequences. For example, it may unexpectedly break addons that
are not expecting the changes.</p>
<p>To respond to DOM events globally, consider using global event listeners
instead.</p>
<p>Alternatively, you may create a custom subclass of <code>Ember.Component</code> with the
behavior you want and subclass from that in your app. That way, only those
components which explictly opted into the changes will be affected.</p>
</blockquote>
<h3 id="runtime-lookups"><a class="header" href="#runtime-lookups">Runtime Lookups</a></h3>
<p>Example deprecation message:</p>
<pre><code>Looking up `component:input` is deprecated. The implementations of the built-in
components are considered private and should not be relied upon. In the future,
the runtime registry will no longer contain entries for built-in components.
</code></pre>
<hr />
<p>Example that causes deprecation:</p>
<pre><code class="language-js">this.owner.lookup('component:input');
</code></pre>
<p>Fixed example:</p>
<p><strong>(None)</strong></p>
<h3 id="partial-registration-override"><a class="header" href="#partial-registration-override">Partial Registration Override</a></h3>
<p>Example deprecation message:</p>
<pre><code>Registering `component:-checkbox` or having a `app/components/-checkbox`
module in your app is deprecated. To replace the `&lt;Input&gt;` built-in component,
you must fully replace it in its entirity, by registering `component:input` or
defining a `app/components/input` module.
</code></pre>
<hr />
<p>Example that causes deprecation:</p>
<pre><code class="language-js">// app/components/-checkbox.js

import Component from '@glimmer/component';

export default class MyBetterCheckbox extends Component {
  // ...only handles &lt;Input @type=&quot;checkbox&quot; /&gt;
}
</code></pre>
<p>Fixed example:</p>
<pre><code class="language-js">// app/components/input.js

import Component from '@glimmer/component';

export default class MyBetterInput extends Component {
  // ...must handle all cases of &lt;Input /&gt;
}
</code></pre>
<h2 id="how-we-teach-this-127"><a class="header" href="#how-we-teach-this-127">How we teach this</a></h2>
<p>The API documentation should be updated to document the built-in components as
components, not as classes. When reading the documentation, developers should
be able to understand the components in terms of what <em>arguments</em> they are able
to pass. The exact format for documenting components is left unspecified to
provide the learning team some flexibility in accomplish this goal.</p>
<h2 id="drawbacks-145"><a class="header" href="#drawbacks-145">Drawbacks</a></h2>
<p>Apps that heavily customizes the built-in components will have to put in some
work to migrate, though this is largely mitigated by making the existing
implementations available through the legacy addon.</p>
<h2 id="alternatives-148"><a class="header" href="#alternatives-148">Alternatives</a></h2>
<ul>
<li>
<p>We can leave the existing built-in components around, ship new, modernized
versions under new names, without deprecating the old ones. This will create
more cruft and confusion in the long run, as may be difficult for developers
to determine which ones are the recommended ones.</p>
</li>
<li>
<p>We can leave the existing built-in components around, ship new, modernized
versions under new names, and deprecating the old ones. Assuming the new
components are roughly a subset of the existing ones, this will have more or
less the same end result as the plan laid out above, but possibly with more
intermediate churn.</p>
<p>In this case, developers would have to figure out how to refactor away from
legacy features that are no longer supported by the new version before they
could fully migrate, similar to how developers are migrating from classic to
Glimmer components today.</p>
<p>By deprecating and removing individual features, as proposed in this plan, we
will be able to provide more directly actionable guidance in each case.</p>
</li>
<li>
<p>We can remove the built-in components altogether. This is a much bigger lift
that would require analyising all existing use cases and likely requires
designing new capabilities and features to fill some of those gaps.</p>
<p>Other than the problems outlined in this RFC, the built-in components mostly
get the job done adequately, and we feel like there is not a lot of value in
taking on the project to reimagine them significantly and force the entire
community to migrate to completely new patterns at this moment.</p>
<p>Our preference would therefore be to pare down the existing components to
address the problems raised here. In the meantime, we will work on providing
primitives and capabilities that underpins these built-in components (such as
<a href="0391-router-helpers.html">router helpers</a>), so the community can experiment
with alternatives and new patterns.</p>
<p>If and when they mature to the point of becoming widely accepted as best
practices in the ecosystem, we can revisit deprecating and removing any of
these built-in components as they become redundant. Broadly speaking, we do
not believe we are at that point yet, so in the meantime, we should not stop
improving what we have.</p>
</li>
</ul>
<h2 id="unresolved-questions-98"><a class="header" href="#unresolved-questions-98">Unresolved questions</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-10-02
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/673</p>
<hr />
<h1 id="deprecate-tryinvoke"><a class="header" href="#deprecate-tryinvoke">Deprecate <code>tryInvoke</code></a></h1>
<h2 id="summary-160"><a class="header" href="#summary-160">Summary</a></h2>
<p>Deprecate support for <code>tryInvoke</code> in Ember's Utils module (@ember/utils) because native JavaScript has <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> for developers to use as an alternative solution. Deprecating <code>tryInvoke</code> will help to reduce Ember API redundancy.</p>
<h2 id="motivation-160"><a class="header" href="#motivation-160">Motivation</a></h2>
<p>In most cases, Function arguments should not be optional, but in the rare occasion that a Function argument is intentionally optional by design, we can use native JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> as a solution. Deprecating <code>tryInvoke</code> will help to reduce Ember API redundancy.</p>
<h2 id="transition-path-21"><a class="header" href="#transition-path-21">Transition Path</a></h2>
<p>Ember will start logging deprecation messages for <code>tryInvoke</code> usage. Deprecation text: <code>Using tryInvoke has been deprecated. Instead, consider using native JavaScript optional chaining.</code></p>
<p>We can codemod our current usage of <code>tryInvoke</code> with the equivalent behaviour using plain JavaScript. The migration guide will cover this example:</p>
<p>Before:</p>
<pre><code class="language-js">import { tryInvoke } from '@ember/utils';

foo() {
 tryInvoke(this.args, 'bar', ['baz']);
}
</code></pre>
<p>After:</p>
<pre><code class="language-js">foo() {
 this.args.bar?.('baz');
}
</code></pre>
<h4 id="using-optional-chaining-operator"><a class="header" href="#using-optional-chaining-operator">Using Optional Chaining Operator</a></h4>
<p>The optional chaining operator <code>?.</code> permits reading the value of a property located deep within a chain of connected objects without having to expressly validate that each reference in the chain is valid. The <code>?.</code> operator functions similarly to the <code>.</code> chaining operator, except that instead of causing an error if a reference is nullish (<code>null</code> or <code>undefined</code>), the expression short-circuits with a return value of <code>undefined</code>. When used with Function calls, it returns <code>undefined</code> if the given function does not exist:</p>
<pre><code class="language-js">const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah'
  }
};

const dogName = adventurer.dog?.name;
console.log(dogName);
// expected output: undefined

console.log(adventurer.someNonExistentMethod?.());
// expected output: undefined
</code></pre>
<p>Tooling Support:</p>
<ul>
<li>
<p><a href="https://babeljs.io/">Babel</a> already supports the <a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining">optional chaining operator</a> so we can use that for future use-cases.</p>
</li>
<li>
<p><a href="https://www.npmjs.com/package/ember-cli-babel">ember-cli-babel</a> all recent versions support optional chaining operator.</p>
</li>
<li>
<p><a href="https://github.com/microsoft/TypeScript">TypeScript</a>, similarly, as of <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">version 3.7</a> also supports the operator so we will not be breaking that flow either.</p>
</li>
</ul>
<h2 id="how-we-teach-this-128"><a class="header" href="#how-we-teach-this-128">How We Teach This</a></h2>
<h3 id="add-to-ember-deprecation-guide"><a class="header" href="#add-to-ember-deprecation-guide">Add to Ember Deprecation Guide</a></h3>
<p>In the <a href="https://deprecations.emberjs.com/">Ember Deprecation Guide</a> we will add the following text:</p>
<p>Deprecate support for <code>tryInvoke</code> in Ember's Utils module (@ember/utils). In most cases, Function arguments should not be optional, but in the rare occasion that a Function argument is intentionally optional by design, we can use native JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> as a solution. Deprecating <code>tryInvoke</code> will help to reduce Ember API redundancy.</p>
<p>Before:</p>
<pre><code class="language-js">import { tryInvoke } from '@ember/utils';

foo() {
 tryInvoke(this.args, 'bar', ['baz']);
}
</code></pre>
<p>After:</p>
<pre><code class="language-js">foo() {
 this.args.bar?.('baz');
}
</code></pre>
<h3 id="remove-from-api-docs"><a class="header" href="#remove-from-api-docs">Remove from API docs</a></h3>
<p>The references to <code>tryInvoke</code> will need to be removed from the <a href="https://api.emberjs.com/ember/release/functions/@ember%2Futils/tryInvoke">API docs</a>.</p>
<h3 id="add-to-ember-guides"><a class="header" href="#add-to-ember-guides">Add to Ember Guides</a></h3>
<p>In <a href="https://guides.emberjs.com/release/">Ember Guides</a> under the <a href="https://guides.emberjs.com/release/components/component-arguments-and-html-attributes/">Arguments</a> section, we will create 2 new sub-headings called <code>Function Arguments</code> and <code>Optional Function Arguments</code>:</p>
<h4 id="function-arguments"><a class="header" href="#function-arguments">Function Arguments</a></h4>
<p>Arguments passed into components can be of type <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">Function</a>. In most cases, Function arguments should be treated as required arguments and therefore should be invoked with normal Function invocation <code>()</code>. It is important to intentionally treat Function arguments as required because in the off chance that the Function argument is <code>undefined</code>, normal Function invocation <code>()</code> will cause a runtime exception and produce a stack trace, making it easier for the developer to find the root cause of the bug.</p>
<pre><code class="language-js">// app/components/parent.js
@action
fooParent() {
 // ...
}
</code></pre>
<pre><code class="language-hbs">{{!-- app/components/parent.hbs --}}
&lt;Child @bar={{this.fooParent}} /&gt;
</code></pre>
<pre><code class="language-js">// app/components/child.js
fooChild() {
 this.args.bar('baz');
}
</code></pre>
<h4 id="optional-function-arguments"><a class="header" href="#optional-function-arguments">Optional Function Arguments</a></h4>
<p>In the rare occasion that a Function argument is intentionally optional by design, you can use native JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> to invoke the optional Function argument <code>?.()</code>. We want to avoid unintentionally treating Function arguments as optional because optional chaining invocation has the side effect of failing silently with no stack trace logged. This will cause a difficult debugging experience for the developer.</p>
<pre><code class="language-hbs">{{!-- app/components/parent.hbs --}}
&lt;Child @bar={{this.fooParent}} /&gt;
</code></pre>
<pre><code class="language-hbs">{{!-- app/components/some-other-parent.hbs --}}
&lt;Child /&gt;
</code></pre>
<pre><code class="language-js">// app/components/child.js
fooChild() {
 this.args.bar?.('baz');
}
</code></pre>
<h2 id="drawbacks-146"><a class="header" href="#drawbacks-146">Drawbacks</a></h2>
<p>This change will cause some deprecation noise but could be mitigated with a codemod.</p>
<h2 id="alternative-solutions"><a class="header" href="#alternative-solutions">Alternative Solutions</a></h2>
<p>We could check that the Function name exists on the object before invocation using an <code>if</code> block, but this alternative leaves the developer to have to wrap each Function call in an <code>if</code> block, making this pattern very cumbersome.</p>
<pre><code class="language-js">foo() {
  if (typeof this.args.bar === 'function') {
    this.args.bar('baz');
  }
}
</code></pre>
<h2 id="alternatives-149"><a class="header" href="#alternatives-149">Alternatives</a></h2>
<h4 id="do-nothing-3"><a class="header" href="#do-nothing-3">Do nothing</a></h4>
<p>We could keep support in place, and provide more guidance around using it.</p>
<h2 id="unresolved-questions-99"><a class="header" href="#unresolved-questions-99">Unresolved questions</a></h2>
<p>None at the moment.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Start Date: 2020-10-12
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/674</p>
<hr />
<h1 id="deprecate-transition-methods-of-controller-and-route"><a class="header" href="#deprecate-transition-methods-of-controller-and-route">Deprecate transition methods of controller and route</a></h1>
<h2 id="summary-161"><a class="header" href="#summary-161">Summary</a></h2>
<p>The methods <code>transitionTo</code> and <code>replaceWith</code> of the <code>Route</code> and the methods
<code>transitionToRoute</code> and <code>replaceRoute</code> of <code>Controller</code> should be deprecated.
Existing methods <code>transitionTo</code> and <code>replaceWith</code> of <code>RouterService</code> should
be used instead.</p>
<h2 id="motivation-161"><a class="header" href="#motivation-161">Motivation</a></h2>
<p>The main motivation is to reduce public API surface related to routing. This
will make the required refactoring of router easier as soon as the methods
have been removed.</p>
<p>The router is known to be poorly documented and underspecified. Especially timing
of the different APIs has been an issue in the past. Some timing related bugs
are open since years.¹</p>
<p>The implementation of <code>Router#transitionTo</code>, <code>Router#replaceWith</code>,
<code>Controller#transitionToRoute</code> and <code>Controller#replaceRoute</code> on one side and
<code>RouterService#transitionTo</code> and <code>RouterService#replaceWith</code> on the other side
are very different. Therefore it's very likely that they have different timings
in edge cases - even if that's not documented. Changing the timing of the
methods is considered a breaking change, which makes refactorings difficult.</p>
<p>Supporting different ways to do the same increases complexity without providing
much value. Especially if it's not only about true shortcuts. Supporting
transitions through <code>RouterService</code> and <code>&lt;LinkTo&gt;</code> component <em>only</em> will reduce
complexity for maintainers.</p>
<p>Additionally it reduces learning costs as new developers do not need to learn
different APIs to do the same thing. The <a href="https://guides.emberjs.com/release/routing/defining-your-routes/#toc_transitioning-between-routes">current guides</a>
showcase this issue by listing all four methods existing today and when they
could be used:</p>
<blockquote>
<p>It depends on where the transition needs to take place:</p>
<ul>
<li>From a template, use <LinkTo /> as mentioned above</li>
<li>From a route, use the transitionTo() method</li>
<li>From a controller, use the transitionToRoute() method</li>
<li>From anywhere else in your application, such as a component, inject the Router Service and use the transitionTo() method</li>
</ul>
</blockquote>
<p>Deprecating <code>Route#transitionTo</code> and <code>Controller#transitionToRoute</code> will reduce
this list to two options without dropping any use case.</p>
<p>Naming <code>RouterService</code> as the only option to trigger a transition in JavaScript
will also help with teaching Ember as a a component-service framework.
<code>RouterService#transitionTo</code> and <code>RouterService#replaceWith</code> are not only
available in <code>Route</code> and <code>Controller</code> but also in any services and components.</p>
<p>The current architecture might mislead developers not being aware of
<code>RouterService</code> to bubble an action up to the controller or route in order to
trigger a transition. Or pass <code>Controller#transitionToRoute</code> or
<code>Controller#replaceRoute</code> methods down to a component as an argument.</p>
<h2 id="transition-path-22"><a class="header" href="#transition-path-22">Transition Path</a></h2>
<p><code>Router#transitionTo</code>, <code>Route.replaceWith</code>, <code>Controller.transitionToRoute</code>
and <code>Controller.replaceRoute</code> should trigger a deprecation if being used.
The deprecation message should recommend using <code>RouterService#transitionTo</code>
or <code>RouterService#replaceWith</code> instead.</p>
<pre><code class="language-patch">  // app/route/foo.js

  import Route from '@ember/routing/route';
  import { inject as service } from '@ember/service';

  export default class FooRoute extends Route {
+   @service router;
    @service session;

    beforeModel() {
      if (!this.session.isAuthenticated) {
-       this.transitionTo('login');
+       this.router.transitionTo('login');
      }
    }
  }
</code></pre>
<pre><code class="language-patch">  // app/controllers/foo.js

  import Controller from '@ember/controller';
+ import { inject as service } from '@ember/service';

  export default class FooController extends Controller {
+   @service router;
+
    @action
    async save({ title, text }) {
      let post = this.store.createRecord('post', { title, text });
      await post.save();
-     return this.transitionToRoute('post', post.id);
+     return this.router.transitionTo('post', post.id);
    }
  }
</code></pre>
<p>A codemod should be provided, which replaces the usage of <code>transitionTo</code> method
in any class that extends <code>Route</code> and <code>transitionToRoute</code> method in any class
that extends <code>Controller</code> with <code>this.router.transitionTo</code>. The same should be
done for <code>Route#replaceWith</code> and <code>Controller#replaceRoute</code>. Additionally the
<code>RouterService</code> should be injected if needed.</p>
<p>In case consumers face timing issues while refactoring to
<code>RouterService#transitionTo</code> and <code>RouterService#replaceWith</code> they should change
their project to be compatible with the timing provided by these two methods.
The deprecation phase should be long enough to allow all applications to adopt.
For now it's assumed that it will be enough time for all relevant projects to
migrate before <em>v5.0</em> release. The deprecation period might be increased if a
relevant number of projects weren't able to migrate before that date.</p>
<h2 id="how-we-teach-this-129"><a class="header" href="#how-we-teach-this-129">How We Teach This</a></h2>
<p>The guides need to be updated to only use <code>RouterService#transitionTo</code>,
<code>RouterService#replaceWith</code> and <code>&lt;LinkTo&gt;</code> component in order to trigger
a transition.</p>
<p>The routing guides list available option to transition between routes in
<a href="https://guides.emberjs.com/release/routing/defining-your-routes/#toc_transitioning-between-routes"><em>defining your routes</em> chapter</a>.
As already discussed in motivation section <code>Route#transitionTo</code> and
<code>Controller#transitionToRoute</code> should be removed from that list.</p>
<p>The <a href="https://guides.emberjs.com/release/routing/redirection/"><em>redirecting</em> chapter</a>
of routing guides names <code>Route#transitionTo</code>, <code>Controller#transitionToRoute</code>
and <code>Route#replaceWith</code> as options to trigger a redirect. It doesn't mention
<code>RouterService</code> yet at all. It also doesn't list <code>Controller#replaceRoute</code> as
an option. This two paragraphs should be simplified by naming
<code>RouterService#transitionTo</code> and <code>RouterService#replaceWith</code> only.</p>
<p>The same applies to <a href="https://guides.emberjs.com/release/routing/query-params/#toc_transitionto"><em>transitionTo</em> paragraph of <em>query parameters</em> chapter</a>
of routing guides. Instead of <code>Route#transitionTo</code> and
<code>Controller#transitionToRoute</code> only <code>RouterService#transitionTo</code> should be
mentioned.</p>
<p>Additionally <code>Route.transitionTo</code> is used in some code examples in the guides.
These should be changed to use <code>RouterService#transitionTo</code> instead.</p>
<p>The deprecated methods should be marked as such in the API docs.</p>
<p>No changes to the tutorial are needed. Transitions in the tutorial are done
using <code>&lt;LinkTo&gt;</code> component only.</p>
<h2 id="drawbacks-147"><a class="header" href="#drawbacks-147">Drawbacks</a></h2>
<p><code>Route#transitionTo</code> is a highly used API in existing applications. Deprecating
it will very likely require changes to nearly all existing applications.</p>
<p>Using <code>RouterService</code> instead of methods directly available on <code>Route</code> or
<code>Controller</code> requires explicit injection of router service. This could be seen
as boilerplate code.</p>
<p>Some editors are able to suggest methods which are available on a class
directly which is the case for <code>Router#transitionTo</code> and the other methods
proposed for deprecation. This makes discovering them very easy. Discovering
methods only being available on services that need to be injected first, is not
that easy. Developers not being familar with the API might need to reach out
to guides or API docs to find them.</p>
<p>Deprecating (and later removing) these four methods will not enforce all
transitions to be triggered by either <code>RouterService#transitionTo</code>,
<code>RouterService#replaceWith</code> or <code>&lt;LinkTo&gt;</code>. A transition could be still
triggered by setting a controller property, which is bound to a query
parameter. But this should be addressed in a separate RFC, which reworks
registration of query parameters in general.</p>
<p>Ember Engines <a href="https://github.com/ember-engines/ember-engines/blob/v0.8.7/packages/ember-engines/addon/-private/route-ext.js">injects <code>Route#transitionToExternal</code>, <code>Route#replaceWithExternal</code></a>
and <a href="https://github.com/ember-engines/ember-engines/blob/v0.8.7/packages/ember-engines/addon/-private/controller-ext.js"><code>Controller#transitionToExternalRoute</code></a>
methods. These methods allow the consumer to transition between routes external
to the engine. Ember Engines <a href="https://github.com/ember-engines/ember-engines/issues/587">does not provide a service like <code>RouterService</code> yet</a>
to do this. But it's <a href="https://github.com/ember-engines/ember-engines/pull/669">under active development</a>.</p>
<p>Ember Engines uses the methods deprecated by this RFC to implement
<code>Route#transitionToExternal</code>, <code>Route#replaceWithExternal</code> and
<code>Controller#transitionToExternalRoute</code>. This will trigger a deprecation warning
for all users of Ember Engines until Ember Engines is refactored to not use the
deprecated methods anymore.</p>
<p>While this RFC does not intend to decision how Ember Engines should address
the deprecations, it will very like force Ember Engines to deprecate
<code>Route#transitionToExternal</code>, <code>Route#replaceWithExternal</code> and
<code>Controller#transitionToExternalRoute</code> de facto in mid-term for two reasons:</p>
<ol>
<li>These methods would not align anymore with the method provided by Ember to
transition between routes.</li>
<li>Ember Engines would not be able to change the implementations of these
methods to not use the methods deprecated by this RFC anymore. Using the
<code>RouterService</code> would very likely change timing and other details of the
methods, which could be seen as breaking changes. Keeping the current
timings and other details would require usage of private method of the
router.</li>
</ol>
<h2 id="alternatives-150"><a class="header" href="#alternatives-150">Alternatives</a></h2>
<p>Three possible alternative are discovered so far:</p>
<ol>
<li>
<p>Instead of deprecating <code>Route#transitionTo</code>, <code>Route#replaceWith</code>,
<code>Controller#transitionToRoute</code> and <code>Controller#replaceWith</code> we could try to
align their implementations to match <code>RouterService#transitionTo</code> and
<code>RouterService.replaceWith</code> in regards to timing and other details.</p>
<p>Doing so will very likely require breaking changes as existing applications
do very likely depend onto the existing timings and other details. Even if
not being specified and documented these details became part of our public
API over the years.</p>
<p>Therefore we would need to introduce an optional feature which allows
applications to opt-in into the new timings as soon as they have verifed
everything is working as expected.</p>
</li>
<li>
<p>We could introduce new methods on <code>Route</code> and <code>Controller</code>, which are true
shortcuts for using <code>RouterService</code>. This would prevent introducing the need
to explicitly inject <code>RouterService</code> in <code>Route</code> and <code>Controller</code> in order to
trigger a transition. As mentioned above this could be seen as boilerplate.</p>
<p>Coming up with good names for these new methods would be challening as most
of the names has been taken already. Additionally introducing new methods on
<code>Controller</code> and <code>Route</code> will not help with reducing public API surface and
teaching a component-service architecture.</p>
</li>
<li>
<p>We could do nothing and continue the different ways to trigger a transition
in JavaScript - including different timings and other details.</p>
</li>
</ol>
<h2 id="unresolved-questions-100"><a class="header" href="#unresolved-questions-100">Unresolved questions</a></h2>
<p>No open questions have been discovered so far.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<ol>
<li>
<p>Some example for routing related bugs which are open for quite some time
now:</p>
<ul>
<li>https://github.com/emberjs/ember.js/issues/10262</li>
<li>https://github.com/emberjs/ember.js/issues/11152</li>
<li>https://github.com/emberjs/ember.js/issues/12945</li>
<li>https://github.com/emberjs/ember.js/issues/14875</li>
<li>https://github.com/emberjs/ember.js/issues/15801</li>
<li>https://github.com/emberjs/ember.js/issues/18416</li>
<li>https://github.com/emberjs/ember.js/issues/18577</li>
<li>https://github.com/emberjs/ember.js/issues/19037</li>
</ul>
<p>This list does not contain a represantive list of bugs. Neither does it
include bugs, which I verified myself. It's nothing more than a collection
of bug reports that I found by <a href="https://github.com/emberjs/ember.js/search?p=1&amp;q=transitionTo&amp;type=issues">searching for issues containing
<em>transitionTo</em> in ember.js repository</a>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-10-04
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/680</h2>
<h1 id="implicit-injection-deprecation"><a class="header" href="#implicit-injection-deprecation">Implicit Injection Deprecation</a></h1>
<h2 id="summary-162"><a class="header" href="#summary-162">Summary</a></h2>
<p>This RFC seeks to deprecate implicit injections on arbitrary Ember Framework objects. This is commonly done via <code>owner.inject</code> in an intializer or instance-initializer.</p>
<p>A prevalent example of implicit injection is found in <code>ember-data</code> <a href="https://github.com/emberjs/data/blob/4bd2b327c4cbca831f9e9f8bc6b497200a212f9b/packages/-ember-data/addon/setup-container.js">injecting</a> their default <code>@ember-data/store</code> into all <code>@ember/routing/route</code> and <code>@ember/controller</code> factory objects. Here is a pruned example of how this looks.</p>
<pre><code class="language-js">// app/initializers/store-inject.js
export function initialize(application) {
    application.inject('route', 'store', 'service:store');
    application.inject('controller', 'store', 'service:store');
}

export default {
    name: 'store-inject',
    initialize,
};
</code></pre>
<pre><code class="language-js">export default class PostRoute extends Route {
  // This proposal seeks to make this service injection explicit
  // Currently users do not need to specify this injection if ember-data is installed
  // @service store;

  model() {
    return this.store.findRecord('post', 1);
  }
}
</code></pre>
<p>Ensuring a property is present on Ember's Framework objects should be explicitly defined. This will allow the Ember ecosystem to further progress the framework while easing the learning curve for all developers.</p>
<h2 id="motivation-162"><a class="header" href="#motivation-162">Motivation</a></h2>
<p>Implicit injections have long confused developers onboarding into Ember projects. Without an explicit injection visible on the class body, developers start to wonder how certain properties got there. We can infer from a common implicit injection in <code>ember-data</code> to reason about some of the downsides this presents. If a project has <code>ember-data</code> installed, an initializer at runtime registers the <code>@ember-data/store</code> on both
<code>@ember/routing/route</code> and <code>@ember/controller</code> factory objects.  This is a nice convenience for a project with many routes that are used for data fetching. However, it leads to many inconveniences that hinder learning and advancement of the framework. This includes:</p>
<ol>
<li>
<p>By entangling specific objects with the whole dependency tree, we might be preventing incremental adoption. For example, <code>ember-data</code> has laid out its plan for adopting only specific packages in <a href="https://github.com/emberjs/data/issues/6166">Project Trim</a>. However, because <code>@ember-data/store</code> is injected by default on all <code>@ember/routing/route</code> and <code>@ember/controller</code> factory objects, a user cannot easily opt out of <code>@ember-data/store</code>. This is a common problem space in other communities as well. With previous JetBrains IDE installations, adding plugins required a reload. However, by removing a constructor function that injected all the dependencies at once, they were able to avoid reload after installation of a plugin.</p>
</li>
<li>
<p>Eager initialization of the dependency tree from which the property came from prevents tree shaking and incurs a performance hit. For example, if you app does not need <code>ember-data</code> to render the entry route, the <code>@ember-data/store</code> injection will take up more CPU cycles than necessary, hurting common user facing metrics.</p>
</li>
<li>
<p>Eager initialization makes it hard to users to write tests that need to take advantage of a stub. This is often a silent and annoying hurdle that users have to get around when writing tests. Moreover, this is especially apparent for users moving to Ember's new testing APIs in <a href="https://github.com/emberjs/rfcs/blob/master/text/0232-simplify-qunit-testing-api.md">RFC 232</a> and <a href="https://github.com/emberjs/rfcs/blob/master/text/0268-acceptance-testing-refactor.md">RFC 268</a>, ensuring instance initializers run before each test.</p>
</li>
<li>
<p>Injection on commonly used framework objects can lead to deviation of project specific styleguides. For instance, injecting the <code>router</code> on the <code>@ember/component</code> factory object will certainly lead to instances where the <code>router</code> is explicitly injected and other instances where is it implicitly injected.</p>
</li>
<li>
<p>Users have come to associate <code>Route.model()</code> with a hook that returns <code>ember-data</code> models in the absense of explicit injection. While this can be true, it is not wholly true. New patterns of data loading are becoming accepted in the community including opting to fetch data in a Component.</p>
</li>
</ol>
<h2 id="detailed-design-140"><a class="header" href="#detailed-design-140">Detailed design</a></h2>
<p>Removing implicit injections is not possible until we first issue deprecations. For example, <code>@ember/data</code> cannot remove its <code>owner.inject</code> without it being a breaking change. In doing so, deprecating first helps us maintain our strict semver commitment to not completing a major version bump and removing APIs without a deprecation path. As a result, it will take us 3 phases to remove <code>owner.inject</code>.</p>
<h3 id="1-deprecate-implicit-injection-on-target-object"><a class="header" href="#1-deprecate-implicit-injection-on-target-object">1. Deprecate implicit injection on target object</a></h3>
<p>Simply deprecating <code>owner.inject</code> is not sufficient because it is very difficult to detect if you are relying on implicit injection. As a result, the first step will be issuing a deprecation on the target factory object that is receiving a property. This will surface the deprecation on user's owned objects including transitively through addons like <code>ember-data</code>. This can be accomplished by installing a native getter and setter on the target.</p>
<p>The <em>first time</em> the property is accessed, either through getting or setting it, we will check if the property is explicitly injected. If it isn't, we will issue a deprecation in DEBUG builds with an until, id and url value to read more about this deprecation. In production, we will not issue this deprecation and will continue assigning the property. This deprecation will go <code>until: 4.0.0</code>.</p>
<p>To avoid this deprecation, you will need to explicitly add the injected property to the target object.  As an example, you can add <code>@service store</code> to your route or controller to avert this deprecation resulting from <code>@ember/data</code>'s use of <code>owner.inject</code>.  Users and addons can remove implicit injections as well.</p>
<p>Ember.js <code>v4.0.0</code> will still be released with <code>owner.inject</code>. However, it will not doing anything. Effectively a no-op.</p>
<h3 id="2-deprecate-ownerinject"><a class="header" href="#2-deprecate-ownerinject">2. Deprecate <code>owner.inject</code>.</a></h3>
<p>The first phase did not actually deprecate the use of <code>owner.inject</code>.  As a result, we need to deprecate it's use directly iin <code>v4.0.0</code> before removing completely in <code>v5.0.0</code>.</p>
<p>For users and or addons, you likely already have removed implicit injections like <code>owner.inject</code> before upgrading to Ember.js <code>v4.0.0</code>.  However, for libraries like <code>@ember/data</code>, we will look to remove sometime in <code>v4.0.0</code> to resolve this new deprecation.</p>
<h3 id="3-profit"><a class="header" href="#3-profit">3. Profit!</a></h3>
<p>Ember.js <code>v5.0.0</code> will finally remove the ability to call <code>owner.inject</code> to inject arbitrary properties on Ember's Framework objects.</p>
<p>It is important to consider the timeline of these three phases.  The first step will consist of a minimum of one release cycle.  Many addons and apps will need to make minor and major changes to their codebases before <code>v4.0.0</code>.</p>
<h3 id="impementation-constraints"><a class="header" href="#impementation-constraints">Impementation Constraints</a></h3>
<p>An important implementation detail of stage 1 of this RFC is that while we want
to issue a deprecation when the user relies on the implicit injection, we also
<em>must</em> ensure that the implicit injection still &quot;wins&quot; and is assigned to the
value on the class, clobbering the explicit injection, for the time being. This
is the current behavior, and changing it, even in development builds, would be a
breaking change.</p>
<p>The proposed way to implement this is when an object with implicit injections is
created, for each implicit injection:</p>
<ol>
<li>If the property already contains the value, do nothing as it has been setup
eagerly by the user</li>
<li>If the property is a service injection, check that it is the correct service
injection and if it is, do nothing and assign the value like normal</li>
<li>If the property is a native getter/setter, wrap the native getter/setter and
the first time the value is accessed, check to see if it is the injected
value. If it is, do nothing, otherwise log the deprecation.</li>
<li>If the property is not defined on the object or its prototype, install a
getter/setter pair which log the deprecation the first time they are
activated.</li>
</ol>
<p>This should preserve the existing semantics while logging when the user is
accessing a value that was injected implicitly.</p>
<h2 id="how-we-teach-this-130"><a class="header" href="#how-we-teach-this-130">How we teach this</a></h2>
<p>The API docs would need to be overhauld in a few spots. First, we need to remove the <a href="https://guides.emberjs.com/release/applications/dependency-injection/#toc_factory-injections">docs</a> about Factory injections. Second, we need to detail explicit injection where currently relying on implicit injection.  Many examples show fetching data via <code>this.store</code> but do not specifiy how <code>this.store</code> arrived as a property on the Route. Also apparent disclaimers for people visiting the <code>ember-data</code> docs that explicit injection of <code>@ember-data/store</code> is necessary and has deviated from past behaviour is likely prudent.</p>
<p>The default blueprints when generating a new Ember application will not change.</p>
<h3 id="deprecation-guides"><a class="header" href="#deprecation-guides">Deprecation Guides</a></h3>
<h4 id="stage-1"><a class="header" href="#stage-1">Stage 1</a></h4>
<p>Implicit injections are injections that are made by telling Ember to inject a
service (or another type of value) into every instance of a specific type of
object. A common example of this was the <code>store</code> property that was injected into
routes and controllers when users installed Ember Data by default.</p>
<pre><code class="language-js">export default class ApplicationRoute extends Route {
  model() {
    return this.store.findQuery('user', 123);
  }
}
</code></pre>
<p>Notice how the user can access <code>this.store</code> without having declared the store
service using the <code>@service</code> decorator. This was accomplished by using the
<code>owner.inject</code> API, usually in an initializer:</p>
<pre><code class="language-js">export default {
  initialize(app) {
    app.inject('route', 'store', 'service:store');
    app.inject('controller', 'store', 'service:store');
  }
}
</code></pre>
<p>Implicit injections are difficult to understand, both because it's not obvious
that they exist, or where they come from.</p>
<p>In general, in order to migrate away from this pattern, you should use an
explicit injection instead of an implicit one. You can do this by using the
<code>@service</code> decorator wherever you are using the implicit injection currently.</p>
<p>Before:</p>
<pre><code class="language-js">import { Route } from '@ember/routing/route';

export default class ApplicationRoute extends Route {
  model() {
    return this.store.findQuery('user', 123);
  }
}
</code></pre>
<p>After:</p>
<pre><code class="language-js">import { Route } from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  @service store;

  model() {
    return this.store.findQuery('user', 123);
  }
}
</code></pre>
<p>In some cases, you may be using an injected value which is not a service.
Injections of non-service values do not have a direct explicit-injection
equivalent. As such, to migrate away from these, you will have to rewrite the
injection to use services instead.</p>
<p>Before:</p>
<pre><code class="language-js">// app/initializers/logger.js
import EmberObject from '@ember/object';

export function initialize(application) {
  let Logger = EmberObject.extend({
    log(m) {
      console.log(m);
    }
  });

  application.register('logger:main', Logger);
  application.inject('route', 'logger', 'logger:main');
}

export default {
  name: 'logger',
  initialize: initialize
};
</code></pre>
<pre><code class="language-js">// app/routes/application.js
export default class ApplicationRoute extends Route {
  model() {
    this.logger.log('fetching application model...');
    //...
  }
}
</code></pre>
<p>After:</p>
<pre><code class="language-js">// app/services/logger.js
import Service from '@ember/service';

export class Logger extends Service {
  log(m) {
    console.log(m);
  }
}
</code></pre>
<pre><code class="language-js">// app/routes/application.js
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  @service logger;

  model() {
    this.logger.log('fetching application model...');
    //...
  }
}
</code></pre>
<p>In cases where it is not possible to convert a custom injection type into a
service, the value can be accessed by looking it up directly on the container
instead using the <a href="https://api.emberjs.com/ember/3.22/classes/ApplicationInstance/methods/lookup?anchor=lookup">lookup</a>
method:</p>
<pre><code class="language-js">// app/routes/application.js
import { getOwner } from '@ember/application';
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  get logger() {
    if (this._logger === undefined) {
      this._logger = getOwner(this).lookup('logger:main');
    }

    return this._logger;
  }

  set logger(value) {
    this._logger = value;
  }

  model() {
    this.logger.log('fetching application model...');
    //...
  }
}
</code></pre>
<p>You should always include a setter until the implicit injection is removed,
since the container will still attempt to pass it into the class on creation,
and it will cause errors if it attempts to overwrite a value without a setter.</p>
<h3 id="stage-2"><a class="header" href="#stage-2">Stage 2</a></h3>
<p>The <code>owner.inject</code> API would previously inject a values into every instance of a
particular type of class. For instance, you could inject the <code>store</code> service
automatically into every controller and route:</p>
<pre><code class="language-js">export default {
  initialize(app) {
    app.inject('route', 'store', 'service:store');
    app.inject('controller', 'store', 'service:store');
  }
}
</code></pre>
<p>And in doing so, users could use the value without explicitly declaring it in
that type of object, using <code>@service</code>:</p>
<pre><code class="language-js">import { Route } from '@ember/routing/route';

export default class ApplicationRoute extends Route {
  model() {
    return this.store.findQuery('user', 123);
  }
}
</code></pre>
<p>This ability was deprecated and removed in Ember v4.0.0, so users no longer can
do this, even if you are using the <code>owner.inject</code> API. It instead does nothing,
so you can safely remove it without any other changes necessary.</p>
<h2 id="alternatives-151"><a class="header" href="#alternatives-151">Alternatives</a></h2>
<ul>
<li>Continue with use of <code>owner.inject</code> but overhaul docs and recommend explicit injection.</li>
<li>Provide application level super class with a default <code>@ember-data/store</code> injection provided by <code>ember-data</code> and other common examples in the community.</li>
<li>Allow injection on a specific factory with a single backing Class instead of a generic factory object (e.g. <code>route</code> vs <code>route.index</code>).</li>
</ul>
<h2 id="open-questions-3"><a class="header" href="#open-questions-3">Open Questions</a></h2>
<ul>
<li>Should we simply replace the <a href="https://guides.emberjs.com/release/applications/dependency-injection/#toc_factory-injections">docs</a> on Factory Injections without an alternative?</li>
</ul>
<h2 id="related-links-and-rfcs"><a class="header" href="#related-links-and-rfcs">Related links and RFCs</a></h2>
<ul>
<li><a href="https://github.com/emberjs/rfcs/issues/377">Deprecate defaultStore located at <code>Route.store</code></a></li>
<li><a href="https://github.com/emberjs/rfcs/issues/508">Pre-RFC: Deprecate implicit injections (owner.inject)</a></li>
<li><a href="https://github.com/emberjs/rfcs/issues/557">Deprecate implicit record loading in routes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-11-28
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): All
RFC PR: https://github.com/emberjs/rfcs/pull/685</h2>
<h1 id="new-browser-support-policy"><a class="header" href="#new-browser-support-policy">New Browser Support Policy</a></h1>
<h2 id="summary-163"><a class="header" href="#summary-163">Summary</a></h2>
<p>Establishes a new browser support policy for the next major release of Ember and
Ember Data.</p>
<h2 id="motivation-163"><a class="header" href="#motivation-163">Motivation</a></h2>
<p>With Microsoft's recent release of the new Chromium-based Edge browser, which
has a compatibility mode for Internet Explorer built in, many frameworks, tools,
libraries, and websites have begun finally dropping support for the aging
browser. In order to unlock the latest browser features and continue improving
the framework as a whole, Ember should also drop support in the next major
release.</p>
<p>In dropping support for Internet Explorer, we will need a new browser support
policy. Until now Internet Explorer has been the &quot;lowest common denominator&quot;
for all features. It is a very old browser that no longer releases new versions,
and was not &quot;evergreen&quot; (e.g. constantly updating) even when it was. As such,
Ember has been very stable from release to release, as supporting any version of
Internet Explorer meant we simply could not use any new browser features.</p>
<p>With modern evergreen browser release cycles, where browsers release regularly
and users are generally on one of the more recent versions of a browser, this
dynamic changes. We cannot set an explicit version to support anymore, because
it would be impractical - Chrome alone releases a new version every 6 weeks.
Setting an explicit lowest-supported-version would lock us into having to
support a huge number of older browsers, many of which are entirely unused.</p>
<p>Conversely, however, tracking the latest release of a browser may not be enough
stability for Ember apps. If Ember were to adopt a new browser feature
immediately after its release, even though many web users were still using a
previous version, it would cause many Ember apps to either break, or be unable
to update until their users had also updated to the latest browser. Even a
rolling <code>N - 1</code> or <code>N - 2</code> support policy, where the last 1 or 2 versions are
supported, may not be enough. Many users were stuck in the recent Edgium update
for some time, for instance.</p>
<p>This RFC seeks to establish a new support policy that addresses these issues
with a new set of heuristics. These heuristics distinguish between two types of
browsers which are supported:</p>
<ul>
<li><strong>Evergreen browsers</strong>, those which have adopted a continuous update policy
and generally keep their users up-to-date automatically.</li>
<li><strong>Non-evergreen browsers</strong>, which have more complicated support patterns that
may prevent users from updating regularly.</li>
</ul>
<p>Depending on which category a browser falls into, different rules will be
applied. This will allow us to effectively support browsers which release
frequently, such as Chrome, and browsers which do not, such as Safari.</p>
<h2 id="proposed-policy"><a class="header" href="#proposed-policy">Proposed policy</a></h2>
<p>In the new support policy, Ember will support the following browsers:</p>
<ul>
<li>Desktop
<ol>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
<li>Microsoft Edge</li>
<li>Safari</li>
</ol>
</li>
<li>Mobile
<ol>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
<li>Safari</li>
</ol>
</li>
<li>Testing
<ol>
<li>Headless Chrome</li>
<li>Headless Firefox</li>
</ol>
</li>
</ul>
<p>Any browser which is not listed here may work, but is not explicitly supported.</p>
<p>In addition, these browsers have been categorized into <em>evergreen</em> and
<em>non-evergreen</em> browsers, which have different support policies. This categories
have been chose arbitrarily, based on the current state of browsers and their
support policies.</p>
<ul>
<li>
<p>Evergreen</p>
<ul>
<li>Desktop
<ol>
<li>Google Chrome</li>
<li>Chromium</li>
<li>Mozilla Firefox</li>
<li>Microsoft Edge</li>
</ol>
</li>
<li>Mobile
<ol>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
</ol>
</li>
<li>Testing
<ol>
<li>Headless Chrome</li>
<li>Headless Firefox</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Non-evergreen</p>
<ul>
<li>Desktop
<ol>
<li>Safari</li>
</ol>
</li>
<li>Mobile
<ol>
<li>Safari</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>This categorization will <em>not</em> change without an additional RFC, even if the
browsers themselves make significant changes to their own release process or
support system.</p>
<h4 id="heuristics-for-browser-categorization"><a class="header" href="#heuristics-for-browser-categorization">Heuristics for browser categorization</a></h4>
<p>As mentioned above, the evergreen and non-evergreen categorization is ultimately
arbitrary. However, there were some heuristics which were used to categorize the
supported browsers at the time this RFC was made:</p>
<ol>
<li>
<p><strong>Evergreen browsers</strong> are browsers that:</p>
<ul>
<li>Support using the latest version on all supported platforms (e.g. you can
use the latest Chrome an any supported version of Windows, macOS, Android,
etc. The browser is versioned independently from the operating system).</li>
<li>Automatically update whenever a new version is available.</li>
</ul>
</li>
<li>
<p><strong>Non-evergreen browsers</strong> are any browsers which do not meet the
criteria of evergreen browsers. For instance, Safari is a supported browser
whose version is tied to the version of macOS and iOS that users use. As
users will often wait to update their operating system, many users lag behind
on the version of Safari they are using, so it cannot be considered
evergreen.</p>
</li>
</ol>
<h3 id="evergreen-browsers"><a class="header" href="#evergreen-browsers">Evergreen browsers</a></h3>
<p>For a given Ember and Ember Data minor release, the minimum major version
supported for a given browser is determined using the following formula.</p>
<ul>
<li>Whichever browser version is greater/more recent out of:
<ol>
<li>The lowest/least recent version that fulfills any one of these properties</li>
</ol>
<ul>
<li>It is the latest version of the browser.</li>
<li>It is the latest LTS/extended support version of the browser (such as Firefox ESR).</li>
<li>It has at least <strong>0.25%</strong> of global marketshare usage across mobile and
desktop, based on <a href="https://gs.statcounter.com/">statcounter</a>.</li>
</ul>
<ol start="2">
<li>The minimum version supported in the previous release</li>
</ol>
</li>
</ul>
<p>Within a major version of a browser, the latest patch release is the only
release that is supported.</p>
<p>This policy has the following attributes:</p>
<ul>
<li>It allows us to generally support the most recent browser versions, which
are typically used for some time before everyone upgrades</li>
<li>It allows us to support browser versions that become temporary &quot;speedbumps&quot;
that take longer for users to update, such as the last non-Chromium version of
MS Edge.</li>
<li>It prevents backsliding, once a version is no longer supported, it never
becomes supported again.</li>
</ul>
<p>Above all else, this policy is easy to communicate - for every minor release, we
calculate the minimum supported version, and then communicate that we support
all versions &gt;= that version.</p>
<p>It is important to note that this policy means that each minor release <em>may</em>
drop support for some major versions of evergreen browsers.</p>
<h3 id="non-evergreen-browsers"><a class="header" href="#non-evergreen-browsers">Non-evergreen browsers</a></h3>
<p>Ember and Ember Data will support all major versions greater than or equal to
the following version for non-evergreen browsers:</p>
<ul>
<li>Desktop
<ul>
<li>Safari: 12</li>
</ul>
</li>
<li>Mobile
<ul>
<li>Safari: 12</li>
</ul>
</li>
</ul>
<p>These versions will continue to be supported until support is explicitly dropped
via a new RFC, and dropping support for any version of these browsers will
require a new <strong>major</strong> release.</p>
<p>Within a major version of a browser, the latest patch release is the only
release that is supported.</p>
<h4 id="note-on-the-versions-chosen"><a class="header" href="#note-on-the-versions-chosen">Note on the versions chosen</a></h4>
<p>iOS Safari 12 has a usage of ~1.5% globally as of the writing of this RFC. Given
this, and the fact that newer versions of Safari do not introduce any major
features, 12 seems like an acceptable cutoff at this time.</p>
<h3 id="what-support-means"><a class="header" href="#what-support-means">What support means</a></h3>
<p>This policy governs two major aspects of Ember and Ember Data:</p>
<ol>
<li>When the framework adopts new browser features</li>
<li>How the framework responds to bug reports</li>
</ol>
<p>Ember and Ember Data <em>may</em> introduce new browser feature usage in any <em>minor</em>
version release of Ember, provided the feature is supported in all browsers that
are supported in this policy at the time the the version in released.</p>
<p>Ember and Ember Data <em>may</em> introduce new browser feature usage in any <em>patch</em>
version release of Ember, provided the feature is supported in all browsers that
were supported in this policy at the time the <em>minor</em> that the patch is applied
to was released. In other words, no breakage can or should occur due to new
browser feature usage in <em>any</em> patch release, and if it does, it is a bug.</p>
<p>For bug reports, support is determined by combining our existing Ember version
support policy with the browser versions that were supported at the time an
Ember version was released. This means Ember will work as time and resourcing is
available to fix any browser specific issues that occur in:</p>
<ol>
<li>The current stable and LTS releases of Ember and Ember Data</li>
<li>For browsers that were supported by those versions when they were relased</li>
</ol>
<p>For the previous LTS release, only security bugfixes will be supported,
following the existing LTS policy.</p>
<h3 id="future-changes-to-the-policy"><a class="header" href="#future-changes-to-the-policy">Future changes to the policy</a></h3>
<p>This policy is not meant to be immutable. Over time, new browsers could be added
to the support matrix, and explicit exceptions could be added for &quot;critical
internet infrastructure&quot;.</p>
<p>For example, it was well known that Google's search crawler used a very old
version of Google Chrome for a very long time. It no longer does and is
regularly updated, but during that time frame it was important to support that
version of Chrome. Likewise, it was very important to support IE11 for a very
long time since it had a large usage percentage, especially in corporate
environments. While none of these cases are known to exist at the time of this
writing, if one should arise it may be added explicitly via RFC.</p>
<p>Future RFCs may amend this policy in a strictly additive way without requiring
a major version bump in Ember. Newly supported browsers will begin being
supported in the next minor version of Ember after the updated support policy is
implemented.</p>
<p>Future RFCs that amend this policy to <em>remove</em> support for a browser will
<em>require</em> a major version of Ember to implement.</p>
<h3 id="impact-on-semver"><a class="header" href="#impact-on-semver">Impact on SemVer</a></h3>
<p>While this policy does result in us dropping support for versions of browsers
with each minor release, this RFC proposes that this should not have an impact
on our SemVer policy. SemVer is a communication mechanism, which is used to
communicate to users when impactful changes occur, and what those changes are in
broad categories: breaking, new features, bugfixes.</p>
<p>While dropping support for an evergreen browser version could be considered
breaking in the strictest technical sense, it generally is not considered one
because of the usage patterns that these browsers have in the first place. Their
users are automatically opted into updating every time they boot the browser,
which means in almost all cases users update quickly and efficiently. In fact,
it is often considered a <em>security issue</em> if users are <em>not</em> using the most
recent version of an evergreen browser.</p>
<p>As such, the fact is that in most cases, if a bug is somehow reported on an
older version of an unsupported browser, then the fix is usually to tell the
user to update the browser version, not to patch the application or framework
for that browser version. In practice, this is how Ember has operated for years,
and this policy only formalizes this process.</p>
<h2 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h2>
<p>In order to support this policy while keeping all of our tooling on the same
page, Ember.js itself will add automation to calculate the current minimum
supported version of browsers on its main branch, and publish them in an
accessible format. Each time we branch a release, these versions will stop
updating, so they will effectively be locked in.</p>
<p>These versions will be used for a variety of use cases, such as generating
documentation and release blog posts (see below), and generating the default
<code>config/targets.js</code> for new Ember apps and addons.</p>
<h3 id="deprecation"><a class="header" href="#deprecation">Deprecation</a></h3>
<p>We will add a deprecation to Ember CLI that shows when users have any
unsupported browser in there <code>targets.json</code>, along with a guide for updating to
modern targets.</p>
<h3 id="implementation-timeline"><a class="header" href="#implementation-timeline">Implementation timeline</a></h3>
<p>This policy drops support for a major browser, and therefore can only be
implemented with a major version bump.</p>
<h2 id="how-we-teach-this-131"><a class="header" href="#how-we-teach-this-131">How we teach this</a></h2>
<p>This will be an ongoing process, since the minimum browser versions supported
change over time. The most important thing here is that users can easily
determine whether or not a given version of a browser is supported for a given
Ember release.</p>
<p>The following are the ways we will communicate this:</p>
<ul>
<li>For the release blog post for a minor version, we'll include a table which has
the list of every supported browser, along with the minimum supported major
version of that browser for the release. We will also include the underlying
engine version.</li>
<li>On the <a href="https://emberjs.com/releases">releases page</a> of the Ember.js website,
for each of the listed releases, we will include a table of the supported
versions major browsers for that release.</li>
<li>The browser support on the releases page for the Stable and LTS branches will
be linked in the Ember.js README.</li>
</ul>
<p>This documentation will be supported by the minimum supported versions that are
published in the Ember.js package (see above), which will allow them to be
mostly automated. The supported browser table could look like the following
(generated using today's usage stats):</p>
<h3 id="supported-browsers"><a class="header" href="#supported-browsers">Supported Browsers</a></h3>
<h4 id="desktop"><a class="header" href="#desktop">Desktop</a></h4>
<table><thead><tr><th>Chrome</th><th>Edge</th><th>Firefox</th><th>Safari</th></tr></thead><tbody>
<tr><td>83</td><td>18</td><td>78 (ESR)</td><td>12</td></tr>
</tbody></table>
<h4 id="mobile"><a class="header" href="#mobile">Mobile</a></h4>
<table><thead><tr><th>Chrome</th><th>Firefox</th><th>Safari</th></tr></thead><tbody>
<tr><td>87</td><td>83</td><td>12</td></tr>
</tbody></table>
<h4 id="headless"><a class="header" href="#headless">Headless</a></h4>
<table><thead><tr><th>Chrome</th><th>Firefox</th></tr></thead><tbody>
<tr><td>87</td><td>78 (ESR)</td></tr>
</tbody></table>
<h3 id="how-we-determine-support-page"><a class="header" href="#how-we-determine-support-page">&quot;How we determine support&quot; page</a></h3>
<p>In addition, the technical details of the support policy should be documented on
the Ember website, in a less prominent position (e.g. a link from the supported
versions table titled &quot;how do we determine browser support?&quot;). This could use
the following text:</p>
<p>Ember supports the following major browsers:</p>
<ul>
<li>Desktop
<ol>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
<li>Microsoft Edge</li>
<li>Safari</li>
</ol>
</li>
<li>Mobile
<ol>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
<li>Safari</li>
</ol>
</li>
<li>Testing
<ol>
<li>Headless Chrome</li>
<li>Headless Firefox</li>
</ol>
</li>
</ul>
<p>Other browsers may work with Ember.js, but are not explicitly supported. If you
would like to add support for a new browser, please <a href="https://github.com/emberjs/rfcs">submit an RFC or RFC issue for discussion</a>!</p>
<p>We determine support on a browser-by-browser basis. Browsers are categorized as
either <strong>evergreen</strong> or <strong>non-evergreen</strong>. The categorization is as follows:</p>
<ul>
<li>
<p>Evergreen</p>
<ul>
<li>Desktop
<ol>
<li>Google Chrome</li>
<li>Chromium</li>
<li>Mozilla Firefox</li>
<li>Microsoft Edge</li>
</ol>
</li>
<li>Mobile
<ol>
<li>Google Chrome</li>
<li>Mozilla Firefox</li>
</ol>
</li>
<li>Testing
<ol>
<li>Headless Chrome</li>
<li>Headless Firefox</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Non-evergreen</p>
<ul>
<li>Desktop
<ol>
<li>Safari</li>
</ol>
</li>
<li>Mobile
<ol>
<li>Safari</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>For evergreen browsers, the minimum version of the browser that we support is
determined at the time of every minor release, following this formula:</p>
<ul>
<li>Whichever browser version is greater/more recent out of:
<ol>
<li>The lowest/least recent version that fulfills any one of these properties</li>
</ol>
<ul>
<li>It is the latest version of the browser.</li>
<li>It is the latest LTS/extended support version of the browser (such as Firefox ESR).</li>
<li>It has at least <strong>0.25%</strong> of global marketshare usage across mobile and
desktop, based on <a href="https://gs.statcounter.com/">statcounter</a>.</li>
</ul>
<ol start="2">
<li>The minimum version supported in the previous release</li>
</ol>
</li>
</ul>
<p>To simplify, the supported version either moves forward or stays the same for
each release based on overall usage and LTS/current release versions.</p>
<p>For non-evergreen browsers, support is locked at a specific major version, and
we support all major versions above that version:</p>
<ul>
<li>Desktop
<ul>
<li>Safari: 12</li>
</ul>
</li>
<li>Mobile
<ul>
<li>Safari: 12</li>
</ul>
</li>
</ul>
<p>Within a version of a browser, we only support the most recent patch release.</p>
<h2 id="drawbacks-148"><a class="header" href="#drawbacks-148">Drawbacks</a></h2>
<ul>
<li>
<p>The proposed policy makes Safari the new &quot;lowest common denominator&quot; browser,
replacing IE11. Since the supported versions of Safari will continue to be
supported indefinitely, we will not be able to use any new browser features
added afterwards without another major version. In particular, the spec for
<code>WeakRef</code> has finally been stabilized, and this is something we'll likely want
to make use of in the not-to-distant future.</p>
<p>While this is true, it does not impact the immediate roadmap for Ember in the
next few years. When the time comes, we can update our browser support policy
again, and release a new major version.</p>
</li>
</ul>
<h2 id="alternatives-152"><a class="header" href="#alternatives-152">Alternatives</a></h2>
<ul>
<li>Keep things as they are.</li>
<li>Document the existing policy but do not change it.</li>
<li>Support fewer browsers, for a shorter amount of time.</li>
<li>Support more browsers, for a longer amount of time.</li>
<li>Drop IE11 but not add more definition to support (keeping it as a case by case
determination by the core teams)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-11-28
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/686</h2>
<h1 id="deprecate-old-manager-capabilities"><a class="header" href="#deprecate-old-manager-capabilities">Deprecate Old Manager Capabilities</a></h1>
<h2 id="summary-164"><a class="header" href="#summary-164">Summary</a></h2>
<p>Deprecate older capabilities versions from the various manager APIs.</p>
<h2 id="motivation-164"><a class="header" href="#motivation-164">Motivation</a></h2>
<p>In the 3.x cycle, Ember introduced a series of new low-level APIs for managing
template constructs:</p>
<ul>
<li><a href="https://github.com/emberjs/rfcs/blob/master/text/0213-custom-components.md">Component managers</a></li>
<li><a href="https://github.com/emberjs/rfcs/blob/master/text/0373-Element-Modifier-Managers.md">Modifier managers</a></li>
<li><a href="https://github.com/emberjs/rfcs/blob/master/text/0625-helper-managers.md">Helper managers</a></li>
</ul>
<p>These APIs were expected to evolve more quickly than the higher level APIs they
enabled, and they have in fact done so. They do this via the <code>capabilities</code>
mechanism, where users can specify a version of capabilities that they want.
This allows Ember to change these APIs as needs evolve, as long as the prior
capabilities can still be maintained.</p>
<p>Maintaining the prior capabilities versions has a cost however in terms of
maintenance burden, and sometimes requires us to keep around a decent amount of
extra code or internal features. Deprecating these versions for the next major
release will help clean up code internally overall.</p>
<h2 id="transition-path-23"><a class="header" href="#transition-path-23">Transition Path</a></h2>
<p>Users should update to the most recent manager versions, which will not be
deprecated. The versions which are being deprecated include:</p>
<ul>
<li>Component Managers
<ul>
<li>3.4</li>
</ul>
</li>
<li>Modifier Managers
<ul>
<li>3.13</li>
</ul>
</li>
</ul>
<p>The versions that are still supported are:</p>
<ul>
<li>Component Managers
<ul>
<li>3.13</li>
</ul>
</li>
<li>Modifier Managers
<ul>
<li>3.22</li>
</ul>
</li>
<li>Helper Managers
<ul>
<li>3.23</li>
</ul>
</li>
</ul>
<h2 id="how-we-teach-this-132"><a class="header" href="#how-we-teach-this-132">How We Teach This</a></h2>
<p>In general, the guides won't need to be updated as there isn't guide material
for these manager APIs. We should update the API docs for them to remove the
deprecated capabilities versions. In addition, we should add deprecation guides
for each of the deprecated versions.</p>
<p>Guides as follows.</p>
<h3 id="component-managers"><a class="header" href="#component-managers">Component Managers</a></h3>
<h4 id="34"><a class="header" href="#34">3.4</a></h4>
<p>Any component managers using the <code>3.4</code> capabilities should update to the most
recent component capabilities that are available, currently <code>3.13</code>. In <code>3.13</code>,
the only major change is that update hooks are no longer called by default. If
you need update hooks, use the <code>updateHook</code> capability:</p>
<pre><code class="language-js">capabilities({
  updateHook: true,
});
</code></pre>
<h3 id="modifier-managers"><a class="header" href="#modifier-managers">Modifier Managers</a></h3>
<h4 id="313"><a class="header" href="#313">3.13</a></h4>
<p>Any modifier managers using the <code>3.13</code> capabilities should update to the most
recent modifier capabilities, currently <code>3.22</code>. In <code>3.22</code>, the major changes
are:</p>
<ol>
<li>
<p>The modifier definition, associated via <code>setModifierManager</code> is passed
directly to <code>create</code>, rather than a factory wrapper class. Previously, you
would access the class via the <code>class</code> property on the factory wrapper:</p>
<pre><code class="language-js">// before
class CustomModifierManager {
  capabilities = capabilities('3.13');

  createModifier(Definition, args) {
    return new Definition.class(args);
  }
}
</code></pre>
<p>This can be updated to use the definition directly:</p>
<pre><code class="language-js">// after
class CustomModifierManager {
  capabilities = capabilities('3.22');

  createModifier(Definition, args) {
    return new Definition(args);
  }
}
</code></pre>
</li>
<li>
<p>Args are both lazy and autotracked by default. This means that in order to
track an argument value, you must actually use it in your modifier. If you do
not, the modifier will not update when the value changes.</p>
<p>If you still need the modifier to update whenever a value changes, even if it
was not used, you can manually access every value in the modifiers
<code>installModifier</code> and <code>updateModifier</code> lifecycle hooks:</p>
<pre><code class="language-js">function consumeArgs(args) {
  for (let key in args.named) {
    // consume value
    args.named[key];
  }

  for (let i = 0; i &lt; args.positional.length; i++) {
    // consume value
    args.positional[i];
  }
}

class CustomModifierManager {
  capabilities = capabilities('3.22');

  installModifier(bucket, element, args) {
    consumeArgs(args);

    // ...
  }

  updateModifier(bucket, args) {
    consumeArgs(args);

    // ...
  }
}
</code></pre>
<p>In general this should be avoided, however, and users who are writing
modifiers should instead use the value if they want it to be tracked by the
modifier.</p>
</li>
</ol>
<h2 id="drawbacks-149"><a class="header" href="#drawbacks-149">Drawbacks</a></h2>
<ul>
<li>There will be some minor churn in the ecosystem as managers update, but this
is outweighed by the lowered maintenance burden in general for this
functionality.</li>
</ul>
<h2 id="alternatives-153"><a class="header" href="#alternatives-153">Alternatives</a></h2>
<ul>
<li>Maintian capabilities versions indefinitely. This is not really feasible, as
more and more changes will likely happen over time and eventually it will
result in a large maintenance burden.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-12-22
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/689</h2>
<h1 id="deprecate-hasblock-and-hasblockparams-in-templates"><a class="header" href="#deprecate-hasblock-and-hasblockparams-in-templates">Deprecate <code>{{hasBlock}}</code> and <code>{{hasBlockParams}}</code> in templates</a></h1>
<h2 id="summary-165"><a class="header" href="#summary-165">Summary</a></h2>
<p>Deprecate the <code>{{hasBlock}}</code> and <code>{{hasBlockParams}}</code> properties in templates in
favor of the <code>{{has-block}}</code> and <code>{{has-block-params}}</code> keywords.</p>
<h2 id="motivation-165"><a class="header" href="#motivation-165">Motivation</a></h2>
<p><code>{{hasBlock}}</code> is a way to check if component has a default block provided to
it, and <code>{{hasBlockParams}}</code> is a way to check if that default block has block
parameters. They are effectively aliases for calling <code>{{has-block}}</code> and
<code>{{has-block-params}}</code> respectively, without providing a block name or with the
block name <code>&quot;default&quot;</code>. They are also not called, and acts like a template
fallback lookup instead.</p>
<pre><code class="language-hbs">{{! hasBlock and hasBlockParams can be referenced directly }}
{{#if hasBlock}}{{/if}}

{{#if hasBlockParams}}{{/if}}


{{! has-block and has-block-params must be called }}
{{#if (has-block)}}{{/if}}

{{#if (has-block-params)}}{{/if}}
</code></pre>
<p>Having two ways of accomplishing this task is confusing, and with the property
form it is not possible to check if other blocks exist, such as named blocks. As
such, this RFC proposes that we deprecate <code>{{hasBlock}}</code> and
<code>{{hasBlockParams}}</code> and recommend that users switch to using <code>{{has-block}}</code>
and <code>{{has-block-params}}</code>.</p>
<h2 id="transition-path-24"><a class="header" href="#transition-path-24">Transition Path</a></h2>
<p>Users who are currently using <code>{{hasBlock}}</code> or <code>{{hasBlockParams}}</code> will need
to replace all of their usages with <code>{{has-block}}</code>/<code>{{has-block-params}}</code>
respectively. This is generally a very codemoddable change, so it should be
pretty straightforward to accomplish, and we will attempt to make a codemod to
help out with the transition.</p>
<h2 id="how-we-teach-this-133"><a class="header" href="#how-we-teach-this-133">How We Teach This</a></h2>
<p>Currently, <code>{{hasBlock}}</code> and <code>{{hasBlockParams}}</code> are documented in the API docs,
but <code>{{has-block}}</code> and <code>{{has-block-params}}</code> are not. The new keywords should
be thoroughly documented.</p>
<h3 id="deprecation-guide-3"><a class="header" href="#deprecation-guide-3">Deprecation Guide</a></h3>
<h4 id="hasblock"><a class="header" href="#hasblock"><code>{{hasBlock}}</code></a></h4>
<p>The <code>{{hasBlock}}</code> property is true if the component was given a default block,
and false otherwise. To transition away from it, you can use the <code>(has-block)</code>
helper instead.</p>
<pre><code class="language-hbs">{{hasBlock}}

{{! becomes }}
{{has-block}}
</code></pre>
<p>Unlike <code>{{hasBlock}}</code>, the <code>(has-block)</code> helper must be called, so in nested
positions you will need to add parentheses around it:</p>
<pre><code class="language-hbs">{{#if hasBlock}}

{{/if}}


{{! becomes }}
{{#if (has-block)}}

{{/if}}
</code></pre>
<p>You may optionally pass a name to <code>(has-block)</code>, the name of the block to check.
The name corresponding to the block that <code>{{hasBlock}}</code> represents is &quot;default&quot;.
Calling <code>(has-block)</code> without any arguments is equivalent to calling
<code>(has-block &quot;default&quot;)</code>.</p>
<h4 id="hasblockparams"><a class="header" href="#hasblockparams"><code>{{hasBlockParams}}</code></a></h4>
<p>The <code>{{hasBlockParams}}</code> property is true if the component was given a default block,
and false otherwise. To transition away from it, you can use the <code>(has-block-params)</code>
helper instead.</p>
<pre><code class="language-hbs">{{hasBlockParams}}

{{! becomes }}
{{has-block-params}}
</code></pre>
<p>Unlike <code>{{hasBlockParams}}</code>, the <code>(has-block-params)</code> helper must be called, so in nested
positions you will need to add parentheses around it:</p>
<pre><code class="language-hbs">{{#if hasBlockParams}}

{{/if}}


{{! becomes }}
{{#if (has-block-params)}}

{{/if}}
</code></pre>
<p>You may optionally pass a name to <code>(has-block-params)</code>, the name of the block to check.
The name corresponding to the block that <code>{{hasBlockParams}}</code> represents is &quot;default&quot;.
Calling <code>(has-block-params)</code> without any arguments is equivalent to calling
<code>(has-block-params &quot;default&quot;)</code>.</p>
<h2 id="drawbacks-150"><a class="header" href="#drawbacks-150">Drawbacks</a></h2>
<ul>
<li>
<p>Introduces some churn.</p>
</li>
<li>
<p><code>(has-block)</code> is dasherized, which is not inline with the future of strict
mode and template imports. Dasherized strings are not valid identifiers in
JavaScript, so helpers and modifiers will likely switch to camel case when
that transition occurs.</p>
<p>This actually makes this deprecation even more valuable. As it stands, even if
we wanted to use <code>{{hasBlock &quot;name&quot;}}</code> in templates, we could not, since
<code>{{hasBlock}}</code> already has semantics and is not callable. By deprecating this
syntax, we can reclaim it in the future as a possible alias for the dasherized
version.</p>
</li>
</ul>
<h2 id="alternatives-154"><a class="header" href="#alternatives-154">Alternatives</a></h2>
<ul>
<li>Keep the existing syntax as an alias for <code>(has-block)</code>/<code>(has-block-params)</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-12-22
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/690</h2>
<h1 id="deprecate-using-attrs-in-templates"><a class="header" href="#deprecate-using-attrs-in-templates">Deprecate using <code>{{attrs}}</code> in templates</a></h1>
<h2 id="summary-166"><a class="header" href="#summary-166">Summary</a></h2>
<p>The <code>{{attrs}}</code> object in templates is an alternative way for users to reference
named arguments directly in a template.</p>
<pre><code class="language-hbs">{{attrs.foo}}

{{! is equivalent to }}
{{@foo}}
</code></pre>
<p>It was a legacy API that existed prior to named arguments being introduced in
Ember, and has continued to be supported via a template transform for some time.
This RFC proposes that we deprecate this functionality in favor of directly
using named arguments.</p>
<h2 id="motivation-166"><a class="header" href="#motivation-166">Motivation</a></h2>
<p>The <code>{{attrs}}</code> syntax was from a previous iteration of the concepts that
eventually became named argument syntax. Now that named arguments exist in the
framework, and are considered the best practice, there is no reason to continue
supporting this syntax.</p>
<h2 id="transition-path-25"><a class="header" href="#transition-path-25">Transition Path</a></h2>
<p>Users who currently rely on referencing <code>{{attrs}}</code> can convert their references
to named arguments. This should be highly codemoddable, and we will attempt to
make a codemod to help out with the transition.</p>
<h2 id="how-we-teach-this-134"><a class="header" href="#how-we-teach-this-134">How We Teach This</a></h2>
<h3 id="deprecation-guide-4"><a class="header" href="#deprecation-guide-4">Deprecation Guide</a></h3>
<p>The <code>{{attrs}}</code> object was an alternative way to reference named arguments in
templates that was introduced prior to named arguments syntax being finalized.
References to properties on <code>{{attrs}}</code> can be converted directly to named
argument syntax.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{attrs.foo}}
{{this.attrs.foo.bar}}
{{deeply (nested attrs.foobar.baz)}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs"> {{@foo}}
 {{@foo.bar}}
 {{deeply (nested @foobar.baz)}}
</code></pre>
<h2 id="drawbacks-151"><a class="header" href="#drawbacks-151">Drawbacks</a></h2>
<ul>
<li>None</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-12-22
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/691</h2>
<h1 id="deprecate-passing-classbinding-and-classnamebindings-as-arguments"><a class="header" href="#deprecate-passing-classbinding-and-classnamebindings-as-arguments">Deprecate passing <code>classBinding</code> and <code>classNameBindings</code> as arguments</a></h1>
<h2 id="summary-167"><a class="header" href="#summary-167">Summary</a></h2>
<p>In Ember today, it is possible to pass <code>classBinding</code> and <code>classNameBindings</code> as
arguments to a component when invoked with curly syntax.</p>
<pre><code class="language-hbs">{{some-component classNameBindings=&quot;foo:truthy:falsy&quot;}}
</code></pre>
<p>These arguments are merged into the <code>class</code> attribute on the class, regardless
of whether or not the component is a classic component which contains the
<code>classNameBindings</code> logic. It is also fully possible to accomplish with template
syntax in alternative ways, so this RFC proposes deprecating them.</p>
<h2 id="motivation-167"><a class="header" href="#motivation-167">Motivation</a></h2>
<p><code>classBinding</code> and <code>classNameBindings</code> are Classic component APIs for
manipulating the class name of the element that wraps the component. These were
&quot;merged properties&quot; on classic components historically, which meant that rather
than overwriting the values, they would merge into the superclass when extending
a class. And for <em>instances</em> of components this was also true, so passing it as
an argument into a component instance would <em>add</em> the name bindings to the
class, rather than replacing them.</p>
<p>At some point, the ability for merging on the instance itself was removed. In
its place, a general template transform was added, which transformed the
<code>classBinding</code> and <code>classNameBindings</code> args into the <code>class</code> argument, with the
same semantics.</p>
<pre><code class="language-hbs">{{some-component class=&quot;bar&quot; classNameBindings=&quot;foo:truthy:falsy&quot;}}

{{! becomes }}
{{some-component class=(concat &quot;bar &quot; (if this.foo &quot;truthy&quot; &quot;falsy&quot;))}}
</code></pre>
<p>Note the conversion of the <code>foo</code> string into a path in the local context,
something that is very much unexpected in modern Ember applications.</p>
<p>The output here is a bit cumbersome to write, which may be why the original
syntax was kept. However, with angle bracket invocation, we can now write this
in a much cleaner way:</p>
<pre><code class="language-hbs">&lt;SomeComponent class=&quot;bar {{if this.foo &quot;truthy&quot; &quot;falsy&quot;}}&quot; /&gt;
</code></pre>
<p>Given these alternatives, it doesn't make sense any longer to continue
supporting this transform, <em>especially</em> given that it also affects components
which do not even support <code>classNameBindings</code>, such as Glimmer components. Since
<code>class</code> in this case is an <em>argument</em> and not an attribute, and since this only
affects curly components, it is unlikely that anyone is actually relying on this
behavior, but removing this incongruity seems like the best course of action.</p>
<h2 id="transition-path-26"><a class="header" href="#transition-path-26">Transition Path</a></h2>
<p>In general, users should convert to use angle bracket syntax to invoke their
component, and then use standard interpolation within the <code>class</code> attribute of
the component. In cases where this is not possible/desired, users can continue
using curly invocation with <code>(concat)</code> to pass the value.</p>
<h2 id="how-we-teach-this-135"><a class="header" href="#how-we-teach-this-135">How We Teach This</a></h2>
<h3 id="deprecation-guide-5"><a class="header" href="#deprecation-guide-5">Deprecation Guide</a></h3>
<p><code>classBinding</code> and <code>classNameBindings</code> can currently be passed as arguments to
components that are invoked with curly invocation. These allow users to
conditionally bind values to the <code>class</code> argument using a microsyntax similar to
the one that can be defined in a Classic component's class body:</p>
<pre><code class="language-js">import Component from '@ember/component';

export default Component.extend({
  classNameBindings: ['isValid:is-valid:is-invalid']
});
</code></pre>
<pre><code class="language-hbs">{{my-component classNameBindings=&quot;isValid:is-valid:is-invalid&quot;}}
</code></pre>
<p>Each binding is a triplet separated by colons. The first identifier in the
triplet is the value that the class name should be bound to, the second
identifier is the name of the class to add if the bound value is truthy, and the
third value is the name to bind if the value is falsy.</p>
<p>These bindings are additive - they add to the existing bindings that are on the
class, rather than replacing them. Multiple bindings can also be passed in by
separating them with a space:</p>
<pre><code class="language-hbs">{{my-component
  classBinding=&quot;foo:bar&quot;
  classNameBindings=&quot;some.boundProperty isValid:is-valid:is-invalid&quot;
}}
</code></pre>
<p>These bindings can be converted into passing a concatenated string into the
class argument of the component, using inline <code>if</code> to reproduce the same
behavior. This is most conveniently done by converting the component to use
angle-bracket invocation at the same time.</p>
<p>Before:</p>
<pre><code class="language-hbs">{{my-component
  classBinding=&quot;foo:bar&quot;
  classNameBindings=&quot;some.boundProperty isValid:is-valid:is-invalid&quot;
}}
</code></pre>
<p>After:</p>
<pre><code class="language-hbs">&lt;MyComponent
  class=&quot;
    {{if this.foo &quot;bar&quot;}}
    {{if this.some.boundProperty &quot;bound-property&quot;}}
    {{if this.isValid &quot;is-valid&quot; &quot;is-invalid&quot;}}
  &quot;
&gt;
</code></pre>
<p>Note that we are passing in the <code>class</code> attribute, not the <code>class</code> argument. In
most cases, this should work exactly the same as previously. If you referenced
the <code>class</code> argument inside of your component, however, you will need to pass
<code>@class</code> instead.</p>
<p>If you do not want to convert to angle bracket syntax for some reason, the same
thing can be accomplished with the <code>(concat)</code> helper in curly invocation.</p>
<pre><code class="language-hbs">{{my-component
  class=(concat
    (if this.foo &quot;bar&quot;)
    &quot; &quot;
    (if this.some.boundProperty &quot;bound-property&quot;)
    &quot; &quot;
    (if this.isValid &quot;is-valid&quot; &quot;is-invalid&quot;)
  )
}}
</code></pre>
<h2 id="drawbacks-152"><a class="header" href="#drawbacks-152">Drawbacks</a></h2>
<ul>
<li>Introduces a minor amount of churn.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-12-23
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/692</h2>
<h1 id="deprecate-array-observers"><a class="header" href="#deprecate-array-observers">Deprecate Array Observers</a></h1>
<h2 id="summary-168"><a class="header" href="#summary-168">Summary</a></h2>
<p>Deprecate array observers, and all associated APIs and events, including:</p>
<ul>
<li>Methods:
<ul>
<li><code>addArrayObserver</code></li>
<li><code>removeArrayObserver</code></li>
<li><code>arrayContentWillChange</code></li>
<li><code>arrayContentDidChange</code></li>
</ul>
</li>
<li>Events:
<ul>
<li><code>@array:before</code></li>
<li><code>@array:change</code></li>
</ul>
</li>
</ul>
<h2 id="motivation-168"><a class="header" href="#motivation-168">Motivation</a></h2>
<p>Array observers are a feature of Ember's custom array implementations. They are
implemented using a completely different system than standard observers, and
historically served different goals, namely integrating array changes with
Ember's classic push-based reactivity system. With autotracking, the reactivity
system was rewritten in a way that didn't require array observers at all, so
there is no longer a need for them internally.</p>
<p>In addition, array observers are fundamentally synchronous. They install
observers that run both <em>before</em> the change has occured, and <em>after</em>. This means
that we need to trigger the before observer synchronously before we run the
change. This synchronous nature introduces overhead, and conceptually is not
inline with the future direction of the framework. With autotracking, the core
concept is that reactivity should be <em>lazy</em>. Derived state should only update
when it is accessed, meaning that if a value is updated but never used, it will
not react.</p>
<p>It is possible to design custom iterables that follow this paradigm, and in fact
most former users of array observers have <em>already</em> converted to this type of
pattern. For instance, all of the custom arrays defined in Ember Data, one of
the biggest users of array observers in the past, have been rewritten to update
lazily when the values are accessed.</p>
<p>Projects like <a href="https://github.com/pzuraq/tracked-built-ins">tracked-built-ins</a>
build on these techniques, demonstrating how modern iterables can be defined
without using any of Ember's custom enumerable/array mixins or classes. By
deprecating the synchronous observers, we can align the remaining custom
enumerables in the ecosystem with the way that modern custom iterables will
work, setting us up for a smoother transition overall.</p>
<h2 id="transition-path-27"><a class="header" href="#transition-path-27">Transition Path</a></h2>
<p>Array observers are a very flexible tool, and are possible to use in many
different ways, similar to observers. As such, each use case may have a somewhat
different solution. This RFC will outline solutions for known use cases based on
public code, and should be converted directly into the deprecation guide. If
more use cases are discovered, we will continue to add transition paths for them
to the guide.</p>
<h3 id="deprecation-guide-6"><a class="header" href="#deprecation-guide-6">Deprecation Guide</a></h3>
<p>Array observers are a special type of observer that can be used to synchronously
react to changes in an <code>EmberArray</code>. In general, to refactor away from them, these
reactions need to be converted from <em>eager</em>, <em>synchronous</em> reactions into <em>lazy</em>
reactions that occur when the array in question is <em>used or accessed</em>.</p>
<p>For example, let's say that we had a class which wrapped an <code>EmberArray</code> and
converted its contents into strings by calling <code>toString()</code> on them. This class
could be implemented using array observers like so:</p>
<pre><code class="language-js">class ToStringArray {
  constructor(innerArray) {
    this._inner = innerArray;

    this._content = innerArray.map((value) =&gt; value.toString());

    innerArray.addArrayObserver(this, {
      willChange: '_innerWillChange',
      didChange: '_innerDidChange',
    });
  }

  // no-op
  _innerWillChange() {}


  _innerDidChange(innerArray, changeStart, removeCount, addCount) {
    if (removeCount) {
      // if items were removed, remove them
      this._content.removeAt(changeStart, removeCount);
    } else {
      // else, find the new items, convert them, and add them to the array
      let newItems = innerArray.slice(changeStart, addCount);

      this._content.replace(changeStart, 0, newItems.map((value) =&gt; value.toString()));
    }

    // Let observers/computeds know that the value has changed
    notifyPropertyChange(this, '[]');
  }

  objectAt(index) {
    return this._content.objectAt(index);
  }
}
</code></pre>
<p>To convert this to no longer use array observers, we could instead convert the
wrapping to happen when the array is accessed in <code>objectAt</code>, using the <code>@cached</code>
decorator from <a href="https://github.com/pzuraq/tracked-toolbox">tracked-toolbox</a>.</p>
<pre><code class="language-js">import { cached } from 'tracked-toolbox';

class ToStringArray {
  constructor(innerArray) {
    this._inner = innerArray;
  }

  @cached
  get _content() {
    return this._inner.map((value) =&gt; value.toString());
  }

  objectAt(index) {
    return this._content.objectAt(index);
  }
}
</code></pre>
<p>This can also be accomplished with native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>,
allowing your users to interact with the array using standard array syntax
instead of <code>objectAt</code>:</p>
<pre><code class="language-js">class ToStringArrayHandler {
  constructor(innerArray) {
    this._inner = innerArray;
  }

  @cached
  get _content() {
    return this._inner.map((value) =&gt; value.toString());
  }

  get(target, prop) {
    return this._content.objectAt(prop);
  }
}

function createToStringArray(innerArray) {
  return new Proxy([], new ToStringArrayHandler(innerArray));
}
</code></pre>
<p>This solution will work with autotracking in general, since users who access the
array via <code>objectAt</code> will be accessing the tracked property. However, it will
not integrate with computed property dependencies. If that is needed, then you
can instead extend Ember's built-in <code>ArrayProxy</code> class, which handles forwarding
events and dependencies itself.</p>
<pre><code class="language-js">import ArrayProxy from '@ember/array/proxy';
import { cached } from 'tracked-toolbox';

class ToStringArray extends ArrayProxy {
  @cached
  get _content() {
    return this.content.map((value) =&gt; value.toString());
  }

  objectAtContent(index) {
    return this._content.objectAt(index);
  }
}
</code></pre>
<h3 id="converting-code-that-watches-arrays-for-changes"><a class="header" href="#converting-code-that-watches-arrays-for-changes">Converting code that watches arrays for changes</a></h3>
<p>Array observers and change events can be used to watch arrays and react to
changes in other ways as well. For instance, you may have a component like
<code>ember-collection</code> which used array observers to trigger a rerender and
rearrange its own representation of the array. A simplified version of this
logic looks like the following:</p>
<pre><code class="language-js">export default Component.extend({
  layout: layout,

  init() {
    this._cells = A();
  },

  _needsRevalidate(){
    if (this.isDestroyed || this.isDestroying) {return;}
    this.rerender();
  },

  didReceiveAttrs() {
    this._super();

    this.updateItems();
  },

  updateItems(){
    var rawItems = this.get('items');

    if (this._rawItems !== rawItems) {
      if (this._items &amp;&amp; this._items.removeArrayObserver) {
        this._items.removeArrayObserver(this, {
          willChange: noop,
          didChange: '_needsRevalidate'
        });
      }
      this._rawItems = rawItems;
      var items = A(rawItems);
      this.set('_items', items);

      if (items &amp;&amp; items.addArrayObserver) {
        items.addArrayObserver(this, {
          willChange: noop,
          didChange: '_needsRevalidate'
        });
      }
    }
  },

  willRender() {
    this.updateCells();
  },

  updateCells() {
    // ...
  },

  actions: {
    scrollChange(scrollLeft, scrollTop) {
      // ...
      if (scrollLeft !== this._scrollLeft ||
          scrollTop !== this._scrollTop) {
        set(this, '_scrollLeft', scrollLeft);
        set(this, '_scrollTop', scrollTop);
        this._needsRevalidate();
      }
    },
    clientSizeChange(clientWidth, clientHeight) {
      if (this._clientWidth !== clientWidth ||
          this._clientHeight !== clientHeight) {
        set(this, '_clientWidth', clientWidth);
        set(this, '_clientHeight', clientHeight);
        this._needsRevalidate();
      }
    }
  }
});
</code></pre>
<p>We can refactor this to update the cells themselves when they are accessed, by
accessing them into a computed property that depends on the items array, and
which updates the cells when it is accessed:</p>
<pre><code class="language-js">export default Component.extend({
  layout: layout,

  init() {
    this._cells = A();
  },

  cells: computed('items.[]', function() {
    this.updateCells();

    return this._cells;
  })

  updateCells() {
    // ...
  },

  actions: {
    scrollChange(scrollLeft, scrollTop) {
      // ...
      if (scrollLeft !== this._scrollLeft ||
          scrollTop !== this._scrollTop) {
        set(this, '_scrollLeft', scrollLeft);
        set(this, '_scrollTop', scrollTop);
        this.notifyPropertyChange('cells');
      }
    },
    clientSizeChange(clientWidth, clientHeight) {
      if (this._clientWidth !== clientWidth ||
          this._clientHeight !== clientHeight) {
        set(this, '_clientWidth', clientWidth);
        set(this, '_clientHeight', clientHeight);
        this.notifyPropertyChange('cells');
      }
    }
  }
});
</code></pre>
<p>Mutating untracked local state like this is generally ok as long as the state is
essentially a cached representation of computed or getter is deriving in
general. It allows you to do things like compare the previous state to the
current state during the update, and cache portions of the computation so that
you do not need to redo all of it.</p>
<p>It is also possible that you have some code which must run whenever the array
has changed, and must run eagerly. For instance, the array fragment from
<code>ember-data-model-fragments</code> has some logic for signalling to the parent record
that it has changed, which looks like this (simplified):</p>
<pre><code class="language-js">const StatefulArray = ArrayProxy.extend(Copyable, {
  content: computed(function() {
    return A();
  }),

  // ...

  arrayContentDidChange() {
    this._super(...arguments);

    let record = get(this, 'owner');
    let key = get(this, 'name');

    // Any change to the size of the fragment array means a potential state change
    if (get(this, 'hasDirtyAttributes')) {
      fragmentDidDirty(record, key, this);
    } else {
      fragmentDidReset(record, key);
    }
  },
});
</code></pre>
<p>Ideally the dirty state would be converted into derived state that could read
the array it was dependent upon, but if that's not an option or would require
major refactors, it is also possible to override the mutator method of the array
and trigger the change when it is called. In EmberArray's, the primary mutator
method is the <code>replace()</code> method.</p>
<pre><code class="language-js">const StatefulArray = ArrayProxy.extend(Copyable, {
  content: computed(function() {
    return A();
  }),

  // ...

  replace() {
    this._super(...arguments);

    let record = get(this, 'owner');
    let key = get(this, 'name');

    // Any change to the size of the fragment array means a potential state change
    if (get(this, 'hasDirtyAttributes')) {
      fragmentDidDirty(record, key, this);
    } else {
      fragmentDidReset(record, key);
    }
  },
});
</code></pre>
<p>Note that this method will work for arrays and array proxies that are mutated
directly, but will not work for array proxies which wrap other arrays and watch
changes on them. In those cases, the recommendation is to refactor such that:</p>
<ol>
<li>Changes are always intercepted by the proxy, and can call the code
synchronously when they occur.</li>
<li>The change logic is added by intercepting changes on the original array, so
it will occur whenever it changes.</li>
<li>The API that must be called synchronously is instead driven by derived state.
For instance, in the example above, the record's dirty state could be driven
by the various child fragments it contains, and updated whenever the user
accesses it, rather than by sending events such as <code>didDirty</code> and <code>didReset</code>.</li>
</ol>
<h3 id="converting-code-that-uses-the-willchange-functionality"><a class="header" href="#converting-code-that-uses-the-willchange-functionality">Converting code that uses the <code>willChange</code> functionality</a></h3>
<p>In general, it is no longer possible to react to an array change before it
occurs except by overriding the mutation methods on the array itself. You can do
this by replacing them and calling your logic <em>before</em> calling <code>super</code>.</p>
<pre><code class="language-js">const ArrayWithWillChange = EmberObject.extend(MutableArray, {
  replace() {
    // Your logic here

    this._super(...arguments);
  },
});
</code></pre>
<p>In cases where this is not possible, you can instead convert to derived state,
and cache the previous value of the array to compare it the next time the state
is accessed.</p>
<h2 id="how-we-teach-this-136"><a class="header" href="#how-we-teach-this-136">How We Teach This</a></h2>
<p>Array observers and their usage in general is not part of the default Ember
learning path, so the main guides should not need to change. Eventually, we will
likely want to add some guides for developing custom iterables that work in a
lazy way, but this is a separate change that should not be tied to this specific
deprecation.</p>
<p>For the deprecation guide, see the transition path above.</p>
<h2 id="drawbacks-153"><a class="header" href="#drawbacks-153">Drawbacks</a></h2>
<ul>
<li>While array observers are not used commonly in public code, they are used by
several commonly used addons, such as <code>ember-collection</code>,
<code>ember-data-model-fragments</code>, and <code>ember-light-table</code>. Deprecating them will
cause these addons to need to rewrite and release new versions, which will
introduce some churn in the ecosystem.</li>
<li>The public use cases for array observers have known solutions which are
outlined in this deprecation guide, and which should not require refactors
that are unreasonable in scope. However, array observers are a powerful API,
and its possible that there are some use cases out there which are far more
difficult to refactor and detangle. If there are, those users could be heavily
impacted by this deprecation.</li>
</ul>
<h2 id="alternatives-155"><a class="header" href="#alternatives-155">Alternatives</a></h2>
<ul>
<li>Leave array observers undeprecated. This currently prevents us from
refactoring the internals of array proxies, and also ultimately means that the
community will have to absorb these changes later on in more comprehensive
refactors to native iterables.</li>
</ul>
<h2 id="unresolved-questions-101"><a class="header" href="#unresolved-questions-101">Unresolved questions</a></h2>
<ul>
<li>What other use cases exist for array observers that are not covered in the
guides?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-01-05
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/698</h2>
<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->
<h1 id="deprecate--component-positional-arguments"><a class="header" href="#deprecate--component-positional-arguments">Deprecate <LinkTo> Component Positional Arguments</a></h1>
<h2 id="summary-169"><a class="header" href="#summary-169">Summary</a></h2>
<p>We propose to deprecate invoking the <code>&lt;LinkTo&gt;</code> component with positional
arguments, in favor of the equivalent named arguments introduced in
<a href="0459-angle-bracket-built-in-components.html">RFC #459</a>. We also propose to
deprecate the <code>(query-params)</code> helper, which is only needed when invoking the
<code>&lt;LinkTo&gt;</code> component with positional arguments.</p>
<h2 id="motivation-169"><a class="header" href="#motivation-169">Motivation</a></h2>
<p>In modern Ember, the idiomatic way to invoke most components is to use the
<a href="0311-angle-bracket-invocation.html">angle bracket syntax</a> along with the named
arguments <code>@</code> syntax. On the other hand, curly invocations are now reserved for
&quot;helper-like&quot; and &quot;control-flow&quot; components.</p>
<p>The <code>&lt;LinkTo&gt;</code> built-in component started life as a &quot;helper&quot; in the early days
of Ember, even before an official components API was created. Over time, it
became clear that <code>&lt;LinkTo&gt;</code> is better classified as a component than a helper
in modern Ember, and the learning materials have been updated accordingly.</p>
<p>This historical origin meant that <code>&lt;LinkTo&gt;</code> was designed to accept positional
arguments exclusively, as was common with most helpers at the time. The angle
bracket syntax, on the other hand, accepts named arguments exclusively.</p>
<p>Another downside to the positional arguments syntax was it required the use of
the <code>(query-params)</code> helper to distinguish query params from model arguments.</p>
<p>Finally, the meaning of the positional arguments also changes slightly when the
component is invoked with or without a block, which made things needlessly
confusing.</p>
<p>To address these issues, <a href="0459-angle-bracket-built-in-components.html">RFC #459</a>
introduced explicit equivalent names for the positional arguments that were
accepted by the <code>&lt;LinkTo&gt;</code> component. This allowed it to be invoked with the
same angle bracket syntax and avoided the other confusions mentioned above.</p>
<p>These features were made available since v3.10 and are the idomatic thing to do
in modern Ember codebase.</p>
<p>Given that the feature are now available on all currently-supported Ember
versions and the community had adequate time to make the transition, this would
be a good time to deprecate the obsolete features to reduce confusion as well
as implementation complexity.</p>
<p>In particular, some of the obsolete features required capabilities not usually
available to other components, such as knowing whether a block was passed or
not and relies on &quot;AST transforms&quot; to normalize some of the differences. These
implementation strategies introduces unnecessary complexity in the internals
that sometimes causes bugs or other surprising behaviors.</p>
<h2 id="transition-path-28"><a class="header" href="#transition-path-28">Transition Path</a></h2>
<pre><code class="language-hbs">Deprecated:

{{link-to &quot;About Us&quot; &quot;about&quot;}}
          ~~~~~~~~~~~~~~~~~~

Invoking the `&lt;LinkTo&gt;` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`) and pass a
block for the link's content.

&lt;LinkTo @route=&quot;about&quot;&gt;About Us&lt;/LinkTo&gt;
</code></pre>
<pre><code class="language-hbs">Deprecated:

{{#link-to &quot;about&quot;}}About Us{{/link-to}}
           ~~~~~~~

Invoking the `&lt;LinkTo&gt;` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`).

Replacement:

&lt;LinkTo @route=&quot;about&quot;&gt;About Us&lt;/LinkTo&gt;
</code></pre>
<pre><code class="language-hbs">Deprecated:

{{#link-to &quot;post&quot; @post}}Read {{@post.title}}...{{/link-to}}
           ~~~~~~~~~~~~

Invoking the `&lt;LinkTo&gt;` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`, `@model`).

Replacement:

&lt;LinkTo @route=&quot;post&quot; @model={{@post}}&gt;Read {{@post.title}}...&lt;/LinkTo&gt;
</code></pre>
<pre><code class="language-hbs">Deprecated:

{{#link-to &quot;post.comment&quot; @comment.post @comment}}
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Comment by {{@comment.author.name}} on {{@comment.date}}
{{/link-to}}

Invoking the `&lt;LinkTo&gt;` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`, `@models`).

Replacement:

&lt;LinkTo @route=&quot;post.comment&quot; @models={{array post comment}}&gt;
  Comment by {{comment.author.name}} on {{comment.date}}
&lt;/LinkTo&gt;
</code></pre>
<pre><code class="language-hbs">Deprecated:

{{#link-to &quot;posts&quot; (query-params direction=&quot;desc&quot; showArchived=false)}}
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Recent Posts
{{/link-to}}

Invoking the `&lt;LinkTo&gt;` component with positional arguments is deprecated.
Instead, please use the equivalent named arguments (`@route`, `@query`) and the
`hash` helper.

Replacement:

&lt;LinkTo @route=&quot;posts&quot; @query={{hash direction=&quot;desc&quot; showArchived=false}}&gt;
  Recent Posts
&lt;/LinkTo&gt;
</code></pre>
<p>These migrations can be automated using the <a href="https://github.com/ember-codemods/ember-angle-brackets-codemod">angle brackets codemod</a>.</p>
<h2 id="how-we-teach-this-137"><a class="header" href="#how-we-teach-this-137">How We Teach This</a></h2>
<p>The Octane learning materials have already been updated to use the latest
idioms, so no changes are necessary. The API documentation should be updated
to mark the obsolete features and the <code>(query-params)</code> helper as deprecated.</p>
<p>A deprecation guide will need to be written using the same examples from the
<a href="0698-deprecate-link-to-positional-arguments.html#transition-path">Transition Path</a> section. The guide should also promote the
use of the codemod to automate the migration.</p>
<h2 id="drawbacks-154"><a class="header" href="#drawbacks-154">Drawbacks</a></h2>
<p>None.</p>
<h2 id="alternatives-156"><a class="header" href="#alternatives-156">Alternatives</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-102"><a class="header" href="#unresolved-questions-102">Unresolved questions</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-01-09
Release Date: Unreleased
Release Versions:
ember-cli: vX.Y.Z
Relevant Team(s): Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/702</h2>
<h1 id="add-eslint-plugin-qunit-to-ember-cli-blueprint"><a class="header" href="#add-eslint-plugin-qunit-to-ember-cli-blueprint">Add eslint-plugin-qunit to ember-cli blueprint</a></h1>
<h2 id="summary-170"><a class="header" href="#summary-170">Summary</a></h2>
<p>This RFC proposes adding <a href="https://github.com/platinumazure/eslint-plugin-qunit">eslint-plugin-qunit</a> to the blueprints
that back <code>ember new</code> and <code>ember addon</code>.</p>
<h2 id="motivation-170"><a class="header" href="#motivation-170">Motivation</a></h2>
<p>Ember apps and addons already come with a number of linting plugins targeting various areas of the code:</p>
<ul>
<li>ember-template-lint - handlebars best practices</li>
<li>eslint - general JavaScript best practices</li>
<li>eslint-plugin-ember - Ember best practices</li>
<li>eslint-plugin-node - Node best practices</li>
<li>prettier - automatic styling (as a result of a recent <a href="https://github.com/emberjs/rfcs/blob/master/text/0628-prettier.md">RFC</a>)</li>
</ul>
<p>But there's an important aspect of Ember apps that is not yet targeted by specialized linting: testing. Test code can easily make up half of the code in an Ember app, and well-written tests are of course critical to application quality.</p>
<p><a href="https://qunitjs.com/">QUnit</a> is the default testing framework used by Ember apps and the good news is that a popular and mature QUnit linting plugin is available for it: eslint-plugin-qunit. This plugin has been around for five years and is used in thousands of applications including many Ember applications. It has over 30 rules for enforcing best testing practices and detecting broken or incorrectly-written tests.</p>
<h2 id="detailed-design-141"><a class="header" href="#detailed-design-141">Detailed design</a></h2>
<p>The general idea is that we will update the <code>app</code> and <code>addon</code> blueprints to add the eslint-plugin-qunit package to the <code>package.json</code>, and update the linting configuration to extend the new presets.</p>
<h3 id="packages-2"><a class="header" href="#packages-2">Packages</a></h3>
<p>The following packages will be added to the <code>package.json</code> of both <code>app</code> and <code>addon</code> blueprints:</p>
<ul>
<li><a href="https://www.npmjs.com/package/eslint-plugin-qunit">eslint-plugin-qunit</a></li>
</ul>
<h3 id="configuration-changes-1"><a class="header" href="#configuration-changes-1">Configuration Changes</a></h3>
<p>The <code>.eslintrc.js</code> that is generated will be updated to extend the <code>qunit</code> linting configurations.</p>
<p>This change will be limited to test files only using an override, similar to how Node linting is limited to Node files only with an override. Using an override to scope linting to specific files provides additional protection against unwanted impacts (i.e. false positives or performance hits).</p>
<pre><code class="language-js">{
  overrides: [
    ...,
    {
      files: ['tests/**/*'],
      extends: ['plugin:qunit/recommended', 'plugin:qunit/two'],
    },
  ],
}
</code></pre>
<h2 id="how-we-teach-this-138"><a class="header" href="#how-we-teach-this-138">How we teach this</a></h2>
<p>We do not currently discuss linting in either guides.emberjs.com or cli.emberjs.com.</p>
<p>Users will be able to find documentation for the new rules on the <a href="https://github.com/platinumazure/eslint-plugin-qunit">eslint-plugin-qunit</a> GitHub page. Many IDEs will provide a link directly to the rule documentation on highlighted lint violations.</p>
<p>Any violations of the new rules will be detected by <code>yarn lint</code> and in some cases autofixed by <code>yarn lint:fix</code>.</p>
<h2 id="drawbacks-155"><a class="header" href="#drawbacks-155">Drawbacks</a></h2>
<p>For those introducing eslint-plugin-qunit to an existing codebase, the largest drawback is generally the initial cost of fixing linting violations. This can be mitigated by individually disabling noisy lint rules and working to fix violations overtime. But note that this RFC is more likely to impact newly-generated applications where there will be no existing lint violations to fix as opposed to existing applications.</p>
<p>In rare cases, users may be using an alternative testing framework like Mocha or Jest, and they can safely ignore or remove eslint-plugin-qunit.</p>
<h2 id="alternatives-157"><a class="header" href="#alternatives-157">Alternatives</a></h2>
<p>The implementation is straightforward and there are no known alternative implementations for adding more test-oriented linting.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-01-14
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/704</h2>
<h1 id="deprecate-octane-optional-features"><a class="header" href="#deprecate-octane-optional-features">Deprecate Octane Optional Features</a></h1>
<h2 id="summary-171"><a class="header" href="#summary-171">Summary</a></h2>
<p>Deprecate the optional features introduced in the transition to Ember Octane.
This specifically refers to the optional features which are required for an
Ember application to set the <code>octane</code> edition:</p>
<ul>
<li><code>application-template-wrapper</code></li>
<li><code>template-only-glimmer-components</code></li>
</ul>
<h2 id="motivation-171"><a class="header" href="#motivation-171">Motivation</a></h2>
<p>The Octane edition consisted for the most part of backwards compatible changes,
a design choice inline with the Ember philosophy of introducing new features and
changes while ensuring that there is an upgrade path. Editions are about
introducing a new programming model side-by-side with the old one, allowing
users to adopt the changes gradually. As such, enabling Octane is almost
identical to any other Ember upgrade, with one exception - required optional
features.</p>
<p>While most changes in the Octane programming model were backwards compatible,
there were a few small tweaks to behaviors that could not be done in a backwards
compatible way. In order to fully enable Octane, users had to both upgrade to
the minimum version of Ember, <em>and</em> toggle these behaviors via optional
features.</p>
<p>The two optional features that were required for Octane are:</p>
<ul>
<li><code>application-template-wrapper</code>, which must be set to <code>false</code> in Octane</li>
<li><code>template-only-glimmer-components</code>, which must be set to <code>true</code> in Octane</li>
</ul>
<p>While there are other optional features available which Ember users should
adopt, they are not requirements for Octane specifically.</p>
<p>As part of the post-Octane cleanup, this RFC proposes deprecating these optional
features, so that the Octane behavior is the only supported behavior. This will
simplify user configuration, and enable cleanup of the code that supports these
optional features internally.</p>
<h2 id="transition-path-29"><a class="header" href="#transition-path-29">Transition Path</a></h2>
<p>This deprecation will be a 2 phase deprecation:</p>
<ol>
<li>Deprecate the following optional feature flag settings:</li>
</ol>
<ul>
<li><code>application-template-wrapper: true</code></li>
<li><code>template-only-glimmer-components: false</code></li>
</ul>
<ol start="2">
<li>Deprecate specifying the optional feature at all</li>
</ol>
<h3 id="phase-1"><a class="header" href="#phase-1">Phase 1</a></h3>
<p>The first phase will require that all users have toggled the optional feature to
the correct position for Octane. This phase can be implemented immediately, and
will position us to be able to enter phase 2 in the next major version after
implementation (currently v4).</p>
<p>Since the specifying the optional feature will cause it to be set to the
incorrect value in Ember v3, users will have to specify the optional feature
explicitly.</p>
<h3 id="phase-2"><a class="header" href="#phase-2">Phase 2</a></h3>
<p>Once a major version has been released after phase 1 has been implemented, all
users will be using the same setting for these optional features, explicitly. In
the first release of Ember v4, we will be able to safely change the default
value of the optional feature flags to be the correct Octane setting. Users will
be able to drop the explicit setting at this point, and the blueprint will be
updated to drop it as well.</p>
<p>At this point, the default setting will be the Octane-compatible one, and
explicitly setting it to the Octane-compatible one will be allowed. Explicitly
setting it to the non-Octane setting will trigger an assertion. This means that
users can only possibly have one behavior specified, and we can deprecate
specifying the optional feature at all.</p>
<h2 id="how-we-teach-this-139"><a class="header" href="#how-we-teach-this-139">How We Teach This</a></h2>
<h3 id="deprecation-guide-7"><a class="header" href="#deprecation-guide-7">Deprecation Guide</a></h3>
<h4 id="application-template-wrapper"><a class="header" href="#application-template-wrapper"><code>application-template-wrapper</code></a></h4>
<p>Setting the <code>application-template-wrapper</code> optional feature to <code>true</code> has been
deprecated. You must set this feature to <code>false</code>, disabling the application
wrapper. For more details on this optional feature, including the changes in
behavior disabling it causes and how you can disable it, see the
<a href="https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_application-template-wrapper">optional features section</a>
of the Ember guides. You can also run <code>npx @ember/octanify</code> to set this feature
to the correct value.</p>
<h4 id="template-only-glimmer-components"><a class="header" href="#template-only-glimmer-components"><code>template-only-glimmer-components</code></a></h4>
<p>Setting the <code>template-only-glimmer-components</code> optional feature to <code>false</code> has been
deprecated. You must set this feature to <code>true</code>, enabling the template-only
Glimmer components. For more details on this optional feature, including the
changes in behavior enabling it causes and how you can enable it, see the
<a href="https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_template-only-glimmer-components">optional features section</a>
of the Ember guides. You can also run <code>npx @ember/octanify</code> to set this feature
to the correct value.</p>
<h2 id="drawbacks-156"><a class="header" href="#drawbacks-156">Drawbacks</a></h2>
<ul>
<li>Could cause churn in some existing applications</li>
</ul>
<h2 id="alternatives-158"><a class="header" href="#alternatives-158">Alternatives</a></h2>
<ul>
<li>We could deprecate the other optional feature flags as well. While it is
encouraged to toggle all optional feature flags, and all optional feature
flags are toggled by default in new Ember apps, the other flags were required
as part of Ember Octane and are conceptually separate. As such, they should be
deprecated in a separate RFC.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-01-14
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/705</h2>
<h1 id="deprecate-jquery-integration-optional-feature"><a class="header" href="#deprecate-jquery-integration-optional-feature">Deprecate jQuery Integration Optional Feature</a></h1>
<h2 id="summary-172"><a class="header" href="#summary-172">Summary</a></h2>
<p>Deprecate the <code>jquery-integration</code> optional feature flag.</p>
<h2 id="motivation-172"><a class="header" href="#motivation-172">Motivation</a></h2>
<p>jQuery integration has been a part of Ember since the beginning. When Ember was
first released, a variety of browser features had not been standardized yet, and
jQuery was a necessary tool for creating code that worked in all major browsers.
This is no longer the case, and Ember is no longer internally reliant on jQuery.</p>
<p>That said, jQuery is still a useful library with many plugins, and that many
developers use. Adding jQuery to an Ember application is still completely
possible, and <strong>not deprecated by this or any other RFC</strong>.</p>
<p>The <code>jquery-integration</code> optional feature is not about removing jQuery from your
Ember application. It is instead about removing the <em>integration</em> that Ember has
with jQuery, which is left over from the days when jQuery was used by Ember for
many different basic tasks. Specifically, disabling the feature removes the
following APIs:</p>
<ul>
<li><code>Ember.$</code>, which is an alias for jQuery</li>
<li><code>this.$</code>, which is an alias for a jQuery selector that is scoped to <code>this</code>.
This is available in Classic components and tests.</li>
</ul>
<p>Deprecating the <code>jquery-integration</code> optional feature means that users will have
to transition away from using these specific APIs, but <em>not</em> from using jQuery
in general. This will help us to clarify that Ember is not dependent on jQuery,
and allow us to simplify Ember's internals.</p>
<h2 id="transition-path-30"><a class="header" href="#transition-path-30">Transition Path</a></h2>
<p>This deprecation will be a 2 phase deprecation:</p>
<ol>
<li>Deprecate the following optional feature flag settings:</li>
</ol>
<ul>
<li><code>jquery-integration: true</code></li>
</ul>
<ol start="2">
<li>Deprecate specifying the optional feature at all</li>
</ol>
<h3 id="phase-1-1"><a class="header" href="#phase-1-1">Phase 1</a></h3>
<p>The first phase will require that all users have toggled the optional feature to
<code>false</code>. This phase can be implemented immediately, and will position us to be
able to enter phase 2 in the next major version after implementation (currently
v4).</p>
<p>Since the not specifying the optional feature will cause it to be set to the
<code>true</code> by default in Ember v3, users will have to specify the optional feature
explicitly.</p>
<h3 id="phase-2-1"><a class="header" href="#phase-2-1">Phase 2</a></h3>
<p>Once a major version has been released after phase 1 has been implemented, all
users will be using the same setting for this optional feature, explicitly. In
the first release of Ember v4, we will be able to safely change the default
value of the optional feature to <code>false</code>. Users will be able to drop the
explicit setting at this point, and the blueprint will be updated to drop it as
well.</p>
<p>At this point, the default setting will be <code>false</code>, and explicitly setting it to
<code>false</code> will be allowed. Explicitly setting it to <code>true</code> will trigger an
assertion. This means that users can only possibly have one behavior specified,
and we can deprecate specifying the optional feature at all.</p>
<h2 id="how-we-teach-this-140"><a class="header" href="#how-we-teach-this-140">How We Teach This</a></h2>
<p>We should update the Optional Features guide to discuss in more detail how users
can migrate away from jQuery. In general, most usages should be fairly
straightforward, and the current guides do not cover it in great detail. They
also do not mention that <code>@ember/jquery</code> can be used without the feature flag.</p>
<h3 id="updated-optional-feature-guide"><a class="header" href="#updated-optional-feature-guide">Updated Optional Feature Guide</a></h3>
<p>jQuery is commonly used for event handling and many popular libraries for
charting and UI components. Ember was originally built using jQuery, but has
since refactored and is no longer dependent on it. jQuery can still be used
as in independent library alongside Ember, however.</p>
<p>There are a few APIs that exist in Ember still that directly expose jQuery,
Disabling this optional feature disables those APIs, but does not remove jQuery
itself. jQuery is provided by the <code>@ember/jquery</code> addon, independent of the
integration APIs.</p>
<h4 id="migrating-away-from-and-disabling-ember-jquery-integration-apis"><a class="header" href="#migrating-away-from-and-disabling-ember-jquery-integration-apis">Migrating Away from and disabling Ember jQuery integration APIs</a></h4>
<p>To disable this feature, first migrate away from the jQuery integration APIs.
Below is a list of the jQuery specific APIs in Ember, and how to migrate away
from them.</p>
<ul>
<li>
<p><code>this.$()</code> in Classic Ember components. This creates a jQuery selector that
targets the component's element. You can migrate away by using <code>this.element</code>
instead, which is the actual DOM element for the component. If you want to
continue using jQuery via <code>@ember/jquery</code>, you can do so with <code>this.element</code>:</p>
<pre><code class="language-js">import $ from 'jquery';
import Component from '@ember/copmonent';

export default class MyComponent extends Component {
  didInsertElement() {
    let el = $(this.element);

    // ...
  }
}
</code></pre>
</li>
<li>
<p>Event handlers on Classic components, such as <code>click()</code> and <code>mouseEnter()</code>.
These APIs still work without the integrations enabled, but they no longer
receive a jQuery event, they receive a native Event instead. You can convert
to using native events incrementally by using the <a href="https://github.com/emberjs/ember-jquery-legacy"><code>ember-jquery-legacy</code></a> addon, which provides a function that converts a jQuery
event into a native event safely. Once all of your event handlers have been
converted, you can disable jQuery integration.</p>
</li>
<li>
<p><code>Ember.$()</code>, which is an alias for the global jQuery. This can either be
replaced with alternative, non-jquery based APIs, or by installing
<code>@ember/jquery</code> and importing it directly.</p>
</li>
<li>
<p>Global acceptance test helpers like <code>find()</code> or <code>click()</code>. These can be
replaced with the <code>@ember/test-helpers</code>, which is the default for test helpers
now.</p>
</li>
<li>
<p><code>this.$()</code> in component tests. This can be replaced with corresponding test
helpers from <code>@ember/test-helpers</code>.</p>
</li>
</ul>
<p>Note that if you disable these APIs, then all addons you use must also work
without them, as they will not be available at all.</p>
<p>Next, follow the instructions above to install <code>@ember/optional-features</code>, and
run the following command to change <code>@ember/optional-features</code>:</p>
<pre><code class="language-sh">ember feature:disable jquery-integration
</code></pre>
<h4 id="including-jquery-without-integration-apis"><a class="header" href="#including-jquery-without-integration-apis">Including jQuery without integration APIs</a></h4>
<p>If you would like to include jQuery without the Ember integration APIs, you can
install <code>@ember/jquery</code>:</p>
<pre><code class="language-sh">ember install @ember/jquery
</code></pre>
<p>This will allow you to import jQuery from <code>jquery</code>:</p>
<pre><code class="language-js">import $ from 'jquery';
</code></pre>
<h4 id="including-jquery-with-integration-apis"><a class="header" href="#including-jquery-with-integration-apis">Including jQuery with integration APIs</a></h4>
<p>To include jQuery in your Ember app and enable the jQuery integration APIs such
as <code>this.$()</code>, follow the instructions above to install <code>@ember/optional-features</code>.
Next, enable the feature:</p>
<pre><code class="language-sh">ember feature:enable jquery-integration
</code></pre>
<p>Then, install the <code>@ember/jquery</code> addon:</p>
<pre><code class="language-sh">ember install @ember/jquery
</code></pre>
<p>Now, almost anywhere in your app, you can use the various jQuery integrations.</p>
<h4 id="removing-jquery-completely"><a class="header" href="#removing-jquery-completely">Removing jQuery completely</a></h4>
<p>If you are working on an application that already has jQuery installed, and
would like to remove it, follow these steps.</p>
<p>First, refactor your own code to not depend on jQuery. See the section above on
how to do this. Keep in mind that you will have to remove jQuery usage entirely,
you cannot use solutions that replace the integration API with jQuery
independently such as <code>$(this.element)</code>.</p>
<p>Next, follow the instructions above to install <code>@ember/optional-features</code>, and
run the following command to change <code>@ember/optional-features</code>:</p>
<pre><code class="language-sh">ember feature:disable jquery-integration
</code></pre>
<p>Then, remove <code>@ember/jquery</code> from your package.json.</p>
<p>This will remove jQuery from your vendor.js bundle and disable any use of jQuery
in Ember itself. Now your app will be about 30KB lighter!</p>
<h3 id="deprecation-guide-8"><a class="header" href="#deprecation-guide-8">Deprecation Guide</a></h3>
<p>Setting the <code>jquery-integration</code> optional feature to <code>true</code> has been
deprecated. You must set this feature to <code>false</code>, disabling jQuery integration.
This only disables <strong>integration</strong> with Ember, jQuery can still be included and
used as an independent library via the <a href="https://github.com/emberjs/ember-jquery"><code>@ember/jquery</code> addon</a>.</p>
<p>For more details on this optional feature, including the changes in
behavior disabling it causes and how you can disable it, see the
<a href="https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_removing-jquery">optional features section</a>
of the Ember guides.</p>
<h2 id="drawbacks-157"><a class="header" href="#drawbacks-157">Drawbacks</a></h2>
<ul>
<li>Could cause churn in some existing applications</li>
</ul>
<h2 id="alternatives-159"><a class="header" href="#alternatives-159">Alternatives</a></h2>
<ul>
<li>We could continue supporting these jQuery integrations forever.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2020-14-01
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/706</h2>
<h1 id="deprecate-the-ember-global"><a class="header" href="#deprecate-the-ember-global">Deprecate the Ember Global</a></h1>
<h2 id="summary-173"><a class="header" href="#summary-173">Summary</a></h2>
<p>Deprecate the Ember global, <code>window.Ember</code>, and replace it fully with
<code>import Ember from 'ember';</code></p>
<h2 id="motivation-173"><a class="header" href="#motivation-173">Motivation</a></h2>
<p>The Ember global, available at <code>window.Ember</code> (or <code>globalThis.Ember</code> in all
environments) is a mostly legacy API from before Ember adopted native ES
modules. Modern Ember apps do not use the global, and in general it is mostly
used by legacy code and occasionally in examples. However, it still exists and
remains undeprecated.</p>
<p>The primary motivation for deprecating the global object is for <em>tree shaking</em>
purposes. Because the global object is assigned eagerly to <code>window.Ember</code>
whenever Ember is loaded, it essentially means that every Ember application
implicitly uses every single API that is exported on the global object. This
means that we cannot tree shake any of those APIs, and we must in fact load them
all eagerly and execute all of their code as soon as Ember is loaded.</p>
<p>While it is tempting to remove the <code>Ember</code> object altogether, there are a number
of undeprecated legacy and intimate APIs that are only available through this
object, such os <code>Ember.meta</code>. This is why this RFC proposes only deprecating
accessing <code>Ember</code> <em>via</em> <code>window.Ember</code>/<code>globalThis.Ember</code>. Instead, users will
have to import <code>Ember</code> using standard ES module syntax if they want to use it.</p>
<pre><code class="language-js">import Ember from 'ember';
</code></pre>
<p>This ensures there is an <em>explicit</em> dependency if it is used, and which will
allow us to treeshake in the future if nothing imports <code>Ember</code>. In time, we will
be able to deprecate the <code>Ember</code> object altogether.</p>
<h2 id="transition-path-31"><a class="header" href="#transition-path-31">Transition Path</a></h2>
<p>When the <code>Ember</code> object is defined on the global, we will create a getter for it
that also issues a deprecation. Users who currently use the global will have to
add <code>import Ember from 'ember';</code> at the top of the files in which they use it.</p>
<h2 id="how-we-teach-this-141"><a class="header" href="#how-we-teach-this-141">How we teach this</a></h2>
<h3 id="deprecation-guide-9"><a class="header" href="#deprecation-guide-9">Deprecation Guide</a></h3>
<p>Accessing Ember on the global context (e.g. <code>window.Ember</code>, <code>globalThis.Ember</code>,
or just <code>Ember</code> without importing it) is no longer supported. Migrate to
importing Ember explicitly instead.</p>
<p>Before:</p>
<pre><code class="language-js">export default class MyComponent extends Ember.Component {
  // ...
}
</code></pre>
<p>After:</p>
<pre><code class="language-js">import Ember from 'ember';

export default class MyComponent extends Ember.Component {
  // ...
}
</code></pre>
<p>Alternatively, consider converting to use the Ember modules API equivalent to
the API you are using:</p>
<pre><code class="language-js">import Component from '@ember/component';

export default class MyComponent extends Component {
  // ...
}
</code></pre>
<p>If there is no modules API equivalent, consider refactoring away from using that
API.</p>
<h2 id="drawbacks-158"><a class="header" href="#drawbacks-158">Drawbacks</a></h2>
<ul>
<li>
<p>Introduces churn in legacy codebases</p>
</li>
<li>
<p>Some polyfills and addons use <code>Ember</code> in places where the modules API is not
available, such as in <code>vendor</code> files. These are advanced use cases in general,
and there are possible workarounds (such as using the <code>require</code> global
function), so this shouldn't block us from removing the global.</p>
</li>
</ul>
<h2 id="alternatives-160"><a class="header" href="#alternatives-160">Alternatives</a></h2>
<ul>
<li>Keep the global indefinitely.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-01-14
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/707</h2>
<h1 id="reduce-api-surface-of-built-in-components"><a class="header" href="#reduce-api-surface-of-built-in-components">Reduce API Surface of Built-In Components</a></h1>
<h2 id="summary-174"><a class="header" href="#summary-174">Summary</a></h2>
<p>In order to reduce the API surface of the built-in <code>&lt;LinkTo&gt;</code>, <code>&lt;Input&gt;</code> and
<code>&lt;Textarea&gt;</code> components, we propose to deprecate all named arguments on these
components <em>except</em> the following:</p>
<ul>
<li><code>&lt;LinkTo&gt;</code>
<ul>
<li><code>@route</code></li>
<li><code>@model</code></li>
<li><code>@models</code></li>
<li><code>@query</code></li>
<li><code>@replace</code></li>
<li><code>@disabled</code></li>
<li><code>@current-when</code></li>
<li><code>@activeClass</code></li>
<li><code>@loadingClass</code></li>
<li><code>@disabledClass</code></li>
</ul>
</li>
<li><code>&lt;Input&gt;</code>
<ul>
<li><code>@type</code></li>
<li><code>@value</code></li>
<li><code>@checked</code></li>
<li><code>@insert-newline</code></li>
<li><code>@enter</code></li>
<li><code>@escape-press</code></li>
</ul>
</li>
<li><code>&lt;Textarea&gt;</code>
<ul>
<li><code>@value</code></li>
<li><code>@insert-newline</code></li>
<li><code>@enter</code></li>
<li><code>@escape-press</code></li>
</ul>
</li>
</ul>
<h2 id="motivation-174"><a class="header" href="#motivation-174">Motivation</a></h2>
<p>This is a follow-up to <a href="./0671-modernize-built-in-components-1.html">RFC #671</a>
and shares the same high-level motivations and historical context.</p>
<h2 id="detailed-design-142"><a class="header" href="#detailed-design-142">Detailed design</a></h2>
<p>The following named arguments should be explicitly documented as public:</p>
<ul>
<li><code>&lt;LinkTo&gt;</code>
<ul>
<li><code>@route</code></li>
<li><code>@model</code></li>
<li><code>@models</code></li>
<li><code>@query</code></li>
<li><code>@replace</code></li>
<li><code>@disabled</code></li>
<li><code>@current-when</code></li>
<li><code>@activeClass</code></li>
<li><code>@loadingClass</code></li>
<li><code>@disabledClass</code></li>
</ul>
</li>
<li><code>&lt;Input&gt;</code>
<ul>
<li><code>@type</code></li>
<li><code>@value</code></li>
<li><code>@checked</code></li>
<li><code>@insert-newline</code></li>
<li><code>@enter</code></li>
<li><code>@escape-press</code></li>
</ul>
</li>
<li><code>&lt;Textarea&gt;</code>
<ul>
<li><code>@value</code></li>
<li><code>@insert-newline</code></li>
<li><code>@enter</code></li>
<li><code>@escape-press</code></li>
</ul>
</li>
</ul>
<p>The arguments not enumerated above are either no longer necessary, recommended
or accidentally exposed private implementation details.</p>
<h3 id="no-longer-necessary"><a class="header" href="#no-longer-necessary">No Longer Necessary</a></h3>
<h4 id="html-attributes-1"><a class="header" href="#html-attributes-1">HTML Attributes</a></h4>
<p>The built-in components historically accepted a varierty of named arguments for
applying certain HTML attributes to the component's HTML element. This includes
the following (may not be a complete list):</p>
<ul>
<li><code>&lt;LinkTo&gt;</code>
<ul>
<li><code>@id</code></li>
<li><code>@elementId</code> (alias for <code>@id</code>)</li>
<li><code>@ariaRole</code> (maps to the <code>role</code> HTML attribute)</li>
<li><code>@class</code></li>
<li><code>@classNames</code> (deprecated, expands into the <code>class</code> HTML atttribute)</li>
<li><code>@classNameBindings</code> (deprecated, expands to the <code>class</code> HTML atttribute)</li>
<li><code>@isVisible</code> (deprecated, expands to the <code>display: none</code> inline style)</li>
<li><code>@rel</code></li>
<li><code>@tabindex</code></li>
<li><code>@target</code></li>
<li><code>@title</code></li>
</ul>
</li>
<li><code>&lt;Input&gt;</code>
<ul>
<li><code>@id</code></li>
<li><code>@elementId</code> (alias for <code>@id</code>)</li>
<li><code>@ariaRole</code> (maps to the <code>role</code> HTML attribute)</li>
<li><code>@class</code></li>
<li><code>@classNames</code> (deprecated, expands into the <code>class</code> HTML atttribute)</li>
<li><code>@classNameBindings</code> (deprecated, expands to the <code>class</code> HTML atttribute)</li>
<li><code>@isVisible</code> (deprecated, expands to the <code>display: none</code> inline style)</li>
<li><code>@accept</code></li>
<li><code>@autocapitalize</code></li>
<li><code>@autocomplete</code></li>
<li><code>@autocorrect</code></li>
<li><code>@autofocus</code></li>
<li><code>@autosave</code></li>
<li><code>@dir</code></li>
<li><code>@disabled</code></li>
<li><code>@form</code></li>
<li><code>@formaction</code></li>
<li><code>@formenctype</code></li>
<li><code>@formmethod</code></li>
<li><code>@formnovalidate</code></li>
<li><code>@formtarget</code></li>
<li><code>@height</code></li>
<li><code>@indeterminate</code></li>
<li><code>@inputmode</code></li>
<li><code>@lang</code></li>
<li><code>@list</code></li>
<li><code>@max</code></li>
<li><code>@maxlength</code></li>
<li><code>@min</code></li>
<li><code>@minlength</code></li>
<li><code>@multiple</code></li>
<li><code>@name</code></li>
<li><code>@pattern</code></li>
<li><code>@placeholder</code></li>
<li><code>@readonly</code></li>
<li><code>@required</code></li>
<li><code>@selectionDirection</code></li>
<li><code>@size</code></li>
<li><code>@spellcheck</code></li>
<li><code>@step</code></li>
<li><code>@tabindex</code></li>
<li><code>@title</code></li>
<li><code>@width</code></li>
</ul>
</li>
<li><code>&lt;Textarea&gt;</code>
<ul>
<li><code>@id</code></li>
<li><code>@elementId</code> (alias for <code>@id</code>)</li>
<li><code>@ariaRole</code> (maps to the <code>role</code> HTML attribute)</li>
<li><code>@class</code></li>
<li><code>@classNames</code> (deprecated, expands into the <code>class</code> HTML atttribute)</li>
<li><code>@classNameBindings</code> (deprecated, expands to the <code>class</code> HTML atttribute)</li>
<li><code>@isVisible</code> (deprecated, expands to the <code>display: none</code> inline style)</li>
<li><code>@autocapitalize</code></li>
<li><code>@autocomplete</code></li>
<li><code>@autocorrect</code></li>
<li><code>@autofocus</code></li>
<li><code>@cols</code></li>
<li><code>@dir</code></li>
<li><code>@disabled</code></li>
<li><code>@form</code></li>
<li><code>@lang</code></li>
<li><code>@maxlength</code></li>
<li><code>@minlength</code></li>
<li><code>@name</code></li>
<li><code>@placeholder</code></li>
<li><code>@readonly</code></li>
<li><code>@required</code></li>
<li><code>@rows</code></li>
<li><code>@selectionDirection</code></li>
<li><code>@selectionEnd</code></li>
<li><code>@selectionStart</code></li>
<li><code>@spellcheck</code></li>
<li><code>@tabindex</code></li>
<li><code>@title</code></li>
<li><code>@wrap</code></li>
</ul>
</li>
</ul>
<p>These arguments are no longer necessary – with angle bracket invocations, HTML
attributes can be passed directly. An invocation passing one or more of these
named arguments shall trigger a deprecation warning similar to this:</p>
<pre><code>&lt;Input @placeholder=&quot;Ember.js&quot; /&gt;
       ~~~~~~~~~~~~~~~~~~~~~~~
or

{{input placeholder=&quot;Ember.js&quot;}}
        ~~~~~~~~~~~~~~~~~~~~~~

Passing the `@placeholder` argument to &lt;Input&gt; is deprecated. Instead, please
pass the attribute directly, i.e. `&lt;Input placeholder={{...}} /&gt;` instead of
`&lt;Input @placeholder={{...}} /&gt;` or `{{input placeholder=...}}`.
</code></pre>
<p>A notable exception when passing an argument named <code>@href</code> to the <code>&lt;LinkTo&gt;</code>
component. This was never intentionally supported and will trigger an error
instead of a deprecation warning.</p>
<h4 id="dom-events"><a class="header" href="#dom-events">DOM Events</a></h4>
<p>The built-in components historically accepted a varierty of named arguments for
listening to certain DOM events on the component's HTML element. This includes
the following (may not be a complete list):</p>
<ul>
<li><code>&lt;LinkTo&gt;</code>
<ul>
<li><code>@change</code></li>
<li><code>@click</code></li>
<li><code>@contextMenu</code> (for the <code>contextmenu</code> event)</li>
<li><code>@doubleClick</code> (for the <code>dblclick</code> event)</li>
<li><code>@drag</code></li>
<li><code>@dragEnd</code> (for the <code>dragend</code> event)</li>
<li><code>@dragEnter</code> (for the <code>dragenter</code> event)</li>
<li><code>@dragLeave</code> (for the <code>dragleave</code> event)</li>
<li><code>@dragOver</code> (for the <code>dragover</code> event)</li>
<li><code>@dragStart</code> (for the <code>dragstart</code> event)</li>
<li><code>@drop</code></li>
<li><code>@focusIn</code> (for the <code>focusin</code> event)</li>
<li><code>@focusOut</code> (for the <code>focusout</code> event)</li>
<li><code>@input</code></li>
<li><code>@keyDown</code> (for the <code>keydown</code> event)</li>
<li><code>@keyPress</code> (for the <code>keypress</code> event)</li>
<li><code>@keyUp</code> (for the <code>keyup</code> event)</li>
<li><code>@mouseDown</code> (for the <code>mousedown</code> event)</li>
<li><code>@mouseEnter</code> (deprecated, for the <code>mouseenter</code> event)</li>
<li><code>@mouseLeave</code> (deprecated, for the <code>mouseleave</code> event)</li>
<li><code>@mouseMove</code> (deprecated, for the <code>mousemove</code> event)</li>
<li><code>@mouseUp</code> (for the <code>mouseup</code> event)</li>
<li><code>@submit</code></li>
<li><code>@touchCancel</code> (for the <code>touchcancel</code> event)</li>
<li><code>@touchEnd</code> (for the <code>touchend</code> event)</li>
<li><code>@touchMove</code> (for the <code>touchmove</code> event)</li>
<li><code>@touchStart</code> (for the <code>touchstart</code> event)</li>
</ul>
</li>
<li><code>&lt;Input&gt;</code>
<ul>
<li><code>@click</code></li>
<li><code>@contextMenu</code> (for the <code>contextmenu</code> event)</li>
<li><code>@doubleClick</code> (for the <code>dblclick</code> event)</li>
<li><code>@drag</code></li>
<li><code>@dragEnd</code> (for the <code>dragend</code> event)</li>
<li><code>@dragEnter</code> (for the <code>dragenter</code> event)</li>
<li><code>@dragLeave</code> (for the <code>dragleave</code> event)</li>
<li><code>@dragOver</code> (for the <code>dragover</code> event)</li>
<li><code>@dragStart</code> (for the <code>dragstart</code> event)</li>
<li><code>@drop</code></li>
<li><code>@input</code></li>
<li><code>@mouseDown</code> (for the <code>mousedown</code> event)</li>
<li><code>@mouseEnter</code> (deprecated, for the <code>mouseenter</code> event)</li>
<li><code>@mouseLeave</code> (deprecated, for the <code>mouseleave</code> event)</li>
<li><code>@mouseMove</code> (deprecated, for the <code>mousemove</code> event)</li>
<li><code>@mouseUp</code> (for the <code>mouseup</code> event)</li>
<li><code>@submit</code></li>
<li><code>@touchCancel</code> (for the <code>touchcancel</code> event)</li>
<li><code>@touchEnd</code> (for the <code>touchend</code> event)</li>
<li><code>@touchMove</code> (for the <code>touchmove</code> event)</li>
<li><code>@touchStart</code> (for the <code>touchstart</code> event)</li>
<li><code>@focus-in</code> (for the <code>focusin</code> event)</li>
<li><code>@focus-out</code> (for the <code>focusout</code> event)</li>
<li><code>@key-down</code> (for the <code>keydown</code> event)</li>
<li><code>@key-press</code> (for the <code>keypress</code> event)</li>
<li><code>@key-up</code> (for the <code>keyup</code> event)</li>
</ul>
</li>
<li><code>&lt;Textarea&gt;</code>
<ul>
<li><code>@click</code></li>
<li><code>@contextMenu</code> (for the <code>contextmenu</code> event)</li>
<li><code>@doubleClick</code> (for the <code>dblclick</code> event)</li>
<li><code>@drag</code></li>
<li><code>@dragEnd</code> (for the <code>dragend</code> event)</li>
<li><code>@dragEnter</code> (for the <code>dragenter</code> event)</li>
<li><code>@dragLeave</code> (for the <code>dragleave</code> event)</li>
<li><code>@dragOver</code> (for the <code>dragover</code> event)</li>
<li><code>@dragStart</code> (for the <code>dragstart</code> event)</li>
<li><code>@drop</code></li>
<li><code>@input</code></li>
<li><code>@mouseDown</code> (for the <code>mousedown</code> event)</li>
<li><code>@mouseEnter</code> (deprecated, for the <code>mouseenter</code> event)</li>
<li><code>@mouseLeave</code> (deprecated, for the <code>mouseleave</code> event)</li>
<li><code>@mouseMove</code> (deprecated, for the <code>mousemove</code> event)</li>
<li><code>@mouseUp</code> (for the <code>mouseup</code> event)</li>
<li><code>@submit</code></li>
<li><code>@touchCancel</code> (for the <code>touchcancel</code> event)</li>
<li><code>@touchEnd</code> (for the <code>touchend</code> event)</li>
<li><code>@touchMove</code> (for the <code>touchmove</code> event)</li>
<li><code>@touchStart</code> (for the <code>touchstart</code> event)</li>
<li><code>@focus-in</code> (for the <code>focusin</code> event)</li>
<li><code>@focus-out</code> (for the <code>focusout</code> event)</li>
<li><code>@key-down</code> (for the <code>keydown</code> event)</li>
<li><code>@key-press</code> (for the <code>keypress</code> event)</li>
<li><code>@key-up</code> (for the <code>keyup</code> event)</li>
</ul>
</li>
</ul>
<p>These arguments are no longer necessary – with angle bracket invocations, DOM
event listeners can be registered directly using the <code>{{on}}</code> modifier. An
invocation passing one or more of these named arguments shall trigger a
deprecation warning similar to this:</p>
<pre><code>&lt;Input @click={{this.onClick}} /&gt;
       ~~~~~~~~~~~~~~~~~~~~~~~
or

{{input click=this.onClick}}
        ~~~~~~~~~~~~~~~~~~

Passing the `@click` argument to &lt;Input&gt; is deprecated. Instead, please use the
{{on}} modifier, i.e. `&lt;Input {{on &quot;click&quot; ...}} /&gt;` instead of
`&lt;Input @click={{...}} /&gt;` or `{{input click=...}}`.
</code></pre>
<p>Note that these named arguments were not necessarily an intentional part of the
component's original design. Rather, these are callbacks that would have fired
on all classic components, and since classic components' arguments are set on
the component instances as properties, passing these arguments at invocation
time would have &quot;clobbered&quot; any callbacks with the same name defined on the
component's class/prototype, whether it was intended by the component's author
or not.</p>
<p>For instance, the <code>&lt;Input&gt;</code> and <code>&lt;Textarea&gt;</code> built-in components implemented
callbacks that would have been clobbered by these named arguments (may not be a
complete list):</p>
<ul>
<li><code>@change</code></li>
<li><code>@focusIn</code></li>
<li><code>@focusOut</code></li>
<li><code>@keyDown</code></li>
<li><code>@keyPress</code></li>
<li><code>@keyUp</code></li>
</ul>
<p>Passing these named arguments historically supressed certain behavior of the
built-in components, in some cases preventing the components from functioning
properly. This was never an intended part of the original design and should be
considered a bug.</p>
<p>This bug may be fixed at any time during the transition period – the supression
behavior may stop without notice and should not be relied upon. An invocation
with these named arguemnts shall trigger a deprecation warning with this
additional caveat, similar to this:</p>
<pre><code>&lt;Input @change={{this.onChange}} /&gt;
       ~~~~~~~~~~~~~~~~~~~~~~~~~
or

{{input change=this.onChange}}
        ~~~~~~~~~~~~~~~~~~~~

Passing the `@change` argument to &lt;Input&gt; is deprecated. This would have
overwritten the internal `change` method on the &lt;Input&gt; component and prevented
it from functioning properly. Instead, please use the {{on}} modifier, i.e.
`&lt;Input {{on &quot;change&quot; ...}} /&gt;` instead of `&lt;Input @change={{...}} /&gt;` or
`{{input change=...}}`.
</code></pre>
<h3 id="no-longer-recommended"><a class="header" href="#no-longer-recommended">No Longer Recommended</a></h3>
<h4 id="changing-tagname-on-linkto"><a class="header" href="#changing-tagname-on-linkto">Changing <code>@tagName</code> on <code>&lt;LinkTo&gt;</code></a></h4>
<p>Due to the classic component implementation heritage, the built-in components
historically accepted a <code>@tagName</code> argument that allows customizing the tag
name of the underlying HTML element.</p>
<p>This was once popular with the <code>&lt;LinkTo&gt;</code> component for adding navigation
behavior to buttons, table row and other UI elements. The current concensus is
that this is an anti-pattern and causes issues with assistive technologies.</p>
<p>In most cases, the <code>&lt;a&gt;</code> anchor HTML element should be used for navigational UI
elements and styled with CSS to fit with the design requirements. Ocasionally,
a button may be acceptable, in which case a custom event handler can be written
using the router service and attached using the <code>{{on}}</code> modifier.</p>
<p>Other edge cases exists, but generally those solutions can be adapted to fufill
the requirements. For example, to make a table row clickable as a convenience,
the primary column can be made into a link, while a click event handler is
attached to the table row to redispatch the click to trigger the link.</p>
<p>Since this feature is no longer recommended, invoking <code>&lt;LinkTo&gt;</code> with the
<code>@tagName</code> argument shall trigger a deprecation warning similar to this:</p>
<pre><code>&lt;LinkTo @tagName=&quot;div&quot; ...&gt;...&lt;/LinkTo&gt;
        ~~~~~~~~~~~~~~
or

{{#link-to tagName=&quot;div&quot; ...}}...{{/link-to}}
           ~~~~~~~~~~~~~

Passing the `@tagName` argument to &lt;LinkTo&gt; is deprecated. Using a &lt;div&gt;
element for navigation is not recommended as it creates issues with assistive
technologies. Remove this argument to use the default &lt;a&gt; element. In the rare
cases that calls for using a different element, refactor to use the router
service inside a custom event handler instead.
</code></pre>
<p>With the ability to modify <code>@tagName</code> being deprecated, the previously private
<code>@eventName</code> and <code>@preventDefault</code> arguments on <code>&lt;LinkTo&gt;</code> should be removed as
well. These arguments were ocationally useful when the element is something
other than an <code>&lt;a&gt;</code> element, but in the case of an <code>&lt;a&gt;</code> element, the default
browser action is to navigate to the <code>href</code> via a full-page refresh. If that is
not prevented, it would defeat the purpose of using the <code>&lt;LinkTo&gt;</code> component.</p>
<p>Note that while the <code>&lt;Input&gt;</code> and <code>&lt;Textarea&gt;</code> components also accepted the
<code>@tagName</code> argument, it was never supported and its behavior is undefined. This
may stop &quot;working&quot; at any point without warning and should not be relied upon.</p>
<h3 id="other-unsupported-arguments"><a class="header" href="#other-unsupported-arguments">Other Unsupported Arguments</a></h3>
<p>Other named arguments not explicitly mentioned above are considered private
implementation details. Due to the nature of classic components' arguments
being set on its instance, any internal properties and methods could have been
clobbered by a named argument with the same name.</p>
<p>Some examples include private properties like <code>@active</code> and <code>@loading</code> on
<code>&lt;LinkTo&gt;</code>, <code>@bubbles</code> and <code>@cancel</code> on <code>&lt;Input&gt;</code> and <code>&lt;Textarea&gt;</code>, lifecycle
hooks inherited from the classic component super class like <code>@didRender</code>,
<code>@willDestroy</code> and so on.</p>
<p>Clobbering these intenral properties and methods cause the components to behave
in unexpected ways. This should be considered a bug and should not be relied
upon. Any accidental difference in behavior caused by passing these unsupported
named arguments may stop at any time without warning.</p>
<h2 id="how-we-teach-this-142"><a class="header" href="#how-we-teach-this-142">How we teach this</a></h2>
<p>The implementation plan primarily relies on good deprecation messages to inform
users of the deprecated features and their migration paths. Deprecation guides
should be written based on the content and suggestions in this RFC. API docs
should be updated to mark these arguments as deprecated.</p>
<p>Once this migration is complete, the built-in components will be much easier to
teach, as they will have a small, well-defined API surface.</p>
<h2 id="drawbacks-159"><a class="header" href="#drawbacks-159">Drawbacks</a></h2>
<p>None.</p>
<h2 id="alternatives-161"><a class="header" href="#alternatives-161">Alternatives</a></h2>
<p>Instead of enumerating the supported arguments, we could attempt to enumerate
all the unsupported ones. However, this is quite difficult as any internal or
inherited properties could in theory be used as an invocation argument.</p>
<h2 id="unresolved-questions-103"><a class="header" href="#unresolved-questions-103">Unresolved questions</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-01-23
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/711</h2>
<h1 id="deprecate-autolocation"><a class="header" href="#deprecate-autolocation">Deprecate AutoLocation</a></h1>
<h2 id="summary-175"><a class="header" href="#summary-175">Summary</a></h2>
<p>Deprecate Ember.AutoLocation and related APIs. In next major version,
make history the default location (instead of auto).</p>
<h2 id="motivation-175"><a class="header" href="#motivation-175">Motivation</a></h2>
<p>In practice, 'auto' will almost always resolve to the 'history' location.</p>
<p>By removing the 'auto' location and setting 'history' as the default we're removing
some complexity around router location, with no downside for users, since they
all get it resolved to history anyway.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The Ember Router can use different mechanisms to serialize its state.
The two common ones are 'history' and 'hash'. There is also a special
location called 'auto' which does feature detection, preferring 'history'.</p>
<p>When the special 'auto' location was added (and made default), less than
half of browsers supported the (then) new history location API. For seamless
upgrade to history API when available, Ember created the special auto location.</p>
<p>These days (many years later), basically all browsers will get 'history',
since the History Location API is very widely supported, even by IE 11:
https://caniuse.com/mdn-api_history_pushstate</p>
<p>The check 'auto' is basically doing this:</p>
<pre><code class="language-js">// Boosted from Modernizr: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
// The stock browser on Android 2.2 &amp; 2.3, and 4.0.x returns positive on history support
// Unfortunately support is really buggy and there is no clean way to detect
// these bugs, so we fall back to a user agent sniff :(

// We only want Android 2 and 4.0, stock browser, and not Chrome which identifies
// itself as 'Mobile Safari' as well, nor Windows Phone.

if (
    (userAgent.indexOf('Android 2.') !== -1 || userAgent.indexOf('Android 4.0') !== -1) &amp;&amp;
    userAgent.indexOf('Mobile Safari') !== -1 &amp;&amp;
    userAgent.indexOf('Chrome') === -1 &amp;&amp;
    userAgent.indexOf('Windows Phone') === -1
  ) {
    return false;
  }

  return Boolean(window.history &amp;&amp; 'pushState' in window.history);
</code></pre>
<h2 id="transition-path-32"><a class="header" href="#transition-path-32">Transition Path</a></h2>
<p>We'll begin with deprecating auto (explicitly or implicitly set).</p>
<p>In next major release we change the default to 'history'.
Since auto is default today, and almost always resolve to history,
most users can change to 'history' and it's done.</p>
<p>We also need to update the template in ember-cli blueprint,
so that 'history' will be the default value for <code>locationType</code>
in environment.js.</p>
<p>There are two groups to consider:</p>
<ol>
<li>People who need auto-detection (hash/history switching) and</li>
<li>those with location set to 'auto' (this will be most people).</li>
</ol>
<p>The first group can implement feature detection,
via e.g. Modernizr[1], like this:</p>
<pre><code class="language-js">// app/router.js
export default class Router extends EmberRouter {
  location = (historyFeatureDetection() ? 'history' : 'hash');
  // …
}
</code></pre>
<p>For the second group, they need to replace their choice
of 'auto' for 'history' in <code>locationType</code> in environment.js (or
<code>location</code> in router.js), since history is what 'auto' mostly
resolves to anyway.</p>
<h3 id="what-to-deprecate-and-later-remove"><a class="header" href="#what-to-deprecate-and-later-remove">What To Deprecate (and later remove)</a></h3>
<ul>
<li>The AutoLocation class</li>
<li>The method <code>detect</code> from the <code>Location</code> interface</li>
<li>Explicitly setting 'auto' as the preferred location.</li>
</ul>
<h3 id="deprecated-or-already-private-should-also-be-removed"><a class="header" href="#deprecated-or-already-private-should-also-be-removed">Deprecated or already private (should also be removed)</a></h3>
<ul>
<li>Remove the <code>create</code> method on Location (replaced by registry)</li>
<li><code>registerImplementation</code> method on <code>Location</code></li>
<li><code>supportsHistory</code> function exported in location/utils.ts</li>
</ul>
<h2 id="how-we-teach-this-143"><a class="header" href="#how-we-teach-this-143">How We Teach This</a></h2>
<ul>
<li>Remove the text about auto location from guides.</li>
<li>There is already good documentation about the different
location types (history, hash, none) and how to write your own.</li>
<li>Slight adjustments needed for the guides, removing mentions of auto[2].</li>
</ul>
<p>Overall there should be fairly little changes to how Ember is taught. Since
the vast majority of users will need to make zero code changes and will have
zero change in actual behaviour.</p>
<h2 id="drawbacks-160"><a class="header" href="#drawbacks-160">Drawbacks</a></h2>
<p>Anyone using an unsupported browser will need to do feature detection
in their own code base or opt everyone into using the hash location.</p>
<p>https://caniuse.com/mdn-api_history_pushstate</p>
<h2 id="alternatives-162"><a class="header" href="#alternatives-162">Alternatives</a></h2>
<p>Do nothing.</p>
<h2 id="unresolved-questions-104"><a class="header" href="#unresolved-questions-104">Unresolved questions</a></h2>
<p>There are currently no unresolved questions.</p>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<p>[1] https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
[2] https://guides.emberjs.com/release/configuring-ember/specifying-url-type/</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>Stage: Accepted
Start Date: 2021-03-11
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js, Ember Data, Ember CLI, Learning, Steering
RFC PR: https://github.com/emberjs/rfcs/pull/724</p>
<hr />
<h1 id="official-typescript-support"><a class="header" href="#official-typescript-support">Official TypeScript Support</a></h1>
<h2 id="summary-176"><a class="header" href="#summary-176">Summary <!-- omit in toc --></a></h2>
<p>TypeScript has become a key part of the front-end development ecosystem over the past several years, and powers many of the best developer experiences in the front-end ecosystem. Ember was a relatively early TypeScript adopter for its internals, and there is widespread usage in the ecosystem with community support from the Typed Ember team, but to date Ember has not provided “out of the box” or official support for authoring apps or addons in TypeScript.</p>
<p>This RFC declares our intent to officially support TypeScript as a peer to JavaScript, in a way which makes the developer experience better for <em>all</em> Ember developers. It outlines the key constraints and goals for the effort, details a roadmap for accomplishing those goals, and provides the following definition of official support (from <a href="0724-road-to-typescript.html#defining-official-support">Detailed Design: Defining Official Support</a>):</p>
<blockquote>
<p>Ember officially supporting TypeScript means: <em><strong>All libraries which are installed as part of the default blueprint must ship accurate and up-to-date type definitions for the current edition. These types will uphold a Semantic Versioning commitment which includes a definition of SemVer for TypeScript types as well as a specification of supported compiler versions and settings, so that TypeScript will receive the same stability commitments as the rest of Ember.</strong></em></p>
</blockquote>
<h3 id="outline"><a class="header" href="#outline">Outline <!-- omit in toc --></a></h3>
<ul>
<li><a href="0724-road-to-typescript.html#motivation">Motivation</a></li>
<li><a href="0724-road-to-typescript.html#detailed-design">Detailed design</a>
<ul>
<li><a href="0724-road-to-typescript.html#defining-official-support">Defining Official Support</a></li>
<li><a href="0724-road-to-typescript.html#constraints">Constraints</a></li>
<li><a href="0724-road-to-typescript.html#non-goals">Non-Goals</a></li>
<li><a href="0724-road-to-typescript.html#roadmap">Roadmap</a>
<ul>
<li><a href="0724-road-to-typescript.html#rfc-required">RFC Required</a>
<ul>
<li><a href="0724-road-to-typescript.html#types">Types</a></li>
<li><a href="0724-road-to-typescript.html#official-documentation">Official documentation</a></li>
<li><a href="0724-road-to-typescript.html#authoring-and-build">Authoring and Build</a></li>
</ul>
</li>
<li><a href="0724-road-to-typescript.html#implementation-details">Implementation Details</a></li>
<li><a href="0724-road-to-typescript.html#recommendations">Recommendations</a></li>
</ul>
</li>
<li><a href="0724-road-to-typescript.html#semantic-versioning-and-supported-typescript-versions">Semantic Versioning and Supported TypeScript Versions</a></li>
</ul>
</li>
<li><a href="0724-road-to-typescript.html#how-we-teach-this">How we teach this</a></li>
<li><a href="0724-road-to-typescript.html#drawbacks">Drawbacks</a></li>
<li><a href="0724-road-to-typescript.html#alternatives">Alternatives</a></li>
<li><a href="0724-road-to-typescript.html#unresolved-questions">Unresolved questions</a></li>
</ul>
<h2 id="motivation-176"><a class="header" href="#motivation-176">Motivation</a></h2>
<p>TypeScript is a key ingredient of contemporary front-end development. Per community surveys like <a href="https://octoverse.github.com">the GitHub Octoverse</a>, the <a href="https://insights.stackoverflow.com/survey/2020">Stack Overflow Developer report</a>, and the <a href="https://2020.stateofjs.com/en-US/">State of JS survey</a>, TypeScript has exploded in popularity over the last half decade, and is the rare tool which has continuously grown in both usage and satisfaction over that time. While all of these surveys should be understood to be wildly unrepresentative of the broader front-end development community in various ways, they nonetheless provide some useful signal about the state of the ecosystem, especially when combined with experience reports from major companies like Microsoft (millions of lines of Typescript, all of it adopted voluntarily), Google, AirBnB, Dropbox, Bloomberg, Slack, and many others.</p>
<p>Additionally, the development of the language server protocol and the widespread adoption of the TypeScript language server has led to first-class support for TypeScript across many tools, from Vim to Visual Studio. This support also powers rich developer experiences for JavaScript-only developers, as it can provide smart autocomplete, inline documentation, and more even for codebases which are written solely in JavaScript. Thus, non-TypeScript and TypeScript users alike benefit when working with a project which supplies type definitions.</p>
<p>Ember users have been working with TypeScript for years with community support led by the Typed Ember team, but there is one critical problem which cannot be solved without making TypeScript support official, and several key ways in which official support would substantially improve the experience of both TypeScript and JavaScript developers:</p>
<ul>
<li>
<p>Solving the &quot;SemVer problem&quot; for Ember and TypeScript:</p>
<ul>
<li>
<p>The TypeScript compiler does not follow semantic versioning, meaning anyone depending on it either explicitly (as a TypeScript user) or implicitly (as a consumer of the TypeScript Language Server, including for JavaScript editor support) is subject to uncontrolled breaking changes in their experience of Ember app and addon authoring. Supplying an official TypeScript version support policy would help stabilize the ecosystem, by guaranteeing accurate and up-to-date types which work with known supported versions of TypeScript, including the versions which power language server tooling for JS users.</p>
</li>
<li>
<p><em>Many</em> JavaScript users (everyone who uses VS Code) currently implicitly depends on the unofficially maintained types from DefinitelyTyped via VS Code's <a href="https://code.visualstudio.com/docs/nodejs/working-with-javascript#_typings-and-automatic-type-acquisition">automatic type acquisition</a> feature. However, DefinitelyTyped does not allow us to properly version types with the libraries they represent, especially Ember core libraries. Publishing types officially would allow us to substantially improve the stability and correctness of those types, providing a better experience for all Ember developers, and <em>particularly</em> benefiting TypeScript users, for whom there are currently no good mechanisms to insulate them from breaking changes.</p>
</li>
</ul>
</li>
<li>
<p>Making it <em>easy</em> for everyone to benefit from TypeScript-powered enhancements to the ecosystem. Since TS types power autocomplete, documentation, go-to-definition, etc., supplying type definitions for the whole Ember ecosystem will make all Ember developers' &quot;developer experience&quot; better. Additionally, TypeScript-powered tooling is our best bet for supplying richly interactive feedback in templates, for both JS and TS developers.</p>
</li>
<li>
<p>Closing a key gap with other front-end frameworks: React, Vue, Svelte, and Angular all have strong support for TS, and use its tooling to improve the authoring experience for JS and TS developers. Having top-notch TypeScript support would make Ember more compelling.</p>
</li>
</ul>
<p>For TypeScript Ember users specifically:</p>
<ul>
<li>
<p>Easing adoption for interested parties. Both the Typed Ember team and Ember core team members semi-regularly hear from parties interested in TypeScript adoption, but for whom the lack of official support is a concern or even a roadblack. By making it an officially-supported option, we will increase confidence for existing Ember users who are interested but worried about the current community-driven support.</p>
</li>
<li>
<p>Improving coordination, for example by guaranteeing that everything from RFC completion to Edition completion includes not only docs updates but also full TypeScript support for any new features.</p>
</li>
<li>
<p>A richer and better-integrated experience for TS user from the Ember CLI tools, such as the generators and blueprints, which have historically required hand-maintenance (and accordingly fallen sorely out of date).</p>
</li>
</ul>
<p>In sum, making TypeScript an officially supported language for Ember will benefit <em>all</em> Ember users, JavaScript and TypeScript alike; it will solve many pain points for TypeScript users that cannot otherwise be addressed; and it will close a gap for Ember compared to other frameworks.</p>
<h2 id="detailed-design-143"><a class="header" href="#detailed-design-143">Detailed design</a></h2>
<p>The primary goal of this RFC is to add TypeScript as an officially supported language. This involves the following major elements:</p>
<ul>
<li>Determining whether we <em>should</em> make TypeScript a first-class language</li>
<li><a href="0724-road-to-typescript.html#defining-official-support">Defining official support</a>: what it does and does not entail</li>
<li>Identifying the <a href="0724-road-to-typescript.html#constraints">constraints</a> under which adoption can proceed</li>
<li>Making explicit the <a href="0724-road-to-typescript.html#non-goals">non-goals</a> of this project</li>
<li>Building a <a href="0724-road-to-typescript.html#roadmap">roadmap</a> for completing the effort</li>
</ul>
<p>This RFC intentionally does <em>not</em> propose the concrete solutions for each of the problems we will need to solve to successfully adopt TypeScript. Instead, the <a href="0724-road-to-typescript.html#roadmap">Roadmap</a> below lays out a series of problems which require RFCs to resolve, which we believe to represent the full set of work required to officially support the language—neither the full set of work we would like to see for TypeScript in the years ahead nor the solutions to those problems, but a definition of a good MVP.</p>
<h3 id="defining-official-support"><a class="header" href="#defining-official-support">Defining Official Support</a></h3>
<p>Ember officially supporting TypeScript means: <em><strong>All libraries which are installed as part of the default blueprint must ship accurate and up-to-date type definitions for the current edition. These types will uphold a Semantic Versioning commitment which includes a definition of SemVer for TypeScript types as well as a specification of supported compiler versions and settings, so that TypeScript will receive the same stability commitments as the rest of Ember.</strong></em></p>
<p>Key implications of this commitment:</p>
<ul>
<li>
<p><em>Not all</em> libraries maintained as part of &quot;Ember Core&quot; must ship types: only those which come in the default blueprint. (Of course, many such libraries will <em>choose</em> to ship types for the benefits they offer to consumers; this is a matter of what we <em>guarantee</em>.)</p>
</li>
<li>
<p>We have considerable flexibility in opting <em>into</em> increased backwards-compatibility, but can move forward at a reasonable pace. For example, we may choose to support <em>additional</em> features beyond those for the current edition, but may also drop support for earlier editions at a major version milestone.</p>
</li>
<li>
<p>The Semantic Versioning specification, including definitions of SemVer for TypeScript types and TypeScript compiler support policy, will be a key artifact of this process. Without it, we will not be able to provide the stability guarantees Ember users have come to rely on.</p>
</li>
<li>
<p>Given the importance of templates in Ember and Glimmer apps, “typed templates” are a key part of the path to adopting TypeScript as a community. TypeScript-powered integration between the template layer and the JavaScript context is a key goal for the Typed Ember team already. It is not a <em>gating feature</em> for Ember packages to officially supply TypeScript. Instead: the feature can be rolled out and integrated with Ember CLI, the Ember Language Server, and other tooling whenever it is ready, decoupled from the other efforts here. However, given its importance as one of the primary API boundaries within Ember and Glimmer apps, our definition of official Ember support would be incomplete without it.</p>
</li>
</ul>
<h3 id="constraints"><a class="header" href="#constraints">Constraints</a></h3>
<p>The following are our hard constraints in supporting TypeScript with Ember:</p>
<ul>
<li>We must not compromise our commitment to “stability without stagnation” and our strong Semantic Versioning guarantees. </li>
<li>Using TypeScript should never be mandatory for anyone who uses Ember.</li>
<li>TypeScript support must never <em>degrade</em> the experience of JavaScript users, and wherever possible it should benefit both JavaScript and TypeScript developers.</li>
<li>Types are published in the packages they represent, <em>not</em> in a third-party package.</li>
</ul>
<h3 id="non-goals-3"><a class="header" href="#non-goals-3">Non-Goals</a></h3>
<p>The combination of constraints and ecosystem status lead us to a key non-goal for this effort. A <em>non-goal</em> here means that it is not part of the initial road to making TypeScript available.</p>
<p>This RFC aims to <em>add</em> a new first-class language to the Ember support matrix. However, it does <em>not</em> recommend replacing JavaScript with TypeScript. To the contrary: this is an explicit non-goal. Per the constraints described above, adding first-class TypeScript support should be a net positive for JavaScript-only Ember developers.</p>
<p>Additionally, this RFC does not propose changing the <em>default</em> experience from JavaScript to TypeScript even once we have full support for TypeScript.</p>
<h3 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h3>
<p>With this definition and associated design constraints in mind, the path to full TypeScript support in Ember requires RFCs to address key blockers, as well as some implementation details which do not require RFCs but are important for successfully delivering TypeScript support to our users..</p>
<h4 id="rfc-required"><a class="header" href="#rfc-required">RFC Required</a></h4>
<p>Each of the following concerns must be addressed by RFCs. (Note that some RFCs might cover more than one of these points, but the use of a heading does not imply that a single RFC must cover all of the points within it.)</p>
<h5 id="types"><a class="header" href="#types">Types</a></h5>
<ul>
<li>
<p><strong>The set of supported types.</strong> Specifically, should the types support the whole API surface of Ember, including both Classic and Octane features, or only Octane features? Mixins, for example, are <em>not</em> part of the Octane programming model and are a major source of complexity in Ember’s current types; should they be included at all in types shipped with Ember?</p>
</li>
<li>
<p><strong>Migration from DefinitelyTyped.</strong> TypeScript users in the Ember community currently rely on the types in DefinitelyTyped. We need to define a transition story for them, which is closely related to the previous point. If we drop support for features currently supported on DefinitelyTyped, or make even well-motivated changes, how will users migrate successfully to them?</p>
</li>
<li>
<p><strong>Semantic Versioning of types and TypeScript compiler version support.</strong> We must <em>create a definition for semantic versioning of TypeScript types</em>, since there is currently no widely-used definition in the broader front-end ecosystem. (Hopefully this effort can benefit the broader TypeScript community!). Additionally, we must <em>define a support policy</em> for TypeScript versions: do we pin to a minimum type when we release a major, do something our Node support policy, or some other approach? (See also further discussion <a href="0724-road-to-typescript.html#semantic-versioning-and-supported-typescript-versions">below</a>.)</p>
</li>
<li>
<p><strong>The <code>@glimmer/component@2.x</code> Type API.</strong> The current Glimmer component TypeScript API works well, but research efforts into “typed templates” and <a href="https://github.com/emberjs/rfcs/pull/678">component documentation</a> have both exposed the importance of being able to specify more “type parameters” for components than simply its args, including its root element(s) and blocks, if any. Additionally, the types should be readily extensible if other such concerns emerge in the future. For example: we might in the future want to be able to constrain what can and what cannot be “splatted” onto an element with <code>...attributes</code>; the type signature should be able to support that addition in a backwards-compatible way.</p>
<p>(This may also be a good time to remove the <code>isDestroying</code> and <code>isDestroyed</code> properties and the <code>willDestroy</code> hook from the Glimmer Component API, to making a single set of breaking changes instead of multiple sets. Note, however, that official TypeScript support in Ember is not <em>gated</em> on those further changes.)</p>
</li>
</ul>
<h5 id="official-documentation"><a class="header" href="#official-documentation">Official documentation</a></h5>
<p>If Ember officially supports TypeScript, it is important that we support it in all of Ember’s documentation, including guides, API docs, etc. This requires considerable design effort, including thinking through how to present JavaScript and TypeScript (side by side? toggle-able? etc.), where to introduce discussion of TypeScript support in the guides, how API docs should be presented (and whether it may make sense to switch to something like API Extractor) and so on.</p>
<p>The official RFC templates for new features and for deprecations will also need to be updated:</p>
<ul>
<li>They must include a description of how changes affect TypeScript consumers.</li>
<li>They will need to formally adopt TypeScript types as normative and required for new APIs, formalizing the rough pattern already common for new API designs.</li>
</ul>
<h5 id="authoring-and-build"><a class="header" href="#authoring-and-build">Authoring and Build</a></h5>
<ul>
<li>
<p><strong>How do consumers generate TypeScript apps and addons (and blueprints more generally)?</strong> Should we support <code>ember new --typescript</code>? How should blueprints work? This will need to identify the path forward for authoring and publishing, Ember CLI integration, and in particular integration with the Embroider v2 Package Format. (If possible, TypeScript integration should piggy-back on the Embroider v2 <em>Authoring</em> Format, but if that format is not available, this is not a blocker.)</p>
</li>
<li>
<p><strong>Supported compilation modes.</strong> What should the out-of-the-box settings be for compiling Ember apps and addons written in TypeScript? This will need to be written with an eye to Embroider, preferably with the v2 Package Format as the <em>only</em> supported publication format. It must also address the transition path from current ember-cli-typescript (if any). It <em>must</em> address interoperation hazards between Babel and TypeScript: for example, in the decorators implementations, use of the <code>isolatedModules</code> setting and associated lints, etc.</p>
</li>
<li>
<p><strong>Migration from the status quo.</strong>  Today, users install <code>ember-cli-typescript</code> to opt into using TypeScript, and there is a wholly separate (and, unfortunately, very poorly-maintained) set of blueprints for working with TypeScript.  We will need to identify a migration story from the <em>current</em> paired design of <code>ember-cli-babel</code> and <code>ember-cli-typescript</code> to the future approach suggested by the previous bullet.</p>
</li>
</ul>
<h4 id="implementation-details-3"><a class="header" href="#implementation-details-3">Implementation Details</a></h4>
<p>There are also a number of key implementation concerns which must be addressed, but which, as implementation details, do <em>not</em> require RFCs:</p>
<ul>
<li>
<p><strong>How are the published types generated?</strong> While much of Ember is implemented in TypeScript, its internal types are not currently ready to be used for public API, and it will likely take some time for them to be ready (with different packages ready at different times). We will need to determine how to publish hand-authored type-definition files, implementation-derived definition files, and over time a mix of the two until we hopefully are able to publish <em>only</em> implementation-derived files.</p>
</li>
<li>
<p><strong>Where do published type definition files live in the artifacts published to npm?</strong> TypeScript generally assumes that types are published with packages of the same name. While there is <a href="https://emberjs.github.io/rfcs/0706-deprecate-ember-global.html">now</a> a path to publishing actual packages like <code>&quot;@ember/object&quot;</code>, this effort should not be gated on any such effort, and there is additional work to be done. However, that work simply consists of implementation details, rather than defining new public API.</p>
</li>
<li>
<p><strong>How do app and addon authors <em>consume</em> published types?</strong> There are a few “gotchas” about how TypeScript supports features like autocomplete in a project, which primarily affect the very first few interactions end users have with TypeScript, which we should address via tooling. How this works is closely related to where the type definition files are generated during publication, and so will likely need to be solved in conjunction with that issue.</p>
</li>
<li>
<p><strong>What should the final design for template-aware type checking be?</strong> <a href="https://github.com/typed-ember/glint">Glint</a> has a number of decisions which make good sense and indeed are necessary for template-aware type checking given both the design constraints of the Octane era and its own experimental status. However, we should nail these down before it becomes an officially-recommended tool!</p>
</li>
</ul>
<h4 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h4>
<p>Since the authoring and support policies we adopt for Ember itself will likely be adopted in an <em>ad hoc</em> way, it may be useful to provide official <em>recommendations</em> for authors. These might include:</p>
<ul>
<li>Semantic Versioning guidelines</li>
<li>tooling recommendations (in line with the defaults for the build pipeline)</li>
<li>documentation guidelines</li>
</ul>
<p>The existence of these guidelines is not a requirement for Ember's official adoption of TypeScript, but the adoption process would be a prime opportunity to generate these artifacts.</p>
<h3 id="semantic-versioning-and-supported-typescript-versions"><a class="header" href="#semantic-versioning-and-supported-typescript-versions">Semantic Versioning and Supported TypeScript Versions</a></h3>
<p>Ember and TypeScript have fundamentally different views on Semantic Versioning (SemVer).</p>
<p>Ember has a deep commitment to minimizing breaking changes in general, and to strictly following SemVer when breaking changes <em>are</em> made. (The use of lockstep versioning for Ember Data and Ember CLI complicates this commitment to a substantial degree, but that complication is outside the scope of this RFC.)</p>
<p>TypeScript explicitly <em>does not</em> follow SemVer. TypeScript's core team argues that <em>every</em> change to the compiler is a breaking change, and that SemVer is therefore meaningless. (We do not agree with this characterization, but are also uninterested in arguing it. This RFC takes the TypeScript team's position as a given.) Accordingly, every TypeScript point release may be a breaking change, and &quot;major&quot; numbers for releases signify nothing beyond having reached <code>x.9</code> in the previous cycle.</p>
<p>For TypeScript to be a first-class citizen of the Ember ecosystem, we need:</p>
<ul>
<li>a policy defining what constitutes a breaking change for consumers of a library which publishes types, including Ember’s core libraries</li>
<li>tooling to detect breaking changes in types—whether from refactors, or from new TypeScript releases—and to minimize the amount of churn from breaking changes in TypeScript</li>
<li>a general and widely-adopted policy for supported TypeScript versions</li>
</ul>
<p>Once all three of those elements are adopted, end users will be able to have equally high confidence in the stability of published types as they do in their runtime code.</p>
<h2 id="how-we-teach-this-144"><a class="header" href="#how-we-teach-this-144">How we teach this</a></h2>
<p>This RFC intentionally defers most of the analysis of teaching work to an RFC dedicated to the question. At a high level, once the roadmap is complete, the Ember blog should announce support, and Ember’s docs should explicitly state that TypeScript is officially supported and show TypeScript examples alongside JavaScript examples.</p>
<p>It is critical that these materials (including the blog post) emphasize that TypeScript support is <em>additive</em>, not a replacement for JavaScript, as discussed above in <a href="0724-road-to-typescript.html#non-goals">Non-Goals</a>.</p>
<h2 id="drawbacks-161"><a class="header" href="#drawbacks-161">Drawbacks</a></h2>
<p>Adding TypeScript support imposes an additional maintenance burden on all contributors to Ember:</p>
<ul>
<li>documentation must be kept up to date in both JavaScript and TypeScript</li>
<li>changes to APIs must be kept in sync with published types (when the types are not generated from the implementation)</li>
<li>managing support for TypeScript versions will require additional effort and versioning coordination</li>
<li>presumably, API designs will be constrained in new ways (though this may also be an upside!)</li>
</ul>
<h2 id="alternatives-163"><a class="header" href="#alternatives-163">Alternatives</a></h2>
<p>TypeScript support has historically been managed by the community. We could continue with this approach, including e.g. investigating other alternatives to DefinitelyTyped for supplying types in a more robust way. This has worked reasonably well to date, though it has added friction for adopters, especially when the Typed Ember maintainers could not keep up with changes to Ember itself.</p>
<h2 id="unresolved-questions-105"><a class="header" href="#unresolved-questions-105">Unresolved questions</a></h2>
<blockquote>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-03-23
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js, Steering, Ember Data, Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/730</h2>
<h1 id="semantic-versioning-for-typescript-types"><a class="header" href="#semantic-versioning-for-typescript-types">Semantic Versioning for TypeScript Types</a></h1>
<h2 id="note-on-authoritative-source"><a class="header" href="#note-on-authoritative-source">Note on Authoritative Source</a></h2>
<p><strong>The living specification to which Ember is committed lives at <a href="https://www.semver-ts.org">www.semver-ts.org</a>.</strong></p>
<p>The text below represents the RFC as it was merged as part of Ember.js’ RFC process. However, <a href="0730-semver-for-ts.html#how-we-teach-this">per the text below</a>, this is not the authoritative form of this specification:</p>
<blockquote>
<p>If these recommendations are adopted, the <strong>Detailed Design</strong> section shall be published to a dedicated, standalone repository to ease linking to it (including by TypeScript packages beyond the Ember ecosystem, if they find it useful, as we hope they will!).</p>
</blockquote>
<p>Accordingly, the text below represents the state of the specification at the time it was accepted as for Ember’s purposes, with the expectation that it will continue to evolve and be improved over time.</p>
<hr />
<h2 id="summary-177"><a class="header" href="#summary-177">Summary</a></h2>
<p>This RFC proposes a definition of <a href="https://semver.org">Semantic Versioning</a> for managing changes to TypeScript types, including when the TypeScript compiler makes breaking changes in its type-checking and type emit across a “minor” release.(Note that this RFC addresses <em>only</em> type checking and type emit, <em>not</em> the “transpilation” mode of the TypeScript compiler.)</p>
<p>(While this RFC is being authored in the context of <a href="https://github.com/emberjs/rfcs/pull/724">Ember.js’ adoption of TypeScript as a first-class supported language</a>, its recommendations are intentionally general, in hopes that these recommendations can be widely adopted by the broader TypeScript community.)</p>
<h3 id="design-overview"><a class="header" href="#design-overview">Design overview</a></h3>
<p>This section is a non-normative short summary for easy digestion. See <a href="0730-semver-for-ts.html#detailed-design"><strong>Detailed Design</strong></a> below for normative text.</p>
<h4 id="for-package-consumers"><a class="header" href="#for-package-consumers">For package consumers</a></h4>
<p>Things a package may do in a non-breaking way:</p>
<ul>
<li>widen what it accepts from you</li>
<li>narrow what it provides to you</li>
<li>add new exports</li>
</ul>
<p>Things which constitute breaking changes in a package:</p>
<ul>
<li>narrowing what it accepts from you</li>
<li>widening what it provides to you</li>
<li>removing exports</li>
</ul>
<p>Note that this summary elides <em>many</em> important details, and those details may surprise you! In particular &quot;what it accepts&quot; and &quot;what it provides&quot; have considerable depth and nuance: they include interfaces or types you can construct, function arguments, class field mutability, and more.</p>
<h4 id="for-package-authors"><a class="header" href="#for-package-authors">For package authors</a></h4>
<ul>
<li>
<p>Public published types are part of the SemVer contract of a package, and must be versioned accordingly, per the specification above.</p>
</li>
<li>
<p>Adding a new TypeScript version to the support matrix <em>may</em> cause breaking changes. When it does not, adding it is a normal minor release. When it <em>does</em> cause a breaking change, the package must either mitigate that breakage (so consumers are not broken) <em>or</em> the package must release a major version.</p>
</li>
<li>
<p>Removing a TypeScript version from the support matrix is a breaking change, except when it falls out of the supported version range under the “rolling support windows” policy.</p>
</li>
<li>
<p>There are two recommended support policies for TypeScript compiler versions: <em>simple majors</em> and <em>rolling window</em>.</p>
<ul>
<li>
<p>In <em>simple majors</em>, dropping support for a previously supported compiler version requires a breaking change.</p>
</li>
<li>
<p>In <em>rolling window</em>, a package may declare a range of supported versions which moves over time, similar to supporting evergreen browsers.</p>
<p>Packages using the “rolling window” policy should normally support all TypeScript versions released during the current ‘LTS’ of other core packages/runtimes/etc. they support, and drop support for them only when they drop support for that ‘LTS’, to minimize the number of major versions in the ecosystem.</p>
</li>
</ul>
</li>
<li>
<p>Both the currently-supported compiler versions and the compiler version support policy must be documented.</p>
</li>
<li>
<p>Packages must be authored with the following compiler options:</p>
<ul>
<li><code>strict: true</code></li>
<li><code>noUncheckedIndexedAccess: true</code></li>
</ul>
</li>
<li>
<p>Libraries should generally be authored with the following compiler options:</p>
<ul>
<li><code>esModuleInterop: false</code></li>
<li><code>allowSyntheticDefaultImports: false</code></li>
</ul>
</li>
</ul>
<h3 id="outline-1"><a class="header" href="#outline-1">Outline <!-- omit in toc --></a></h3>
<ul>
<li><a href="0730-semver-for-ts.html#summary">Summary</a>
<ul>
<li><a href="0730-semver-for-ts.html#design-overview">Design overview</a>
<ul>
<li><a href="0730-semver-for-ts.html#for-package-consumers">For package consumers</a></li>
<li><a href="0730-semver-for-ts.html#for-package-authors">For package authors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="0730-semver-for-ts.html#motivation">Motivation</a></li>
<li><a href="0730-semver-for-ts.html#detailed-design">Detailed design</a>
<ul>
<li><a href="0730-semver-for-ts.html#background-typescript-and-semantic-versioning">Background: TypeScript and Semantic Versioning</a></li>
<li><a href="0730-semver-for-ts.html#defining-breaking-changes">Defining breaking changes</a>
<ul>
<li><a href="0730-semver-for-ts.html#definitions">Definitions</a></li>
<li><a href="0730-semver-for-ts.html#reasons-for-breaking-changes">Reasons for Breaking Changes</a></li>
</ul>
</li>
<li><a href="0730-semver-for-ts.html#changes-to-types">Changes to types</a>
<ul>
<li><a href="0730-semver-for-ts.html#variance">Variance</a></li>
<li><a href="0730-semver-for-ts.html#breaking-changes">Breaking Changes</a></li>
<li><a href="0730-semver-for-ts.html#non-breaking-changes">Non-breaking changes</a></li>
<li><a href="0730-semver-for-ts.html#bug-fixes">Bug fixes</a></li>
</ul>
</li>
<li><a href="0730-semver-for-ts.html#compiler-considerations">Compiler considerations</a></li>
<li><a href="0730-semver-for-ts.html#conformance">Conformance</a></li>
</ul>
</li>
<li><a href="0730-semver-for-ts.html#how-we-teach-this">How we teach this</a></li>
<li><a href="0730-semver-for-ts.html#drawbacks">Drawbacks</a></li>
<li><a href="0730-semver-for-ts.html#alternatives">Alternatives</a>
<ul>
<li><a href="0730-semver-for-ts.html#no-policy">No policy</a></li>
<li><a href="0730-semver-for-ts.html#decouple-typescript-support-from-lts-cycles">Decouple TypeScript support from LTS cycles</a></li>
</ul>
</li>
<li><a href="0730-semver-for-ts.html#unresolved-questions">Unresolved questions</a></li>
<li><a href="0730-semver-for-ts.html#appendices">Appendices</a>
<ul>
<li><a href="0730-semver-for-ts.html#appendix-a-existing-implementations">Appendix A: Existing Implementations</a></li>
<li><a href="0730-semver-for-ts.html#appendix-b-tooling">Appendix B: Tooling</a>
<ul>
<li><a href="0730-semver-for-ts.html#documenting-supported-versions-and-policy">Documenting supported versions and policy</a></li>
<li><a href="0730-semver-for-ts.html#detect-breaking-changes-in-types">Detect breaking changes in types</a></li>
<li><a href="0730-semver-for-ts.html#mitigate-breaking-changes">Mitigate breaking changes</a></li>
<li><a href="0730-semver-for-ts.html#matching-exports-to-public-api">Matching exports to public API</a></li>
</ul>
</li>
<li><a href="0730-semver-for-ts.html#appendix-c-on-variance-in-typescript">Appendix C: On Variance in TypeScript</a>
<ul>
<li><a href="0730-semver-for-ts.html#inference-and-pervasive-mutability">Inference and pervasive mutability</a></li>
<li><a href="0730-semver-for-ts.html#structural-typing">Structural typing</a></li>
<li><a href="0730-semver-for-ts.html#higher-order-type-operations">Higher-order type operations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="motivation-177"><a class="header" href="#motivation-177">Motivation</a></h2>
<p>For TypeScript packages be good citizens of the broader, semantically-versioned JavaScript ecosystem, package authors need a useful definition of SemVer for TypeScript’s type system.</p>
<p>This is somewhat more complicated than in other languages, even those other statically-typed languages with language-level SemVer guarantees (such as <a href="https://rust-lang.github.io/rfcs/1122-language-semver.html">Rust</a> and Elm), because TypeScript has an unusually flexible type system. In particular, its <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural type system</a> means many more kinds of both breaking and non-breaking changes are possible than in languages with a <a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominal type system</a>.<sup class="footnote-reference"><a href="#other-structural-types">1</a></sup> Accordingly, this document proposes a definition of SemVer which accounts for the extra flexibility afforded by these features.</p>
<p>Furthermore, unlike the rest of the JavaScript ecosystem, the TypeScript compiler explicitly <em>rejects</em> SemVer. TypeScript's core team argues that <em>every</em> change to a compiler is a breaking change, and that SemVer is therefore meaningless for TypeScript. We do not agree with this characterization, but take the TypeScript team's position as a given for the purposes of this document. Accordingly, every TypeScript non-patch release may be a breaking change, and &quot;major&quot; numbers for releases signify nothing beyond having reached <code>x.9</code> in the previous cycle.</p>
<p>This means that defining SemVer for TypeScript Types requires that we specify a definition of Semantic Versioning which can absorb breaking changes in the TypeScript compiler as well as intentional changes by package authors. As such, it also requires clearly defined TypeScript compiler version support policies.</p>
<div class="footnote-definition" id="other-structural-types"><sup class="footnote-definition-label">1</sup>
<p>Many languages include structural typing in certain contexts, including Swift's protocols, Elm's record types, and row-polymorphic types in OCaml, PureScript, etc. However, of these only Elm provides language-level guidance or tooling, and at the time of authoring there is no public specification of its behavior. Its current algorithm is <a href="https://github.com/elm/compiler/blob/770071accf791e8171440709effe71e78a9ab37c/builder/src/Deps/Diff.hs#L128-L136">implementations-specified</a> and roughly checks for addition or removal of fields.</p>
</div>
<h2 id="detailed-design-144"><a class="header" href="#detailed-design-144">Detailed design</a></h2>
<p>TypeScript types should be treated with exactly the same (or even greater!) rigor as other elements of the JavaScript ecosystem, with the same level of commitment to stability, clear and accurate use of Semantic Versioning, testing, and clear policies about breaking changes.</p>
<p>TypeScript introduces two new concerns around breaking changes for packages which publish types.</p>
<ol>
<li>
<p>TypeScript does not adhere to the same norms around Semantic Versioning as the rest of the npm ecosystem, so it is important for package authors to understand when TypeScript versions may introduce breaking changes without any other change made to the package.</p>
</li>
<li>
<p>The runtime behavior of the package is no longer the only source of potentially-breaking changes: types may be as well. In a well-typed package, runtime behavior and types should be well-aligned, but it is possible to introduce breaking changes to types without changing runtime behavior and vice versa.</p>
</li>
</ol>
<p>Accordingly, we must define breaking changes precisely and carefully.</p>
<h3 id="background-typescript-and-semantic-versioning"><a class="header" href="#background-typescript-and-semantic-versioning">Background: TypeScript and Semantic Versioning</a></h3>
<p>TypeScript <em><strong>does not</strong></em> adhere to Semantic Versioning, but since it participates in the npm ecosystem, it uses the same format for its version numbers: <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>.</p>
<p>In Semantic Versioning, <code>&lt;major&gt;</code> would be a breaking change release, <code>&lt;minor&gt;</code> would be a backwards-compatible feature-addition release, and <code>&lt;patch&gt;</code> would be a &quot;bug fix&quot; release.</p>
<p>In TypeScript, both <code>&lt;major&gt;</code> and <code>&lt;minor&gt;</code> releases <em>may</em> introduce breaking changes of the sort that Semantic Versioning reserves for the <code>&lt;major&gt;</code> slot in the version number. Not all <code>&lt;minor&gt;</code> <em>or</em> <code>&lt;major&gt;</code> releases <em>do</em> introduce breaking changes in the normal Semantic Versioning sense, but either <em>may</em>. Accordingly, and for simplicity, the JavaScript ecosystem should treat <em>all</em> TypeScript <code>&lt;major&gt;.&lt;minor&gt;</code> releases as a major release.</p>
<p>TypeScript's use of patch releases is more in line with the rest of the ecosystem's use of patch versions. The TypeScript Wiki <a href="https://github.com/microsoft/TypeScript/wiki/TypeScript&#x27;s-Release-Process/e669ab1ad96edc1a7bcef5f6d9e35e24397891e5">currently summarizes patch releases</a> as follows:</p>
<blockquote>
<p>Patch releases are periodically pushed out for any of the following:</p>
<ul>
<li>High-priority regression fixes</li>
<li>Performance regression fixes</li>
<li>Safe fixes to the language service/editing experience</li>
</ul>
<p>These fixes are typically weighed against the cost (how hard it would be for the team to retroactively apply/release a change), the risk (how much code is changed, how understandable is the fix), as well as how feasible it would be to wait for the next version.</p>
</blockquote>
<p>These three categories of fixes are well within the normally-understood range of fixes that belong in a &quot;bug fix&quot; release in the npm ecosystem. In these cases, a user's code may stop type-checking, but <em>only</em> if they were depending on buggy behavior. This matches users' expectations around runtime code: a SemVer patch release to a package which fixes a bug may cause packages which were depending on that bug to stop working.</p>
<p>By example:</p>
<ul>
<li><code>4.8.3</code> to <code>4.8.4</code>: always considered a bug fix</li>
<li><code>4.8.3</code> to <code>4.9.0</code>: <em>may or may not</em> introduce breaking changes; equivalent to a major in the rest of the ecosystem</li>
<li><code>4.9.0</code> to <code>5.0.0</code>: <em>may or may not</em> introduce breaking changes; equivalent to a major in the rest of the ecosystem</li>
</ul>
<h3 id="defining-breaking-changes"><a class="header" href="#defining-breaking-changes">Defining breaking changes</a></h3>
<p>Changes to the types of the public interface are subject to the same constraints as runtime code: <em>breaking the public published types entails a breaking change.</em> Not all changes to published types are <em>breaking</em>, however:</p>
<ul>
<li>Some changes will continue to allow user code to continue working without any issue.</li>
<li>Some published types represent private API.</li>
</ul>
<p>It is impossible to define the difference between breaking and non-breaking changes purely in the abstract. Instead, we must define exactly what changes are &quot;backwards-compatible&quot; and which are &quot;breaking,&quot; and we must further define what constitutes a legitimate &quot;bug fix&quot; for type definitions designed to represent runtime behavior. Note that this is a <em>socio-technical</em> contract, not a purely-technical contract, and therefore (contra <a href="http://www.hyrumslaw.com">Hyrum’s Law</a>) a breaking change is not simply <em>any observable change to a system</em> but rather <em>a change to the system which violates the contract</em>.</p>
<p>Accordingly, we propose the following specific definitions of breaking, non-breaking, and bug-fix changes for TypeScript types. Because types are designed to represent runtime behavior, we assume throughout that these changes <em>do</em> in fact correctly represent changes to runtime behavior, and that changes which <em>incorrectly</em> represent runtime behavior are <em>bugs</em>.</p>
<p><strong>Note:</strong> The examples supplied throughout via links to the TypeScript are illustrative rather than normative. However, the distinction between &quot;observed&quot; and &quot;promised&quot; behavior in TypeScript is quite loose: there is no independent specification, so the formal behavior of the type system is implementation-specified.</p>
<h4 id="definitions-1"><a class="header" href="#definitions-1">Definitions</a></h4>
<dl>
<dt>Symbols</dt>
<dd>
<p>There are two kinds of <em>symbols</em> in TypeScript: value symbols and type symbols. (Note that these are distinct from the <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> object in JavaScript.)</p>
<p>Value symbols represent values present at runtime in JavaScript:</p>
<ul>
<li><code>let</code>, <code>const</code>, and <code>var</code> bindings</li>
<li><code>function</code> declarations</li>
<li><code>class</code> declarations</li>
<li><code>enum</code> and <code>const enum</code> declarations</li>
<li><code>namespace</code> declarations (which produce or represent <em>objects</em> at runtime)</li>
</ul>
<p>Type symbols represent types which are used in type checking:</p>
<ul>
<li><code>interface</code> declarations</li>
<li><code>type</code> (type alias) declarations</li>
<li><code>function</code> declarations</li>
<li><code>class</code> declarations</li>
<li><code>enum</code> and <code>const enum</code> declarations</li>
</ul>
<p>(Note that <code>namespace</code> declarations can also be present in type-only declarations, as when a type is exported from a namespace and referenced like <code>let val: SomeNamespace.ExportedInterface</code>, but the value produced by the <code>namespace</code> is not itself a type.)</p>
</dd>
<dt>Functions</dt>
<dd>
<p>Unless otherwise specified, &quot;functions&quot; always refers interchangeably to: functions in standalone scope, whether defined with either <code>function</code> or an arrow; class methods; and class constructors.</p>
</dd>
<dt>User constructibility</dt>
<dd>
<p>A type is user-constructible if the consumer of a package is allowed to create their own objects which match a given type structurally, that is, <em>without</em> using a function or class exported from the package which provides the type.</p>
<p>For example, a package may choose to export an interface to allow users to name the type returned by a function, while specifying that the only legal way to construct such an interface is via that exported function, in which case the type is <em>not</em> user-constructible.</p>
<p>Alternatively, a package may export an interface or type alias explicitly for users to construct objects implementing that type, in which case the type <em>is</em> user-constructible.</p>
</dd>
<dd>
<p>Using the type-level <code>typeof</code> operator to construct a type using the type of an exported item from a library wholly defeats the ability of authors to specify a public API. Accordingly:</p>
<ol>
<li>Authors who wish to treat any given type as user-constructible should export a type definition for it under their public API contract (see the next section).</li>
<li>A type defined in terms of <code>typeof</code> which “breaks” under the rules discussed below is <em>not</em> breaking, because it was not legally user-constructible.</li>
</ol>
</dd>
<dd>
<p>One challenge for this definition is the common scenario where code is not ordinarily user-constructible but may need to be mocked for tests. Changes to these <em>do not</em> constitute breaking changes—but library authors can also mitigate the challenge presented by this scenario. (See discussion below under <a href="0730-semver-for-ts.html#avoiding-user-constructibility">Appendix B: Tooling – Mitigate Breaking Changes – Avoiding User constructibility</a>.)</p>
</dd>
<dd>
<p><strong>Non-normative example:</strong> in Ember.js today, the interface for a <code>Transition</code> is public API and consumers can rely on its stability, but only Ember is allowed to create <code>Transition</code> instances.</p>
<p>If a user imported the <code>Transition</code> interface and wrote a <code>class CustomTransition implements Transition { ... }</code>, this would be stepping outside the SemVer contract.</p>
</dd>
<dt>Public API</dt>
<dd>
<p><strong>Overview:</strong> Some packages may choose to specify that the public API consists of <em>documented</em> exports, in which case no published type may be considered public API unless it is in the documentation. Other packages may choose to say the reverse: all exports are public unless explicitly defined as private (for example with the <code>@private</code> JSDoc annotation, a note in the docs, etc.).
In either case, no change to a type documented as private is a breaking change, whether or not the type is exported, where <em>documented as private</em> is defined in terms of the documentation norm of the package in question.</p>
</dd>
<dd>
<p><strong>Documentation of user constructibility:</strong> Exported types (interfaces, type aliases, and the type side of classes) may be defined by documentation to be user-constructible or not.</p>
</dd>
<dd>
<p><strong>Documentation of subclassibility:</strong> Exported classes may be defined by documentation to be user-subclassible or not.</p>
</dd>
<dd>
<p><strong>Re-exports:</strong> using the <code>export * from</code> re-export syntax can in theory cause breakage by causing export conflicts: if the library being re-exported and the library doing the re-export both export the same name. For this reason, changes caused by the <code>export * from ...</code> are never breaking changes.<sup class="footnote-reference"><a href="#re-export-antipattern">2</a></sup></p>
</dd>
<div class="footnote-definition" id="re-export-antipattern"><sup class="footnote-definition-label">2</sup>
<p>In general, it is an antipattern for one package to re-export another package directly like this, and the cases where it makes sense (e.g. Ember re-exporting Glimmer APIs) are cases of collaborators which can manage this.</p>
</div>
<h4 id="reasons-for-breaking-changes"><a class="header" href="#reasons-for-breaking-changes">Reasons for Breaking Changes</a></h4>
<p>Each of the kinds of breaking changes defined below will trigger a compiler error for consumers, surfacing the error. As such, they should be easily detectable by testing infrastructure (see below under <a href="0730-semver-for-ts.html#detect-breaking-changes-in-types">Tooling: Detect breaking changes in types</a>).</p>
<p>There are several reasons why breaking changes may occur:</p>
<ol>
<li>
<p>The author of the package may choose to change the API for whatever reason. This is no different than the situation today for packages which do not support TypeScript. This would be a major version independent of types.</p>
</li>
<li>
<p>The author of the package may need to make changes to adapt to changes in the JavaScript ecosystem, for example to support Octane idioms in Ember.js. This is likewise identical with the situation for packages which do not support TypeScript: it would require a major version regardless.</p>
</li>
<li>
<p>Adopting a new version of TypeScript may change the meaning of existing types. For example, in TypeScript 3.5, generic types without a specified default type changed their default value from <code>{}</code> to <code>unknown</code>. This improved type safety, but broke many existing types, as <a href="https://github.com/microsoft/TypeScript/issues/33272">described in detail by Google</a>.</p>
</li>
<li>
<p>Adopting a new version of TypeScript may change the type definitions emitted in <code>.d.ts</code> files in backwards-incompatible ways. For example, changing to use the finalized ECMAScript spec for class fields meant that <a href="https://github.com/microsoft/TypeScript/pull/33470">types emitted by TypeScript 3.7 were incompatible with TypeScript 3.5 and earlier</a>.</p>
</li>
</ol>
<p>The kinds of breaking changes represented by reasons (1) and (2) are described below under <a href="0730-semver-for-ts.html#changes-to-types"><strong>Changes to Types</strong></a>; reasons (3) and (4) are discussed below in <a href="0730-semver-for-ts.html#compiler-considerations"><strong>Compiler Considerations</strong></a>.</p>
<p>Additionally, there are some changes which we define <em>not</em> to be breaking changes because, while they will cause the compiler to produce a type error, they will do so in a way which simply allows the removal of now-defunct code.</p>
<h3 id="changes-to-types"><a class="header" href="#changes-to-types">Changes to types</a></h3>
<h4 id="variance"><a class="header" href="#variance">Variance</a></h4>
<p>Virtually all of the rules around what constitutes a breaking change to types come down to <em>variance</em>.<sup class="footnote-reference"><a href="#variance">3</a></sup> In a real sense, everything in the discussion below is a way of showing the variance rules by example.<sup class="footnote-reference"><a href="#thanks-to-ryan">4</a></sup></p>
<div class="footnote-definition" id="variance"><sup class="footnote-definition-label">3</sup>
<p>For the purposes of this discussion, I will <em>assume</em> knowledge of variance, rather than explaining it.</p>
</div>
<div class="footnote-definition" id="thanks-to-ryan"><sup class="footnote-definition-label">4</sup>
<p>Thanks to <a href="https://github.com/RyanCavanaugh">Ryan Cavanaugh</a> of the TypeScript team for pointing out the various examples which motivated this discussion.</p>
</div>
<p>In many cases, these are the standard variance rules applicable in any and all languages with types:</p>
<ul>
<li>read-only types (sources) may be covariant</li>
<li>write-only types (sinks) may be contravariant</li>
<li>read-write (mutable) types must be invariant</li>
</ul>
<p>These basic intuitions underlie the guidelines below. However, several factors complicate them.</p>
<p>First of all, notice that the vast majority of objects in JavaScript are mutable, which means they must be <em>invariant</em>. When combined with type inference, this effectively means that <em>any</em> change to an object type <em>can</em> cause breakage for consumers. (The only real counter-examples are <code>readonly</code> types.)</p>
<p>Additionally, TypeScript has two other features many other languages do not which complicate reasoning about variance: <em>structural typing</em>, <em>higher-order type operations</em>. The result of these additional features is a further impossibility of safely writing types which can be <em>guaranteed</em> never to stop compiling for runtime-safe changes.</p>
<p>Accordingly, we propose the rules below, with the caveat that (as noted in several places throughout) they will <em>not</em> prevent all possible breakage—only the majority of it, and substantially the worst of it. Most of all, they give us a workable approach which can be well-tested and well-understood, and the edge cases identified here do not prevent the rules from being generally useful or applicable.<sup class="footnote-reference"><a href="#satisficery">5</a></sup></p>
<div class="footnote-definition" id="satisficery"><sup class="footnote-definition-label">5</sup>
<p>Precisely because SemVer is a <em>sociological</em> and not only a <em>technical</em> contract, the problem is tractable: We define a breaking change as above, and accept the reality that some changes are not preventable (but may in many cases be mitigated or fixed automatically). This is admittedly unsatisfying, but we believe it <a href="https://www.merriam-webster.com/dictionary/satisfice">satisfices</a> our constraints.</p>
</div>
<p>For a more detailed explanation and analysis of the impact of variance on these rules, see <a href="0730-semver-for-ts.html#appendix-c-on-variance-in-typescript"><strong>Appendix C</strong></a>.</p>
<h4 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking Changes</a></h4>
<h5 id="symbols"><a class="header" href="#symbols">Symbols</a></h5>
<p>Changing a symbol is a breaking change when:</p>
<ul>
<li>
<p>changing the name of an exported symbol (type or value), since users' existing imports will need to be updated. This is breaking for value exports (<code>let</code>, <code>const</code>, <code>class</code>, <code>function</code>) independent of types, but renaming exported <code>interface</code>, <code>type</code> alias, or <code>namespace</code> declarations is breaking as well.</p>
</li>
<li>
<p>removing an exported symbol, since users' existing imports will stop working. This is a breaking change for value exports (<code>let</code>, <code>const</code>, <code>class</code>, <code>function</code>) independent of types, but removing exported <code>interface</code>, <code>type</code> alias, or <code>namespace</code> declarations is breaking as well.</p>
<p>This includes changing a previously type-and-value export such as <code>export class</code> to either—</p>
<ul>
<li>
<p>a type-only export, since the exported value symbol has been removed:</p>
<pre><code class="language-diff">-export class Foo {
+class Foo {
  neato: string;
}
+
+export type { Foo };
</code></pre>
</li>
<li>
<p>a value-only export, since the exported type symbol has been removed:</p>
<pre><code class="language-diff">-export class Foo {
+class _Foo {
  neato: string;
}
+
+export let Foo: typeof _Foo;
</code></pre>
</li>
</ul>
</li>
<li>
<p>changing the kind (<em>value</em> vs. <em>type</em>) of an exported symbol in any way, since users' imports and own definitions may both be broken, since imports resolve all symbols imported together if they share a name:</p>
<ul>
<li>
<p>Given a <em>value</em>-only exported symbol, including <code>namespace</code> declarations, adding a <em>type</em> export with the same name as the <em>value</em> may break users' code: they may have imported the value and safely created a type of the same name. Their existing import will now cause a re-declaration conflict. Note that this is distinct from adding an entirely new type export where there was no type or value export previously, since the user could never accidentally introduce the conflict, and could work around the conflict using the <code>as</code> import specifier when introducing the import.</p>
</li>
<li>
<p>Given a <em>type</em>-only exported symbol, including <code>type</code>, <code>interface</code>, or <code>export type</code> for a type or value, adding a <em>value</em> export with the same name may break users' code: they may have imported the type and safely created a value of the same name. Their existing import will now cause a re-declaration conflict. Note that this is distinct from adding an entirely new value export where there was no type or value export previously, since the user could never accidentally introduce the conflict, and could work around the conflict using the <code>as</code> import specifier when introducing the import. (Type-only imports via <code>import type</code> do not change this because they still import the symbol into value space to use with <code>typeof</code>, e.g. to get a class' constructor.)</p>
</li>
<li>
<p>Given a <code>namespace</code> export, changing it to a value-only export (that is, to an exported object) will break all nested type access, since types cannot be exported as nested members of non-<code>namespace</code> values. (<code>namespace</code> exports cannot be directly converted to type-only exports.)</p>
</li>
</ul>
</li>
<li>
<p>changing an <code>interface</code> to a <code>type</code> alias will break any user code which used interface merging</p>
</li>
<li>
<p>changing a <code>namespace</code> export to any other type will break any code which used namespace merging</p>
</li>
<li>
<p>changing a <code>class</code> export to a type-only export will break any code which extended the class or constructed an instance of the class (<a href="https://www.typescriptlang.org/play?#code/PTAEEEDtQIgewE4EsDmTIEMA2NQBMBTAYywwQwBck5IAaUAdwAsCEDQKXGm4t2SMAZ0GMhoAgA8ADogoE8AOgBQhAW1ADhoAOpCAotNnzQAbwC+SpSFAAVJkhEOOXAgEcArkgBu2ApAqgcABmoBgcAJ5SBAC0NFjh4oYIAcGhGqTC9MxIREyMcO5YeKCQiAC22PFWYABG7AzIFHLQWEgA1uycDgBc1aB9AAZDfZoiuoIGMsnG5n2SUwEUkewmOvpJcsUW1kMDSqOgAPoAcnAUk0bFs0tRoKfnG8YAvEf3F9N4ANyWBwDK7jVRgAxRDvTaJZp4MbrBYzCx-AHAxBvR7FSSQkQo2FXCwqYikdRBdyQIhUGgcDAdQTjMHyAAUDBhl26awmqIAlCyvHAkF88Wp2ESSWToBRKQRBFjLgymR8WVKPpzQNzed99jRBAFGWzsaAXpACAxWbS8HT2d8iBqAqUHrr9Ya7mcTWbPkA">playground</a>), and changing a <code>class</code> export to a value-only export will break any code which referred to the class as a type (<a href="https://www.typescriptlang.org/play?#code/PTAEEEDtQIgewE4EsDmTIEMA2NQBMBTAYywwQwBck5IAaUAdwAsCEDQKXGm4t2SMAZ0GMhoAgA8ADogoE8AOgBQhAW1ADhoAOpCAotNnzQAbwC+SpSFAAVJkhEOOXAgEcArkgBu2ApAqgcABmoBigPljuBAC0NFgAnuKGCAHBoRqkwgqgAHKIALbYCaDxcO6MZVh4VmAMyHLOTgxInKAABpIyKaB8FG2g5JyszhjQbaqk6r1typoiAPp5FAZdcnimFhNk7L25cMvJawBcHPFSBGmL+ytGeADclnOgAMruAEZzAGKINynGknJIHgRLpBL81hslE9Xh9MoJvggluD-hJAcC9gdVsZzJYtuogu5IEQqDQOBgANYEQSg5F4AAUDH0h3kJxpzLwAEoTl44Eh7ipiJN2ASiSToBQKVSkeyGUysXgTtL5Vzwrz+VCaIIAoywezQABeUCQAgMHRy250jkPIiagKQa56w3G01Ki1WoA">playground</a>)</p>
</li>
</ul>
<h5 id="interfaces-type-aliases-and-classes"><a class="header" href="#interfaces-type-aliases-and-classes">Interfaces, Type Aliases, and Classes</a></h5>
<p>Object types may be defined with interfaces, type aliases, or classes. Interfaces and type aliases define type symbols only. Classes define both type symbols and value symbols. The <code>namespace</code> construct defines a value symbol (as well as introducing a context in which you can name other nested type or value symbols). The additional constraints for the value symbols introduced by classes are covered above under <a href="0730-semver-for-ts.html#symbols">Breaking Changes: Symbols</a>.</p>
<p>A change to any object type (user constructible or not) is breaking when:</p>
<ul>
<li>
<p>a non-<code>readonly</code> object property's type changes in any way:</p>
<ul>
<li>
<p>if it was previously <code>string</code> but now is <code>string | number</code>, some of the user's existing <em>reads</em> of the property will now be wrong (<a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgOrADYfQEwiZAbwFgAoZC5OALmQGcwpQBzAbjIF8yzRJZEUAEWA5c+ImUpVaDJiGbIAPshABXALYAjaO1JdSZGKpAIwwAPYEAFnBA4MEOuixiQACgBucDKoi1n2CL4AJS0alrQEuSUUBBgqlAEXj4QAHRwqQ7yYFa6+mR4CBhwscgOYMgA7piBeCD+Na66NnYOTo1B7tUuncG6BRBFJSjlyDgirrTCop3NtvaOAa5u4zN1fWRAA">playground</a>). Note that this includes making a property optional.</p>
</li>
<li>
<p>if it was previously <code>string | number</code> but now is <code>string</code>, some of the user's existing <em>writes</em> to the property will now be wrong (<a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgOrADYYHJylAewHdkBvAWAChkbk4AuZAZzClAHNkAfZEAVwC2AI2gBuKgF8qVUJFiIUAEWAATXPmJkqtOo37Cxk6ZRh8QCMMAIhkRNpCYAVAuizrCRABQA3OBj4QjK44eB4AlFrUtL7+EAB0cMgAvMgA5AAWEFgEqeKUUpRUKhAIGHgoGBBgtpghGkRBte7EeXbADs7BzV5ETaHEYXlFJWVQFVXIKqrdjMpq-UR5U-P1CcnIAEQADgRgcGAEG6LIAPQnyPCYTFRtHS599Z7L3YOn50x8CEgQKkzI0IQQBACHwmBgAJ5UIA">playground</a>). Note that this includes making a previously-optional property required. </p>
<p>Note that at present, TypeScript cannot actually catch all variants of this error. <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgOrADYYHJylAewHdkBvAWAChkbk4AuZAZzClAHNkAfZEAVwC2AI2gBuKgF8qVUJFiIUAEWAATXPmJkqtOo37Cxk6ZRh8QCMMAIhkRNpCYAVAuizrCRABQA3OBj4QjK44eB4AlFrUtL7+EAB0cMgAvMgA5AAWEFgEqeKUUpRUKhAIGHgoGBBgtpghGkRBte7EeXbADs7BzV5ETaHEYXlFJWVQFVXIKqrdjMpq-UR5U-P1CcnIAEQADgRgcGAEG6LIAPQnyPCYTFRtHS599Z7L3YOn50x8CEgQKkzI0IQQBACHwmBgAJ5UIA">This playground</a> demonstrates that there is a runtime error but no <em>type</em> error in one scenario. TypeScript's type system understands these types in terms of <em>assignability</em>, rather than local <em>mutability</em>. However, package authors should test for the catchable variant of this condition.</p>
</li>
</ul>
</li>
<li>
<p>a property is removed from the type entirely, since some of the user's existing uses of the type will break, even if the property was optional (<a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEIHU4GcDyAHMYAexDgBtkBvAWAChkHk4AuZAIyKLIjhAG46jdgH5WHLj350AvnTqhIsRClQAlCAFsiANwgATKoMYt2nbrwG1ZtOtzDISZAJ4BBVBBhEoEVhmz5CEnJkAF4qJlYwKABXFGlLO2RQBDJovX1Ud09vX0xcAmJSCjDKCOQo2IAadlZ4Miw4y1sIe0dXFxhFX3UtXQMSsorG5vtk1PS9VA6utB6dfVDwkyHqtlryBuR4oA">optional</a>, <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEIHU4GcBKECOArsFBACbIDeAsAFDIPJwBcyARgPYcA2EcIAbjqN2rTjz6C6AXzp1QkWIhSo8AWw4A3clWGMW7Lr35Das2nV5hkoBN0JlyqVBBgdSrDNjxESOgLxUTKxgUIQQADSiyPDcWCjSppYQ1rb2jmSoAIIwip7qWgFBBqHhUWyssfHIiUA">required</a>)</p>
</li>
</ul>
<p>A change to a user-constructible type is breaking when:</p>
<ul>
<li>a required property is added to the type, since all of the user's existing constructions of the type will be incorrect (<a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEIRgeyig3gWAChkTk4AuZAI00wBsI4QBuIgXyKNElkRQEEYPZAWKkK1WgyasxJKpRABXALZVosjoSIg4KiAGcADnzQZsEAKpGAJnEgiipZAzDIEmEAbBQlCMMCelOhYOMgAvCJklD5KKGyanIS6+samgjzWdg6izq7unt6+-oEglBnQEVESsfGJhEA">new-required-property</a>)</li>
</ul>
<p>A change to a non-user-constructible object type is breaking when:</p>
<ul>
<li>
<p>a <code>readonly</code> object property type becomes a <em>less specific (&quot;wider&quot;) type</em>, for example if it was previously <code>string</code> but now is <code>string | string[]</code>—since the user's existing handling of the property will be wrong in some cases (<a href="https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwPIwJYHMsDsoJ4BvAKHnjimAHt8IBPeABxlpZBgBdGAueMm7Z8OANxkAvmTKgkcRNFTwA6llD4QwUhSoga9Jq3ace-QcII54AHwsicAbQC6UmQDMArvjDcs9eAALKHxgCBBkTFwCIgA5WHYAdwAKADciTxABKLxCCABKAXxPAFsAIy4dSjhuTxh8eHSITIA6Ng4uXhbw0W5AiWlZcGgFcO54KGzsXKIJORGEMfgygTUNLQlg0PDI6ZiIeJgk5Kh8zZCwiJz9w+Oys7IgA">playground</a>—the playground uses a class but an interface or type alias would have the same behavior).</p>
<p>Note that this includes making a property optional, since these are equivalent for the purposes of type-checking:</p>
<pre><code class="language-diff">interface A {
- a: string;
+ a?: string;
}
</code></pre>
<pre><code class="language-diff">interface A {
- a: string;
+ a: string | undefined;
}
</code></pre>
</li>
</ul>
<h5 id="functions"><a class="header" href="#functions">Functions</a></h5>
<p>For functions which return or accept user-constructible types, the rules specified for <a href="0730-semver-for-ts.html#interfaces-type-aliases-and-classes">Breaking Changes: Interfaces, Type Aliases, and Classes</a> hold. Otherwise, a change to the type of a function is breaking when:</p>
<ul>
<li>
<p>an argument or return type changes entirely, for example if a function previously accepted <code>number</code> and now accepts <code>{ count: number }</code>, or previously returned <code>string</code> and now returns <code>boolean</code>—since the user will have to change all call sites for the function (<a href="https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0NigkBqBbJyoAPKY8AjknGZyoMUubIj0OPChLPSMNNK2nPYAFIEE0HqIbJAARlgAlHoAbhrwgeFyDtGx8Ymo5JS0DKgAwviIloGFJaXlldUMdQ12yK3teub0GmW6oF29WKAOg6AjYxNTctm5SFwAdIdkPUqI0WgBGABMAGZ+hM1tANshAgDakDjk1TpCYeEgA">playground</a>)</p>
</li>
<li>
<p>a function (including a class constructor or methods) argument <em>requires a more specific (&quot;narrower&quot;) type</em>, for example if it previously accepted <code>string | number</code> but now requires <code>string</code>—since the user will have to change some calls to the function (<a href="https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEs9Iw00rac9gAUgQTQesLZiLCgAD7JbJAARlgAlHoAbhrwgeFyDtGx8YmoKdR0jKAA6jOSyIEFxSVlFVUMtfV2yC1tHThdsOOgUzNzCwpgQlig9BqxclkckguAA6c7IOpUBrNACMACYAMyjOaA3Kg8GQ6HXTwYbgaTzIuQ7WIoQJgmoQy6Na7wpFzYl7MkYqnNHHIPEE8JAA">playground</a>)</p>
</li>
<li>
<p>a function (including a class constructor or method) <em>returns a less specific (&quot;wider&quot;) type</em>, for example if it previously returned <code>string</code> but now returns <code>string | null</code>—since the user's existing handling of the return value will be wrong in some cases (<a href="https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEWVrac9gAUAJR6wtmIsOFyDtGx8YmoKdR0jKAA6vCxKIEFxSVlFVWWNnbITS04bbCgAD7JbNyd3QpgQlig9Bqxcs6l5ZWI6NCIgZzIAErU+zj1AG4r65tGjNith2JgHn86sgAHSvdp4Q7RfDPV4fKhfepZHJILjQpa1BqNRqdZEvd6fTjfcaTZCBPE1FZNYlyIA">playground</a>).</p>
<p>This includes widening from a <em>type guard</em> to a more general check. For example:</p>
<pre><code class="language-diff">-function isString(x: string | number): x is string {
+function isString(x: string): boolean {
  return typeof x === 'string';
}
</code></pre>
<p>This change would cause user-land code that expects narrowing to break:</p>
<pre><code class="language-ts">if (isString(value)) {
  return value.length;
} else {
  return value;
}
</code></pre>
</li>
<li>
<p>a function (including a class constructor or method) adds any new <em>required</em> arguments—since all user invocations of the function will now be broken (<a href="https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwEo7ictgBuAKFCRYCFOmx54yAsCgYQwanQZNWAGngAjOqmQBbTSBgd4XHgP4QQGeFHgBeQiTJUA5ARwY5OV2wFWbTQcpGTkFSndPb19eIA">playground</a>)</p>
</li>
<li>
<p>a function (including a class constructor or method) removes an existing argument entirely—since user invocations of the function may now fail to type-check</p>
<ul>
<li>
<p>if the argument was required, <em>all</em> invocations will fail to type-check (<a href="https://www.typescriptlang.org/play/?ssl=2&amp;ssc=35&amp;pln=2&amp;pc=47#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwBp4AjO1ZAW04gYASjrEcWYAG4AUKEiwEKdNjzxkBYFAwhg1OgyatR8cZNkyIIDPCjwAvIRJkqAcgI4M2nK44BGACZhWSsbTgd1TW1dSndPb194QOCgA">playground</a>)</p>
</li>
<li>
<p>if the argument was optional, any invocations which used it will fail to type-check (<a href="https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwBp4AjAfjtWQC2nEDACUdYjizAA3AChQkWAhTpseeMgLAoGEMGp0GTVuPiTp8uRBAZ4UeAF5CJMlQDkBHBl053HAEYAJlF5GztOJ01tXX1KT29ff3hg0OtbeDAoohBSHAp4rx8MPzTw+GAorR09AwTi0vkgA">playground</a>)</p>
</li>
</ul>
</li>
<li>
<p>changing a function from a <code>function</code> declaration to an arrow function declaration, since it changes the type of <code>this</code>, the effect of calling <code>bind</code> or <code>call</code> on the function, and requires parameters to be contravariant instead of allowing bivariance</p>
</li>
</ul>
<h4 id="non-breaking-changes"><a class="header" href="#non-breaking-changes">Non-breaking changes</a></h4>
<p>In each of these cases, some user code becomes <em>superfluous</em>, but it neither fails to type-check nor causes any runtime errors.</p>
<h5 id="symbols-1"><a class="header" href="#symbols-1">Symbols</a></h5>
<p>A change to an exported symbol is <em>not</em> breaking when:</p>
<ul>
<li>a symbol is exported which was not previously exported and which does not share a name with another symbol which was previously exported</li>
</ul>
<h5 id="interfaces-type-aliases-and-classes-1"><a class="header" href="#interfaces-type-aliases-and-classes-1">Interfaces, Type Aliases, and Classes</a></h5>
<p>Any change to a non-user-constructible type is <em>not</em> breaking when:</p>
<ul>
<li>
<p>a new optional property is added to the type, since all existing code will continue working (<a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPJWAc1HANsgbwFgAoZc5OALmQGcwMRMBuUgX1NNElkRQFUADgBM4kYYVIVKNeoxZSKAIwD8NEAFcAtkuisSHEqWEQEuOFBQwNIBGGAB7EMktgNUELXRYcuABQAlDTe2CB4+iZmFlY2do7Oru6eQqLigTQpYhDC+sam5pbI1rb2TshgcADWEF4YoXh+AB7Bdb5ByABuDsA5eVGFxXFlFdW0mWnNyOPZ7V09uSRhWjWCfMgAQhAwDpbTkmQUAPSHyAhOchpDIIrkuBBgMmitYfgAvISPAEQAFhC4uA5Psg2AtpMcXPcktlkEoAJ7IXDAJRQCywm4I+4wlo+F7Id6JDy1HENAKgo4nBB4cxKYCIsBog7kEY1EK+PxwUno5lE+r+AhfX7-QHAgLsTiLODLWirJDIACCMB4e2IjOQ4LOngYl1K11Vdwe1CmIiyEne-MNPz+AKBIPFYJOBJA0LhCKRKKgDOk+qxT2JbwhbkJ02EgTJ5HVVLgNLpnoo3NZL3ZnNV3ODSf00njzwaSmTmaqNTTuYzcYLY2NaXNNEtQptooMpCAA">playground</a>)</p>
</li>
<li>
<p>a <code>readonly</code> object property on the type becomes a <em>more specific (&quot;narrower&quot;) type</em>, for example if it was previously <code>string | string[]</code> and now is always <code>string[]</code>—since all user code will continue working and type-checking (<a href="https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEkoGdnwPIwJYHMsDsoJ4BvAKHngAcYB7KkGAFwE8AueZJ7fHeAH07cCOANoBdANxkAvmTKgkcRNFTwAcrDoB3EMFIVqdBs3ZCeOWfIBmAV3xgmWWvngALKPmAQQyTLgIiTRgdAAoANyJbEA5-PEIIAEoOfFsAWwAjRgNKOCZbGFdIiGiAOhp6RlZSn14mN2k5BXBoZR8meChY7HiiaUVWhHb4DI5gnT1pDy8fPx7AiHHabVCoRKnPb184haWVjPWyIA">playground</a>). Note that this includes a previously-optional property becoming required.<sup class="footnote-reference"><a href="#nit-on-comparability">6</a></sup></p>
</li>
<li>
<p>a new required property is added to the object—since its presence does not require the consuming code to use the property at a type level (<a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPJWAc1HANsgbwFgAoZc5OALmQGcwMRMBuUgX1NNElkRQFUADgBM4kYYVIVKNeoxZSKAIxogArgFsl0ViQ4lSwiAlxwoKGGpAIwwAPYhk5sGqgha6LDlwAKAJQ0ntggeLpGJmYWVjb2js6u7kKi4v40SWIQwrqGxqbmyJbWtg7IYHAA1hAeGMF4PgAegTXeAcgAbnbAWTkR+YUxJWWVtOkpjcijma0dXdkkIRpVgnzIAEIQMHbmk5JkFAD0+04QLm6ZyEoAnsi4wEpQZpeK5LgnMmjNIfgAvMen7kFvP5dNJXmBkKAYNBzBJfvE3NUvF9gZw9uRDsgEHhTEpgLcwNcAO7AMAACz+CUyz1KFSqgORcD8IIoQzpnzqkOhU10+lICyWKwAgjAeDtiGjkBj4SBzlcbncHlAnhKMQBhUlwJigTClUkoYAaQRbcHAWiYrbmGwXYxwNS0fWOMkocx4drQWixZB2GC600AGmpGMudjUyEJIdwEm0yGEnSYyAABgajVBwQRkABlOyLACS4Gg8CQyDYBSg2eQAHJaNmIABaW73R4V5gJgMqo6aiRO5BqEQZCTcAsrcNqSPIDVtFDd2hwRbIfl+uh2XUoCD1QS3BAkwMd2gezAgRbgMMRiT0PH4ZZ75A+OBmteCYziPzIABUndfNwyUB79ohIB3c183qMAzUJUlgAQclzAARzUYB8m7QQy0fVMiVPShcGra1fzgJRXjDElSRDMBAI0OxhGAGBILEWJqTBd5JlhCkESY4FJSOc9cHwO99xCfCIHot5OSgGFkDhE4EhGPsUiZVFpAxLFuLwvESSJIiWJlYRqVZRFal8RlmXIXT6Q5EAoVE7kdNpaTkkyW85IlXS2JEmFHP0IA">playground</a>)<sup class="footnote-reference"><a href="#variance-in-discriminating">7</a></sup></p>
</li>
</ul>
<div class="footnote-definition" id="nit-on-comparability"><sup class="footnote-definition-label">6</sup>
<p>Strictly speaking, one value may stop being comparable to another value in this scenario. However, this is both a rare edge case and fits under the standard rule where changes which simply let users delete now-defunct code are allowed.</p>
</div>
<div class="footnote-definition" id="variance-in-discriminating"><sup class="footnote-definition-label">7</sup>
<p>Mostly, anyway—see <a href="0730-semver-for-ts.html#higher-order-type-operations">Appendix C: On Variance in TypeScript – Higher-order type operations</a> below for a discussion of how the <code>in</code> operator (or similar operations discriminating between unions) makes this cause breakage in some cases. These are rare enough, and easily-enough solved, that the rule remains workable.</p>
</div>
<h5 id="functions-1"><a class="header" href="#functions-1">Functions</a></h5>
<p>For functions which return or accept user-constructible types, the rules specified for <a href="0730-semver-for-ts.html#interfaces-type-aliases-and-classes-1">Non-breaking Changes: Interfaces, Type Aliases, and Classes</a> hold. Otherwise, a change to a function declaration is <em>not</em> breaking when:</p>
<ul>
<li>
<p>a function (including a class method or constructor) <em>accepts a less specific (&quot;wider&quot;) type</em>, for example if it previously accepted only a <code>boolean</code> but now accepts <code>boolean | undefined</code>—since all existing user code will continue working and type-checking (<a href="https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEs9Iw00rac9gAUgQTQegBGGhqcyNCIAJR6AG4a8IHhcg7RsfGJqCnUdIygAOrjksiBBcUlZRVVDLX1dsgtbZ3dvf2gAD6gpbHOSFtDoKPjk9MKYEJYoPQNLE5FkckguAA6I7IOpUBrNHCYewDSag3KQ6Gw+FnZxcCQouTrWIoQJQmowk6NM6I5GTImbUmYynNXGcfHhIA">playground</a>)</p>
</li>
<li>
<p>a function (including a class method) which <em>returns a more specific (&quot;narrower&quot;) type</em>, for example if it previously returned <code>number | undefined</code> and now always returns <code>number</code>—since all user code will continue working and type-checking (<a href="https://www.typescriptlang.org/play?#code/PTAEEkFsEMHMEsB2BTUALZAnVAXN0dQ9UAiRaSZAZwAdoBjZE0BnAV2gBtOBPUAKzZVC2GtirJEOKkQwAoEKCoVU8SDQD2mHAC5QAAzWbtoAN6hYyHADUubVAF9QAM0wbIoAORV3yALTQACaBGoieANz6cnKByPSc0Nig5JS0DKgA8pjwCOScZnKgRS5siPQ48KEWVrac9gAUAJR6wtmIsKAAPsls3OFyDtGx8YmoKdR0jKAAcoluAO7IgQXFJWUVVZY2dshNLThtsP2DCmBCWKD0GrFyzqXllYjo0IiBnMgAStS9OPUAbjt9ocuj1uM0epAAEYXUyFYrYdiYJ4AurIAD8ADp3u08KA0WjQAAGY7RfCvd5fKg-epZHJILgYra1BqNRr9MlvT7fTi-WaYBZLRk1HZNNlyIA">playground</a>)</p>
</li>
<li>
<p>a function (including a class constructor or method) makes a previously-required argument optional—since all existing user code will continue to work with it (<a href="https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAc4A3XZAZwAooAuecjGLVAcwBp4AjO1ZAW04gYASjrEcWYAG4AUKEiwEKdNjzxkBYFAwhg1OgyasOnAPw9+gkWInSZMiCAzwo8ALyESZKgHICODG0cHw4ARgAmYVlHZ053dU1tXUo-AKCQ+AiooA">playground</a>)</p>
</li>
<li>
<p>changing a function from an arrow function declaration to <code>function</code> declaration, since it allows the caller to use <code>bind</code> or <code>call</code> meaningfully where they could not before. (Note that at the time of authoring, current TypeScript version 4.3, such a change introduces parameter bivariance. This is not breaking, but may be undesirable.)</p>
</li>
</ul>
<h4 id="bug-fixes"><a class="header" href="#bug-fixes">Bug fixes</a></h4>
<p>As with runtime code, types may have bugs. We define a ‘bug' here as a mismatch between types and runtime code. That is: if the types allow code which will cause a runtime type error, or if they forbid code which is allowed at runtime, the types are buggy. Types may be buggy by being inappropriately <em>wider</em> or <em>narrower</em> than runtime.</p>
<p>For example (noting that this list is illustrative, not exhaustive):</p>
<ul>
<li>
<p>If a function is typed as accepting <code>any</code> but actually requires a <code>string</code>, this will cause an error at runtime, and is a bug.</p>
</li>
<li>
<p>If a function is typed as returning <code>string | number</code> but is intended to return only <code>string</code>, this is a bug. Note that this is distinct from the runtime behavior: a package author may intentionally specify the type as wider than the current implementation with the expectation of future changes. This will not cause an error at runtime, since consumers must &quot;narrow&quot; the type to use it, and narrowing the type would not even be a breaking change.</p>
</li>
<li>
<p>If an interface is defined as having a property which is <em>not</em> part of the public API of the runtime object, or if an interface is defined as <em>missing</em> a property which the public API of the runtime object does have, this is a bug.</p>
</li>
</ul>
<p>As with runtime bugs, authors are free to fix type bugs in a patch release. As with runtime code, this may break consumers who were relying on the buggy behavior. However, as with runtime bugs, this is well-understood to be part of the sociotechnical contract of semantic versioning.</p>
<p>In practice, this suggests two key considerations around type bugs:</p>
<ol>
<li>
<p>It is essential that types be well-tested! See discussion below under <a href="0730-semver-for-ts.html#tooling"><strong>Tooling</strong></a>.</p>
</li>
<li>
<p>If a given type bug has existed for long enough, an author may choose to treat it as <a href="https://twitter.com/wycats/status/918644693759488005">&quot;intimate API&quot;</a> and change the <em>runtime</em> behavior to match the types rather than vice versa.</p>
</li>
</ol>
<h3 id="compiler-considerations"><a class="header" href="#compiler-considerations">Compiler considerations</a></h3>
<p>To reiterate, Semantic Versioning is a matter of adherence to a specified contract. This is particularly important when dealing with transitive or peer dependencies, especially at the level of ecosystem dependencies—including Node versions, browsers, compilers, and frameworks (such as Ember, React, Vue, Svelte, etc.). Accordingly, the specification of breaking changes as described below is further defined in terms of the TypeScript compiler support version adopted by any given package as well as specific settings.</p>
<h5 id="supported-compiler-versions"><a class="header" href="#supported-compiler-versions">Supported compiler versions</a></h5>
<p>Conforming packages must adopt and clearly specify one of two support policies: <em>simple majors</em> or <em>rolling support windows</em>.</p>
<h6 id="simple-majors"><a class="header" href="#simple-majors">Simple majors</a></h6>
<p>In “simple majors” pattern, dropping a previously-supported TypeScript version constitutes a breaking change, because it has the same kind of impact on users of the package as dropping support for a previously-supported version of Node: they must upgrade a <em>different</em> dependency to guarantee their code continues to work. Thus, whenever dropping a previously-supported TypeScript release, packages using “simple majors” should publish a new major version.</p>
<p>However, bug fix/patch releases to TypeScript (as described above under <a href="0730-semver-for-ts.html#bug-fixes">Bug fixes</a>) qualify for bug fix releases for packages using the “simple majors” policy. For example, if a package initially publishes support for TypeScript 4.5.0, but a critical bug is discovered and fixed in 4.5.1, the package may drop support for 4.5.0 without a major release. Dropping support for a bad version does not require publishing a new release, only documenting the change.</p>
<p>In this case, packages should generally couple dropping support for previously-supported TypeScript versions with dropping support for other ecosystem-level dependencies, such as previously-supported Node.js LTS versions, Ember LTS releases, React major versions, etc. (This is not a requirement for conformance, but makes for a generally healthier ecosystem.)</p>
<p>This pattern is recommended for “normal” packages, where major versions do not themselves have ecosystem-wide implications. For example, a package like <a href="https://true-myth.js.org">True Myth</a> (maintained by the primary author of this RFC) is small and not presently foundational to any broader ecosystem. It is safely using the “simple majors” approach today for both Node and TypeScript versions.</p>
<h6 id="rolling-support-windows"><a class="header" href="#rolling-support-windows">Rolling support windows</a></h6>
<p>The “rolling support windows” policy decouples compiler version support from major breaking changes, by specifying a rolling window of supported versions. For example, Ember and Ember CLI <a href="https://github.com/ember-cli/ember-cli/blob/master/docs/node-support.md">specify</a> that any change landing on <code>master</code> must work on the <a href="https://nodejs.org/en/about/releases/">Current, Active LTS, and Maintenance LTS Node versions</a> at the time the change lands, and that when the Node Working Group drops support for an LTS, Ember and Ember CLI do so as well <em>without a breaking change</em>. This allows the CLI to use new Node features as part of its public API over time, rather than being fixed at the set of features available at the time of the latest release of the CLI (e.g. Node 8 for the Ember CLI 3.x series).</p>
<p>Following this pattern, core ecosystem components (hypothetically including examples such <code>ember-source</code>, <code>react</code>, <code>@vue/cli</code>, etc.) could adopt a similar policy for supported TypeScript compiler versions, allowing the component to adopt new TypeScript features which impact the published types (e.g. in type emit, type system features such as conditional types, etc.) rather than being coupled to the features available at the time of release. Conforming projects which adopt this may choose any rolling support window they choose, except that if they have an LTS release schedule, upgrading to a new LTS shall not require upgrading to a new version of TypeScript.</p>
<p>Bug fix/patch releases to TypeScript (as described above under <a href="0730-semver-for-ts.html#bug-fixes">Bug fixes</a>) qualify for bug fix releases for packages using the “rolling support windows” policy. For example, if a package initially publishes support for TypeScript 4.5.0, but a critical bug is discovered and fixed in 4.5.1, the package may drop support for 4.5.0 without a major release. Dropping support for a bad version does not require publishing a new release, only documenting the change.</p>
<h5 id="strictness"><a class="header" href="#strictness">Strictness</a></h5>
<p>Type-checking in TypeScript behaves differently under different “strictness” settings, and the compiler adds more strictness settings over time. Changes to types which are not breaking under looser compiler settings may be breaking under stricter compiler settings.</p>
<p>For example: a package with <code>strictNullChecks: false</code> could make a function return type nullable without the compiler reporting it within the package or the package’s type tests. However, as described above, this is a breaking change for consumers which have <code>strictNullChecks: true</code>. (By contrast, a <em>consumer</em> may disable strictness settings safely: code which type-checks under a stricter setting also type-checks under a less strict setting.) Likewise, with <code>noUncheckedIndexedAccess: false</code>, an author could change a type <code>SomeObj</code> from <code>{ a: string }</code> to <code>{ [key: string]: string }</code> and accessing <code>someObj.a.length</code> would now error.</p>
<p>Accordingly, conforming packages must use <code>strict: true</code> in their compiler settings. Additionally, communities may define further strictness settings to which they commit to conform which include “pedantic” strictness settings like <code>noUncheckedIndexedAccess</code>. For example, the Ember community might commit to a set of <em>additional</em> strictness flags it supports for its own types for any LTS release, published in Ember’s own TypeScript documentation.</p>
<p><strong>Note:</strong> While the TypeScript compiler may include new strictness flags under <code>strict: true</code> in any release, this is simply a special case of TypeScript’s policy on breaking changes.</p>
<h5 id="module-interop"><a class="header" href="#module-interop">Module interop</a></h5>
<p>The two flags <code>esModuleInterop</code> and <code>allowSyntheticDefaultImports</code> smooth the interoperation between ES Modules and CommonJS, AMD, and UMD modules for <em>emit</em> from TypeScript and <em>type resolution</em> by TypeScript respectively. The options are viral: enabling them in a package requires all downstream consumers to enable them as well (even if this is not desirable for whatever reasons). The reasons for this are details of how CommonJS and ES Modules interoperate for bundlers (Webpack, Parcel, etc.), and are beyond the scope of this document.</p>
<p>Here, it is enough to note that changing from <code>esModuleInterop: true</code> to <code>esModuleInterop: false</code> on a package which emits <em>is a breaking change</em>:</p>
<ul>
<li>with <code>esModuleInterop: true</code>: <a href="https://www.typescriptlang.org/play?target=7#code/CYUwxgNghgTiAEBbA9sArhBByAzsxIAtGgA44AucUihEAlgEYywCeW8A3gLABQ8-8MMgB2FeADNkyAFzwAFAEp4AXgB88CjDrCA5gG5eA+CAAeJZDHIqJUgzwC+vXqEiwEKdJnhZELWo2YYNk5DATpEc0sbZAkYfG88AmIyShBqfyZWLDtQ-lNIqyFRK18AFQALbR1Zbj4jAUkZeHIWEhBkcWi7eoEGWFlFFXVhNEQGEBhugUcHIA">playground</a></li>
<li>with <code>esModuleInterop: false</code>: <a href="https://www.typescriptlang.org/play?esModuleInterop=false&amp;target=7#code/CYUwxgNghgTiAEBbA9sArhBByAzsxIAtGgA44AucUihEAlgEYywCeW8A3gLABQ8-8MMgB2FeADNkyAFzwAFAEp4AXgB88CjDrCA5gG5eA+CAAeJZDHIqJUgzwC+vXqEiwEKdJnhZELWo2YYNk5DATpEc0sbZAkYfG88AmIyShBqfyZWLDtQ-lNIqyFRK18AFQALbR1Zbj4jAUkZeHIWEhBkcWi7eoEGWFlFFXVhNEQGEBhugUcHIA">playground</a></li>
</ul>
<p>Accordingly, library authors should set both <code>allowSyntheticDefaultImports</code> and <code>esModuleInterop</code> to <code>false</code>. This allows consumers to opt into these semantics, but does not <em>require</em> them to do so. Consumers can always safely use alternative import syntaxes (including falling back to <code>require()</code> and <code>import()</code>), or can enable these flags and opt into this behavior themselves.</p>
<p>(If the Node ecosystem migrates fully to ES modules over the next few years, this problem will be substantially mitigated.)</p>
<h3 id="conformance"><a class="header" href="#conformance">Conformance</a></h3>
<p>To conform to this standard, a package must:</p>
<ul>
<li>link to the final published version of this specification</li>
<li>specify the compiler support policy</li>
<li>specify the currently-supported versions of TypeScript</li>
<li>specify the definition of “public API” used by the library (e.g. “only documented types” vs. “all published types” etc.)</li>
<li>author and publish its types with <code>strict: true</code> and <code>noUncheckedIndexedAccess: true</code> in its compiler configuration</li>
</ul>
<h2 id="how-we-teach-this-145"><a class="header" href="#how-we-teach-this-145">How we teach this</a></h2>
<p>If these recommendations are adopted, the <a href="0730-semver-for-ts.html#detailed-design"><strong>Detailed Design</strong></a> section shall be published to a dedicated, standalone repository to ease linking to it (including by TypeScript packages beyond the Ember ecosystem, if they find it useful, as we hope they will!).</p>
<p>When any Ember package begins publishing types, it shall follow the rules specified in <a href="0730-semver-for-ts.html#conformance"><strong>Conformance</strong></a>. In the case of Ember, Ember CLI, and Ember Data, the link to the published spec shall be added alongside the existing links to the Node SemVer support policies. Additionally, Ember should publish a table showing supported versions in the same format as the Node version support table.</p>
<p>Other official Ember packages which publish types must publish their supported TypeScript versions and compiler version policy, but may do so in whatever form is appropriate for the package, for example badges in the README linking to the published specification text and to CI.</p>
<h2 id="drawbacks-162"><a class="header" href="#drawbacks-162">Drawbacks</a></h2>
<ul>
<li>
<p>The definition of breaking changes above, while precise, may prove difficult to maintain without investment in specific supporting tooling to identify and mitigate breakage (which this RFC does not require, though see <a href="0730-semver-for-ts.html#appendix-b-tooling"><strong>Appendix B: Tooling</strong></a> for some recommendations).</p>
</li>
<li>
<p>Providing the “rolling support window” option means that consumers still have to deal with some potentially-breaking changes to supported TypeScript versions during a single major version of a package. While this allows more flexibility for authors of packages which publish types, it does decrease the strength of the stability guarantees for those types.</p>
</li>
<li>
<p>Adopting <em>any</em> policy constricts the options available to packages which publish types.</p>
</li>
</ul>
<h2 id="alternatives-164"><a class="header" href="#alternatives-164">Alternatives</a></h2>
<h3 id="no-policy"><a class="header" href="#no-policy">No policy</a></h3>
<p>Currently, no frameworks and few packages in the broader TypeScript ecosystem have any specific TypeScript support policy. Instead, they just roughly track the latest TypeScript version and expect downstream consumers of the types to absorb the changes. This strategy <em>could</em> work if libraries were honest about the SemVer implications of this and cut major releases any time a new TypeScript version resulted in breaking changes. Notably, the Ember TypeScript ecosystem has largely operated in this mode to date, and it has worked all right so far—though not without some challenges.</p>
<p>However, there are three major problems with this approach.</p>
<ul>
<li>
<p>First, it does not scale well. While many packages are using TypeScript today, as the community of TypeScript users grows and especially as it increasingly includes packages used extensively throughout the community (e.g. frameworks or core libraries), the cost of breaking changes grows in an unbounded fashion, with all of that cost being borne by the consumers of those changes, and worst of all <em>there is no signal about these breaking changes</em>.</p>
</li>
<li>
<p>Second, and closely related, the more central a package is to the ecosystem, the worse the impact is—especially when combined with any attempts to enforce “Highlander” rules for web bundling (e.g. Ember CLI will only resolve a single major version of an Ember package). Without a strategy for specifying breaking changes and therefore opportunities to mitigate them, core packages could easily end up fragmenting the ecosystem.</p>
</li>
<li>
<p>Third, in the absence of a specific policy, each package ends up developing its own <em>ad hoc</em> support policy. Many parts of the TypeScript ecosystem would benefit from adopting a shared solution and improving stability—preferring to avoid churn and risk through policies and definitions such as those outlined in this RFC. Accordingly, a policy which aligns TypeScript support with existing community norms around supported versions would make TypeScript adoption more palatable both at the community level in general and specifically to large/enterprise engineering organizations with a lower appetite for risk.</p>
</li>
</ul>
<h3 id="decouple-typescript-support-from-lts-cycles"><a class="header" href="#decouple-typescript-support-from-lts-cycles">Decouple TypeScript support from LTS cycles</a></h3>
<p>The “rolling support window” policy could be decoupled from LTS requirements. Similarly, the “simple majors” policy could drop the recommendation to combine dropping Node versions, TypeScript versions, and other LTS packages. This would simplify the rule for adopting packages. However, it comes with the previously mentioned challenges when multiple major versions of a package exist in a given ecosystem. While a strategy for resolving those challenges at the ecosystem level would be nice, it is far beyond the scope of <em>this</em> RFC and indeed is a general challenge for package-rich ecosystems like Node’s.</p>
<h2 id="unresolved-questions-106"><a class="header" href="#unresolved-questions-106">Unresolved questions</a></h2>
<ul>
<li>
<p>What policy should this RFC adopt for compiler settings which behave in both lint-like and strictness-checking-like ways, but which cannot cause type breakage for consumers, such as <code>noUncheckedIndexAccess</code>?</p>
<p>The semantics of this check is that it effectively exposes <code>| undefined</code> in more places, but authors of types cannot construct a type which <em>avoids</em> emitting <code>T | undefined</code> if the consumer enables <code>noUncheckedIndexAccess</code> and <code>strictNullChecks</code>. That is: if an author publishes <code>function foo(): Array&lt;string&gt;</code> <em>or</em> <code>function foo(): Array&lt;string | undefined&gt;</code>, then <em>whether or not</em> the author has <code>noUncheckedIndexedAccess</code> enabled, the semantics are the same for downstream consumers, and is dependent on <em>their</em> setting. The only safety improvement would be to publish types as <code>SafeArray&lt;string&gt;</code> where:</p>
<pre><code class="language-ts">type SafeArray&lt;T&gt; = Array&lt;T | undefined&gt;;
</code></pre>
</li>
<li>
<p>Are there any type system edge cases not covered by this policy?</p>
</li>
<li>
<p>Are there any compiler version change scenarios not covered by this policy?</p>
</li>
<li>
<p>Is the recommended compiler version support policy appropriate? There are other options available, like Typed Ember's current commitment to support the latest two (<i>N−1</i>) versions in the types. (In practice, the Typed Ember team did not bump most of the Ember types' minimum version from TypeScript 2.8 until the release of TypeScript 3.9, at which time they bumped minimum supported TypeScript version to 3.7.)</p>
</li>
<li>
<p>How should transitive dependencies be expected to be handled? Should package authors be expected to absorb any upstream differences in SemVer handling?</p>
</li>
</ul>
<h2 id="appendices"><a class="header" href="#appendices">Appendices</a></h2>
<p>These sections are non-normative.</p>
<h3 id="appendix-a-existing-implementations"><a class="header" href="#appendix-a-existing-implementations">Appendix A: Existing Implementations</a></h3>
<p>The recommendations in this RFC have been fully implemented in <a href="https://github.com/ember-modifier/ember-modifier"><code>ember-modifier</code></a>, <a href="https://true-myth.js.org">True Myth</a>, and <a href="https://github.com/chriskrycho/ember-async-data">ember-async-data</a>; and partly implemented in <a href="https://github.com/machty/ember-concurrency"><code>ember-concurrency</code></a>. <code>ember-modifier</code>, <code>ember-async-data</code>, and <code>true-myth</code> all publish types generated from implementation code. <code>ember-concurrency</code> supplies a standalone, hand-written type definition file. Since adopting this policy in these implementations (beginning in early summer 2020), no known issues have emerged, and the experience of implementing earlier versions of the recommendations from this RFC were incorporated into the final form of this RFC.</p>
<p>There are, to the best of our knowledge, no other major adopters of these recommendations, and no similar such recommendations in the TypeScript ecosystem at large.</p>
<h3 id="appendix-b-tooling"><a class="header" href="#appendix-b-tooling">Appendix B: Tooling</a></h3>
<p>To successfully adopt this RFC’s recommendations, package authors need to be able to <em>detect</em> breaking changes (whether from their own changes or from TypeScript itself) and to <em>mitigate</em> them. Package <em>consumers</em> need to know the support policy for the library.</p>
<h4 id="documenting-supported-versions-and-policy"><a class="header" href="#documenting-supported-versions-and-policy">Documenting supported versions and policy</a></h4>
<p>In line with ecosystem norms, badges linking to CI status</p>
<ul>
<li>
<p>An example supported versions badge (which could link to CI config):</p>
<p><img src="https://img.shields.io/badge/TS%20Versions-4.1%20%7C%204.2%20%7C%20next-blue" alt="supported TypeScript versions: 4.1, 4.2 and next" /></p>
</li>
<li>
<p>Example support policy badges (which could link to the published recommendation from this RFC):</p>
<p><img src="https://img.shields.io/badge/TS%20Support-Rolling%20Window-purple" alt="TypeScript support policy" /> <img src="https://img.shields.io/badge/TS%20Support-Simple%20Majors-purple" alt="TypeScript support policy" /></p>
</li>
</ul>
<h4 id="detect-breaking-changes-in-types"><a class="header" href="#detect-breaking-changes-in-types">Detect breaking changes in types</a></h4>
<p>As with runtime code, it is essential to prevent unintentional changes to the API of types supplied by a package. We can accomplish this using <em>type tests</em>: tests which assert that the types exposed by the public API of the package are stable.</p>
<p>Package authors publishing types can use whatever tools they find easiest to use and integrate, within the constraint that the tools must be capable of catching all the kinds of breaking changes outlined above. Additionally, they must be able to run against multiple supported versions of TypeScript, so that users can detect and account for breaking changes in TypeScript.</p>
<p>The current options include:</p>
<ul>
<li>
<p><a href="https://github.com/microsoft/dtslint"><code>dtslint</code></a>—used to support the DefinitelyTyped ecosystem, so it is well-tested and fairly robust. It uses the TypeScript compiler API directly, and is maintained by the TypeScript team directly. Accordingly, it is very unlikely to stop working against the versions of TypeScript it supports. However, there are several significant downsides as well:</p>
<ul>
<li>
<p>The tool checks against string representations of types, which makes it relatively fragile: it can be disturbed by changes to the representation of a type, even when those changes would not impact type-checking.</p>
</li>
<li>
<p>As its name suggests, it is currently powered by <a href="https://github.com/palantir/tslint">tslint</a>, which is deprecated in favor of <a href="https://github.com/eslint/eslint">eslint</a>. While there is <a href="https://github.com/microsoft/dtslint/issues/300">initial interest</a> in migrating to eslint, there is no active effort to accomplish this task.</p>
</li>
<li>
<p>The developer experience of authoring assertions with dtslint is poor, with no editor-powered feedback or indication of whether you've actually written the test correctly at all. For example, if a user types <code>ExpectType</code> instead of <code>$ExpectType</code>, the assertion will simply be silently ignored.</p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/SamVerschueren/tsd"><code>tsd</code></a>—a full solution for testing types by writing <code>.test-d.ts</code> files with a small family of assertions and using the <code>tsd</code> command to validate all <code>.test-d.ts</code> files. Authoring has robust editor integration, since the type assertions are normal TS imports, and the type assertions are specific enough to catch all the kinds of breakage identified above. It is implemented using the TS compiler version directly, which makes its assertions fairly robust. Risks and downsides:</p>
<ul>
<li>
<p>The tool uses a patched version of the TypeScript compiler, which increases the risk of errors and the risk that at some points it will simply be unable to support a new version of TypeScript.</p>
</li>
<li>
<p>Because the assertions are implemented as type definitions, the library is subject to the same risk of compiler breakage as the types it is testing.</p>
</li>
<li>
<p><strong>BLOCKER:</strong>  currently only supports a single version of TypeScript at a time. While the author is <a href="https://github.com/SamVerschueren/tsd/issues/47">interested</a> in supporting multiple versions, it is not currently possible.</p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/mmkal/ts/tree/master/packages/expect-type#readme"><code>expect-type</code></a>—a library with a variety of type assertions, inspired by Jest's matchers but tailored to types and with no runtime implementation. Like <code>tsd</code>, it is implemented as a series of function types which can be imported, and accordingly it has excellent editor integration. However, unlike <code>tsd</code>, it does <em>not</em> use the compiler API. Instead,  It is robust enough to catch all the varieties of breaking type changes. The risks with expect-type are:</p>
<ul>
<li>
<p>It currently has a single maintainer, and relatively few users.</p>
</li>
<li>
<p>It is relatively young, having been created only about a year ago, and therefore having existed for only 5 TypeScript releases. While its track record is good so far, there is not yet evidence of how it would deal with serious breaking changes like those introduced in TypeScript 3.5.</p>
</li>
<li>
<p>Because the assertions are implemented as type definitions, the library is subject to the same risk of compiler breakage as the types it is testing.</p>
</li>
</ul>
</li>
</ul>
<p>At present, <code>expect-type</code> seems to be the best option, and several libraries both in the Ember ecosystem and elsewhere in the TS community are already using <code>expect-type</code> successfully (see <a href="0730-semver-for-ts.html#appendix-a-existing-implementations"><strong>Appendix A</strong></a> above). However, for the purposes of <em>this</em> RFC, we do not make a specific recommendation about which library to use. The tradeoffs above are offered to help authors make an informed choice in this space.</p>
<p>Users should add one of these libraries and generate a set of tests corresponding to their public API. These tests should be written is such a way as to test the imported API as consumers will consume the library. For example, type tests should not import using relative paths, but using the absolute paths at which the types should resolve, just as consumers would. </p>
<p>These type tests should be specific and precise. It is important, for example, to guarantee that an API element never <em>accidentally</em> becomes <code>any</code>, thereby making many things allowable which should not be in the case of function arguments, and &quot;infecting&quot; the caller's code by eliminating type safety on the result in the case of function return values. For example, the <code>expect-type</code> library's <code>.toEqualTypeOf</code> assertion is robust against precisely this scenario; package authors are also encouraged to use its <code>.not</code> modifier and <code>.toBeAny()</code> method where appropriate to prevent this failure mode.</p>
<p>To be safe, these tests should be placed in a directory which does not emit runtime code—either colocated with the library's runtime tests, or in a dedicated <code>type-tests</code> directory. Additionally, type tests should <em>never</em> export any code.</p>
<p>In addition to <em>writing</em> these tests, package authors should make sure to run the tests (as appropriate to the testing tool chosen) in their continuous integration configuration, so that any changes made to the library are validated to make sure the API has not been changed accidentally.</p>
<p>Further, just as packages are encouraged to test against a matrix of Ember versions which includes the current stable release, the currently active Ember LTS release, and the canary and beta releases, packages should test the types against all versions of TypeScript supported by the package (see the <a href="0730-semver-for-ts.html#policy-for-supported-typescript-versions">suggested policy for version support</a> below) as well as the upcoming version (the <code>next</code> tag for the <code>typescript</code> package on npm).</p>
<p>Type tests can run as normal <a href="https://github.com/ember-cli/ember-try">ember-try</a> variations or similar CI. Typed Ember will document a conventional setup for ember-try configurations, so that correct integration into CI setups will be straightforward for package authors.</p>
<h4 id="mitigate-breaking-changes"><a class="header" href="#mitigate-breaking-changes">Mitigate breaking changes</a></h4>
<p>It is insufficient merely to be <em>aware</em> of breaking changes. It is also important to <em>mitigate</em> them, to minimize churn and breakage for package users.</p>
<h5 id="avoiding-user-constructibility"><a class="header" href="#avoiding-user-constructibility">Avoiding user constructibility</a></h5>
<p>For types where it is useful to publish an interface for end users, but where users should not construct the interface themselves, authors have a number of options (noting that this list is not exhaustive):</p>
<ul>
<li>
<p>The type can simply be documented as non-user-constructible. This is the easiest, and allows an escape hatch for scenarios like testing, where users will recognize that if the public interface changes, they will necessarily need to update their test mocks to match. This can further be mitigated by providing a sanctioned test helper to construct test versions of the types.</p>
</li>
<li>
<p>Export a nominal-like version of the type, using <code>export type</code> with a class with a private field:</p>
<details>
<summary>implementation of a nominal-like class in TS</summary>
<pre><code class="language-ts">class Person {
  // 1.  The private brand means this cannot be constructed other than the
  //     class's own constructor, because other approaches cannot add the
  //     private field. Even if you write a class yourself with a matching
  //     private field, TS will treat them as distinct.
  // 2.  Using `declare` means this marker has no runtime over head: it will
  //     not be emitted by TypeScript or Babel.
  // 3.  Because the class itself is declared but not exported, the only way
  //     to construct it is using the function exported lower in the module.
  declare private __brand: void;

  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

// This exports only the *type* side of `Person`, not the *value* side, so
// users can neither call `new Person(...)` nor subclass it. Per the note
// above, they also cannot *implement* their own version of `Person`, since
// they do not have the ability to add the private field.
export type { Person };

// This is the controlled way of building a person: users can only get a
// `Person` by calling this function, even though they can *name* the type
// by doing `import type { Person} from '...';`.
export function buildPerson(name: string, age: number): Person {
  return new Person(name, age);
}
</code></pre>
</details>
<p>This <em>cannot</em> be constructed outside the module. Note that it may be useful to provide corresponding test helpers for scenarios like this, since users cannot safely provide their own mocks.</p>
</li>
<li>
<p>Document that users can create their own local aliases for these types, while <em>not</em> exporting the types in a public way. This has one of the same upsides as the use of the classes with a private brand: the type is not constructible other than via the module. It also shares the upside of being able to create your own instance of it for test code. However, it has ergonomic downsides, requiring the use of the <code>ReturnType</code> utility class and requiring all consumers to generate that utility type for themselves.</p>
</li>
<li>
<p>Provide sanctioned mocks for testing purposes. Since these live alongside, and therefore can be tested with and kept in sync with the package they are mocks for, they can also be provided with the exact same versioning stability guarantees as the package code itself.</p>
</li>
</ul>
<p>Each of these leaves this module in control of the construction of <code>Person</code>s, which allows more flexibility for evolving the API, since non-user-constructible types are subject to fewer breaking change constraints than user-constructible types. Whichever is chosen for a given type, authors should document it clearly.</p>
<h5 id="updating-types-to-maintain-compatibility"><a class="header" href="#updating-types-to-maintain-compatibility">Updating types to maintain compatibility</a></h5>
<p>Sometimes, it is possible when TypeScript makes a breaking change to update the types so they are backwards compatible, without impacting consumers at all. For example, <a href="https://github.com/microsoft/TypeScript/issues/33272">TypeScript 3.5</a> changed the default resolution of an otherwise-unspecified generic type from the empty object <code>{}</code> to <code>unknown</code>. This change was an improvement in the robustness of the type system, but it meant that any code which happened to rely on the previous behavior broke.</p>
<p>This example from <a href="https://github.com/microsoft/TypeScript/issues/33272">Google's writeup on the TS 3.5 changes</a> illustrates the point. Given this function:</p>
<pre><code class="language-ts">function dontCarePromise() {
  return new Promise((resolve) =&gt; {
    resolve();
  });
}
</code></pre>
<p>In TypeScript versions before 3.5, the return type of this function was inferred to be <code>Promise&lt;{}&gt;</code>. From 3.5 forward, it became <code>Promise&lt;unknown&gt;</code>. If a user ever wrote down this type somewhere, like so:</p>
<pre><code class="language-ts">const myPromise: Promise&lt;{}&gt; = dontCarePromise();
</code></pre>
<p>…then it broke on TS 3.5, with the compiler reporting an error (<a href="https://www.typescriptlang.org/play/?ts=3.5.1&amp;ssl=1&amp;ssc=27&amp;pln=1&amp;pc=40#code/GYVwdgxgLglg9mABAEwVAwgQwE4FMAK2cAtjAM64AUAlIgN4CwAUIonlCNkmLgO6KES5KpTxk4AGwBuuWgF4AfPWatWYyTJoBuFYgC+1HUz3NmEBGSiJiAT0GkKALgFEHuADx09SuSjRY8e2FtIA">playground</a>):</p>
<blockquote>
<p>Type 'Promise<unknown>' is not assignable to type 'Promise&lt;{}&gt;'.
Type 'unknown' is not assignable to type '{}'.</p>
</blockquote>
<p>This change could be mitigated by supplying a default type argument equal to the original value (<a href="https://www.typescriptlang.org/play/?ts=3.5.1#code/GYVwdgxgLglg9mABAEwVAwgQwE4FMAK2cAtjAM64AUAlAFyKEnm4A8A3gL4B8ibAsAChEiPFBDYkYXAHcGRUhUqU8ZOABsAbrmqIAvD35DhI3Ks1VqAbkHCOVwR0GCICMlETEAnowW56P5nZuPRQ0LDwAxSsgA">playground</a>):</p>
<pre><code class="language-ts">function dontCarePromise(): Promise&lt;{}&gt; {
  return new Promise((resolve) =&gt; {
    resolve();
  });
}
</code></pre>
<p>This is a totally-backwards compatible bugfix-style change, and should be released in a bugfix/point release. Users can then just upgrade to the bugfix release <em>before</em> upgrading their own TypeScript version—and will experience <em>zero</em> impact from the breaking TypeScript change.</p>
<p>Later, the default type argument <code>Promise&lt;{}&gt;</code> could be dropped and defaulted to the new value for a major release of the library when desired (per the policy <a href="0730-semver-for-ts.html#policy-for-supported-type-script-versions">outlined below</a>, giving it the new semantics. (Also see <a href="0730-semver-for-ts.html#opt-in-future-types"><b>Opt-in future types</b></a> below for a means to allow users to <em>opt in</em> to these changes before the major version.)</p>
<h5 id="downleveling-types"><a class="header" href="#downleveling-types">&quot;Downleveling&quot; types</a></h5>
<p>When a new version of TypeScript includes a backwards-incompatible change to <em>emitted type definitions</em>, as they did in <a href="https://github.com/microsoft/TypeScript/pull/33470">3.7</a>, the strategy of changing the types directly may not work. However, it is still possible to provide backwards-compatible types, using the combination of <a href="https://github.com/sandersn/downlevel-dts">downlevel-dts</a> and <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#version-selection-with-typesversions">typesVersions</a>. (In some cases, this may also require some manual tweaking of types, but this should be rare for most packages.)</p>
<ul>
<li>
<p>The <a href="https://github.com/sandersn/downlevel-dts"><code>downlevel-dts</code></a> tool allows you to take a <code>.d.ts</code> file which is not valid for an earlier version of TypeScript (e.g. the changes to class field emit mentioned in <a href="0730-semver-for-ts.html#breaking-changes"><b>Breaking Changes</b></a>), and emit a version which <em>is</em> compatible with that version. It supports targeting all TypeScript versions later than 3.4.</p>
</li>
<li>
<p>TypeScript supports using the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html#version-selection-with-typesversions"><code>typesVersions</code></a> key in a <code>package.json</code> file to specify a specific set of type definitions (which may consist of one or more <code>.d.ts</code> files) which correspond to a specific TypeScript version.</p>
</li>
</ul>
<p>The recommended flow would be as follows:</p>
<ol>
<li>
<p>Add <code>downlevel-dts</code>, <code>npm-run-all</code>, and <code>rimraf</code>  to your dev dependencies:</p>
<pre><code class="language-sh">npm install --save-dev downlevel-dts npm-run-all rimraf
</code></pre>
<p>or </p>
<pre><code class="language-sh">yarn add --dev downlevel-dts npm-run-all rimraf
</code></pre>
</li>
<li>
<p>Create a script to downlevel the types to all supported TypeScript versions:</p>
<pre><code class="language-sh"># scripts/downlevel.sh
npm run downlevel-dts . --to 3.7 ts3.7
npm run downlevel-dts . --to 3.8 ts3.8
npm run downlevel-dts . --to 3.9 ts3.9
npm run downlevel-dts . --to 4.0 ts4.0
</code></pre>
</li>
<li>
<p>Update the <code>scripts</code> key in <code>package.json</code>  to generate downleveled types generated by running <code>downlevel-dts</code> on the output from <code>tsc</code>, and to clean up the results after publication. For example, using <code>ember-cli-typescript</code>’s tooling:</p>
<pre><code class="language-diff">{
  &quot;scripts&quot;: {
-   &quot;prepublishOnly&quot;: &quot;ember ts:precompile&quot;,
+   &quot;prepublish:types&quot;: &quot;ember ts:precompile&quot;,
+   &quot;prepublish:downlevel&quot;: &quot;./scripts/downlevel.sh&quot;,
+   &quot;prepublishOnly&quot;: &quot;run-s prepublish:types prepublish:downlevel&quot;,
-   &quot;postpublish&quot;: &quot;ember ts:clean&quot;,
+   &quot;clean:ts&quot;: &quot;ember ts:clean&quot;,
+   &quot;clean:downlevel&quot;: &quot;rimraf ./ts3.7 ./ts3.8 ./ts3.9 ./ts4.0&quot;,
+   &quot;clean&quot;: &quot;npm-run-all --aggregate-output --parallel clean:*&quot;,
+   &quot;postpublish&quot;: &quot;npm run clean&quot;,
  }
}
</code></pre>
</li>
<li>
<p>Add a <code>typesVersions</code> key to <code>package.json</code>, with the following contents:</p>
<pre><code class="language-json">{
  &quot;types&quot;: &quot;index.d.ts&quot;,
  &quot;typesVersions&quot;: {
    &quot;3.7&quot;: { &quot;*&quot;: [&quot;ts3.7/*&quot;] },
    &quot;3.8&quot;: { &quot;*&quot;: [&quot;ts3.8/*&quot;] },
    &quot;3.9&quot;: { &quot;*&quot;: [&quot;ts3.9/*&quot;] },
    &quot;4.0&quot;: { &quot;*&quot;: [&quot;ts4.0/*&quot;] },
  }
}
</code></pre>
<p>This will tell TypeScript how to use the types generated by this process. Note that we explicitly include the <code>types</code> key so TypeScript will fall back to the defaults for 3.9 and higher.</p>
</li>
<li>
<p>If using the <code>files</code> key in <code>package.json</code> to specify files to include (unusual but not impossible for TypeScript-authored packages), add each of the output directories (<code>ts3.7</code>, <code>ts3.8</code>, <code>ts3.9</code>, <code>ts4.0</code>) to the list of entries.</p>
</li>
</ol>
<p>Now consumers using older versions of TypeScript will be buffered from the breaking changes in type definition emit.</p>
<p>If the community adopts this practice broadly we will want to invest in tooling to automate support for managing dependencies, downleveling, and type tests. However, the core constraints of this RFC do not depend on such tooling existing, and the exact requirements of those tools will emerge organically as the community begins implementing this RFC's recommendations.</p>
<h5 id="opt-in-future-types"><a class="header" href="#opt-in-future-types">Opt-in future types</a></h5>
<p>In the case of significant breaking changes to <em>only</em> the types—whether because the package author wants to make a change, or because of TypeScript version changes—packages may supply <em>future</em> types, which users may opt into <em>before</em> the library ships a breaking change. (We expect this use case will be rare, but important.)</p>
<p>In this case, package authors will need to <em>hand-author</em> the types for the future version of the types, and supply them at a specific location which users can then import directly in their <code>types/my-app.d.ts</code> file—which will override the normal types location, while not requiring the user to modify the <code>paths</code> key in their <code>tsconfig.json</code>.</p>
<p>This approach is a variant on <a href="0730-semver-for-ts.html#updating-types-to-maintain-compatibility"><strong>Updating types to maintain compatibility</strong></a>. Using that same example, a package author who wanted to provide opt-in future types instead (or in addition) would follow this procedure:</p>
<ol>
<li>
<p>Backwards-compatibly <em>fix</em> the types by explicitly setting the return type on <code>dontCarePromise</code>, just as discussed above:</p>
<pre><code class="language-diff">- function dontCarePromise() {
+ function dontCarePromise(): Promise&lt;{}&gt; {
</code></pre>
</li>
<li>
<p>Create a new directory, named something like <code>ts3.5</code>.</p>
</li>
<li>
<p>Generate the type definition files for the package by running <code>ember ts:precompile</code>.</p>
</li>
<li>
<p>Manually move the generated type definition files into <code>ts3.5</code>.</p>
</li>
<li>
<p>In the <code>ts3.5</code> directory, either <em>remove</em> or <em>change</em> the explicit return type, so that the default from TypeScript 3.5 is restored:</p>
<pre><code class="language-diff">- function dontCarePromise(): Promise&lt;{}&gt; {
+ function dontCarePromise(): Promise&lt;unknown&gt; {
</code></pre>
</li>
<li>
<p>Wrap each module file in the generated definition with a <code>declare module</code> specifying the <em>canonical</em> module name. For example, if our <code>dontCarePromise</code> definition were from a module at <code>my-library/sub-package</code>, we would have the following structure:</p>
<pre><code>my-library/
  ts3.5/
    index.d.ts
    sub-package.d.ts
</code></pre>
<p>—and the contents of <code>sub-package.d.ts</code> would be:</p>
<pre><code class="language-ts">declare module 'my-library/sub-package' {
  export function dontCarePromise(): Promise&lt;unknown&gt;;
}
</code></pre>
</li>
<li>
<p>Explicitly include each such sub-module in the import graph available from <code>ts3.5/index.d.ts</code>—either via direct import in that file or via imports in the other modules. (Note that these imports can simply be of the form <code>import 'some-module';</code>, rather than importing specific types or values from the modules.)</p>
</li>
<li>
<p>Commit the <code>ts3.5</code> directory, since it now needs to be maintained manually until a breaking change of the library is released which opts into the new behavior.</p>
</li>
<li>
<p>Cut a release which includes the new fixes. With that release:</p>
<ul>
<li>
<p>Inform users about the incoming breaking change.</p>
</li>
<li>
<p>Tell users to add <code>import 'fancy-package/ts3.5';</code> to the entry point of their package or a similar location. For example, in Ember, users would add the import to the top of their <code>types/my-app.d.ts</code> or <code>types/my-package.d.ts</code> file (which are generated by <code>ember-cli-typescript</code>).</p>
</li>
</ul>
</li>
<li>
<p>At a later point, cut a breaking change which opts into the TypeScript 3.5 behavior.</p>
<ul>
<li>
<p>Remove the <code>ts3.5</code> directory from the repository.</p>
</li>
<li>
<p>Note in the release notes that users who did not previously opt into the changes will need to do so now.</p>
</li>
<li>
<p>Note in the release notes that users who <em>did</em> previously opt into the changes should remove the <code>import 'fancy-package/ts3.5';</code> import from <code>types/my-app.d.ts</code> or <code>types/my-package.d.ts</code>.</p>
</li>
</ul>
</li>
</ol>
<h4 id="matching-exports-to-public-api"><a class="header" href="#matching-exports-to-public-api">Matching exports to public API</a></h4>
<p>Another optional tool for managing public API is <a href="https://api-extractor.com">API Extractor</a>. Authors can mark their exports as <code>@public</code>, <code>@protected</code>, <code>@private</code>, <code>@alpha</code>, <code>@beta</code>, etc. and use the tool to generate type definitions accordingly. For example, for mitigating a future TypeScript version change, or experimenting on a new API, authors can use <code>@alpha</code> or <code>@beta</code> and use <code>typesVersions</code> to publish to a dedicated directory. Similarly, authors can make an export public for use through the package or even a set of related packages in a moinorepo, but mark it as <code>@private</code> and use API Extractor to generate types which exclude it when publishing to npm.</p>
<h3 id="appendix-c-on-variance-in-typescript"><a class="header" href="#appendix-c-on-variance-in-typescript">Appendix C: On Variance in TypeScript</a></h3>
<p>As alluded to in <a href="0730-semver-for-ts.html#variance">Changes to Types: Variance</a>, there are several complicating factors for the discussion of variance in TypeScript:</p>
<ul>
<li>the combination of inference with pervasive mutability</li>
<li>structural typing</li>
<li>what I will describe here as <em>higher-order type operations</em></li>
</ul>
<h4 id="inference-and-pervasive-mutability"><a class="header" href="#inference-and-pervasive-mutability">Inference and pervasive mutability</a></h4>
<p>For example, by the classic rules, <code>Array&lt;T&gt;</code> should be invariant: it is a read-write (i.e. mutable) type. That means that a very simple change, otherwise apparently safe for consumers, can break it. Start with a library function which returns <code>string | number</code>:</p>
<pre><code class="language-ts">declare function example(): string | number;
</code></pre>
<p>A consumer might use this code in the construction of an array, and then having leaned on inference, push both <code>string</code>s and <code>number</code>s into it:</p>
<pre><code class="language-ts">const myArray = [example()]; // Array&lt;string | number&gt;
myArray.push(123);           // ✅
myArray.push(&quot;hello&quot;);       // ✅
</code></pre>
<p>The author of the library might later update <code>example</code> to return only <code>string</code>s:</p>
<pre><code class="language-ts">declare function example(): string;
</code></pre>
<p>This would be safe under the rule for write-only types, which is the intuition underlying many of the definitions below—but for our array example, it is <em>not</em> safe: <code>.push()</code>-ing in a <code>number</code> is now illegal.</p>
<pre><code class="language-ts">const myArray = [example()]; // Array&lt;string&gt;
myArray.push(123);           // ❌ number not assignable to string
myArray.push(&quot;hello&quot;);       // ✅
</code></pre>
<p>What's more, we don't need an object like an array to trigger this kind of behavior. Using a <code>let</code> binding instead of a <code>const</code> binding will produce exactly the same issue. Under the original definition of <code>example</code>, this would be perfectly legal:</p>
<pre><code class="language-ts">let value = example(); // string | number
value = 123;           // ✅
value = &quot;hello&quot;;       // ✅
</code></pre>
<p>But it stops being valid as soon as <code>example</code> is narrowed:</p>
<pre><code class="language-ts">let value = example(); // string
value = 123;           // ❌ number not assignable to string
value = &quot;hello&quot;;       // ✅
</code></pre>
<p>While lint guidelines preferring <code>const</code> may <em>help</em> mitigate the latter, they are controversial<sup class="footnote-reference"><a href="#const-controversy">8</a></sup> and they do not and cannot help with the <code>Array</code> example or others like it. Nor is it feasible to require a “functional” immutable-update style, given that JavaScript lacks robust immutable data structures, which would allow for recommending that approach.</p>
<p>In this case, cautious users may work around this by explicitly annotating their types to match the return type of the:</p>
<pre><code class="language-ts">const myArray: Array&lt;string | number&gt; = [example()];
let value: string | number = example();
</code></pre>
<p>We do not expect this to be common, however: the cost of this is much higher than the cost of changing one's code in the cases where it may be broken.</p>
<div class="footnote-definition" id="const-controversy"><sup class="footnote-definition-label">8</sup>
<p>Rightly so, in my opinion!</p>
</div>
<h4 id="structural-typing"><a class="header" href="#structural-typing">Structural typing</a></h4>
<p>Most programming languages where programmers must deal with variance have <em>nominal</em> type systems, and and subtyping relations can be straightforwardly specified in terms of the relations between the types—particular via subclassing (as in Java, C++, and C#) or between interfaces (as in Rust’s <code>trait</code> system). In TypeScript, however, subtyping relationships include both subclassing and interface-based subtypes and also <em>structural subtyping</em>.</p>
<p>Given types <code>A</code> and <code>B</code>, <code>B</code> is a subtype of <code>A</code> for the purposes of assignability (e.g. in function calls) when it is a <em>superset</em> of <code>A</code>. Most simply:</p>
<pre><code class="language-ts">type A = {
  a: number;
}

type B = {
  a: number;
  b: string;
}

type C = {
  a?: number;
  b: string;
}

declare function takesA(a: A): void;

declare let a: A;
declare let b: B;
declare let c: C;
takesA(a); // ✅
takesA(b); // ✅
takesA(c); // ❌
</code></pre>
<p>Notice that this is <em>unlike</em> the dynamics in nominal type systems, where unless <code>B</code> explicitly declared a relationship to <code>A</code> (e.g. <code>class B extends A { }</code> or <code>interface B : A { }</code> or similar), the two are unrelated, regardless of their structural relationships. Similar dynamics play out for other kinds of types.</p>
<h4 id="higher-order-type-operations"><a class="header" href="#higher-order-type-operations">Higher-order type operations</a></h4>
<p>The second factor which makes dealing with TypeScript types difficult is its support for <em>type-level mutation</em>. Consider the type of <code>x</code> at points 1–4 in the following simple, but relatively idiomatic, TypeScript function definition:</p>
<pre><code class="language-ts">function describe(x: string | number | undefined) {
  switch (typeof x) {                 // 1
    case 'string':
      return `x is the string ${x}`;  // 2
    case 'number':
      return `x is the number ${x}`;  // 3
    default:
      return `x is &quot;undefined&quot;`;      // 4
  }
}
</code></pre>
<ol>
<li>The type is <code>string | number | undefined</code>.</li>
<li>The type is <code>string</code>.</li>
<li>The type is <code>number</code>.</li>
<li>The type is <code>undefined</code>.</li>
</ol>
<p>While this quickly becomes second-nature to TypeScript developers and we don’t give it a second thought, it’s important to take a step back and consider what is actually happening here: the type of <code>x</code> is a variable—a <em>type-level</em> variable—whose value changes over the body of the function. That is, it is a <em>mutable type-level variable</em>. While it is possible to construct values whose types in TypeScript are <em>not</em> mutable (e.g. with <code>never</code> or a boolean or numeric literal value), <em>most</em> values constructed in an ordinary TypeScript program have mutable types.</p>
<p>What’s more, this combines with TypeScript’s use of structural typing and inference mean that many cases which would intuitively be “safe” to make changes around can in fact create compiler errors. For example, consider a function which today returns <code>string | number</code>:</p>
<pre><code class="language-ts">declare function a(): string | number;
</code></pre>
<p>Using this function to create a value <code>x</code> will give us the type <code>x: string | number</code> as we would expect. Then we might <em>narrow</em> the type later:</p>
<pre><code class="language-ts">const x = a(); // string | number
const y = typeof x === 'string' ? x.length : x;  // ✅
</code></pre>
<p>In general by the rules of variance, we would expect that narrowing the return type of <code>a</code> to always return <code>number</code> would be fine. This is in a “write-only” position, and so we would expect that we should allow contravariance: a narrower type is permissible. From a runtime perspective, that is true, because all existing code will continue to work (even if there are some unnecessary branches). However, TypeScript will produce a type error here, because the type of <code>x</code> no longer includes <code>string</code>, and so the <code>typeof x === 'string'</code> check can be statically known to be.</p>
<p>Practically speaking, this is an annoyance rather than a meaningful breaking change. It can, however, result in significant work across a code base! What is more, it is not possible to work around this merely with an explicit type definition today. Naïvely, we might expect explicit type declarations to allow us to dodge this problem in places we actually care about it:</p>
<pre><code class="language-ts">const x: string | number = a();
const y = typeof x === 'string' ? x.length : x;  // ❌
</code></pre>
<p>In practice, however, TypeScript today (up through 4.5) will first check that the type returned by <code>a()</code> is a subtype of the declared type of <code>x</code>, and then if <code>a()</code> returns a <em>narrower</em> type than that declared for <code>x</code>, it will actually set <code>x</code>'s type to the narrower type returned by <code>a()</code> instead of the explicitly-declared type. Thus, a user who wishes to avoid this problem must <em>everywhere</em> annotate their code with explicit type casts:</p>
<pre><code class="language-ts">const x = a() as string | number;
const y = typeof x === 'string' ? x.length : x;
</code></pre>
<p>This is very annoying; worse, it is also easy to break. TypeScript today silently allows an unsafe cast here, which can in turn produce runtime errors:</p>
<pre><code class="language-ts">declare function a(): string | number;
const x = a() as string; // 👎🏼
const y = x.length;  // possible runtime error!
</code></pre>
<p>Thus, for the thoroughly pragmatic reason that no one would ever want to write these kinds of casts and the more principled reason that these kinds of casts as readily undermine as support the kinds of type safety TypeScript aims to provide <em>and</em> the versioning guarantees this RFC aims to provide, we simply acknowledge that from a practical standpoint, the pervasiveness of type-level mutation makes it impossible to provide a definition of breaking changes which forbids the introduction of compiler errors by even apparently-safe changes.</p>
<p>The problem runs the other direction, too: while this example shows now-extraneous code which can be deleted, the same underlying issue can also require <em>adding</em> code, e.g. when adding a field to a library type which was previously being used to discriminate two objects.</p>
<p>Given this starting code:</p>
<pre><code class="language-ts">// provided by the library
type LibType = {
  a: boolean;
}

type MyType = {
  b: string;
}

function takesEither(obj: LibType | MyType) {
  if ('b' in obj) {
      // narrowed obj to `MyType`
    console.log(obj.b.substring(0));
  }
}
</code></pre>
<p>If the library adds a field <code>b</code> which is of any type but <code>string</code>—</p>
<pre><code class="language-ts">type LibType = {
  a: boolean;
  b: number;
}
</code></pre>
<p>—then we have a type error in <code>takesEither()</code> because the <code>in</code> operator no longer successfully discriminates between <code>LibType</code> and <code>MyType</code>:</p>
<pre><code class="language-ts">function takesEither(obj: LibType | MyType) {
  if ('b' in obj) {
    // `obj` is still `LibType | MyType` so `b` is now `string | number`
    console.log(obj.b.substring(0)); // ❌
  }
}
</code></pre>
<p>The compiler will dutifully report:</p>
<blockquote>
<p>Property 'substring' does not exist on type 'string | number'.</p>
</blockquote>
<p>In sum, just as pervasive runtime mutability and inference made it impossible to fully specify an approach which prevents users from experiencing breaking changes.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-04-23
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): ember-data
RFC PR: https://github.com/emberjs/rfcs/pull/738</h2>
<h1 id="emberdata--deprecate-model-reopen"><a class="header" href="#emberdata--deprecate-model-reopen">EmberData | Deprecate Model Reopen</a></h1>
<h2 id="summary-178"><a class="header" href="#summary-178">Summary</a></h2>
<p>Deprecates using <code>reopen</code> to alter clases extending <code>@ember-data/model</code>.</p>
<h2 id="motivation-178"><a class="header" href="#motivation-178">Motivation</a></h2>
<p><code>reopen</code> restricts the ability of EmberData to design better primitives that maintain
compatibility with <code>@ember-data/model</code>, and is a footgun that leads to confusing incorrect
states for users that utilize it.</p>
<h2 id="detailed-design-145"><a class="header" href="#detailed-design-145">Detailed design</a></h2>
<p>The static <code>reopen</code> method on <code>Model</code> will be overwritten to provide a deprecation which
once resolved or after the deprecation lifecycle completes will result in <code>reopen</code> throwing
an error when used in dev and silently no-oping in production. This deprecation will target
<code>5.0</code> and not be <code>enabled</code> sooner than <code>4.1</code> though it may come available before that.</p>
<h2 id="how-we-teach-this-146"><a class="header" href="#how-we-teach-this-146">How we teach this</a></h2>
<p>This is best taught through a deprecation guide. Users using <code>reopen</code> to test multiple
configurations in their test suite should instead extend and register a new model each time.</p>
<p>Users using <code>reopen</code> to modify a class immediately after creating it should also refactor
to <code>extend</code> instead.</p>
<p>Users using <code>reopen</code> to modify a class dynamically at runtime should refactor to either register
new model types or (better) utilize a megamorphic solution such as ember-m3 to achieve their needs.</p>
<p>In all cases, using <code>reopen</code> after a class instance for a record has already been created has <em>always</em>
resulted in at least minor and potentially major errors in application state.</p>
<h2 id="drawbacks-163"><a class="header" href="#drawbacks-163">Drawbacks</a></h2>
<p>Test suites, including EmberData's own, that make use of <code>reopen</code> are often &quot;order dependent&quot; in order
for the test suite to pass, and refactoring them can sometimes be a difficult exercise in determining
which tests had modified the class to achieve the model shape needed by another test. In general though
the drawbacks here are small given the widespread adoption of class syntax and growing adoption of octane
paradigms.</p>
<h2 id="alternatives-165"><a class="header" href="#alternatives-165">Alternatives</a></h2>
<ul>
<li>
<p>Don't deprecate <code>reopen</code> and wait to replace <code>@ember-data/model</code> in it's entirety. This alternative would prevent us from providing custom decorators not extending from <code>computed</code> and limit potential build tools allowing users to optimize existing usage of EmberData.</p>
</li>
<li>
<p>Wait for <code>ember</code> to deprecate <code>reopen</code>. Because we cannot build custom decorators and support <code>reopen</code> without asking for <code>ember</code> to make available to use private APIs I do not think we should wait for Ember here. This RFC does not preclude or force Ember to deprecate reopen more broadly.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-04-23
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): ember-data
RFC PR: https://github.com/emberjs/rfcs/pull/739</h2>
<h1 id="emberdata--deprecate-non-strict-relationships"><a class="header" href="#emberdata--deprecate-non-strict-relationships">EmberData | Deprecate Non Strict Relationships</a></h1>
<h2 id="summary-179"><a class="header" href="#summary-179">Summary</a></h2>
<p>Deprecates various shorthands for defining a <code>belongsTo</code> or <code>hasMany</code> 
relationship that create ambiguity, cause expensive runtime lookups, 
or hinder static analysis.</p>
<h2 id="motivation-179"><a class="header" href="#motivation-179">Motivation</a></h2>
<p>Deprecating these shorthands allows us to provide better tooling, remove the bulky
and expensive code necessary to determine the outcomes of these shorthands at 
runtime, and in the process clarify and simplify relationship behaviors in the
documentation. Further, it allows us to align our own internal usage of 
&quot;relationship meta&quot; with the API put forward in <a href="https://github.com/emberjs/rfcs/blob/master/text/0487-custom-model-classes.md#exposing-schema-information">RFC#487 Custom Model Classes</a>.</p>
<h2 id="detailed-design-146"><a class="header" href="#detailed-design-146">Detailed design</a></h2>
<p>Three shorthands are proposed to be deprecated, with the deprecation targeting <code>5.0</code>
and being <code>enabled</code> no-sooner than <code>4.1</code>. It may be <code>available</code> sooner.</p>
<ul>
<li>Deprecates the relationship shorthand that does not provide the related type as the first argument.</li>
</ul>
<p>This deprecation is related to deprecating <code>non-strict</code> types as it requires us to
normalize the property name into a type string in a manner which may not be correct.</p>
<p><em>Before</em></p>
<pre><code class="language-./before.js">import Model, { belongsTo, hasMany } from '@ember-data/model';

export default class Comment extends Model {
  @belongsTo()
  author;

  @hasMany({ async: true, inverse: null })
  likes;
}
</code></pre>
<p><em>After</em></p>
<pre><code class="language-./after.js">import Model, { belongsTo, hasMany } from '@ember-data/model';

export default class Comment extends Model {
  @belongsTo('author')
  author;
  @hasMany('like', { async: true, inverse: null })
  likes;
}
</code></pre>
<ul>
<li>Deprecates not explicitly setting the relationship inverse property (or <code>null</code>).</li>
</ul>
<p>The current default when not specified is to attempt to find a property on the
related model that either explicity or implicitly points back, resolving to <code>null</code>
if no such relationship is found and erring if more than one potential inverse was
discovered.</p>
<p><em>Before</em></p>
<pre><code class="language-./before.js">import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user')
  author;

  @hasMany('like')
  likes;
}

class User extends Model {
  @hasMany('comment')
  comments;
}

class Like extends Model {
  @belongsTo('user')
  author;
}
</code></pre>
<p><em>After</em></p>
<pre><code class="language-./after.js">import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user', { inverse: 'comments' })
  author;

  @hasMany('like', { inverse: null })
  likes;
}

class User extends Model {
  @hasMany('comment', { inverse: 'author' })
  comments;
}

class Like extends Model {
  @belongsTo('user', { inverse: null })
  author;
}
</code></pre>
<ul>
<li>Deprecates not explicitly setting <code>async</code> to <code>true|false</code>.</li>
</ul>
<p>The current default when not specified is <code>true</code>.</p>
<p><em>Before</em></p>
<pre><code class="language-./before.js">import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user', { inverse: 'comments' })
  author;

  @hasMany('like', { inverse: null })
  likes;
}

class User extends Model {
  @hasMany('comment', { inverse: 'author' })
  comments;
}

class Like extends Model {
  @belongsTo('user', { inverse: null })
  author;
}
</code></pre>
<p><em>After</em></p>
<pre><code class="language-./after.js">import Model, { belongsTo, hasMany } from '@ember-data/model';

class Comment extends Model {
  @belongsTo('user', { async: true, inverse: 'comments' })
  author;

  @hasMany('like', { async: true, inverse: null })
  likes;
}

class User extends Model {
  @hasMany('comment', { async: true, inverse: 'author' })
  comments;
}

class Like extends Model {
  @belongsTo('user', { async: true, inverse: null })
  author;
}
</code></pre>
<h2 id="codemod-4"><a class="header" href="#codemod-4">Codemod</a></h2>
<p>A codemod should be provided. This codemod would analyze a user's relationships
and wherever possible format the provided options with the now deprecated missing
information. Note: For the related type and inverse property name when 
mixin-based polymorphism is present codemods may not be practical.</p>
<h2 id="how-we-teach-this-147"><a class="header" href="#how-we-teach-this-147">How we teach this</a></h2>
<p>Generally these changes improve our ability to document and explain relationship
APIs as confusing behaviors (such as undefined <code>async</code> defaulting to <code>true</code>) and
inverse determination are no longer magical resolutions but explicit declarations.
API documentation will be updated and any examples in the guides should be as well.</p>
<h2 id="drawbacks-164"><a class="header" href="#drawbacks-164">Drawbacks</a></h2>
<p>Some churn, but via codemod we can make this quick and seamless for most apps.</p>
<h2 id="alternatives-166"><a class="header" href="#alternatives-166">Alternatives</a></h2>
<p>Provide new decorators that replace these. Leave these alone. While we may introduce
new decorator primitives in the near future, iterating on the existing decorators to
make them stricter in largely painless ways will allow more teams to migrate to a full
replacement in the future with greater ease.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-04-23
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): ember-data
RFC PR: https://github.com/emberjs/rfcs/pull/742</h2>
<h1 id="emberdata--deprecate-helper-functions"><a class="header" href="#emberdata--deprecate-helper-functions">EmberData | Deprecate Helper Functions</a></h1>
<h2 id="summary-180"><a class="header" href="#summary-180">Summary</a></h2>
<p>Deprecates the exported util functions <code>errorsHashToArray</code> <code>errorsArrayToHash</code>
and <code>normalizeModelName</code> that were recommended for deprecation by the <a href="https://github.com/emberjs/rfcs/blob/master/text/0395-ember-data-packages.md">RFC#395 packages</a></p>
<h2 id="motivation-180"><a class="header" href="#motivation-180">Motivation</a></h2>
<p>These utils are a legacy remnant of when parts of the codebase were shared with each other
by a <code>DS</code> global. Over time their utility has shrunk and today they no longer align with
the direction of <a href="https://github.com/emberjs/rfcs/blob/master/text/0465-record-data-errors.md">error management</a> or <a href="https://github.com/emberjs/rfcs/pull/740">type constraints</a>.</p>
<h2 id="detailed-design-147"><a class="header" href="#detailed-design-147">Detailed design</a></h2>
<p>Users would receive a build-time deprecation when importing these methods using the paths
specified in <a href="https://github.com/emberjs/rfcs/blob/master/text/0395-ember-data-packages.md">RFC#395 packages</a>.</p>
<p>They would receive a run-time deprecation when using these methods via the <code>DS</code> global.</p>
<p>The deprecation would target <code>5.0</code> and would become <code>enabled</code> no-sooner than <code>4.1</code> (although
it may be made <code>available</code> before then).</p>
<p>Users making use of these methods can trivially copy them into their own codebase to continue
using them, though we recommend refactoring to a more direct conversion into the expected errors
format. For refactoring <code>normalizeModelName</code> we also recommend following <a href="https://github.com/emberjs/rfcs/pull/740">RFC#740 Deprecate Non-Strict Types</a>.</p>
<h2 id="how-we-teach-this-148"><a class="header" href="#how-we-teach-this-148">How we teach this</a></h2>
<p>Generally usage has not been widely observed and these are not methods commonly shown in 
examples or docs. We should make sure to audit for usages and remove them if they exist.</p>
<h2 id="drawbacks-165"><a class="header" href="#drawbacks-165">Drawbacks</a></h2>
<p>A trivial amount of churn for users that did utilize them.</p>
<h2 id="alternatives-167"><a class="header" href="#alternatives-167">Alternatives</a></h2>
<p>Leave them to waste away.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-05-13
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/748</h2>
<h2 id="summary-181"><a class="header" href="#summary-181">Summary <!-- omit in toc --></a></h2>
<p>In TypeScript, the <code>@glimmer/component</code> base class currently has a single <code>Args</code> type parameter. This parameter declares the names and types of the arguments the component expects to receive.</p>
<p>This RFC proposes a change to that type parameter to become <code>Signature</code>, capturing more complete information about how components can be used in a template, including their expected <strong>arguments</strong>, the <strong>blocks</strong> they accept, and what type of <strong>element(s)</strong> they apply any received attributes and modifiers to.</p>
<p>This RFC is based in large part on prior work by <a href="https://github.com/gossi">@gossi</a> and on learnings from <a href="https://github.com/typed-ember/glint">Glint</a>.</p>
<h3 id="outline-2"><a class="header" href="#outline-2">Outline <!-- omit in toc --></a></h3>
<ul>
<li><a href="0748-glimmer-component-signature.html#motivation">Motivation</a></li>
<li><a href="0748-glimmer-component-signature.html#detailed-design">Detailed design</a>
<ul>
<li><a href="0748-glimmer-component-signature.html#invokablecomponentsignature"><code>InvokableComponentSignature</code></a></li>
<li><a href="0748-glimmer-component-signature.html#glimmercomponentsignature"><code>GlimmerComponentSignature</code></a></li>
<li><a href="0748-glimmer-component-signature.html#updated-type-for-glimmer-component">Updated type for Glimmer <code>Component</code></a></li>
<li><a href="0748-glimmer-component-signature.html#example">Example</a></li>
<li><a href="0748-glimmer-component-signature.html#args"><code>Args</code></a></li>
<li><a href="0748-glimmer-component-signature.html#blocks"><code>Blocks</code></a></li>
<li><a href="0748-glimmer-component-signature.html#element"><code>Element</code></a>
<ul>
<li><a href="0748-glimmer-component-signature.html#components-with-multiple-or-varying-elements">Components With Multiple or Varying Elements</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="0748-glimmer-component-signature.html#how-we-teach-this">How we teach this</a>
<ul>
<li><a href="0748-glimmer-component-signature.html#documentation">Documentation</a></li>
<li><a href="0748-glimmer-component-signature.html#migration">Migration</a>
<ul>
<li><a href="0748-glimmer-component-signature.html#codemods">Codemods</a></li>
<li><a href="0748-glimmer-component-signature.html#deprecation-warningslinting">Deprecation Warnings/Linting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="0748-glimmer-component-signature.html#drawbacks">Drawbacks</a></li>
<li><a href="0748-glimmer-component-signature.html#alternatives">Alternatives</a>
<ul>
<li><a href="0748-glimmer-component-signature.html#additional-positional-type-parameters">Additional Positional Type Parameters</a></li>
<li><a href="0748-glimmer-component-signature.html#only-args">Only <code>Args</code></a></li>
<li><a href="0748-glimmer-component-signature.html#naming">Naming</a>
<ul>
<li><a href="0748-glimmer-component-signature.html#args-1"><code>Args</code></a></li>
<li><a href="0748-glimmer-component-signature.html#element-1"><code>Element</code></a></li>
<li><a href="0748-glimmer-component-signature.html#blocks-1"><code>Blocks</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="motivation-181"><a class="header" href="#motivation-181">Motivation</a></h2>
<p>When a developer goes to invoke a component in a template, there are a variety of questions about its interface they need to be able to answer in order to determine how to use it correctly.</p>
<ol>
<li>What arguments does this component accept?
<ul>
<li>Which arguments are required and which are optional?</li>
<li>What does each argument do?</li>
<li>What types of values am I expected to pass for a given argument?</li>
</ul>
</li>
<li>How can I nest content within this component?
<ul>
<li>Does it accept a default block? Named blocks?</li>
<li>In what context will my block content appear in the component's output?</li>
<li>For any blocks I write, what parameters does the component expose to them?</li>
</ul>
</li>
<li>In what ways can I treat this component like a regular HTML/SVG element?
<ul>
<li>Can I pass attributes to it?</li>
<li>If I apply a modifier, what kind(s) of DOM <code>Element</code> object will the modifier see?</li>
</ul>
</li>
</ol>
<p>In the Glimmer <code>Component</code> base class today, a TypeScript component author can answer the first bucket of questions above by defining an <code>Args</code> type for the component class. Using this structured documentation, developer tooling can surface information about a component's arguments to consumers without requiring them to go read either ad-hoc prose or the implementation itself to determine the component's intended usage.</p>
<p>For the second and third sets of questions, however, there is no such affordance for providing structured answers.</p>
<p>The goal of this change is to enable tooling to provide a more complete picture for developers of the ways in which Glimmer components can be used. The word &quot;tooling&quot; here is used in broad terms, including:</p>
<ul>
<li>API/design system documentation generators, like <a href="https://storybook.js.org/">Storybook</a> or <a href="https://github.com/hokulea/hokulea">Hokulea</a></li>
<li>Language servers that provide hover information, go-to-definition, etc. like <a href="https://www.typescriptlang.org/">TypeScript</a> or <a href="https://github.com/lifeart/ember-language-server">uELS</a></li>
<li>Template-aware static analysis and typechecking systems, like <a href="https://github.com/typed-ember/glint">Glint</a> or <a href="https://github.com/lifeart/els-addon-typed-templates"><code>els-addon-typed-templates</code></a></li>
</ul>
<h2 id="detailed-design-148"><a class="header" href="#detailed-design-148">Detailed design</a></h2>
<p>This RFC proposes two new TypeScript APIs:</p>
<ol>
<li>A fully general <code>InvokableComponentSignature</code> type which can capture <em>all</em> the relevant details of components in the Glimmer VM, with</li>
<li>A user-facing Glimmer Component <code>Signature</code> type that enables authors to answer the questions outlined above about their Glimmer components in a more concise and convenient way.</li>
</ol>
<p>Throughout, these new interfaces intentionally use <code>PascalCase</code> for names representing <em>types</em>, including types nested in interfaces:</p>
<ul>
<li>to match the general TypeScript ecosystem norm that types are named in <code>PascalCase</code></li>
<li>to thereby distinguish clearly between type- and value- names in contexts which might otherwise be ambiguous</li>
<li><em><strong>to enable adopting this in a backwards-compatible way with the existing Glimmer Component type definition</strong></em></li>
</ul>
<p>The third of these is the most critical, and much more strongly motivates the others.</p>
<p>These interfaces are <em>not</em> importable, because importing them does not give any value to consumers: use of <code>extends</code> does not add any constraints (because of the optional-ity discussed below).</p>
<h3 id="invokablecomponentsignature"><a class="header" href="#invokablecomponentsignature"><code>InvokableComponentSignature</code></a></h3>
<p>The base <code>InvokableComponentSignature</code> type is an intentionally-verbose form, which end users will not <em>normally</em> write, but it is legal to do so.</p>
<p>Two points to notice about the signature:</p>
<ol>
<li>All of the fields for what users author are optional. They are resolved into the appropriate <em>non</em>-optional representations by type machinery in Glint. For example, in a Glimmer component the <code>args</code> is never undefined; it is minimally an empty object.</li>
<li>This provides the foundation for further extensions of each of these as needed. For example, if we were to add support for named block params (in addition to today’s support for positional arguments), they could be added as a <code>Named</code> field in the interface, just like the <code>Positional</code> field present today.</li>
</ol>
<pre><code class="language-ts">// A base signature type which represents items which can be invoked with
// arguments, and could be reused for helpers, modifiers, etc.
interface InvokableSignature {
  Args?: {
    Named?: {
      [argName: string]: unknown;
    };
    Positional?: unknown[];
  };
}

interface InvokableComponentSignature extends InvokableSignature {
  // The `null` means &quot;this does not use ...attributes&quot;
  Element?: Element | null;
  Blocks?: {
    [blockName: string]: {
      Params?: {
        Positional?: unknown[];
      };
    }
  }
}

interface InvokableGlimmerComponentSignature extends InvokableComponentSignature {
  Args?: {
    Named?: {
      [argName: string]: unknown;
    };
    // empty tuple here means it does not allow *any* positional params
    Positional?: [];
  }
}
</code></pre>
<p>As suggested by this lattermost form, specific component implementations may also represent a <em>subset</em> of the full signature. Future component implementations may take advantage of this just as future extensions to the system may take advantage of the ability to add more information into the signature.</p>
<h3 id="glimmercomponentsignature"><a class="header" href="#glimmercomponentsignature"><code>GlimmerComponentSignature</code></a></h3>
<p>Since the fully-expanded form is quite verbose, we also provide a much smaller interface users can write, which we expand “under the hood” into the full signature as well as onto the class body for <code>args</code>. Users are <em>allowed</em> to supply the fully-expanded form; they just do not <em>have</em> to.</p>
<pre><code class="language-ts">interface GlimmerComponentSignature {
  Args?: {
    [argName: string]: unknown;
  };
  Blocks?: {
    [blockName: string]: unknown[];
  };
  Element?: Element | null;
}
</code></pre>
<p>As with the <code>InvokableComponentSignature</code>, the type that authors <em>must</em> write is simply empty: all the fields are optional. Once the type is attached to the component, it is resolved to the appropriate default value. For example, a component’s <code>args</code> property is <em>always</em> an object, but it may be empty. If <code>Args</code> is not supplied, it is defaulted the empty object. We cover the details of this defaulting behavior for each field below.</p>
<h3 id="updated-type-for-glimmer-component"><a class="header" href="#updated-type-for-glimmer-component">Updated type for Glimmer <code>Component</code></a></h3>
<p>With these signature types defined, we can update the type for the Glimmer <code>Component</code> class in a backwards-compatible way:</p>
<ul>
<li>adding support for the new expanded type signature</li>
<li>continuing to support all <em>current</em> uses of the type signature</li>
<li>dropping the <code>extends</code> constraint, which provides little-to-no actual constraining value</li>
</ul>
<p>Previously:</p>
<pre><code class="language-ts">declare class Component&lt;Args extends {} = {}&gt; {
  readonly args: Args;

  constructor(owner: Owner, args: Args);
}
</code></pre>
<p>Updated:</p>
<pre><code class="language-ts">declare class Component&lt;Signature&gt; {
  readonly args: ComponentArgs&lt;Signature&gt;;

  constructor(owner: Owner, args: ComponentArgs&lt;Signature&gt;);
}
</code></pre>
<p>Here, the <code>ComponentArgs</code> type will be a type utility which can resolve the named arguments to the component (the exact mechanics are an implementation detail, but you can see one possible design in <a href="https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgUwB5mQYxgFQJ4YDyAZnAL5zFQQhwDkaG2AtDAcnQNwBQ3AJlgA2AQyjI4mCADsAzvACi4NgC44AVynAAjmvEy8IAEYRBPNhjiKwbQoYBWWeAF5EcANpW2AXQD8qmFC65Dzc5uIA4sgwhFDygjLIADy2dgA0cADS6QBiwoKChsKYANYAfHAuGSioMMhSfDJwxch4EKQpcD5wKW4ZXnCqufmFJSFhcACCUADmMtnQiQDK5S7NraSL1bX1jQBEU7O7cAA+cLtxyCB1MEenuwBCghAlMkcA9G9wAJKNMAAWwEawjgMmA0ykwhgajEPm4cE6ZwOry2dQaTRabTgmw+cAAIhBkL8AY1QeDIdDxH9hAA3cQAAyRdLgAmIwCkyD4sPh8K6izc+xmr36aG2aKQADlhFdOaoIPZHJw4AAFCCgmDAaR5PzqKTFKQQADuUjc-QoOKm4n+LTgTyk0yp9TgeTEwj4eC53J5rkl0tUkWisXiST5AsOXnSdB9HLo6U8eBSjlKipVao1EMEfqiMTiCSW-KRu3D9BTwHVmsEMfcXnKZDhnoG3qlHNUIYLXmTqtLabyqhN5Dr8NUEqbfFUcYT2A7qfLvdNdaHcCjo6xU67M6rwV4bwAVNu4OFgLSpE6pHgnflDRyQX9oP9hI7iNBaJjgaSIVCxOkBDI1NNRI1SzgGAIDgUtGmINR8mqMB7wEPggPYOBtzeUJEPkdBYMWMF3wpRIcBWRA6wuK4pBgVRzkES5riOEVUUaNZMRwBEcH5YjqP6VQpEg0w6yRVQkXmKA8KTOtHmeYoZHIsSXhomo6PRdY4BwAcEQQFTPTcaTilA48GNIFiHieGSvC8VQDK0oVNKM4phTknYdT1Q1jS8dT6y6JASzLdMzP5CzCys8S53resfMM8TLK09tXNrT0xyUeN5UnbgyBCHEAAFpkEUArigN5JHAaRrjgABGAA6AAGbg2VqKBiCKcRCEEPhFkwG8TCRQj4UfCBVDkKA2WmHha24HFdmENR-mgAbKCfSEjghaVmFEWZmGkQQ8Cq0jkFq+qsRvWAHT4JFCCkdbOsmQUFxU7reoCAaeHhWthpxWkoGMBJ0kMCabWQGlpogb7GCyzBAM87tBE2mq6swcQl2O06zzU+E+PO+ElyHVybpBO67Qe7kYv7Z7Ple97xAWjklsFVaEbgAAKOl0Jg+osLJD9kCZGQb0g+DDHEYF9QgMA4GkIDiQASkh7bofEbJuPhs6kYu2YMc9MH1xNPG0ZHFX6yxvr7pUgmUqIyiSLIuAuPyPGLLi6wEocJLhsYRx8CIYhEkZzDsPJMRkialq2sEJFSlKWmxdK4D5B0PJXeQEhEll-J5bwUOxZ4Z3sFj+PPeZ722aWfa73qZOQ7DiOICjtQY-YePE6DwUTvW1P0-QF2a-dnPmrz3C4YbhHS-DyPo8ELP3brkuw5bphcHbj2MNz1ncPHvum9T8vK+rt2E7lleU8nrdPjGib9umx8oBAObmWQOrIPgQxrOFhHJZ2mG9tvQ6LMbxHROsyTUavm+ghzZuCuDIGQwhpjIFuv1O0UVHrJQPnAEmqpxAsnGkAuA99xKPzOvTTuLMcJiA5lzJqmC+YWwgILR+otAQS2qlLXaddP400VmxUinFuJ4xRsOX0lh4oThgKuLyPYqyKmNvCG2-80G3x1qrTswiMzuD1jjaYcD8Z1mNk7VumdZ74O7r7RYhcP6-y-gPdew9R7b3yMwpu+8M4zy3noxevsmEmP7mvIeVcR6z1ceFUx+8RqH3GpNGB0wZrn0vsgU2RU1obXoS-cQhj36wTYdEFhJsqLsLgAACRwAAWQADIAGF7zUmEDIVJQ1EHIISCgaJpEcFnjwfPLuzj2bXgBqQ3mToKFUJFv8Whz9pZwDrqkr+51JHjkSoI3il1Gy8KmQ7QRyp5Hg1nJueEqTVC5MKSUqQZSKn1JmVo6elinGEODEYlJRzTEeIrhYnx3Exn9zsdohxccO4tIIT7JIoybnuLLp4zeHyrGCGebYtOiCIL5DPJAMAkFIQcnSNCs6jBYJXjfD8umDMvn6PaZzTpPNyECyFv08WQzdryFengAZdp7gQKiedbhKl0auGUaEjZ3I1beXcKWS4HCjDbTUeIywRztn5OKaU8plSf7hVkQA9B5tFZyOnDytwZTBC6F6gYYwggXKeiNgg7g9izm4raR7altLpj0sgYIMxQLvGOMtQCOlDK7UBPGEUmgkB2SkSREsAiAkFjLDcJGEcdAor8CEKIcQmARBgLgF6gqvqYABvOi6PgsSnRzKDUJENYbpQRqNXG8pjRGrNTYJRFE9kk0+uuH7ZqrVKH11mOURWkD4DdTDv-MQH5jwDJkKVZag7up4yerwEtCbxTIANIsSt4haI1u9YVUiBdknF13m2usHaZoQG7cquAvboT9uJEOwUpVR0aOSkAA">this playground</a>). Users may pass any of:</p>
<ul>
<li>an arguments-only definition, as has been recommended up till now in the Glimmer Component v1 era</li>
<li>the <code>GlimmerComponentSignature</code> short-hand form</li>
<li>the expanded <code>InvokableGlimmerComponentSignature</code> form</li>
<li>the fully-expanded <code>InvokableComponentSignature</code> form</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>Given a component with this template:</p>
<pre><code class="language-hbs">&lt;div class=&quot;notice notice-{{@kind}}&quot; ...attributes&gt;
  {{yield this.dismiss}}
&lt;/div&gt;
</code></pre>
<p>A TypeScript backing class currently written like this:</p>
<pre><code class="language-ts">import Component from '@glimmer/component';

export interface NoticeArgs {
  /** The kind of message displayed in this notice. Defaults to `info`. */
  kind?: 'error' | 'warning' | 'info' | 'success';
}

export default class Notice extends Component&lt;NoticeArgs&gt; {
  // ...
}
</code></pre>
<p>Would instead, if fully typed, be written like this:</p>
<pre><code class="language-ts">import Component from '@glimmer/component';

export interface NoticeSignature {
  Element: HTMLDivElement;
  Args: {
    /** The kind of message displayed in this notice. Defaults to `info`. */
    kind?: 'error' | 'warning' | 'info' | 'success';
  };
  /**
   * Any default block content will be displayed in the body of the notice.
   * This block receives a single `dismiss` parameter, which is an action
   * that can be used to dismiss the notice.
   */
  Blocks: {
    default: [dismiss: () =&gt; void];
  };
}

export default class Notice extends Component&lt;NoticeSignature&gt; {
  // ...
}
</code></pre>
<p>By nesting the existing <code>Args</code> type under a top-level <em>signature</em> type, we create a place to provide additional type information for other aspects of a component's behavior. This, along with the fully-expanded/desugared form, is the key element of this design which enables future evolution of the signature, as including additional keys with new meaning won't be a breaking change.</p>
<h3 id="args-1"><a class="header" href="#args-1"><code>Args</code></a></h3>
<p>The <code>Args</code> signature member works exactly as the top-level <code>Args</code> type parameter does in <code>@glimmer/component@1.x</code> prior to this RFC. That is, it determines the type of <code>this.args</code> in the component backing class, as well as acting as an anchor for human-readable documentation for specific arguments.</p>
<p><strong>A signature with no <code>Args</code> indicates that its component does not accept any arguments. The type of the <code>args</code> field on a Glimmer component class is an empty object.</strong></p>
<h3 id="blocks"><a class="header" href="#blocks"><code>Blocks</code></a></h3>
<p>The <code>Blocks</code> member dictates what blocks a component accepts and specifies what parameters, if any, it provides to those blocks. All blocks must named explicitly.<sup class="footnote-reference"><a href="#blocks-sugar">1</a></sup> When the component only yields to the default block, simply name the <code>default</code> block:</p>
<pre><code class="language-ts">Blocks: {
  default: [name: string];
}
</code></pre>
<pre><code class="language-hbs">{{yield &quot;Tomster&quot;}}
</code></pre>
<p>When there are multiple blocks, each is named to indicate what parameters a component's named blocks provide:</p>
<pre><code class="language-ts">Blocks: {
  header: [];
  body: [item: T; index: number]
}
</code></pre>
<pre><code class="language-hbs">{{yield to=&quot;header&quot;}}

{{#each items as |item index|}}
  {{yield item index to=&quot;body&quot;}}
{{/each}}
</code></pre>
<p>This means that if a component also accepts both a default block <em>and</em> other named blocks, it can specify the default block by name (<code>default: [...]</code>) in its <code>Blocks</code> in exactly the same way a consumer of the component might use <code>&lt;:default&gt;</code> to pass a default block alongside named ones when invoking a component.</p>
<p><strong>A signature with no <code>Blocks</code> indicates that its component never yields to any blocks.</strong></p>
<p>The <a href="https://github.com/emberjs/rfcs/blob/master/text/0460-yieldable-named-blocks.md">yieldable named blocks RFC</a> and recent versions of the <a href="https://guides.emberjs.com/release/components/block-content/">Component guides</a> discuss blocks in some depth, but since named blocks in particular are relatively new to the community, brief definitions based on those in <a href="https://github.com/emberjs/rfcs/pull/678">RFC 678</a> are included here for clarity.</p>
<details>
  <summary>Blocks, Block Parameters and Yielding</summary>
<ul>
<li>
<p><strong>Block</strong></p>
<p>A block is a section of content that a template author provides to a component when invoking it. Many components accept a <em>default</em> block, and components invoked using curly braces may also accept an <em>else</em> block.</p>
<pre><code class="language-hbs">&lt;Modal&gt;
  This is a default block.
&lt;/Modal&gt;

{{#if-a-coin-flip-is-heads}}
  This is also a default block.
{{else}}
  This is an else block.
{{/if-a-coin-flip-is-heads}}
</code></pre>
<p>For angle-bracket components, the above example with an <em>implicit</em> default block could also be written with an <em>explicit</em> one:</p>
<pre><code class="language-hbs">&lt;Modal&gt;
  &lt;:default&gt;This is another default block.&lt;/:default&gt;
&lt;/Modal&gt;
</code></pre>
<p>This syntax, using <code>&lt;:identifier&gt;</code> to delimit block contents, allows authors to provide one or more <em>named blocks</em> to a component:</p>
<pre><code class="language-hbs">&lt;Modal&gt;
  &lt;:header&gt;
    This is the header block.
  &lt;/:header&gt;
  &lt;:body&gt;
    This is the body block.
  &lt;/:body&gt;
&lt;/Modal&gt;
</code></pre>
</li>
<li>
<p><strong>Block Parameters</strong></p>
<p>Blocks may also receive <em>parameters</em> from the component that they're provided to, using <code>as |identifier ...|</code> syntax.</p>
<p>For an implicit default block, the parameters are exposed from the top level component:</p>
<pre><code class="language-hbs">&lt;Modal as |close|&gt;
  &lt;button {{on &quot;click&quot; close}}&gt;Close&lt;/button&gt;
&lt;/Modal&gt;
</code></pre>
<p>For named blocks, different parameters may be exposed individually to each block:</p>
<pre><code class="language-hbs">&lt;Modal&gt;
  &lt;:header&gt;Close me&lt;/:header&gt;
  &lt;:body as |close|&gt;
    &lt;button {{on &quot;click&quot; close}}&gt;Click!&lt;/button&gt;
  &lt;/:body&gt;
&lt;/Modal&gt;
</code></pre>
</li>
<li>
<p><strong>Yield</strong></p>
<p>Yielding is how a component invokes a provided block, optionally exposing block parameters. An example from <a href="https://emberjs.github.io/rfcs/0460-yieldable-named-blocks.html#block-parameters">RFC 460</a>:</p>
<pre><code class="language-hbs">&lt;article&gt;
  &lt;header&gt;{{yield @article.title to='header'}}&lt;/header&gt;
  &lt;section&gt;{{yield @article.body to='body'}}&lt;/section&gt;
&lt;/article&gt;
</code></pre>
</li>
</ul>
</details>
<p>The <code>Blocks</code> type maps the block names a component accepts to a tuple type representing the parameters those blocks will receive.</p>
<p>As a concrete example, the <code>BlogPost</code> component in the <a href="https://guides.emberjs.com/release/components/block-content/#toc_block-parameters">Block Parameters section</a> of the Ember guides looks like this:</p>
<pre><code class="language-hbs">{{yield @post.title @post.author @post.body}}
</code></pre>
<pre><code class="language-hbs">&lt;!-- usage --&gt;
&lt;BlogPost @post={{@blogPost}} as |postTitle postAuthor postBody|&gt;
  &lt;img alt=&quot;&quot; role=&quot;presentation&quot; src=&quot;./blog-logo.png&quot;&gt;

  {{postTitle}}

  {{postBody}}

  &lt;AuthorBio @author={{postAuthor}} /&gt;
&lt;/BlogPost&gt;
</code></pre>
<p>The signature for this component might look like:</p>
<pre><code class="language-ts">export interface BlogPostSignature {
  Args: { post: Post };
  Blocks: {
    default: [postTitle: string, postAuthor: string, postBody: string];
  };
}
</code></pre>
<p>Block parameters may also depend on the types of args a component receives. For example, for a fancy table component:</p>
<pre><code class="language-hbs">&lt;FancyTable @items={{this.people}}&gt;
  &lt;:header&gt;
    &lt;td&gt;Name&lt;/td&gt;
    &lt;td&gt;Age&lt;/td&gt;
  &lt;/:header&gt;

  &lt;:row as |person|&gt;
    &lt;td&gt;{{person.name}}&lt;/td&gt;
    &lt;td&gt;{{person.age}}&lt;/td&gt;
  &lt;/:row&gt;
&lt;/FancyTable&gt;
</code></pre>
<p>The backing class and signature might look something like:</p>
<pre><code class="language-ts">export interface FancyTableSignature&lt;T&gt; {
  Args: {
    /** The items to be displayed in the fancy table, each corresponding to one row. */
    items: Array&lt;T&gt;
  };
  Blocks: {
    /** Any header contents for the table, broken into cells. */
    header: [];

    /** Content to be rendered for each row, receiving the corresponding item and its index. */
    row: [item: T, index: number];
  };
}

export default class FancyTable&lt;T&gt; extends Component&lt;FancyTableSignature&lt;T&gt;&gt; {
  // ...
}
</code></pre>
<p>While the runtime design of named blocks currently only permits components to yield parameters out to them, community members have suggested possible ways of making blocks more akin to components themselves, potentially accepting <code>@args</code> or attributes, or even themselves accepting further nested blocks. Should such a design ever become reality, the shape of a signature might evolve to become more recursive. Today, however, there are many open questions about how such functionality would actually work for authors, and so we keep the proposed format here simple.</p>
<div class="footnote-definition" id="blocks-sugar"><sup class="footnote-definition-label">1</sup>
<p>We recognize that it might be desirable to have a shorthand for the very common case of having a single default block. However, none of the designs we have seen so far are satisfactory across the board in terms of teaching and mental model, so we are using this expanded form which <em>does</em> satisfy those constraints. Over time, we hope to come up with a nice bit of “sugar” that works there, but we are not <em>blocked</em> on finding that sugar.</p>
</div>
<h3 id="element"><a class="header" href="#element"><code>Element</code></a></h3>
<p>The <code>Element</code> member of the signature declares what type of DOM element(s), if any, this component may be treated as encapsulating. That is, setting a non-<code>null</code> type for this member declares that this component may have HTML attributes applied to it, and that type reflects the type of DOM <code>Element</code> object any modifiers applied to the component will receive when they execute.</p>
<p><strong>A signature with no <code>Element</code> or with <code>Element: null</code> indicates that its component does not accept HTML attributes and modifiers at all.</strong> While applying attributes or modifiers to such a component wouldn't produce a runtime error, it still likely constitutes a mistake on the author's part, similar to <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks">passing an unknown key in an object literal</a>.</p>
<p>For example, <a href="https://ember-animation.github.io/ember-animated/docs/api/components/animated-if"><code>{{animated-if}}</code></a> would omit <code>Element</code> from its signature, as it emits no DOM content. Even if you invoked it with angle-bracket syntax, any attributes or modifiers you applied wouldn't go anywhere.</p>
<p>On the other hand, <a href="https://github.com/kaliber5/ember-responsive-image#the-responsiveimage-component"><code>&lt;ResponsiveImage&gt;</code></a> would set <code>Element: HTMLImageElement</code>, as the element in its template that it ultimately spreads <code>...attributes</code> on to is an <code>&lt;img&gt;</code>.</p>
<p>The <code>Element</code> member is of particular relevance for the modifiers that consumers can apply to a component. In a system using this information to provide typechecking, any modifiers applied to its component must be declared to accept the component's <code>Element</code> type (or a broader type) as its first parameter, or else produce a type error.</p>
<ul>
<li>
<p>A component with <code>Element: Element</code> can only be used with modifiers that accept <em>any</em> DOM element. Many existing modifiers in the ecosystem, such as <code>{{on}}</code> and everything in <code>ember-render-modifiers</code>, fall into this bucket.</p>
</li>
<li>
<p>A component with e.g. <code>Element: HTMLCanvasElement</code>, may be used with any general-purpose modifiers as described above <em>as well as</em> any modifiers that specifically expect to be attached to a <code>&lt;canvas&gt;</code>.</p>
</li>
<li>
<p>A component whose <code>Element</code> type is a <a href="0748-glimmer-component-signature.html#components-with-multiple-or-varying-elements">union of multiple possible elements</a> can only be used with a modifier that is declared to accept <em>all</em> of those element types. This behavior is, in fact, the point—modifiers are essentially callbacks that receive the element they're attached to, and so the <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">normal considerations</a> for typing callback parameters apply.</p>
</li>
</ul>
<h4 id="components-with-multiple-or-varying-elements"><a class="header" href="#components-with-multiple-or-varying-elements">Components With Multiple or Varying Elements</a></h4>
<p>While it's not common, occasionally components might forward <code>...attributes</code> to different types of elements in their template:</p>
<pre><code class="language-hbs">{{#if @destination}}
  &lt;a ...attributes href={{@destination}}&gt;{{yield}}&lt;/a&gt;
{{else}}
  &lt;span ...attributes&gt;{{yield}}&lt;/span&gt;
{{/if}}
</code></pre>
<p>For such cases, components can use a union type for their <code>Element</code>. In the case of the template above, the signature would have <code>Element: HTMLAnchorElement | HTMLSpanElement</code>. Correspondingly, any modifiers used with such components would need to accept any of the possible types of DOM elements declared.</p>
<p>Similarly, a component that may use <code>...attributes</code> on an <code>&lt;a&gt;</code> element or may not spread them at all might write: <code>Element: HTMLAnchorElement | null</code>. In such cases, ecosystem tooling consuming this type information should treat it as legal to use any modifiers that accept an <code>HTMLAnchorElement</code>, since they wouldn't ever be invoked for the <code>null</code> scenario.</p>
<p>In cases where the distinction between possible elements is key to the functionality of the component and can be statically known based on the arguments passed in, the component author may choose to capture this as part of the signature at the expense of additional type-level bookkeeping.</p>
<details><summary>Gritty details</summary>
<p>The particular shape/value of arguments is something that varies from instance to instance of the component, and the standard tool in TypeScript for handling these cases is to introduce a <em>type parameter</em> on the type(s) in question.</p>
<p>For the <code>{{#if @destination}}</code> example above, the implementation might look like this:</p>
<pre><code class="language-ts">interface MaybeLinkSignature&lt;Destination extends string | undefined&gt; {
  Args: {
    destination: Destination;
    target?: string;
  };
  Blocks: {
    default: []
  };
  Element: Destination extends string
    ? HTMLAnchorElement
    : HTMLSpanElement;
}

export default class MaybeLink&lt;Destination extends string | undefined&gt;
  extends Component&lt;MaybeLinkSignature&lt;Destination&gt;&gt; {
  // ...
}
</code></pre>
<p>This would allow consumers to use a modifier that requires an <code>HTMLAnchorElement</code> on a <code>MaybeLink</code> if and only if the <code>@destination</code> arg they pass is definitely a string.</p>
<p>Note, still, that general-purpose modifiers like <code>{{on}}</code> or <code>{{did-insert}}</code> would be usable with this component regardless of the type of <code>@destination</code>, or even if the author had simply typed <code>Element</code> as <code>HTMLAnchorElement | HTMLSpanElement</code> without the extra song-and-dance of explicitly capturing the <code>Destination</code> type.</p>
<p>Finally, template analysis tools can provide escape hatches in the same vein as TypeScript's <code>@ts-ignore</code> and <code>@ts-expect-error</code> for these or any cases where consumers have information that library authors haven't encoded in the type system.</p>
</details>
<h2 id="how-we-teach-this-149"><a class="header" href="#how-we-teach-this-149">How we teach this</a></h2>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p>Ember is <a href="https://github.com/emberjs/rfcs/pull/724">in the midst</a> of <a href="https://github.com/emberjs/rfcs/pull/800">adding official supported for TypeScript</a>, and as such none of the framework guides or API documentation mention the existing <code>Args</code> type parameter today. The upshot of this is that, while the <code>Args</code> type parameter is well known by the portion of the Ember community that works with TypeScript, there's no official documentation to be updated.</p>
<p>The <a href="https://docs.ember-cli-typescript.com/ember/components#understanding-args"><code>ember-cli-typescript</code> website</a>, however, does have a section on working with components in TypeScript that deals almost exclusively with the <code>Args</code> parameter and <code>this.args</code> on the backing class. We should update and expand this documentation to cover the other concepts included in the <code>Signature</code> type.</p>
<p>When we add sections documenting the use of TypeScript to the official guides, add type information to the API docs, and and so on, we will migrate that discussion from the <code>ember-cli-typescript</code> documentation into the main site documentation.</p>
<p>Glint and its current documentation currently use earlier names and structures for the basic ideas in this signature, and will be updated to match this spec.</p>
<h3 id="migration-4"><a class="header" href="#migration-4">Migration</a></h3>
<p>As noted in <a href="0748-glimmer-component-signature.html#detailed-design"><strong>Detailed Design</strong></a>, we can implement this change in <code>@glimmer/component</code> 1.x in a backwards compatible way, allowing for a deprecation period before moving exclusively to the signature approach in 2.0. Because capitalized arg names are currently illegal, any valid signature will not represent valid arg names, so the backing class can <a href="https://tsplay.dev/Nr2rzN">accept both formats</a> and distinguish which was intended.</p>
<p>Ideally we'll be able to encourage authors to migrate their usage of <code>Args</code> in the same ways they're used to being nudged to move away from other deprecated APIs in the Ember ecosystem.</p>
<h4 id="codemods"><a class="header" href="#codemods">Codemods</a></h4>
<p>A simple codemod to turn <code>Component&lt;MyArgs&gt;</code> into <code>Component&lt;{ Args: MyArgs }&gt;</code> would be straightforward, but it may also be feasible to migrate more completely by inferring information like block names and where <code>...splattributes</code> are used from colocated templates. The richness we pursue here will likely depend on the appetite of the community to explore what's possible.</p>
<h4 id="deprecation-warningslinting"><a class="header" href="#deprecation-warningslinting">Deprecation Warnings/Linting</a></h4>
<p>While type-only deprecations aren't something the Ember ecosystem has dealt with much previously, it's a muscle we may want to begin building as <a href="https://github.com/emberjs/rfcs/pull/724">official TypeScript support</a> is under consideration.</p>
<p>The <code>@typescript-eslint</code> suite of packages supports writing <a href="https://github.com/typescript-eslint/typescript-eslint#can-we-write-rules-which-leverage-type-information">type-aware rules</a> in projects that provide appropriate configuration in their <code>eslintrc</code>, so one option available to use would be to use that functionality to allow users to lint for components that haven't yet been migrated to use a signature type. We could expose this as part of a standalone ESLint plugin, or perhaps make it available on an opt-in basis in <code>eslint-plugin-ember</code>.</p>
<h2 id="drawbacks-166"><a class="header" href="#drawbacks-166">Drawbacks</a></h2>
<p>As with any change that deprecates supported behavior, there's an inherent cost associated with migrating the user base over to new patterns. One goal of this change, however, is to ease such migrations in the future: as the templating system evolves and new information becomes relevant to capture and document, the <code>Signature</code> type provides a place for that information to live without disrupting existing code.</p>
<p>The other potential drawback to this approach is that it introduces TypeScript type information that has no visible effect on the component using out-of-the-box tooling. Without a template-aware system like Glint or <code>els-addon-typed-templates</code> for validating components, nothing enforces that the signature declared is actually accurate. See the &quot;Only <code>Args</code>&quot; section under Alternatives below for further discussion of this point.</p>
<h2 id="alternatives-168"><a class="header" href="#alternatives-168">Alternatives</a></h2>
<h3 id="additional-positional-type-parameters"><a class="header" href="#additional-positional-type-parameters">Additional Positional Type Parameters</a></h3>
<p>Rather than wrapping the information we're interested in capturing in a <code>Signature</code> type, we could instead introduce further type parameters to the <code>Component</code> base class:</p>
<pre><code class="language-ts">class Component&lt;Args = {}, Blocks = {}, Element = null&gt; {
  // ...
}
</code></pre>
<p>This has the advantage of not requiring current users of the <code>Args</code> parameter to change their code, but suffers many of the same ergonomic issues as regular functions do when they begin to accrue many positional parameters. Authors need to remember which parameters appear in which order when using the <code>Component</code> type, and they need to be aware of the appropriate default values for earlier parameters to fill in when they only want to specify a later one.</p>
<h3 id="only-args"><a class="header" href="#only-args">Only <code>Args</code></a></h3>
<p>One of the drawbacks mentioned above is that the <code>Element</code> and <code>Blocks</code> signature members described in this RFC are functionally inert in a vanilla TypeScript project. This leaves them with about the same status as comments: potentially helpful when left by a well-meaning author, but without any checks to ensure that they're accurate and that they stay up-to-date as the implementation changes.</p>
<p>An alternative would be to still introduce the <code>Signature</code> type in <code>@glimmer/component</code> but <em>only</em> formalize the <code>Args</code> member, leaving other tooling to define the semantics of any additional signature members they might be interested in. While this would simplify the overall proposal somewhat, what a component <code>{{yield}}</code>s and what it does with its <code>...attributes</code> are core enough to a component's public interface that we believe they should be considered first-class rather than having individual tools reinvent them, potentially in mutually-incompatible ways.</p>
<h3 id="naming"><a class="header" href="#naming">Naming</a></h3>
<p>The <code>Signature</code> concept itself has been <a href="https://github.com/typed-ember/glint#component-signatures">used in Glint</a> and broadly well received and understood, but the naming of each of the three member elements has received some discussion. While the names proposed above are what we currently believe to be best suited from both pedagogical and API-consistency perspectives, there are alternatives we could choose (and have explored).</p>
<h4 id="args-2"><a class="header" href="#args-2"><code>Args</code></a></h4>
<p>Early discussions have largely been on board with <code>Args</code> as it stands, though the non-abbreviated option <code>Arguments</code> has been suggested as an alternative. Since <code>Args</code> aligns better with <code>this.args</code> on the backing class (as well as the way in which people often colloquially discuss <code>@arg</code> values), we're continuing to propose <code>Args</code> here.</p>
<h4 id="element-1"><a class="header" href="#element-1"><code>Element</code></a></h4>
<p>Among early adopters of Glint there has been some confusion as to what the purpose of this key is. Generally &quot;it's the concrete place your <code>...attributes</code> ultimately land after being passed down through components&quot; has worked as an explainer, but the fact that an explainer is needed may indicate that <code>Element</code> isn't a clear name on its own.</p>
<p>That said, even among those who were initially unclear what the purpose of <code>Element</code> was, no one has been able to come up with an alternative proposal. Attempts at more explicit formulations like <code>UltimateSplattributesTarget</code> don't quite roll off the tongue 🙂</p>
<h4 id="blocks-1"><a class="header" href="#blocks-1"><code>Blocks</code></a></h4>
<p>This key has easily been the largest topic of discussion among the three <code>Signature</code> members. Currently Glint uses <code>Yields</code> for this concept, but developers have given consistent feedback that that doesn't fit with <code>Args</code> and <code>Element</code> in their mental model. Moreover, the Framework team noted that it also doesn’t match with hoped-for iterations on the mental model after Polaris, where the notion of “yielding” (largely a holdover from Ember’s roots with many of its designers coming from the Ruby world) is less prominent or removed entirely in favor of new language/concepts.</p>
<p>An earlier draft also used <code>BlockParams</code>, but that was not readily extensible to capture future information about blocks. Since Blocks are the chunks of content passed <em>in</em> to a component by the author invoking it, while this signature member captures what parameters (if any) the component will pass <em>out</em> to those blocks, we also did not want to support a shorthand like <code>Blocks: []</code>, which could very easily be misread as “there are no blocks” instead of “there is a default block which yields no params”.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-05-26
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/750</h2>
<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->
<h1 id="deprecate-emberassign"><a class="header" href="#deprecate-emberassign">Deprecate Ember.assign</a></h1>
<h2 id="summary-182"><a class="header" href="#summary-182">Summary</a></h2>
<p>Now that Ember is dropping support for IE11, we no longer need <code>Ember.assign</code> as a polyfill since <code>Object.assign</code>
is available in all browsers that Ember v4.x supports (<a href="https://caniuse.com/mdn-javascript_builtins_object_assign">CanIUse</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#browser_compatibility">MDN</a>).</p>
<h2 id="motivation-182"><a class="header" href="#motivation-182">Motivation</a></h2>
<p>The polyfill is no longer necessary, as well as being another Emberism that can be removed. Apps and addons can use <code>Object.assign</code> or object destructuring depending on their browser support targets.</p>
<h2 id="transition-path-33"><a class="header" href="#transition-path-33">Transition Path</a></h2>
<p>The transition path is relatively simple: apps that use Ember 4.x will replace <code>Ember.assign</code> with <code>Object.assign</code>, and apps and addons that use or support Ember 3.x can continue to use the polyfill if needed.</p>
<p>ex:</p>
<pre><code>import { assign as emberAssign } from '@ember/polyfills';

const assign = Object.assign || emberAssign;
</code></pre>
<h2 id="how-we-teach-this-150"><a class="header" href="#how-we-teach-this-150">How We Teach This</a></h2>
<p>A descriptive deprecation message alerting a developer that <code>Ember.assign</code> is deprecated and can be replaced with <code>Object.assign</code>.</p>
<h2 id="drawbacks-167"><a class="header" href="#drawbacks-167">Drawbacks</a></h2>
<p>The only drawback is replacing the polyfill assign with the native assign, but there is minimal effort to do this.</p>
<h2 id="alternatives-169"><a class="header" href="#alternatives-169">Alternatives</a></h2>
<p>Doing nothing.</p>
<h2 id="unresolved-questions-107"><a class="header" href="#unresolved-questions-107">Unresolved questions</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-06-10
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/752</h2>
<!--- 
Directions for above: 

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->
<h1 id="rename-inject-import-to-service"><a class="header" href="#rename-inject-import-to-service">Rename <code>inject</code> import to <code>service</code></a></h1>
<h2 id="summary-183"><a class="header" href="#summary-183">Summary</a></h2>
<p>Currently, in order to use a service in any framework class you can do it like this:</p>
<pre><code class="language-js">import { inject } from '@ember/service';

export class MyComponent extends Component {
  @inject router;
}
</code></pre>
<p>However, it is very common to actually alias this import to <code>service</code>, like this:</p>
<pre><code class="language-js">import { inject as service } from '@ember/service';

export class MyComponent extends Component {
  @service router;
}
</code></pre>
<p>This RFC proposes to actually provide this as a <code>service</code> import directly.</p>
<h2 id="motivation-183"><a class="header" href="#motivation-183">Motivation</a></h2>
<p>You cannot properly/easily use editor autocompletion to import <code>@service</code>. </p>
<p>Even in the guides, <code>inject</code> is aliased to <code>service</code> (see: https://guides.emberjs.com/release/services/#toc_accessing-services)</p>
<p>Finally, there is also an <code>inject</code> export from <code>@ember/controller</code>, which is also a possible source of confusion.</p>
<p>By exporting this directly as <code>service</code>, this would be streamlined:</p>
<pre><code class="language-js">import { service } from '@ember/service';

export class MyComponent extends Component {
  @service router;
}
</code></pre>
<h2 id="detailed-design-149"><a class="header" href="#detailed-design-149">Detailed design</a></h2>
<p>We add an export <code>service</code> from the <code>@ember/service</code> package with the semantics
of <code>inject</code>.</p>
<p>Import of <code>inject</code> itself will be deprecated targeting Ember 5.0 for removal,
and the app blueprint will be updated as soon as possible to the new API.</p>
<p>Addons will likely want to support the legacy API for a long time, especially
if the legacy API is not deprecated in Ember 4.0.0. The addon blueprint and
best practice should be to:</p>
<pre><code class="language-js">import * as ES from '@ember/service';
const service = ES.service ?? ES.inject;
</code></pre>
<p>Then use <code>service</code> for injections.</p>
<h2 id="how-we-teach-this-151"><a class="header" href="#how-we-teach-this-151">How we teach this</a></h2>
<p>The docs should be updated to directly import <code>import { service } from '@ember/service';</code>.</p>
<h2 id="drawbacks-168"><a class="header" href="#drawbacks-168">Drawbacks</a></h2>
<p>It might be considered churn. However, we could probably provide a codemod to
automatically rename the imports, lessening the churn.</p>
<p>Addons will need to live with a degraded injection API for a long time, if they
want to support both versions.</p>
<h2 id="alternatives-170"><a class="header" href="#alternatives-170">Alternatives</a></h2>
<p>We could leave the import as it is, continuing to suggest people rename the import to <code>service</code>. </p>
<p>Or we could stop suggesting the import and push for the community to simply use <code>@inject myService</code>.</p>
<p>We could also choose a different name for the import (e.g. <code>injectService</code> or something like this).</p>
<h2 id="unresolved-questions-108"><a class="header" href="#unresolved-questions-108">Unresolved questions</a></h2>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-05-17
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js, Learning
RFC PR: https://github.com/emberjs/rfcs/pull/756</h2>
<h1 id="default-helper-manager"><a class="header" href="#default-helper-manager">Default Helper Manager</a></h1>
<h2 id="summary-184"><a class="header" href="#summary-184">Summary</a></h2>
<p>Anything that can be in a template has its lifecycle managed by the manager pattern.
Today, we have known managers for <code>@glimmer/component</code>, <code>@ember/helper</code>, etc.
But what happens when the VM encounters an object for which there is no manager?,
such as a plain function? This RFC proposes a default behavior for
those unknown scenarios when it comes to <em>helpers</em>.</p>
<h2 id="motivation-184"><a class="header" href="#motivation-184">Motivation</a></h2>
<p>The addon, <a href="https://github.com/pzuraq/ember-could-get-used-to-this">ember-could-get-used-to-this</a>
demonstrated that it's possible to use plain functions for helpers and modifiers.
And since Ember 3.25, helpers can be invoked directly from value references, this opened
a whole new world of ergonomics improvements where a dev could define a function in a
component class and use that function <strong>as</strong> a helper, thanks to
ember-could-get-used-to-this implementing a Helper Manager that knew what to do with plain functions.</p>
<p>This has the impact of greatly reducing mental overhead around helpers for app and addon authors, in that,
folks no longer need to jump over to the app/addon helpers directory to create a helper
&quot;just to do this one simple thing&quot;. It's all now <code>{{this.myHelper}}</code> or <code>{{this.myModifier}}</code>.</p>
<p>The introduction of a plain-function helper-manager is important because over the past several years,
we've seen on numerous occasion, folks new to Ember inherently expect that plain functions work in templates.</p>
<p>Example:</p>
<pre><code class="language-js">import Component from '@glimmer/component';
import { setComponentTemplate } from '@ember/component';
import { hbs } from 'ember-cli-htmlbars';

export default class Example extends Component {
  double = num =&gt; num * 2;
}
</code></pre>
<pre><code class="language-hbs">{{this.double 2}} =&gt; prints 4
&lt;SomeComponent @foo={{this.double 2}} /&gt; =&gt; @foo === 4
</code></pre>
<p>A default modifier manager will be covered in a different RFC.</p>
<h2 id="detailed-design-150"><a class="header" href="#detailed-design-150">Detailed design</a></h2>
<p><em>A Default Manager is not something that can be chosen by the user, but is baked in to the framework
as a default so that a user doesn't have to build something to use a non-framework-specific variant
of the three constructs: Helpers, Modifiers, and Components.</em></p>
<p>The desired usage of a plain function in a template should be:</p>
<ul>
<li>convenient</li>
<li>reduce boilerplate</li>
<li>be easily portable to JS for developers' mental model of how template and JS interact.</li>
</ul>
<p>Which results in:</p>
<ul>
<li>default to positional parameters</li>
<li>all named arguments are grouped into an &quot;options object&quot; as the last parameter.
this happens to align with the <em>syntax</em> of helper invocation where named arguments may not appear
before the last positional argument.</li>
</ul>
<h4 id="example-with-mixed-params"><a class="header" href="#example-with-mixed-params">Example with mixed params</a></h4>
<pre><code class="language-hbs">{{this.calculate 1 2 op=&quot;add&quot;}}
</code></pre>
<p>would be an example invocation of a function with the following signature
expressed as TypeScript for clarity:</p>
<pre><code class="language-ts">type Options = { op: 'add' | 'subtract' }
class A {
  calculate(first: number, second: number, options: Options) {
    // ...
  }
}
</code></pre>
<p>for unknown amounts of parameters, the <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMJwDYIK4bpAeQAcxgB7EAZ2QG8AoZR5MogLmQHI4ATbj5AD6dK2AEYcA3HQC+dMAE8iKdFlz4IAQSgBzagF5kAbQB0pkNgC2o6IYC6AGjSYceQiXJVbUujGwgEpBTICM5qkAAUpsZwOpTsKi7qWroAlLQMyBgQYMzuFPrIMbrGRCzhaXDUCWEQxIFUUoxZOeYWBUXUlcit1lB23owI+WRZxhhk2uE0ufWUjq3U0ilSsj5+AR7Boa4QAEyRph3x20mxafRN2UYss45RUBAAbtCUENy2yAYdxg-PUK-lRqZK4LT7IX4vN4-J6QwF0DJDKgjCBjCZTGYeObdSyLZYyeHwoA">typescript can be awkward</a>,</p>
<p>but there is a <a href="https://github.com/tc39/proposal-deiter">TC39 proposal: proposal-deiter</a> that could make
destructuring simpler and inlined to</p>
<pre><code class="language-ts">  calculate(...numbers: number[], options: Options) {
</code></pre>
<h4 id="example-with-only-positional-parameters"><a class="header" href="#example-with-only-positional-parameters">Example with only positional parameters</a></h4>
<pre><code class="language-hbs">{{this.add 1 2 3 4}}
</code></pre>
<p>Because there are no named arguments passed in, the method signature can be simple:</p>
<pre><code class="language-js">class A {
  add(...numbers: number[]) {
    // ...
  }
}
</code></pre>
<h4 id="example-default-helper-implementation"><a class="header" href="#example-default-helper-implementation">Example Default Helper Implementation</a></h4>
<p>The implementation for the this function-handling helper-manager could look like this:</p>
<pre><code class="language-ts">import {
  setHelperManager,
  capabilities as helperCapabilities,
} from '@ember/helper';
import { assert } from '@ember/debug';

class FunctionHelperManager {
  capabilities = helperCapabilities('3.23', {
    hasValue: true,
  });

  createHelper(fn, args) {
    return { fn, args };
  }

  getValue({ fn, args }) {
    let argsForFn = args.positional;

    if (Object.keys(args.named).length &gt; 0) {
      argsForFn.push(args.named);
    } else {
      argsForFn.push({});
    }

    return fn(...argsForFn);
  }

  getDebugName(fn) {
    return fn.name || '(anonymous function)';
  }
}

const DEFAULT_HELPER_MANAGER = new FunctionHelperManager();

// side-effect -- this file needs to be imported for the helper manager to be installed
setHelperManager(() =&gt; DEFAULT_HELPER_MANAGER, Function.prototype);
</code></pre>
<ul>
<li>when the &quot;helper&quot; is created, the function is not invoked</li>
<li>when <code>getValue</code> is invoked,
<ul>
<li>the function is invoked with the named arguments all grouped into the last arg</li>
<li>if no named arguments are given, an empty object is used instead to allow less nullish checking in userland</li>
</ul>
</li>
<li>to register this helper manager, it should occur during app boot so developers do not need to import anything to
trigger the <code>setHelperManager</code> call</li>
</ul>
<h3 id="updating-highlevel-manager-choosing-algorithm"><a class="header" href="#updating-highlevel-manager-choosing-algorithm">Updating highlevel manager choosing algorithm</a></h3>
<p>This is the existing manager chooser algorithm, but with extra additions required by this RFC (notated by <code>--&gt;</code>).</p>
<ul>
<li>if inside element space
<ul>
<li>use <code>getModifierManager</code></li>
</ul>
</li>
<li>if inside document body space using curly invocation
<ol>
<li>attempt lookup via <code>getComponentManager</code> and invoke it</li>
<li>attempt lookup via <code>getHelperManager</code> and invoke it</li>
<li><code>--&gt;</code> if function, fallback to this RFC's default manager</li>
<li>render, e.g.: <code>[Object object]</code>, for objects</li>
</ol>
</li>
<li>if inside document body space using angle invocation
<ul>
<li>attempt to lookup via <code>getComponentManager</code> and invoke it</li>
</ul>
</li>
<li>if inside of a subexpression's &quot;head&quot; (e.g. <code>PathExpression</code>) position
<ol>
<li>attempt to lookup via <code>getHelperManager</code> and invoke it</li>
<li><code>--&gt;</code> if function, fallback to this RFC's default manager</li>
<li>error</li>
</ol>
</li>
<li>if inside of a subexpression arguments
<ul>
<li>pass the value</li>
</ul>
</li>
</ul>
<h3 id="how-a-template-syntax-plays-in-to-this-behavior"><a class="header" href="#how-a-template-syntax-plays-in-to-this-behavior">How a template syntax plays in to this behavior</a></h3>
<p>In the current state of templates there is some ambiguity in syntax around helper/component invocation invocation.
Below is a list exploring the various syntaxes and how the code implemented in the framework for this RFC
will react to various passed value/function/etc types. All of this is current behavior and this RFC is not proposing
a syntax change. In template strict mode, there is no ambiguity to worry about.</p>
<ul>
<li><code>{{val}}</code>
<ul>
<li><code>typeof val === 'function'</code>: Helper, invoked
<ul>
<li>presently, it's possible to have curly components use this syntax as well. By defining this as a helper,
there is a possibility of confusion as the manager choosing algorithm will select a component before it selects a helper
when using curlies.</li>
<li>because angle-bracket invocation is the generally accepted way to invoke a component,
this may be an acceptable trade-off</li>
</ul>
</li>
<li><code>typeof val === 'object'</code>: Value, rendered</li>
<li><code>val instanceof AnyClass</code>: Value, rendered
<ul>
<li>Today, classes are <code>.toString()</code>'d, but it's feasible that one could define their own
custom helper manager or component manager to do something different.</li>
</ul>
</li>
</ul>
</li>
<li><code>{{ (val) }}</code>
<ul>
<li><code>typeof val === 'function'</code>: Helper, existing behavior</li>
<li><code>typeof val === 'object'</code>: Expected Helper error, no manager found</li>
<li><code>val instanceof AnyClass</code>: Expected Helper, no manager found</li>
</ul>
</li>
<li><code>{{val arg}}</code>
<ul>
<li><code>typeof val === 'function'</code>: Helper, existing behavior
<ul>
<li>Similar to <code>{{val}}</code>, it is possible today to define a component manager that takes positional args that
would be invoked with this syntax.</li>
</ul>
</li>
<li><code>typeof val === 'object'</code>: Expected Helper error</li>
<li><code>val instanceof AnyClass</code>: Expected Helper, no manager found</li>
</ul>
</li>
<li><code>&lt;Component @arg={{val arg}} /&gt;</code>
<ul>
<li><code>typeof val === 'function'</code>: Helper, existing behavior</li>
<li><code>typeof val === 'object'</code>: Expected Helper error</li>
<li><code>val instanceof AnyClass</code>: Expected Helper, no manager found</li>
</ul>
</li>
<li><code>&lt;Component @arg={{val}} /&gt;</code>
<ul>
<li><code>typeof val === 'function'</code>: Value
<ul>
<li>if this were to evaluate as a helper it would break existing behavior where you may be
passing an event handler to the component</li>
<li>another consequence of evaluating <code>val</code> as a helper and invoking it is that it would be
more likely to cause an infinite revalidation assertion, which at present, would be hard
to track down the source of, but may be an option if the VM one day has an equivalent to
React's ErrorBoundary</li>
<li>if someone wanted to invoke <code>val</code> as a helper when passed as an argument, they would need to
add surrounding <code>()</code>, example: <code>&lt;Component @arg={{ (val) }}</code> /&gt;</li>
</ul>
</li>
<li><code>typeof val === 'object'</code>: Passed as argument to the component</li>
<li><code>val instanceof AnyClass</code>: Passed as argument to the component</li>
</ul>
</li>
<li><code>&lt;Component @arg={{val 1}} /&gt;</code>
<ul>
<li><code>typeof val === 'function'</code>: Helper, existing behavior
<ul>
<li>another consequence of evaluating <code>val</code> as a helper and invoking it is that it would be
more likely to cause an infinite revalidation assertion, which at present, would be hard
to track down the source of, but may be an option if the VM one day has an equivalent to
React's ErrorBoundary</li>
</ul>
</li>
<li><code>typeof val === 'object'</code>: Expected Helper error</li>
<li><code>val instanceof AnyClass</code>: Expected Helper, no manager found</li>
</ul>
</li>
<li><code>&lt;Component @arg={{ (val 1) }} /&gt;</code>
<ul>
<li><code>typeof val === 'function'</code>: Helper, existing behavior</li>
<li><code>typeof val === 'object'</code>: Expected Helper error</li>
<li><code>val instanceof AnyClass</code>: Expected Helper, no manager found</li>
</ul>
</li>
</ul>
<h2 id="how-we-teach-this-152"><a class="header" href="#how-we-teach-this-152">How we teach this</a></h2>
<p>On the <a href="https://guides.emberjs.com/v3.26.0/components/helper-functions/">Helper Functions</a> page,
We'll want to insert a section early on about how helpers can be &quot;local&quot; to or defined on
components and controllers. Then, once there have been examples of the local/private helper,
the existing content can continue to talk about the &quot;global helper&quot; -- explicitly differentiating
between the local/private helper, rather then retaining the general &quot;Helper Function&quot; title as
&quot;Helper Functions&quot; are all of these, rather than just the globally defines ones.</p>
<p>Existing users of Ember should be made aware of these capabilities, once implemented, via
the release blog post, with some examples -- but folks watching developments in the ecosystem
will likely be aware of ember-could-get-used-to-this, which implement
some parts of this RFC, so the migration path for users of ember-could-get-used-to-this should
be straight-forward.  That addon <em>may</em> want to deprecate their similar functionality after
the proposed behavior here lands -- though, this RFC suggests implementation such that developers
may still use ember-could-get-used-to-this without disruption.</p>
<h2 id="drawbacks-169"><a class="header" href="#drawbacks-169">Drawbacks</a></h2>
<p>There would no longer be a possibility of using functions as components when invoked with curlies.
Angle bracket function components would still be possible.</p>
<p>There could be some awkwardness around the last argument passed to the function, as the
type signature may not match how the call-site expects the signature to be.
Projects like <a href="https://github.com/typed-ember/glint#readme">Glint</a> would be essential for
helping with clarity here.</p>
<p>The difference between <code>&lt;Component @handler={{this.handler}} /&gt;</code> and <code>&lt;Component @handler={{this.handler 1}} /&gt;</code>
could awkward for folks, as the syntax says that a value <em>always</em> passes
a value, <em>unless</em> there are arguments added within the curly braces, in which <code>this.handler</code> is invoked
and the return value is instead passed as <code>@handler</code>. This could lead to infinite revalidation assertions,
which, without an ErrorBoundary (from React) and Error messages that show the location in the template
where an error originates from, would be fairly hard to track down. The problem goes away entirely in
template strict mode, so it may not be something we want to worry about in the short-term (outside of
documenting the possibility and what to do when the situation occurs)</p>
<h2 id="alternatives-171"><a class="header" href="#alternatives-171">Alternatives</a></h2>
<p>Class-based default helpers would allow greater flexibility for creating helpers, but would also
perpetuate the current problem of most surprise when trying to invoke functions from defined outside
of ember within templates (such as XState's state.matches function).</p>
<h2 id="unresolved-questions-109"><a class="header" href="#unresolved-questions-109">Unresolved questions</a></h2>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-10-21
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/772</h2>
<h1 id="deprecate-bower-support"><a class="header" href="#deprecate-bower-support">Deprecate Bower Support</a></h1>
<h2 id="summary-185"><a class="header" href="#summary-185">Summary</a></h2>
<p>This RFC proposes to deprecate the following Bower APIs:</p>
<ul>
<li><a href="https://ember-cli.com/api/classes/blueprint#method_addBowerPackageToProject">Blueprint::addBowerPackageToProject</a></li>
<li><a href="https://ember-cli.com/api/classes/blueprint#method_addBowerPackagesToProject">Blueprint::addBowerPackagesToProject</a></li>
<li><a href="https://ember-cli.com/api/classes/project#method_bowerDependencies">Project::bowerDependencies</a> (not public, but used in several addons)</li>
<li><a href="https://github.com/ember-cli/ember-cli/blob/master/lib/models/project.js#L127">Project::bowerDirectory</a> (not public, but used in several addons)</li>
</ul>
<p>This RFC also proposes to deprecate building Bower packages, coming from
<code>/bower_components</code> by default.</p>
<h2 id="motivation-185"><a class="header" href="#motivation-185">Motivation</a></h2>
<p>While <a href="https://bower.io/">Bower</a> is still maintained, it's recommended to use an
alternative package manager instead (<a href="https://www.npmjs.com/">npm</a>, <a href="https://yarnpkg.com/">Yarn</a>, <a href="https://pnpm.io/">pnpm</a>, ...). This is also <a href="https://github.com/bower/bower/blob/master/README.md?plain=1#L7">the official recommendation</a> of the Bower team. Additionally,
Ember CLI stopped emitting a <code>bower.json</code> file since <a href="https://github.com/ember-cli/ember-cli/blob/master/CHANGELOG.md#2130-beta1">v2.13.0</a> and the Ember Guides recommend to
not use Bower anymore as well in the <a href="https://guides.emberjs.com/release/addons-and-dependencies/#toc_compiling-assets">Compiling Assets</a> section. Lastly, most addons have
dropped support for Bower as well.</p>
<p>Putting this all together, deprecating (and later on removing) Bower support
seems like the best path forward.</p>
<h2 id="transition-path-34"><a class="header" href="#transition-path-34">Transition Path</a></h2>
<h3 id="blueprintaddbowerpackagetoproject"><a class="header" href="#blueprintaddbowerpackagetoproject"><code>Blueprint::addBowerPackageToProject</code></a></h3>
<p>Adds a Bower package to the project's <code>bower.json</code> file.</p>
<p>When used, a deprecation message will be triggered suggesting to use
<a href="https://ember-cli.com/api/classes/blueprint#method_addPackageToProject">Blueprint::addPackageToProject</a> instead:</p>
<pre><code>`addBowerPackageToProject` has been deprecated. If the package is also available
on the npm registry, please use `addPackageToProject` instead. If not, please
suggest your users to install the Bower package manually by running:
`bower install &lt;package-name&gt; --save`.
</code></pre>
<p><strong>Deprecation details:</strong></p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>'ember-cli'</code></td></tr>
<tr><td><code>id</code></td><td><code>'ember-cli.blueprint.add-bower-package-to-project'</code></td></tr>
<tr><td><code>since</code></td><td><code>{ available: '4.X.X', enabled: '4.X.X' }</code></td></tr>
<tr><td><code>until</code></td><td><code>'5.0.0'</code></td></tr>
</tbody></table>
<h3 id="blueprintaddbowerpackagestoproject"><a class="header" href="#blueprintaddbowerpackagestoproject"><code>Blueprint::addBowerPackagesToProject</code></a></h3>
<p>Adds multiple Bower packages to the project's <code>bower.json</code> file.</p>
<p>When used, a deprecation message will be triggered suggesting to use
<a href="https://ember-cli.com/api/classes/blueprint#method_addPackagesToProject">Blueprint::addPackagesToProject</a> instead:</p>
<pre><code>`addBowerPackagesToProject` has been deprecated. If the packages are also available
on the npm registry, please use `addPackagesToProject` instead. If not, please
suggest your users to install the Bower packages manually by running:
`bower install &lt;package-name&gt; &lt;package-name&gt; --save`.
</code></pre>
<p><strong>Deprecation details:</strong></p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>'ember-cli'</code></td></tr>
<tr><td><code>id</code></td><td><code>'ember-cli.blueprint.add-bower-packages-to-project'</code></td></tr>
<tr><td><code>since</code></td><td><code>{ available: '4.X.X', enabled: '4.X.X' }</code></td></tr>
<tr><td><code>until</code></td><td><code>'5.0.0'</code></td></tr>
</tbody></table>
<h3 id="projectbowerdependencies"><a class="header" href="#projectbowerdependencies"><code>Project::bowerDependencies</code></a></h3>
<p>Returns the Bower dependencies (including the development dependencies) for the
project.</p>
<p>Addons that use this method, mostly do so to check the presence of a
specific Bower package in order to suggest users to use the npm equivalent
instead.</p>
<p>When used, the following deprecation message will be triggered:</p>
<pre><code>`bowerDependencies` has been deprecated. If you still need access to the
project's Bower dependencies, you will have to manually resolve the project's
`bower.json` file instead.
</code></pre>
<p><strong>Deprecation details:</strong></p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>'ember-cli'</code></td></tr>
<tr><td><code>id</code></td><td><code>'ember-cli.project.bower-dependencies'</code></td></tr>
<tr><td><code>since</code></td><td><code>{ available: '4.X.X', enabled: '4.X.X' }</code></td></tr>
<tr><td><code>until</code></td><td><code>'5.0.0'</code></td></tr>
</tbody></table>
<h3 id="projectbowerdirectory"><a class="header" href="#projectbowerdirectory"><code>Project::bowerDirectory</code></a></h3>
<p>Returns the project's Bower directory.</p>
<p>When used, the following deprecation message will be triggered:</p>
<pre><code>`bowerDirectory` has been deprecated. If you still need access to the
project's Bower directory, you will have to manually resolve the project's
`.bowerrc` file and read the `directory` property instead.
</code></pre>
<p><strong>Deprecation details:</strong></p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>'ember-cli'</code></td></tr>
<tr><td><code>id</code></td><td><code>'ember-cli.project.bower-directory'</code></td></tr>
<tr><td><code>since</code></td><td><code>{ available: '4.X.X', enabled: '4.X.X' }</code></td></tr>
<tr><td><code>until</code></td><td><code>'5.0.0'</code></td></tr>
</tbody></table>
<h3 id="building-bower-packages"><a class="header" href="#building-bower-packages">Building Bower Packages</a></h3>
<p>If Ember CLI detects that the project contains a Bower directory, it will try to
build a Broccoli tree with Bower packages.</p>
<p>When a Bower directory is detected, the following deprecation message will be
triggered:</p>
<pre><code>Building Bower packages has been deprecated. You have Bower packages in
`&lt;bower-directory&gt;`.
</code></pre>
<p>The deprecation message should be triggered when the <a href="https://github.com/ember-cli/ember-cli/blob/e747ac4c21a8e4a37e158a226dfa8ac048541b1f/lib/broccoli/default-packager.js#L630"><code>packageBower</code></a>
method is called.</p>
<p><strong>Deprecation details:</strong></p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>'ember-cli'</code></td></tr>
<tr><td><code>id</code></td><td><code>'ember-cli.building-bower-packages'</code></td></tr>
<tr><td><code>since</code></td><td><code>{ available: '4.X.X', enabled: '4.X.X' }</code></td></tr>
<tr><td><code>until</code></td><td><code>'5.0.0'</code></td></tr>
</tbody></table>
<h3 id="additional-tasks"><a class="header" href="#additional-tasks">Additional Tasks</a></h3>
<ul>
<li>Remove all Bower references from the <code>app</code> and <code>addon</code> blueprints</li>
</ul>
<h2 id="deprecation-guide-10"><a class="header" href="#deprecation-guide-10">Deprecation Guide</a></h2>
<h3 id="blueprintaddbowerpackagetoproject-1"><a class="header" href="#blueprintaddbowerpackagetoproject-1"><code>Blueprint::addBowerPackageToProject</code></a></h3>
<p><code>addBowerPackageToProject</code> has been deprecated. If the package is also available
on the npm registry, please use <code>addPackageToProject</code> instead. If not, please
suggest your users to install the Bower package manually by running:</p>
<pre><code>bower install &lt;package-name&gt; --save
</code></pre>
<h3 id="blueprintaddbowerpackagestoproject-1"><a class="header" href="#blueprintaddbowerpackagestoproject-1"><code>Blueprint::addBowerPackagesToProject</code></a></h3>
<p><code>addBowerPackagesToProject</code> has been deprecated. If the packages are also available
on the npm registry, please use <code>addPackagesToProject</code> instead. If not, please
suggest your users to install the Bower packages manually by running:</p>
<pre><code>bower install &lt;package-name&gt; &lt;package-name&gt; --save
</code></pre>
<h3 id="projectbowerdependencies-1"><a class="header" href="#projectbowerdependencies-1"><code>Project::bowerDependencies</code></a></h3>
<p><code>bowerDependencies</code> has been deprecated. If you still need access to the
project's Bower dependencies, you will have to manually resolve the project's
<code>bower.json</code> file instead:</p>
<pre><code class="language-js">'use strict';

const fs = require('fs-extra');
const path = require('path');

module.exports = {
  name: require('./package').name,

  included() {
    this._super.included.apply(this, arguments);

    let bowerPath = path.join(this.project.root, 'bower.json');
    let bowerJson = fs.existsSync(bowerPath) ? require(bowerPath) : {};
    let bowerDependencies = {
      ...bowerJson.dependencies,
      ...bowerJson.devDependencies,
    };

    // Do something with `bowerDependencies`.
  },
};
</code></pre>
<h3 id="projectbowerdirectory-1"><a class="header" href="#projectbowerdirectory-1"><code>Project::bowerDirectory</code></a></h3>
<p><code>bowerDirectory</code> has been deprecated. If you still need access to the
project's Bower directory, you will have to manually resolve the project's
<code>.bowerrc</code> file and read the <code>directory</code> property instead:</p>
<pre><code class="language-js">'use strict';

const fs = require('fs-extra');
const path = require('path');

module.exports = {
  name: require('./package').name,

  included() {
    this._super.included.apply(this, arguments);

    let bowerConfigPath = path.join(this.project.root, '.bowerrc');
    let bowerConfigJson = fs.existsSync(bowerConfigPath) ? fs.readJsonSync(bowerConfigPath) : {};
    let bowerDirectory = bowerConfigJson.directory || 'bower_components';

    // Do something with `bowerDirectory`.
  },
};
</code></pre>
<h3 id="building-bower-packages-1"><a class="header" href="#building-bower-packages-1">Building Bower Packages</a></h3>
<p>Building Bower packages has been deprecated.</p>
<p>Please consider one of the following alternatives:</p>
<ol>
<li>Install the package via the npm registry and use <code>ember-auto-import</code> to
import the package into your project</li>
<li>If alternative 1 is not an option, you could copy the contents of the Bower
package into the <code>/vendor</code> folder and use <code>app.import</code> to import the package
into your project</li>
</ol>
<h2 id="how-we-teach-this-153"><a class="header" href="#how-we-teach-this-153">How We Teach This</a></h2>
<p>The following references to Bower in the Ember Guides should be removed:</p>
<ul>
<li><a href="https://guides.emberjs.com/release/addons-and-dependencies/#toc_compiling-assets">Compiling Assets</a></li>
</ul>
<p>The following references to Bower in the Ember CLI Guides should be removed:</p>
<ul>
<li><a href="https://cli.emberjs.com/release/basic-use/assets-and-dependencies/#whereshouldassetsanddependenciesgo">Where Should Assets and Dependencies Go?</a></li>
<li><a href="https://cli.emberjs.com/release/advanced-use/debugging/#assetsanddependencies">Assets and Dependencies</a></li>
<li><a href="https://cli.emberjs.com/release/advanced-use/cli-commands-reference/#emberaddon">ember addon</a></li>
<li><a href="https://cli.emberjs.com/release/advanced-use/cli-commands-reference/#emberinit">ember init</a></li>
<li><a href="https://cli.emberjs.com/release/advanced-use/cli-commands-reference/#embernew">ember new</a></li>
<li><a href="https://cli.emberjs.com/release/writing-addons/addon-blueprints/#blueprinthooks">Blueprint Hooks</a></li>
<li><a href="https://cli.emberjs.com/release/appendix/dev-tools/#webstorm">WebStorm</a></li>
</ul>
<p>We should also make sure to remove all references to Bower in the
<a href="https://ember-cli.com/api/">Ember CLI API documentation</a>.</p>
<p><em>NOTE: It's possible that some references are not included in the lists above.</em></p>
<h2 id="drawbacks-170"><a class="header" href="#drawbacks-170">Drawbacks</a></h2>
<ul>
<li>Addons that still rely on a Bower package which does not yet have an npm
equivalent would need to suggest their users to manually install said package</li>
<li>Addons that still require access to the project's Bower dependencies, will
have to manually resolve the project's <code>bower.json</code> file instead</li>
<li>Addons that still require access to the project's Bower directory, will
have to manually resolve the project's <code>.bowerrc</code> file and read the <code>directory</code>
property instead</li>
<li>Projects that still import Bower packages will need to use one of the
suggested alternatives in the <a href="0772-deprecate-bower-support.html#building-bower-packages-1">Building Bower Packages</a>
deprecation guide</li>
</ul>
<h2 id="alternatives-172"><a class="header" href="#alternatives-172">Alternatives</a></h2>
<ul>
<li>Keep supporting Bower indefinitely</li>
</ul>
<h2 id="unresolved-questions-110"><a class="header" href="#unresolved-questions-110">Unresolved questions</a></h2>
<ul>
<li>Should a deprecation warning be displayed when the <code>--skip-bower</code> CLI flag is
used?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-11-11
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember CLI, Ember.js
RFC PR: https://github.com/emberjs/rfcs/pull/776</h2>
<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->
<h1 id="author-built-in-blueprints-in-typescript"><a class="header" href="#author-built-in-blueprints-in-typescript">Author Built-In Blueprints in TypeScript</a></h1>
<h2 id="summary-186"><a class="header" href="#summary-186">Summary</a></h2>
<p>In order to support both TypeScript and JavaScript as official languages in Ember, we should enable blueprints to be written in TypeScript and (optionally) transformed to JavaScript. We should also convert all of the existing built-in blueprints to TypeScript to take advantage of this new functionality and lay the groundwork for future TypeScript inclusion efforts.</p>
<h2 id="motivation-186"><a class="header" href="#motivation-186">Motivation</a></h2>
<p>Ember CLI's generators are a foundational part of Ember itself. They are one of the first elements of the developer experience that Ember prides itself on, and continue to be an essential part of the ecosystem by virtue of the fact that both apps and addons can generate their own custom blueprints. For many years, the <code>ember-cli-typescript</code> addon has provided its own set of TypeScript-flavored built-in blueprints that essentially act as drop-in replacement for the built-in blueprints that provide with Ember today. However, these blueprints have proven very difficult to maintain as it involves keeping them all up to date with every single change made to Ember itself, so much so that the current TypeScript blueprints have diverged to the point there is currently not a TypeScript blueprint for components at all.</p>
<p>As part of the larger effort to <a href="https://github.com/emberjs/rfcs/pull/724">make Typescript an officially supported language in Ember</a>, Ember should provide a single set of blueprints that will support both JavaScript and TypeScript. These new blueprints would be written in TypeScript, and would provide exactly the same JavaScript experience that today's users enjoy, while also providing several benefits over the current system:</p>
<ol>
<li>Remove the disconnect between TypeScript and JavaScript blueprints discussed above, as the Typed Ember team would no longer be responsible for maintaining an entirely independent set of blueprints.</li>
<li>Allow for multiple versions of TypeScript blueprints to exist (since they'd belong to each version of Ember), rather than today where there is no way to tie standalone TypeScript blueprints to individual versions of Ember (e.g. there's no LTS version of the TypeScript blueprints today).</li>
<li>Enable TypeScript blueprint generation in any Ember app or addon right out of the box via a <code>--typescript</code> flag.</li>
<li>Enable addon authors to better support TypeScript users by allowing them to publish their own TypeScript blueprints without concern for also supporting JavaScript users.</li>
</ol>
<p>Note that this does <strong>not</strong> mean that we should generate TypeScript by default, but rather that the blueprints themselves should <em>begin</em> as TypeScript before actually being reified as actual code. By default, all of the Ember generators would still behave exactly as they do today: by generating JavaScript files. This RFC is primarily concerned with TypeScript as an <em>implementation detail</em> for the existing blueprints, rather than being prescriptive about whether or not users should adopt TypeScript themselves.</p>
<h2 id="detailed-design-151"><a class="header" href="#detailed-design-151">Detailed design</a></h2>
<p>tl;dr: Blueprints will be handled exactly the same as before, with the one exception that any blueprint file written in TypeScript will be run through Babel's <a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript"><code>@babel/plugin-transform-typescript</code></a> to strip out all the TypeScript syntax unless the user actually wants TypeScript output. Please read on for a more detailed explanation.</p>
<p>In the current generator system, new files are created from templates that reside in the <code>files</code> directory of the blueprint that corresponds to the generator that was invoked. When a user runs <code>ember generate service foo</code>, Ember CLI will locate the template at <code>blueprints/service/files/__root__/__path__/__name__.js</code>, load it into memory, perform a text replacement on all of the EJS-style tags (e.g. <code>class &lt;%= classifiedModuleName =&gt; extends Service</code> becomes <code>class Foo extends Service</code>), and then writes the entire string out to a file at the correct path inside the parent app or addon. Notably, there is no evaluation of the code itself, as the entire process of blueprint generation is simple text replacement.</p>
<p>In the new version of Ember's blueprint system, this template would instead be named <code>__name__.ts</code>. The generator process would run identically (locate the template, read into memory, perform text replacement) up until it is actually time to <em>write</em> the file. Before that occurs, the (now fully populated) in-memory version of the newly generated file would be run through Babel's <a href="https://babeljs.io/docs/en/babel-plugin-transform-typescript"><code>@babel/plugin-transform-typescript</code></a>. This would strip the file of all TypeScript-related syntax, resulting in a completely valid JavaScript file with no evidence that it had begun as TypeScript file. In this way, we're able to ensure that the built-in generators would continue to perform as exactly as they have previously.</p>
<p>Furthermore, blueprints would have to explicitly opt-in to this behavior by adding a <code>shouldTransformTypeScript: true</code> flag to the blueprint's <code>index.js</code> file. This will make the automatic TypeScript transform behavior purely opt-in, thereby preventing any conflicts with existing projects that may already have their own custom TypeScript blueprints.</p>
<p>In addition to the per-blueprint flag, there will also be a new <code>isTypeScriptProject</code> flag added to <code>.ember-cli</code> that will allow users to mark an entire Ember app or addon as a TypeScript-first project. The presence of this flag would indicate that blueprints should output TypeScript by default, rather than JavaScript as they normally would. Flags specified in <code>.ember-cli</code> are automatically merged into the blueprint options when invoked, so this flag would be readily accessible to all blueprints. We'd also add a step to the <code>init</code> hook for <code>ember-cli-typescript</code> that would check for the presence of this flag in <code>.ember-cli</code> and warn if it's not set. In the future, we'd be able to set this flag as part of a <code>ember new --typescript</code> flag.</p>
<p>There are a few details worth calling out about this change to the generation process:</p>
<ol>
<li>While the TypeScript files are parsed and transformed, they are <em>not</em> type-checked in any way. The Babel plugin is concerned solely with the transformation of TypeScript syntax into JavaScript syntax and does not pay any attention to what the types actually are. This is a good thing, as it minimizes any performance cost during the generation process and we'd expect any actual type-checking to happen at compilation time in the user's app, using their own <code>tsconfig</code> rather than one we'd have to supply (and maintain).
<ol>
<li>In the future, we DO also need the ability to test the actual TypeScript parts of the blueprints (i.e. do the blueprints output TS files that actually type-check?), but that functionality will be covered in a later RFC that is more concerned with enabling TypeScript support in Ember.</li>
</ol>
</li>
<li>By default, the generators would behave exactly as they did before. However, we would also add a <code>--typescript</code> flag to the <code>generate</code> command that tells the generator to simply bypass the Babel transform and instead output TypeScript directly. Since TypeScript is a superset of JavaScript, we're able to easily accomodate both sets of users with a single blueprint file by starting out with the &quot;higher-fidelity&quot; TypeScript and down-leveling it JavaScript when needed.</li>
<li>Addon authors would be able to provide blueprints written in TypeScript that would &quot;just work&quot; in the same way that the built-in blueprints would, e.g. they'd get support for both JavaScript and TypeScript versions of their blueprints with no additional effort or maintenance.</li>
<li>No one is <em>required</em> to write their blueprints in TypeScript. Any blueprint written in JavaScript would be handled in the exact same way that they are today.</li>
</ol>
<p>To sum up, the changes would be as follows:</p>
<ul>
<li>Rewrite Ember's existing blueprints in TypeScript.</li>
<li>Add a <code>--typescript</code> flag to <code>ember generate</code> that will force the command to output TypeScript instead of JavaScript (assuming a TypeScript blueprint exists).</li>
<li>Add a <code>shouldTransformTypeScript</code> flag to the <code>Blueprint</code> base class that opts the blueprint in to the down-leveling behavior.
<ul>
<li>This defaults to <code>false</code>.</li>
<li>This flag exists so that blueprint authors can choose whether they want the auto-transform behavior in case there are already apps/addons that have custom blueprints they expect to always result in TypeScript files.</li>
</ul>
</li>
<li>Add a <code>isTypeScriptProject</code> flag to <code>.ember-cli</code> that can be used to determine whether to generate TypeScript or JavaScript by default.
<ul>
<li>This flag defaults to <code>false</code>.</li>
<li>If <code>isTypeScriptProject</code> is <code>true</code>, <code>ember g component foo</code> would generate a TypeScript file, otherwise it will generate a JavaScript file.</li>
<li>Users can override this default behavior by passing the <code>--typescript</code> flag (mentioned above), which will force the blueprint to output TypeScript as long as a TypeScript blueprint is available.</li>
</ul>
</li>
</ul>
<h2 id="how-we-teach-this-154"><a class="header" href="#how-we-teach-this-154">How we teach this</a></h2>
<p>For most users, there isn't much to teach here since their default experience with Ember's blueprints won't change at all. However, we should document the typescript-related behaviors in the <a href="https://cli.emberjs.com/release/advanced-use/blueprints/">documentation for creating custom blueprints.</a> More specifically, we'd need to mention the 3 new flags being added (<code>shouldTransformTypeScript</code>, <code>isTypeScriptProject</code>, and <code>--typescript</code>) and explain their usage.</p>
<h2 id="drawbacks-171"><a class="header" href="#drawbacks-171">Drawbacks</a></h2>
<p>There should be little to no impact on the end-user as a result of the changes proposed in the RFC. The one drawback worth mentioning is that this change does introduce additional memory and performance overhead as a result of running the files through Babel transforms when converting from TypeScript to JavaScript.</p>
<p>That said, Ember (and most of the front-end world) already relies heavily on Babel, so this change would simply be extending a dependency that already exists. Furthermore, while there <em>is</em> a cost to running a Babel transform as part of a generator, it will be extremely trivial given that generators only ever create a handful of files at a time, and a newly-generated Ember app runs <em>far</em> more files through many more Babel transforms without issue. Finally, we'd be running the transform on the in-memory version of the file, so there'd be no additional I/O cost incurred.</p>
<h2 id="alternatives-173"><a class="header" href="#alternatives-173">Alternatives</a></h2>
<p>We could continue to maintain a wholly independent set of blueprint files, a la <a href="https://github.com/typed-ember/ember-cli-typescript-blueprints"><code>ember-cli-typescript-blueprints</code></a>. However, this would leave us with the same challenges that exist today, and would also make it harder to provide official support for TypeScript in Ember itself.</p>
<h2 id="unresolved-questions-111"><a class="header" href="#unresolved-questions-111">Unresolved questions</a></h2>
<blockquote>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-12-03
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember.js, Learning, Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/779</h2>
<h1 id="first-class-component-templates"><a class="header" href="#first-class-component-templates">First-Class Component Templates</a></h1>
<h2 id="summary-187"><a class="header" href="#summary-187">Summary</a></h2>
<p>Adopt <code>&lt;template&gt;</code> tags as a format for making component templates first-class participants in JavaScript and TypeScript with <a href="https://emberjs.github.io/rfcs/0496-handlebars-strict-mode.html">strict mode</a> template semantics. In support of the new syntax, adopt new custom JavaScript and TypeScript files with the extensions <code>.gjs</code> and <code>.gts</code> respectively.</p>
<p>First-class component templates address a number of pain points in today’s component authoring world, and provide a number of new capabilities to Ember and Glimmer users:</p>
<ul>
<li>
<p>accessing local JavaScript values with no ceremony and no backing class, enabling much easier use of existing JavaScript ecosystem tools, including especially styling libraries—standard <a href="https://github.com/css-modules/css-modules">CSS Modules</a> will “just work,” for example</p>
</li>
<li>
<p>authoring more than one component in a single file, where colocation makes sense—and thereby providing more control over a component’s public API</p>
</li>
<li>
<p>likewise authoring locally-scoped helpers, modifiers, and other JavaScript functionality</p>
</li>
</ul>
<p>First-class component templates offer these new capabilities while not only maintaining but <em>improving</em> Ember’s long-standing commitment to integrated testing, in that it allows app and test code to share a single authoring paradigm—substantially simplifying our teaching story. Similarly, it preserves Ember’s long-standing commitment to treating JavaScript and HTML (and CSS!) as distinctive concerns which, however closely related, are not the <em>same</em>.</p>
<details><summary>Full-fledged example showing how this might work in practice</summary>
<p>Two notes:</p>
<ul>
<li>
<p>For this and all the examples in the RFC, I assume <a href="https://github.com/emberjs/rfcs/pull/757">RFC #0757: Default Modifier Manager</a> for simplicity, but it does not meaningfully change <em>this</em> proposal.</p>
</li>
<li>
<p>The syntax highlighting here is a mess… but that's because GitHub still doesn't have good highlighting for <em>decorators</em>. Samples which have <code>&lt;template&gt;</code> but <em>not</em> <code>@tracked</code> actually already highlight decently well.</p>
</li>
</ul>
<pre><code class="language-js">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

const Greet = &lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) =&gt; {
    this.name = value;
  }

  saveName = (submitEvent) =&gt; {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  &lt;template&gt;
    &lt;form {{on &quot;submit&quot; this.saveName}}&gt;
      &lt;label for='name'&gt;Set username:&lt;/label&gt;
      &lt;input
        id='name'
        value={{this.value}}
        {{on &quot;input&quot; this.updateName}}
      /&gt;
      &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
        Generate
      &lt;/button&gt;
    &lt;/form&gt;
  &lt;/template&gt;
}

function replaceLocation(el, { with: newUrl }) {
  el.contentWindow.location.replace(newUrl);
}

export default class GenerateAvatar extends Component {
  @tracked name = &quot;&quot;;

  get previewUrl() {
    return `http://www.example.com/avatars/${name}`;
  }

  updateName = (newName) =&gt; {
    this.name = newName;
  };

  &lt;template&gt;
    &lt;Greet @name={{this.name}} /&gt;
    &lt;SetUsername
      @name={{this.name}}
      @onSaveName={{this.updateName}}
    /&gt;
    
    {{#if (gt 0 this.name.length)}}
      &lt;iframe
        title='Preview'
        {{replaceLocation with=this.previewUrl}}
      &gt;
    {{/if}}
  &lt;/template&gt;
}
</code></pre>
</details>
<h3 id="contents"><a class="header" href="#contents">Contents <!-- omit in toc --></a></h3>
<ul>
<li><a href="0779-first-class-component-templates.html#summary">Summary</a></li>
<li><a href="0779-first-class-component-templates.html#motivation">Motivation</a>
<ul>
<li><a href="0779-first-class-component-templates.html#namespaces-and-modules">Namespaces and Modules</a></li>
<li><a href="0779-first-class-component-templates.html#scope">Scope</a></li>
<li><a href="0779-first-class-component-templates.html#ecosystem-integration">Ecosystem integration</a></li>
<li><a href="0779-first-class-component-templates.html#testing">Testing</a></li>
<li><a href="0779-first-class-component-templates.html#the-solution">The solution</a></li>
<li><a href="0779-first-class-component-templates.html#constraints">Constraints</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#detailed-design">Detailed design</a>
<ul>
<li><a href="0779-first-class-component-templates.html#compilation">Compilation</a>
<ul>
<li><a href="0779-first-class-component-templates.html#standalone">Standalone</a></li>
<li><a href="0779-first-class-component-templates.html#bound-to-a-name">Bound to a name</a></li>
<li><a href="0779-first-class-component-templates.html#class-body">Class body</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#performance">Performance</a></li>
<li><a href="0779-first-class-component-templates.html#interop">Interop</a>
<ul>
<li><a href="0779-first-class-component-templates.html#named-exports">Named exports</a></li>
<li><a href="0779-first-class-component-templates.html#non-colocated-templates">Non-colocated templates</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#the-prelude">The “prelude”</a></li>
<li><a href="0779-first-class-component-templates.html#tooling">Tooling</a>
<ul>
<li><a href="0779-first-class-component-templates.html#syntax-highlighting">Syntax highlighting</a></li>
<li><a href="0779-first-class-component-templates.html#blueprints">Blueprints</a></li>
<li><a href="0779-first-class-component-templates.html#linting-and-formatting">Linting and formatting</a></li>
<li><a href="0779-first-class-component-templates.html#language-server-support">Language server support</a></li>
<li><a href="0779-first-class-component-templates.html#codemod">Codemod</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#typescript">TypeScript</a></li>
<li><a href="0779-first-class-component-templates.html#custom-file-extension">Custom file extension</a></li>
<li><a href="0779-first-class-component-templates.html#spec">Spec</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#transition-path">Transition path</a></li>
<li><a href="0779-first-class-component-templates.html#how-we-teach-this">How we teach this</a>
<ul>
<li><a href="0779-first-class-component-templates.html#guides">Guides</a>
<ul>
<li><a href="0779-first-class-component-templates.html#tutorial">Tutorial</a></li>
<li><a href="0779-first-class-component-templates.html#core-concepts-components">Core Concepts: Components</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#api-docs">API Docs</a></li>
<li><a href="0779-first-class-component-templates.html#existing-ember-users">Existing Ember users</a></li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#drawbacks">Drawbacks</a></li>
<li><a href="0779-first-class-component-templates.html#alternatives">Alternatives</a>
<ul>
<li><a href="0779-first-class-component-templates.html#typescript-signature">TypeScript signature</a></li>
<li><a href="0779-first-class-component-templates.html#distinguishing-class-backed-and-template-only-components">Distinguishing class-backed and template-only components</a></li>
<li><a href="0779-first-class-component-templates.html#alternative-syntaxes">Alternative syntaxes</a>
<ul>
<li><a href="0779-first-class-component-templates.html#imports-only">Imports-only</a></li>
<li><a href="0779-first-class-component-templates.html#sfcs">SFCs</a></li>
<li><a href="0779-first-class-component-templates.html#template-literals-hbs">Template literals (<code>hbs</code>)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="0779-first-class-component-templates.html#unresolved-questions">Unresolved questions</a></li>
</ul>
<h2 id="motivation-187"><a class="header" href="#motivation-187">Motivation</a></h2>
<p>Today, authors of Ember and Glimmer apps and libraries must author their templates and JavaScript in separate <code>.hbs</code> and <code>.js</code> files, and the templates exist in a “resolution” mode where every component, helper, and modifier exists in a single global namespace. This has a number of significant downsides. What’s more, there are significant new capabilities for Ember and Glimmer authors made available by embracing JavaScript scope—while keeping our commitments to testing and separation of concerns.<sup class="footnote-reference"><a href="#original-primitives-rfc">1</a></sup></p>
<div class="footnote-definition" id="original-primitives-rfc"><sup class="footnote-definition-label">1</sup>
<p>See also <a href="https://github.com/emberjs/rfcs/blob/tomdale/template-primitives/text/000-sfc-and-template-import-primitives.md">the SFC &amp; Template Import Primitives RFC</a>, which described the motivation for implementing the primitives on which this proposal will build.</p>
</div>
<h3 id="namespaces-and-modules"><a class="header" href="#namespaces-and-modules">Namespaces and Modules</a></h3>
<p>First, because of the global namespace, name conflicts are common, and avoiding them requires either manually namespacing components or using (now-deprecated) experimental tools like <a href="https://github.com/rwjblue/ember-holy-futuristic-template-namespacing-batman"><code>ember-holy-futuristic-template-namespacing-batman</code></a>. But:</p>
<ul>
<li>
<p>Manually namespacing is clunky and does not actually <em>guarantee</em> there won't be conflicts. Combined with the way addons typically supply their components, helpers, and modifiers into the app namespace, name conflicts are sometimes unavoidable.</p>
</li>
<li>
<p>Even the workaround via <code>ember-holy-futuristic-template-namespacing-batman</code> requires using different names for modules in Ember than their Node package name when the Node package uses <a href="https://docs.npmjs.com/cli/v8/using-npm/scope">npm scopes</a>. (This was one of the original motivations for exploring a design which leverages JavaScript modules, in fact!) Since our resolution modes must ultimately deal in JavaScript terms, we are in the position of always potentially being one ecosystem shift away from another syntax conflict with template-language-only designs for managing scope.</p>
</li>
<li>
<p>It requires our tooling to understand Ember's resolution rules, and our tooling cannot take advantage of existing ecosystem tooling. Our language servers, for example, have to more or less re-implement Ember’s resolver themselves.</p>
</li>
<li>
<p>There is a substantial performance cost to dynamically resolving components by name at runtime. This can be mitigated by using the combination of something like <code>ember-holy-futuristic-template-namespacing-batman</code> with the <a href="https://github.com/stefanpenner/ember-strict-resolver">strict resolver</a>, but the strict resolver is not standard—and really cannot be without something like this proposal.<sup class="footnote-reference"><a href="#strict-resolver-rfc">2</a></sup></p>
</li>
<li>
<p>It is extremely unpleasant (though, strictly speaking, <em>possible</em> as of Ember 3.25<sup class="footnote-reference"><a href="#verbose-local">3</a></sup>) to introduce a component, helper, or modifier which is not in the global namespace. See the next section, <a href="0779-first-class-component-templates.html#scope"><strong>Scope</strong></a>, for further on this.</p>
</li>
</ul>
<p>The global namespace also comes with overhead for our teaching story by introducing a layer of “magic”: people just have to memorize that a file with a default export in a given location <em>automagically</em> is available with a given name. This is just a “bare fact”: there is nothing to connect it to in terms of a developers’ existing JavaScript or HTML knowledge.</p>
<p>These problems are all well-solved already, using the JavaScript modules spec (or &quot;ESM&quot;, for ECMAScript Modules). Today, however Ember developers cannot take advantage of those or the tooling which understands them!</p>
<div class="footnote-definition" id="strict-resolver-rfc"><sup class="footnote-definition-label">2</sup>
<p>See the still-open <a href="https://github.com/emberjs/rfcs/pull/683">RFC #0683</a> for a discussion of the full set of concerns involved in resolution, which include but are not limited to the template concerns addressed here.</p>
</div>
<div class="footnote-definition" id="verbose-local"><sup class="footnote-definition-label">3</sup>
<p>In all cases, doing so requires introducing a backing class to make the value available to the template <em>or</em> writing Ember's strict mode template syntax manually (which is error-prone and extremely verbose: it is designed as an output format, not an authoring format).</p>
</div>
<h3 id="scope-2"><a class="header" href="#scope-2">Scope</a></h3>
<p>Second, and closely related to the global namespace problem: there is presently no good way for users to introduce or use locally-scoped code. Every component, helper, and modifier must live in its own file, and be globally available—even if it is meant to be used privately. Where JavaScript modules provide users to control their public APIs in terms of <code>export</code>s, Ember apps largely cannot take advantage of exports for anything which interacts with the template layer.</p>
<p>In practice, this has a number of knock-on effects for Ember code.</p>
<p>First, components tend to grow without bound, because the equivalent of the &quot;extract method&quot; or &quot;extract into new class&quot; refactors (which we commonly use on the JS side) end up with two downsides:</p>
<ul>
<li>they make the newly-extracted components available to the whole app, even if the concern is private to that component</li>
<li>the require an entirely new file, which is friction both for the creation and the use/understanding of a given view</li>
</ul>
<p>Second, users also often introduce classes with actions or getters where a simple <a href="https://github.com/emberjs/rfcs/pull/756">function-based helper</a> would do, because that is the only way to provide a non-global function. (I show this by example in <a href="0779-first-class-component-templates.html#reusable-components"><strong>How We Teach This: Guides: Tutorial: Reusable Components</strong></a> below.)</p>
<p>Third, it likewise incentivizes the use of the ember-render-modifiers with backing classes, rather than custom modifiers, because the behavior can then be scoped to that module—whereas, again, a custom modifier would be in global scope. This in turn makes it easy for users to miss the helpful separation of concerns which custom modifiers enable.</p>
<p>Over time, these all lead to a proliferation of backing classes which are only present to work around the fact that we have no <em>other</em> way to provide non-global scope for our components. These classes in turn tend to act as “state attractors,” leading to an unnecessary proliferation of state throughout an app or addon.</p>
<h3 id="ecosystem-integration"><a class="header" href="#ecosystem-integration">Ecosystem integration</a></h3>
<p>Tools which assume they will be used in JavaScript contexts more or less don’t work with our templates today, because the templates have no way to access them. Think of CSS tools like <a href="https://github.com/css-modules/css-modules">CSS Modules</a>, which is widely used in the Ember ecosystem via <a href="https://github.com/salsify/ember-css-modules">Ember CSS Modules</a>: our current implementation has to jump through many hoops and do many hacks to work at all. These problems are fundamental to the current model. A format which makes JavaScript values available in template scope would let us drop <em>all</em> of that special sauce—and this goes for <em>all</em> such JavaScript-side tooling.<sup class="footnote-reference"><a href="#other-css-tools">4</a></sup></p>
<div class="footnote-definition" id="other-css-tools"><sup class="footnote-definition-label">4</sup>
<p>The same applies to all other similar tools, e.g. <a href="https://emotion.sh/docs/@emotion/css">Emotion</a>, <a href="https://styled-components.com">Styled Components</a>, <a href="https://vanilla-extract.style">vanilla-extract</a>: none of them work out of the box with our current design. Whatever anyone’s personal opinions on these specific, they’re potentially-valuable tools which are barely or not at all usable in Ember today.</p>
</div>
<h3 id="testing-2"><a class="header" href="#testing-2">Testing</a></h3>
<p>Finally, the authoring format for tests and the authoring format for app code today is completely different. A test can render a component by calling the <code>render()</code> function from <code>@ember/test-helpers</code> and passing it a Handlebars string.<sup class="footnote-reference"><a href="#testing-rfc">5</a></sup> App code <em>cannot</em> do this or anything like it. This has teaching overhead: we both <em>can</em> do things in tests we <em>cannot</em> do in app code, raising the obvious “but why not?”; and we also <em>must</em> do things in tests we do not <em>need</em> to do in app code.</p>
<p>Additionally, introducing test-only components is quite painful, requiring use of the <code>this.owner.register()</code> functionality, and therefore requiring users to understand at least some of Ember’s custom runtime resolution (as well as learning a microsyntax for it<sup class="footnote-reference"><a href="#microsyntax">6</a></sup>). What's more, authoring a <em>template</em> for a test-only component is undocumented and is also entirely unlike the story for authoring templates for app components.</p>
<div class="footnote-definition" id="testing-rfc"><sup class="footnote-definition-label">5</sup>
<p>The test helper <code>render()</code> also does not actually render components today—but the <em>mental model</em> is that it does. See <a href="https://github.com/emberjs/rfcs/pull/785">RFC #0785</a> which will allow <code>render</code> to work not only with templates (the <em>status quo</em>) but also with components. This will be an independent change which helps eliminate a number of quirks in the testing infrastructure today as well as make it more TypeScript friendly, but it complements <em>this</em> RFC by allowing local definition of tests.</p>
</div>
<div class="footnote-definition" id="microsyntax"><sup class="footnote-definition-label">6</sup>
<p>made that much more bespoke since <a href="https://emberjs.github.io/rfcs/0585-improved-ember-registry-apis.html">RFC #0585</a> is accepted but not yet implemented</p>
</div>
<h3 id="the-solution"><a class="header" href="#the-solution">The solution</a></h3>
<p>To address these problems, the Ember community <a href="https://github.com/emberjs/rfcs/pull/454">proposed primitives</a> which unlocked experimentation in this space and <a href="https://emberjs.github.io/rfcs/0496-handlebars-strict-mode.html">defined the semantics of “strict” templates which use those primitives</a> and <a href="https://emberjs.github.io/rfcs/0432-contextual-helpers.html">made modifers and helpers first-class citizens of templates</a>. Now, with a history of having done that experimentation—with <a href="https://glimmerjs.github.io/glimmer-experimental/">GlimmerX</a> and <a href="https://github.com/ember-template-imports/ember-template-imports">ember-template-imports</a>—and having had <em>many</em> discussions about the trade-offs over the years, it’s time to ship a proposal which resolves these questions: <strong>first-class component templates</strong>.</p>
<p>In this new world, templates are authored in JavaScript files with a <code>&lt;template&gt;</code> tag. Templates defined this way have normal Glimmer template semantics, but instead of using a runtime resolution strategy, they have access to values in JavaScript scope, which means they can just use normal JavaScript imports. What's more, they can define other local components, helpers, or modifiers and export them or not as makes sense. They can do the same kind of extraction refactors they do with JavaScript or CSS. And other tools from the JavaScript ecosystem “just work”—from custom CSS tooling to GraphQL queries authored with <a href="https://www.apollographql.com/docs/react/data/queries/">Apollo Client’s <code>graphql</code> template strings</a> and anything else the ecosystem comes up with.</p>
<p>At the same time, since the body of a template defined with a <code>&lt;template&gt;</code> tag has all the same rules as Glimmer templates do today, this new authoring format keeps all the goodness of today’s clear separation of concerns between HTML and JavaScript and CSS. That means it continues to empower developers who are HTML and CSS experts and reach for JavaScript only secondarily. Indeed, the design goes out of its way to make HTML/Handlebars-only files feel like first-class citizens.</p>
<p>Finally, introducing <code>&lt;template&gt;</code> completely unifies the story between app and test code: in this new world, introducing a test-only component is as simple as introducing any other component in the same file as an existing component.</p>
<p>In sum, <code>&lt;template&gt;</code> resolves each problem outlined above, and introduces new capabilities to boot.</p>
<h3 id="constraints-1"><a class="header" href="#constraints-1">Constraints</a></h3>
<p>There are a number of solutions which could address these needs and add these capabilities. This RFC proposes <code>&lt;template&gt;</code> out of all the possible options because I take the following constraints as guiding the design decision (and the ordering here is purposeful—items earlier in the list I judge to be more important than items later in the list):</p>
<ol>
<li>
<p>Our choice of design <strong>must not regress our ability to write tests</strong>, and if it is possible to <em>improve</em> our testing story, we should take the opportunity to do so.</p>
</li>
<li>
<p>In the absence of hard technical constraints forbidding it, we should <strong>prefer the solution which has the best story for teaching</strong>—at all levels, including beginners but also supporting advanced users. In particular, this means that we should value both <em>progressive disclosure of complexity</em> and the <em>principle of least surprise</em>, and that we may need to weight them against each other, but that we should pay particular attention when they agree.</p>
</li>
<li>
<p>This design must cleanly interoperate with existing Ember code bases. That is, adopting this <strong>must not require users to migrate their entire code base at once</strong>.</p>
</li>
<li>
<p>We should <strong>prefer a design which provides more flexibility</strong> to end users over a design which provides less.</p>
</li>
</ol>
<p>While it is certainly possible to differ with these constraints <em>a priori</em>—reevaluating constraints is, in a very real sense, <a href="https://github.com/emberjs/rfcs/pull/367#issuecomment-423839940">how we got to this very RFC</a>—we also run the risk of paralysis if we <em>continually</em> reevaluate from first principles. More challenging is inevitable disagreement about how we <em>weight</em> these constraints. On that front, there is no possibility of <em>final</em> agreement, but we should commit to some ordering for the purposes of this design so that the rest of it can proceed on the same terms.</p>
<h2 id="detailed-design-152"><a class="header" href="#detailed-design-152">Detailed design</a></h2>
<p>Introduce a new high-level syntax, the <code>&lt;template&gt;</code> tag, which is syntactical sugar for <code>setComponentTemplate</code> and <code>precompileTemplate</code>, in conjunction with the existing Ember and Glimmer <code>Component</code> classes and the special template-only component class returned by the <code>templateOnlyComponent</code> default export from <code>@ember/component/template-only</code>.</p>
<p>There are three distinct, legal forms for this compilation:</p>
<ul>
<li>a standalone <code>&lt;template&gt;</code> at the top level of a module</li>
<li>a <code>&lt;template&gt;</code> bound to a name</li>
<li>in the body of a component class</li>
</ul>
<p>For a discussion of the <code>setComponentTemplate</code> and <code>templateOnlyComponent</code> primitives, see <a href="https://emberjs.github.io/rfcs/0481-component-templates-co-location.html">RFC #0481</a>; for discussion of the <code>precompileTemplate</code> primitive, see <a href="https://emberjs.github.io/rfcs/0496-handlebars-strict-mode.html">RFC #0496</a>. This discussion will <em>assume</em> rather than <em>define</em> those. Additionally, I leave aside here the further build-time passes which transform <code>precompileTemplate</code> invocations into a precompiled template in “wire format” ready for use by the Glimmer VM, as that is not affected by the authoring format.</p>
<h3 id="compilation"><a class="header" href="#compilation">Compilation</a></h3>
<p>The value produced by authoring a <code>&lt;template&gt;</code> is a <em>JavaScript value</em>, and accordingly may be exported, bound to other values, passed as an argument to a function or set as a value on a class, and so on. However, that value is not <em>dynamic</em>. Instead, it is compiled statically to a format targeting the Glimmer VM at compile time, such that even the <code>precompileTemplate</code> invocations are removed in favor of the wire format, which itself may be further optimized or changed in the future.</p>
<p>Therefore, in normal app or addon code, it is nonsensical to reassign it when bound with a <code>let</code> binding: changing the value bound to the <code>let</code> will <em>not</em> result in Ember’s reevaluating anything which <em>uses</em> that value: the “scope” of a template is only ever computed once, for performance reasons.</p>
<p>A function may of course return different components based on its arguments, etc.; but such a function will not be “automatically” re-executed unless the function consumes tracked properties. (This is just applying the standard auto-tracking semantics to functions which return components, which is possible <em>today</em>.) I discuss below the performance pitfalls of doing this inline, and the corresponding guidance we should provide.</p>
<p>Apps or addons which want to compile arbitrary components at runtime are the exception to static component definition as described here. Most apps and addons will <em>not</em> want to do this, because it is expensive and slow and also a security risk in that it allows arbitrary code execution within your app. However, there <em>are</em> good use cases, e.g. dynamic online environments like the <a href="https://glimmerjs.github.io/glimmer-experimental/">GlimmerX playground</a> or the <a href="https://limber.glimdown.com/">Limber Editor</a>, or documentation tooling like <a href="https://storybook.js.org">Storybook</a>.</p>
<p>These kinds of apps and integrations can integrate the template compiler as a runtime dependency and build new templates on the fly. However, the details of doing that are unrelated to providing first-class component templates and do not change as a result of this RFC. The scope remains static for any given <code>&lt;template&gt;</code> declaration after compilation; the difference there is that they are intentionally re-executing the compilation step itself.</p>
<h4 id="standalone"><a class="header" href="#standalone">Standalone</a></h4>
<p>The compiled output for a top-level <code>&lt;template&gt;</code> tag is a default export. This means that the very common case of having a simple template-only component looks basically just like HTML, wrapped in <code>&lt;template&gt;</code>, helping us provide a strong <em>progressive disclosure of complexity</em> flow to our design and our pedagogy. It also means that the basic code Ember developers use today changes very little for the most basic version of the new format. Given this input:</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>The compiled output is:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

export default setComponentTemplate(
  precompileTemplate(`
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
  `,
    {
      strictMode: true,
    }
  ),
  templateOnlyComponent()
);
</code></pre>
<p>If the <code>&lt;template&gt;</code> references values in scope, they will be included in an object with a <code>scope</code> argument (shown here using the current implementation of the underlying primitives). Thus, this definition—</p>
<pre><code class="language-js">function isBirthday(dateOfBirth) {
  const today = new Date();
  return (
    today.getMonth() === dateOfBirth.getMonth() &amp;&amp;
    today.getDate() === dateOfBirth.getDate()
  );
}

&lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
  {{#if (isBirthday @dateOfBirth)}}
    &lt;p&gt;Happy birthday! 🎈&lt;/p&gt;
  {{/if}}
&lt;/template&gt;
</code></pre>
<p>—compiles to this output:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

function isBirthday(dateOfBirth) {
  const today = new Date();
  return (
    today.getMonth() === dateOfBirth.getMonth() &amp;&amp;
    today.getDate() === dateOfBirth.getDate()
  );
}

export default setComponentTemplate(
  precompileTemplate(`
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
  {{#if (isBirthday @dateOfBirth)}}
    &lt;p&gt;Happy birthday! 🎈&lt;/p&gt;
  {{/if}}
  `,
    {
      strictMode: true,
      scope: () =&gt; ({ isBirthday }),
    }
  ),
  templateOnlyComponent()
);
</code></pre>
<p>Since the values in scope use normal JavaScript semantics, this means that imports also “just work”. Thus, if we extracted <code>isBirthday</code> into a separate file for reuse elsewhere, we could import and use it like this:</p>
<pre><code class="language-js">import { isBirthday } from '../utils/user';

&lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
  {{#if (isBirthday @dateOfBirth)}}
    &lt;p&gt;Happy birthday! 🎈&lt;/p&gt;
  {{/if}}
&lt;/template&gt;
</code></pre>
<p>The compiled output would be just the same as before, save using the imported value:</p>
<pre><code class="language-js">import { isBirthday } from '../utils/user';
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

export default setComponentTemplate(
  precompileTemplate(`
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
  {{#if (isBirthday @dateOfBirth)}}
    &lt;p&gt;Happy birthday! 🎈&lt;/p&gt;
  {{/if}}
  `,
    {
      strictMode: true,
      scope: () =&gt; ({ isBirthday }),
    }
  ),
  templateOnlyComponent()
);
</code></pre>
<p>Since the compiled output is a default export, it is a static error to have multiple top-level (i.e. not bound to a name) <code>&lt;template&gt;</code>s in a file—because it is a static error to have multiple <code>export default</code> statements in a JavaScript file. We should provide a lint rule to error on this case, rather than letting it fail at build or runtime.</p>
<h4 id="bound-to-a-name"><a class="header" href="#bound-to-a-name">Bound to a name</a></h4>
<p>A standalone first-class template can also be bound to a name in the module. This allows users to provide locally-scoped modules as well as a single default export, as well as to use modules as a way of grouping related functionality or hiding private functionality while still being able to refactor and extract common code. Given this input:</p>
<pre><code class="language-js">const Greet = &lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>The compiled output is:</p>
<pre><code class="language-js">import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';
import templateOnlyComponent from '@ember/component/template-only';

const Greet = setComponentTemplate(
  precompileTemplate(`
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
  `,
    {
      strictMode: true
    }
  ),
  templateOnlyComponent()
);
</code></pre>
<p>Values referenced from the surrounding scope are included in exactly the same way as with the standalone top-level declaration.</p>
<p>Notice that this allows for a host of convenient (and likely common!) new ways of providing a group of related components. For example:</p>
<ul>
<li>Genuinely private components could be authored within a file which does not export them, and only exports the public API.</li>
<li>Components can be authored in their own files as default exports, and then importing them and re-exporting them as a namespace from an entry-point module.</li>
<li>A namespace export allows an library to supply both a default export as its primary entry point and a series of related components within the same module.</li>
</ul>
<p>No doubt there are many other such useful patterns which will emerge organically here as they have across the broader JS ecosystem.</p>
<p>Users <em>should</em> never reassign the result of binding a template, because Ember will never reevaluate if the name is re-bound later. (Even if we wanted to do that, it would be difficult at best: nothing would notify Ember that it <em>should</em> re-evaluate that value!) We should introduce a lint rule forbidding reassignment of a <code>&lt;template&gt;</code> to a binding to prevent that confusion.</p>
<h4 id="class-body"><a class="header" href="#class-body">Class body</a></h4>
<p>The compilation output with a class-backed component is similar, but instead of using <code>templateOnlyComponent</code>, it uses the backing class. Given this component:</p>
<pre><code class="language-js">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) =&gt; {
    this.name = value;
  }

  saveName = (submitEvent) =&gt; {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  &lt;template&gt;
    &lt;form {{on &quot;submit&quot; this.saveName}}&gt;
      &lt;label for='name'&gt;Set username:&lt;/label&gt;
      &lt;input
        id='name'
        value={{this.value}}
        {{on &quot;input&quot; this.updateName}}
      /&gt;
      &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
        Generate
      &lt;/button&gt;
    &lt;/form&gt;
  &lt;/template&gt;
}
</code></pre>
<p>The compiled output is:</p>
<pre><code class="language-js">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) =&gt; {
    this.name = value;
  }

  saveName = (submitEvent) =&gt; {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };
}

setComponentTemplate(
  precompileTemplate(`
    &lt;form {{on &quot;submit&quot; this.saveName}}&gt;
      &lt;label for='name'&gt;Set username:&lt;/label&gt;
      &lt;input
        id='name'
        value={{this.value}}
        {{on &quot;input&quot; this.updateName}}
      /&gt;
      &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
        Generate
      &lt;/button&gt;
    &lt;/form&gt;
  `,
    {
      strictMode: true,
    }
  ),
  SetUsername
)
</code></pre>
<h5 id="private-class-fields"><a class="header" href="#private-class-fields">Private class fields</a></h5>
<p>In the present design of the template compilation primitives, a template cannot access private fields from the backing class. That is, the following <em>will not work</em>:</p>
<pre><code class="language-js">import Component from '@glimmer/component';

class Example extends Component {
  #aField = true;

  &lt;template&gt;
    &lt;p&gt;The value of the field is: {{this.#aField}}&lt;/p&gt;
  &lt;/template&gt;
}
</code></pre>
<p>That is because the compilation output does <em>not</em> embed the template in the class' body in any way, but instead associates it <em>externally</em> to the class—but private class fields are only accessible within the body of the class itself, per the ECMAScript spec. While we could invest time to change the implementation to avoid this, it is not generally a problem. The only way to get direct access a component instance is to <code>{{yield this}}</code> in a component template. For managing privacy, developers should choose to <code>yield</code> public API instead (e.g. via a getter, or using <code>hash</code> or using a set of positional parameters).</p>
<p>This is a real gap, which we could address in a future RFC. Notably, however, it is <em>not specific to this proposal</em>, but applies to <em>all</em> proposals built on the current primitives.</p>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<p>In normal app code, authors should not <em>generally</em> introduce component definitions <code>&lt;template&gt;</code>s in contexts where they will be “re-executed,” e.g. in a function body. It is technically possible to create components from a function, like so:</p>
<pre><code class="language-js">function conditionalComponent(predicate) {
  if (predicate) {
    return &lt;template&gt;&lt;p&gt;Cool&lt;/p&gt;&lt;/template&gt;
  } else {
    return &lt;template&gt;&lt;p&gt;Lame&lt;/p&gt;&lt;/template&gt;
  }
}
</code></pre>
<p>However, doing so will have a fairly high costs at runtime. It’s worth remembering what the resulting output is:</p>
<pre><code class="language-js">function conditionalComponent(predicate) {
  if (predicate) {
    return setComponentTemplate(
      precompileTemplate(`&lt;p&gt;Cool&lt;/p&gt;`, { strictMode: true }),
      templateOnly()
    );
  } else {
    return setComponentTemplate(
      precompileTemplate(`&lt;p&gt;Lame&lt;/p&gt;`, { strictMode: true }),
      templateOnly()
    );
  }
}
</code></pre>
<p>The problem here is that this requires re-running both the creation of the template-only empty backing instance which has <code>null</code> for <code>this</code>, and the association between the two. As described above, the template precompilation also happens during the build, which eliminates some but not all of the apparent cost here; but the other parts are needlessly dynamic and expensive.</p>
<p>In this scenario, users can accomplish the same thing by manually hoisting the component definitions to module scope:</p>
<pre><code class="language-js">const Cool = &lt;template&gt;&lt;p&gt;Cool&lt;/p&gt;&lt;/template&gt;;
const Lame = &lt;template&gt;&lt;p&gt;Lame&lt;/p&gt;&lt;/template&gt;;

function conditionalComponent(predicate) {
  if (predicate) {
    return Cool;
  } else {
    return Lame;
  }
}
</code></pre>
<p>This is not a hard error because there <em>are</em> legitimate use cases for this, including taking advantage of values which are only in scope within the body of a function. (Test modules alone provide good motivation here; but there are many such examples in app code as well.) Notice that this is no different than any other concern around other costly operations needlessly happening in a function body repeatedly.</p>
<p>See further discussion below under <a href="0779-first-class-component-templates.html#how-we-teach-this"><strong>How We Teach This</strong></a>.</p>
<h3 id="interop"><a class="header" href="#interop">Interop</a></h3>
<p>Since all existing components already work using the same low-level primitives the new system uses, strict-mode components using <code>&lt;template&gt;</code> can import and invoke components authored in Ember’s loose mode format. Similarly, since loose mode components are resolved to a component which is the default export of a module in the correct/conventional location on disk, components authored in strict mode with <code>&lt;template&gt;</code> and exported as the default export in that conventional location will be resolve-able by loose mode components as well.</p>
<p>There are two qualifications to the interop story: a minor one around named exports and a more significant one around non-colocated templates.</p>
<h4 id="named-exports"><a class="header" href="#named-exports">Named exports</a></h4>
<p>Components exported as <em>named</em> exports will not be available in loose mode: resolution only evaluates default exports. This is a temporary incoherence which will be resolved as the ecosystem migrates to strict mode. There are also a number of workarounds for this issue, including yielding components from a default export component and creating reexport-only modules to allow loose-mode access.</p>
<p>For an example of the reexport-only pattern, consider a module <code>app/components/named-only.js</code> with two named export components:</p>
<pre><code class="language-js">export const Greet = &lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;

export const Farewell = &lt;template&gt;
  &lt;p&gt;Goodbye, {{@name}}!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>A user wishing to make these available to loose mode could introduce two new modules:</p>
<ul>
<li>
<p><code>app/components/named-only/greet.js</code>:</p>
<pre><code class="language-js">export { Greet as default } from '../named-only';
</code></pre>
</li>
<li>
<p><code>app/components/named-only/farewell.js</code>:</p>
<pre><code class="language-js">export { Farewell as default } from '../named-only';
</code></pre>
</li>
</ul>
<p>Then a loose-mode component could invoke them like <code>&lt;NamedOnly::Greet @name=&quot;Chris&quot;&gt;</code> and <code>&lt;NamedOnly::Farewell @name=&quot;Krycho&quot; /&gt;</code>. Note that this pattern is not at all <em>necessary</em> for migration, but may be useful.</p>
<h4 id="non-colocated-templates"><a class="header" href="#non-colocated-templates">Non-colocated templates</a></h4>
<p>Since the same time as the Ember Octane release, Ember has supported “colocated templates,” where the template file for a component can live next to it in the <code>app/components</code> or <code>addon/components</code> directory, instead of in the <code>app/templates/components</code> or <code>addon/templates/components</code> directory:</p>
<pre><code>my-ember-app/
  app/
    components/
      example.js
      example.hbs
</code></pre>
<p>Although this appears to be merely a user-facing convenience, there is a real and important difference at the implementation level which currently prevents first-class component templates from using classic, non-colocated templates:</p>
<p>Colocated templates are merged into the sibling JavaScript module at build time and set as the template for the component using <code>setComponentTemplate</code>: the same primitive used by first-class component templates. This includes template-only components, for which Ember's build synthesizes a JavaScript module and uses <code>templateOnlyComponent()</code>—again, just as <code>&lt;template&gt;</code> does.</p>
<p>By contrast, classic/non-colocated templates are <em>not</em> merged into the associated JavaScript module (if any). They remain as their own distinct module at runtime. Those template modules can be looked up via the AMD module system or Ember's DI registry, and Ember connects them to components via the same system it always did before the introduction of the <code>setComponentTemplate</code> primitive (and the same way it continues to connect the route-controller-template triplet). Critically, this means that as of today, Ember does <em>not</em> connect non-colocated templates to the associated class (whether backing class or <code>templateOnlyComponent()</code>-generated) using <code>setComponentTemplate</code>. This means that the corresponding <code>getComponentTemplate()</code> lookup used when resolving those components does not work. First-class component templates which reference non-colocated component templates will build successfully, but <em>do not render anything for them</em>.</p>
<p>This is a fairly serious developer experience problem, because it fails <em>invisibly</em> (see <a href="https://github.com/chriskrycho/fcct-interop-demo">this demo repository</a> to see this failure mode in practice).</p>
<p>We can address in one of two ways:</p>
<ul>
<li>Introduce support into Ember to associated non-colocated templates with their associated classes.</li>
<li>Introduce debug output which informs users that they must first migrate the referenced component to use colocation.</li>
</ul>
<p>Of these, the second option is preferable.<sup class="footnote-reference"><a href="#deprecated-non-colo">7</a></sup> It has significantly lower risk of introducing bugs in the framework along the way, because it only requires adding some debug alerting and does <em>not</em> require changing the semantics or implementation of long-standing Ember features. It is <a href="https://github.com/ember-codemods/ember-component-template-colocation-migrator">straightforward to codemod</a> to colocation.</p>
<div class="footnote-definition" id="deprecated-non-colo"><sup class="footnote-definition-label">7</sup>
<p>We may additionally wish to entirely deprecate non-colocated component templates as part of Polaris. However, even if we do so, we still <em>must</em> provide that debug output for the sake of the transition period, not least since that deprecation can only target Ember 5 at the earliest.</p>
</div>
<h3 id="the-prelude"><a class="header" href="#the-prelude">The “prelude”</a></h3>
<p>While all values used in templates must be explicitly in scope, Ember<sup class="footnote-reference"><a href="#glimmer-prelude">8</a></sup> will provide some via a “prelude”.<sup class="footnote-reference"><a href="#prelude">9</a></sup> These are always in scope and do not need to be imported. See <a href="https://emberjs.github.io/rfcs/0496-handlebars-strict-mode.html#keywords">RFC #0496: Handlebars Strict Mode: Keywords</a> for a detailed list of keywords and imports.</p>
<div class="footnote-definition" id="glimmer-prelude"><sup class="footnote-definition-label">8</sup>
<p>Glimmer.js may provide its own prelude. While long-term the two should likely align, this RFC simply takes the <em>status quo</em> as a given</p>
</div>
<div class="footnote-definition" id="prelude"><sup class="footnote-definition-label">9</sup>
<p>“Prelude” is the conventional name for this functionality in programming language design. See e.g. the discussion from <a href="https://doc.rust-lang.org/std/prelude/index.html">Rust’s <code>std::prelude</code> docs</a>.</p>
</div>
<h3 id="tooling"><a class="header" href="#tooling">Tooling</a></h3>
<p>To support the new format, we need to update tooling across the ecosystem to understand the format.</p>
<h4 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax highlighting</a></h4>
<p>First, we need syntax highlighting support across the ecosystem. Support already exists <a href="https://marketplace.visualstudio.com/items?itemName=chiragpat.vscode-glimmer">for VS Code</a>, which represents the single largest group of web developers; as well as for any tool which can use <a href="https://github.com/alexlafroscia/tree-sitter-glimmer">a tree-sitter grammar</a> (e.g. Neovim).</p>
<p>We will also need to implement support in <a href="https://github.com/github/linguist">Linguist</a> for GitHub syntax highlighting.</p>
<p>Beyond that, we should encourage the community to add support for other editors (IntelliJ, Atom, Emacs, etc.) as well as for tools like <a href="https://rubygems.org/gems/rouge">Rouge</a> (which powers GitLab syntax highlighting) and other highlighters, but need not treat those as <em>blocking</em> adoption of first-class component templates.</p>
<h4 id="blueprints"><a class="header" href="#blueprints">Blueprints</a></h4>
<p>Component and component test blueprints will need to be updated to support generating the new format. (See <a href="https://github.com/emberjs/rfcs/pull/785">RFC #0785</a> for updates to testing to support this more robustly.) During the transition period, we should allow generating both. The rollout will follow the example of the rollout of Glimmer components with Octane:</p>
<ol>
<li>
<p>Introduce the ability to author components in the new format with a new <code>--strict</code> flag, but leave the default today’s loose mode format. Introduce <code>--loose</code> as an explicit flag for using today’s loose mode format.</p>
</li>
<li>
<p>When Ember Polaris<sup class="footnote-reference"><a href="#polaris">10</a></sup> is released, change the default to the new format for apps and addons which set <code>&quot;edition&quot;: &quot;polaris&quot;</code>, while leaving loose mode available via <code>--loose</code>, and preserving <code>--strict</code> as an explicit flag for the new default.</p>
</li>
<li>
<p>If or when loose mode templates are deprecated, the supporting blueprint infrastructure can be removed, including the <code>--loose</code> flag.</p>
</li>
</ol>
<p>The current blueprints support generating a backing class for any existing component template which does not already have a backing class with the <code>component-class</code> format. We have two choices about the behavior of that blueprint for strict mode templates:</p>
<ol>
<li>
<p>Do not support it. Adding a backing class is simply a matter of adding an import and adding a class.</p>
</li>
<li>
<p>Re-implement the blueprint using an AST transform (which we have prior art for: route generation uses that approach), to add a backing class for an existing default export in the module.</p>
</li>
</ol>
<p>(We should do (1). The community can of course implement (2) if interested.)</p>
<p>We should also update the name of the class generated for a component class. The default behavior of today's blueprint when generating a component is to suffix the class name with <code>Component</code>. Thus, running <code>ember generate component greeting --component-class=@glimmer/component</code> will produce a class named <code>GreetingComponent</code>.<sup class="footnote-reference"><a href="#ts-component-name">11</a></sup></p>
<p>There was room for debate about whether this made sense for naming component classes up till now, since the invocation name was based on the file name (using Ember's resolution rules) and <em>not</em> the class name. Now, though, it <em>will</em> be based on the imported name, and the standard behavior of auto-import tooling is to import classes by their full name—whether the item is a named export or a default export. When a user goes to auto-complete <code>Greeting</code> (e.g. in <a href="https://github.com/typed-ember/glint">Glint</a>), they will end up with <code>GreetingComponent</code>, leading to this sort of thing if they don’t rename it:</p>
<pre><code class="language-js">import GreetingComponent from './greeting';

&lt;template&gt;
  &lt;GreetingComponent @name={{@user.name}} /&gt;
&lt;/template&gt;
</code></pre>
<p>This is obviously undesirable, but avoiding this will mean mean renaming locally after the auto-complete works. That renaming operation is a needless paper cut in the best case of importing a default export. It rises to the level of a significant annoyance when using named imports:</p>
<pre><code class="language-js">import {
  ButtonComponent as UIButton,
  FormComponent as UIForm,
  InputComponent as UIInput,
} from './ui';

&lt;template&gt;
  &lt;UIForm @onSubmit={{@saveName}}&gt;
    &lt;UIInput @label=&quot;Name&quot; @value={{@name}} @onUpdate={{@updateName}} /&gt;
    &lt;UIButton @label=&quot;Save&quot; type=&quot;submit&quot; /&gt;
  &lt;/UIForm&gt;
&lt;/template&gt;
</code></pre>
<p>And it makes namespace-style imports basically unusable: to invoke <em>without</em> <code>Component</code> everywhere, you have to rebind all the imports you use!</p>
<pre><code class="language-js">import * as _UI from './ui';
const UI = {
  Form: _UI.FormComponent,
  Button: _UI.ButtonComponent,
  Input: _UI.InputComponent
}

&lt;template&gt;
  &lt;UI.Form @onSubmit={{@saveName}}&gt;
    &lt;UI.Input @label=&quot;Name&quot; @value={{@name}} @onUpdate={{@updateName}} /&gt;
    &lt;UI.Button @label=&quot;Save&quot; type=&quot;submit&quot; /&gt;
  &lt;/UI.Form&gt;
&lt;/template&gt;
</code></pre>
<p>Accordingly, we should switch to generating <em>without</em> a class name: <code>ember generate component greeting --component-class=@glimmer/component</code> should produce a class named <code>Greeting</code>, <em>not</em> <code>GreetingComponent</code>. The generated names for routes, services, and controllers can remain as they are, since they are never invoked this way.</p>
<div class="footnote-definition" id="polaris"><sup class="footnote-definition-label">10</sup>
<p>Polaris was announced as planned at EmberConf 2021. This plan assumes we ship Polaris before Ember 5. If we ship Ember 5 first, the dynamics would be much the same, but with the major version as the point when we switch the default instead.</p>
</div>
<div class="footnote-definition" id="ts-component-name"><sup class="footnote-definition-label">11</sup>
<p>In TypeScript, this also extends to <code>GreetingComponentArgs</code> (or, with <a href="https://github.com/emberjs/rfcs/pull/748">RFC #0748</a>, something like <code>GreetingComponentSignature</code>), which gets <em>really</em> unwieldy!</p>
</div>
<h4 id="linting-and-formatting"><a class="header" href="#linting-and-formatting">Linting and formatting</a></h4>
<p>As with syntax highlighting, we need to support the new format with linting and formatting integration.</p>
<p>For linting, we need to make two changes:</p>
<ol>
<li>
<p>Create an ESLint processor which uses the same Babel transform as the core behavior itself (as provided currently by <a href="https://github.com/ember-template-imports/ember-template-imports">ember-template-imports</a>) to make normal ESLint rules (e.g. unused imports and values) work with the template scope.</p>
</li>
<li>
<p>Going the other direction, make it possible to use the existing <code>ember-template-lint</code> rules in <code>.gjs</code>/<code>.gts</code> files. This likely means integrating <code>ember-template-lint</code> directly into ESLint, in much the same way that other sub-language integration is done (in the same way that e.g. <a href="https://github.com/sveltejs/eslint-plugin-svelte3">eslint-plugin-svelte3</a> integrates Svelte’s custom language).</p>
</li>
</ol>
<p>For formatting, we need to implement a custom parser plugin and language which will make Prettier able to format both the host JavaScript files and the embedded templates. This will need to present a view of the non-template parts of the file to Prettier so that it formats the JavaScript correctly without updating the template contents, and vice versa. The primary work here is to make it so that we can leverage Prettier’s existing support for JavaScript/TypeScript and Handlebars in a <code>.gjs</code>/<code>.gts</code> file (rather than simply ending up with a parse error, as happens when you try to treat those files as pure JS or TS).</p>
<h4 id="language-server-support"><a class="header" href="#language-server-support">Language server support</a></h4>
<p>The final piece of tooling we need for supporting this is <em>language server support</em>. Language servers using the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> allow a variety of different editors (including e.g. Vim, Visual Studio Code, Emacs, Atom, Sublime Text, IntelliJ, and others) to use a single language server Currently, for uninteresting historical reasons, there are a handful of language servers floating around which Ember developers use. Most important for our purposes are the <a href="https://marketplace.visualstudio.com/items?itemName=lifeart.vscode-ember-unstable">Unstable Ember Language Server</a> and <a href="https://github.com/typed-ember/glint">Glint</a>.</p>
<p><strong>Neither of these is technically a hard blocker for adopting first-class component templates, but we expect there to be significant community demand for support.</strong> However, the existing support in these tools for the <code>hbs</code> experiment means that supporting <code>&lt;template&gt;</code> is relatively straightforward: the work needs to be done, but is not especially large. In particular, the same Babel transform which makes <code>&lt;template&gt;</code> work and can power ESLint and Prettier integration should provide the necessary information for language servers as well, which can then leverage their own interpretations of templates (e.g. Glint's mapping from a Handlebars template to a TypeScript representation) to provide richer feedback, auto-completion, go-to-definition, documentation hovers, etc.</p>
<h4 id="codemod-5"><a class="header" href="#codemod-5">Codemod</a></h4>
<p>While providing a codemod is not a <em>hard</em> necessity, it is much like language server support: there will be high community demand.</p>
<p>Such a codemod will automate the fairly mechanical work of providing a wrapping <code>&lt;template&gt;</code> for template-only components and moving the content of an <code>.hbs</code> file into a <code>&lt;template&gt;</code> on the backing class for class-backed components. To do that, however, there are two major pieces such a codemod will need to address:</p>
<ul>
<li>
<p><strong>Identifying where a given component or item came from</strong>. This is not <em>trivial</em>, since in most apps the items are all in one big global namespace. This is definitely <em>tractable</em>, though. A codemod could start by walking the graph of Ember addons any given library depends on and identifying all names it exports in terms of Ember's standard layout. Then that can be fed into each template module being converted.</p>
<p>There will definitely be occasional conflicts here, for example when developers have <em>intentionally</em> overridden something supplied by an addon. In that case of conflict, the codemod can bail and report it to the end user. (We could use a telemetry-powered codemod like we did for the native classes codemod with Octane, but that's a much higher lift and my own judgment is that the cost-benefit ratio is low enough not to be worth it in <em>this</em> case. People generally either work around those or have done it on purpose.)</p>
</li>
<li>
<p><strong>Handling non-colocated templates.</strong> As discussed above in <a href="0779-first-class-component-templates.html#interop"><strong>Detailed Design: Interop</strong></a>, strict mode templates cannot <em>currently</em> resolve components where the template is still located in <code>templates/components</code> rather than next to a backing class, if any, in <code>components</code>. If we do not change this behavior at the framework level, we will need to recommend people start by migrating to colocated templates (which already has <a href="https://github.com/ember-codemods/ember-component-template-colocation-migrator">a reliable codemod</a>).</p>
</li>
</ul>
<h3 id="typescript"><a class="header" href="#typescript">TypeScript</a></h3>
<p>The type of a component is not affected by this proposal. However, it is worth seeing <em>how</em> a component defined using <code>&lt;template&gt;</code> works with types, at least for the purpose of documentation (and for integration with the current DefinitelyTyped definitions).</p>
<p>For a class-backed component, there is no change to the <em>types</em> of the component when using <code>&lt;template&gt;</code>. As described above in the discussion of language servers, tools like Glint will need to provide an interpretation of the body of a <code>&lt;template&gt;</code> which correctly understands the scope in which it is embedded, i.e. correctly providing <code>this</code> to it.</p>
<p>For a template-only component, defining the type will require a type import to represent that there is a component with no <code>this</code> context, etc. Glint already supplies such a type, albeit with the types updated for <a href="https://github.com/emberjs/rfcs/pull/748">RFC #0748</a>. For today’s purposes, we can simply augment the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/54d540ab4deb2588c0eff39dadf370cbf0a2dee4/types/ember__component/template-only.d.ts">existing types on DefinitelyTyped</a> with <code>Args</code>.</p>
<details><summary>updated signature on DT</summary>
<pre><code class="language-ts">declare const A: unique symbol;

// This class is not intended to be directly constructable.
declare class _TemplateOnlyComponent&lt;Args extends {}&gt; {
    // Type brand to simulate a nominal type.
    declare private brand: 'TemplateOnlyComponent';
    // Host to make args &quot;used&quot;
    declare private [A]: Args;
    toString(): string;
}

// Export an interface instead to prevent construction.
// tslint:disable-next-line:no-empty-interface
export interface TemplateOnlyComponent&lt;Args extends {} = {}&gt; extends _TemplateOnlyComponent&lt;Args&gt; {}
type TC&lt;Args extends {} = {}&gt; = TemplateOnlyComponent&lt;Args&gt;

declare function templateOnly(moduleName?: string): TemplateOnlyComponent;

export default templateOnly;

// Shut off automatic exporting.
export {};
</code></pre>
</details>
<p>Users can then define a named template-only component like this:</p>
<pre><code class="language-ts">import type { TemplateOnlyComponent } from '@glimmer/component';

const Greet: TemplateOnlyComponent&lt;{ name: string }&gt; = &lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>(While this empty interface is currently more or less useless from a type-checking perspective—we will need something like Glint to support it—it suffices to provide a hook for documentation tooling such as <a href="https://typedoc.org">TypeDoc</a> or <a href="https://api-extractor.com">API Extractor</a>, and thus suffices for the level of support we have for TypeScript today.)</p>
<p>However, since the top-level <code>&lt;template&gt;</code> syntax is sugar for an anonymous default export, there is nowhere to put a type declaration like this. This is a limitation of default exports in JavaScript: functions and classes have names as part of their declarations, but other items do not, so they cannot be both named <em>and</em> part of the default export of a module.</p>
<p>Accordingly, we propose an extension to <code>&lt;template&gt;</code>, available only in <code>.gts</code> files, which uses the following syntax designed to mirror type parameterization in TypeScript but in a way that is straightforward to parse into the desired target format:</p>
<pre><code class="language-ts">export interface GreetingArgs {
  name: string;
}

&lt;template[GreetingArgs]&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>This syntax for generics has prior art in other programming languages, including Scala, Go, and Ruby’s Sorbet type checker (a cousin of TypeScript, as it were!). It clearly associates the <code>Args</code> with the <code>template</code>, while <em>not</em> putting it in a value space which could conflict with future extensions to <code>&lt;template&gt;</code> with “attributes” in the value space.<sup class="footnote-reference"><a href="#emblem-etc">12</a></sup></p>
<p>Given this design, we can also simplify the definition of named components (both forms will of course be legal):</p>
<pre><code class="language-ts">export interface GreetingArgs {
  name: string;
}

export const Greeting = &lt;template[GreetingArgs]&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>There are two key restrictions here:</p>
<ol>
<li>
<p>As mentioned above, this is illegal in the context of a class-backed component, because the component class itself is the host for the signature (and must be to make <code>this.args</code> type check correctly).</p>
</li>
<li>
<p>The only thing allowed within the <code>[...]</code> is a type available in the local scope. <em>It is not legal to provide an inline type definition.</em> However, given the relative verbosity of even today’s component signature, still less the revised version from <a href="https://github.com/emberjs/rfcs/pull/748">RFC #0748</a>, inline signatures are unlikely to be attractive anyway.</p>
</li>
</ol>
<p>From an implementation perspective, this requires our language parser to handle this variant of the tag, and for the transforms supplied for compilation to properly ignore this for build output but to supply it in an appropriate place for TypeScript-aware tools like Glint to be able to take advantage of it.</p>
<h3 id="custom-file-extension"><a class="header" href="#custom-file-extension">Custom file extension</a></h3>
<p>These tooling considerations together provide the motivation for a custom file extension (<code>.gjs</code> and <code>.gts</code>). In the case of TypeScript in particular, it is not possible to <em>remove</em> errors using a TypeScript language server plugin, which means that in a pure <code>.js</code> or <code>.ts</code> file, a user would get conflicting reports from TypeScript and (e.g.) Glint. Thus, today, Glint recommends that GlimmerX users <em>disable TypeScript in their projects</em>, and rely on only Glint. Taking a lesson from Vue and Svelte, however, introducing a custom file extension allows us to provide a default type for <code>.gjs</code>/<code>.gts</code> files which makes TypeScript happy in <code>.js</code> and <code>.ts</code> files, and on top of which tools like Glint can safely add <em>more</em> information.<sup class="footnote-reference"><a href="#hbs-custom-syntax">13</a></sup></p>
<p>While both Prettier and ESLint <em>can</em> work with <code>.js</code> or <code>.ts</code>, introducing the new file extension also simplifies the tooling implementation for them. It does mean that tools like GitHub’s Linguist will not work without implementing support, but we need to do that work anyway.</p>
<div class="footnote-definition" id="hbs-custom-syntax"><sup class="footnote-definition-label">13</sup>
<p>Note that this also applies to the <code>hbs</code> syntax discussed in <a href="0779-first-class-component-templates.html#template-literals-hbs"><strong>Alternatives: Template literals (<code>hbs</code>)</strong></a>.</p>
</div>
<h3 id="spec"><a class="header" href="#spec">Spec</a></h3>
<p>During implementation—before this is the default for Ember apps, and before it advances to <strong>Recommended</strong> if <a href="https://emberjs.github.io/rfcs/0617-rfc-stages.html">the Stages RFC</a> is implemented before this implementation is finished—we will create a spec for the format we propose here, generalizing it to account for similar potential future extensions:</p>
<ul>
<li>
<p>to make it easy for tooling authors to know when they have implemented the support correctly, including answering questions about nested invocation, escaping, handling closing tags within comments, etc.</p>
</li>
<li>
<p>to enable future design moves in this space—for example, <code>&lt;style&gt;</code> blocks for scoped CSS or <code>&lt;query&gt;</code> blocks for languages like GraphQL, etc.</p>
</li>
<li>
<p>to enable other parts of the JS ecosystem to adopt this—in the same way that JSX is not a React-only syntax but a <a href="https://facebook.github.io/jsx/">spec</a> which can also be used by e.g. <a href="https://www.solidjs.com">Solid</a>—since it could be valuable authoring format for Svelte, Vue, and other template-focused/HTML-first frameworks</p>
</li>
</ul>
<h2 id="transition-path-35"><a class="header" href="#transition-path-35">Transition path</a></h2>
<p>We will transition to using first-class component templates by default as part of Ember Polaris. To do that successfully, we must:</p>
<ul>
<li>implement the features as described in <a href="0779-first-class-component-templates.html#detailed-design"><strong>Detailed design</strong></a>, migrating in the implementation from <code>ember-template-imports</code></li>
<li>update the <a href="0779-first-class-component-templates.html#tooling">tooling</a>:
<ul>
<li><a href="0779-first-class-component-templates.html#syntax-highlighting">syntax highlighting</a></li>
<li><a href="0779-first-class-component-templates.html#blueprints">blueprints</a></li>
<li><a href="0779-first-class-component-templates.html#linting-and-formatting">linting and formatting</a></li>
<li><a href="0779-first-class-component-templates.html#language-server-support">language servers</a></li>
</ul>
</li>
<li>update all <a href="0779-first-class-component-templates.html#how-we-teach-this">the teaching materials</a></li>
</ul>
<p>Additionally, an optimal transition will include changes to <a href="0779-first-class-component-templates.html#language-server-support">language server implementations</a> and supply a <a href="0779-first-class-component-templates.html#codemod">codemod</a> from loose to strict mode. (We may be <em>able</em> to release this as part of Polaris without those, but the transition will be much more successful with them.)</p>
<p>In terms of rollout, we should deliver features incrementally, allowing users to opt into them via command line flags for Ember CLI (<code>--strict</code> and <code>--loose</code> for <code>ember generate component</code>) and possibly also optional features (e.g. a <code>&quot;strict-components&quot;: true</code> in <code>optional-features.json</code>). Once Polaris arrives, setting <code>&quot;edition&quot;: &quot;polaris&quot;</code> will opt users into those as new defaults, while allowing use of command line flags to opt into loose mode for a given component. (Later deprecations may remove that, but that is something to resolve at a later time.)</p>
<p>Finally, the Glimmer.js (and thus <a href="https://glimmerjs.github.io/glimmer-experimental/">GlimmerX</a>) implementation should update to match this, further decreasing the delta between standalone Glimmer and Ember.</p>
<h2 id="how-we-teach-this-155"><a class="header" href="#how-we-teach-this-155">How we teach this</a></h2>
<p>We describe a <code>&lt;template&gt;</code> as representing the <em>template</em> for a <em>component</em>. When there is no backing class, that’s all there is to the component. When there <em>is</em> a backing class, the component also has associated state and behavior. (Notably, this shift already began with Octane, where we generate template-only components by default.)</p>
<p>This explanatory model provides a helpful opportunity, when first introducing the idea of a backing class, to link to deeper-dive materials which let people who want to understand more deeply. In particular, it allows us a place to point out that mechanically, there <em>is</em> in fact always an associated component instance (generated via <code>templateOnlyComponent()</code>), but it’s just a way for this <code>&lt;template&gt;</code> to be hooked into the broader system, rather than a home for state.</p>
<p><strong>Note:</strong> This is complicated by the need to introduce route templates as well as component templates. The text here assumes that we will, in parallel with this work, resolve the design questions addressed by <a href="https://github.com/emberjs/rfcs/pull/731">RFC #0731</a> in something like the design proposed there. Accordingly, it also assumes we will update the generators and the relevant text accordingly. Fundamentally, we <em>should not</em> update the guides until we have a resolution for that design space, so they can be updated in a coherent way.</p>
<h3 id="guides-2"><a class="header" href="#guides-2">Guides</a></h3>
<p>Once <code>&lt;template&gt;</code> is implemented and tooling is sufficiently stable, we will update the guides with changes along the following lines:</p>
<h4 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h4>
<p>One cross-cutting change here will be updating the output from generators, including correct new file extensions. The following discussion of the current sections of the guide <em>assumes</em> that change, and addresses concrete <em>pedagogical</em> changes we need to make. If a section is not included here, it (a) needs little or no other change beyond the minimum or (b) is dependent on the results of <a href="https://github.com/emberjs/rfcs/pull/731">RFC #0731</a> to flesh out the details.</p>
<h5 id="orientation"><a class="header" href="#orientation">Orientation</a></h5>
<p>Here we will need to update the prose to describe that <code>&lt;template&gt;</code> marks this as Ember/Glimmer’s special superset of HTML, with prose long the lines of:</p>
<blockquote>
<p>Note that all you need to do to have a working Ember component is to wrap your HTML in <code>&lt;template&gt;</code>.</p>
</blockquote>
<h5 id="component-basics"><a class="header" href="#component-basics">Component Basics</a></h5>
<p>Introducing components will see a lot of changes, unsurprisingly:</p>
<ol>
<li>
<p>The introduction to components in updated guides will depend on the specific design choices we make in <a href="https://github.com/emberjs/rfcs/pull/731">RFC #0731</a>. One possible approach here will be to note that we have already seen components in practice, if the decision in that space is that routes simply invoke a component template. Otherwise we may indicated that components are similar to route templates, but are self-contained.</p>
</li>
<li>
<p>The use of <code>&lt;CapitalizedComponents /&gt;</code> is no longer required, but remains a <em>helpful convention</em>.<sup class="footnote-reference"><a href="#resolver-capitalized-components">14</a></sup> If someone does <code>const foo = &lt;template&gt;...&lt;/template&gt;</code>, they will be able to invoke that as <code>&lt;foo /&gt;</code> elsewhere. The notes in this section as well as about <code>LinkTo</code> will need to be updated to describe it accordingly.</p>
</li>
<li>
<p>After introducing <code>&lt;Jumbo /&gt;</code> with updated use of a wrapping <code>&lt;template&gt;</code>, discuss <em>importing it</em> into the route (component) template which uses it. This is a good place to describe how <code>.gjs</code> can use JS features, and hint that we’ll see more of this later; it is also a good opportunity to note that we <em>could</em> have defined <code>&lt;Jumbo /&gt;</code> locally, but that we moved it to a separate file because we’re sharing it across multiple different components.</p>
</li>
<li>
<p>Our discussion of the testing will need to be updated to include importing the components under test, and to use <code>&lt;template&gt;</code> rather than <code>hbs</code> strings for the <code>render</code> calls.<sup class="footnote-reference"><a href="#testing-rfc">5</a></sup></p>
</li>
</ol>
<div class="footnote-definition" id="resolver-capitalized-components"><sup class="footnote-definition-label">14</sup>
<p>Historically users <em>had</em> to use this convention, but only because that was the decision for how the resolver would work.</p>
</div>
<h5 id="more-about-components"><a class="header" href="#more-about-components">More About Components</a></h5>
<p>We can simply <em>remove</em> the discussion of namespaced components, in favor of simply describing the use of normal JS imports to accomplish the same goal. However, here we can also note that JavaScript modules are a great way to organize groups of related components, and show how we might use namespace-style imports (<code>import * as Rental from '';</code> and then <code>&lt;Rental.Image /&gt;</code> within a <code>&lt;template&gt;</code>) for this kind of organization.<sup class="footnote-reference"><a href="#namespace-deprecation">15</a></sup></p>
<div class="footnote-definition" id="namespace-deprecation"><sup class="footnote-definition-label">15</sup>
<p>Attentive readers will likely have noticed that this makes the namespace sigil a candidate for later deprecation, since it will be entirely redundant once the ecosystem moves fully to strict mode and template imports. However, that question is best left to a potential future RFC deprecating loose mode.</p>
</div>
<h5 id="interactive-components"><a class="header" href="#interactive-components">Interactive Components</a></h5>
<p>The discussion of adding behavior to components will need to be updated to account for the design <em>and</em> the new possibilities in the space:</p>
<ol>
<li>
<p>Show that when we generate a class for an existing component, it  adds the <code>Component</code> import, creates a wrapping class, and moves the template into the body of that class. Here, teach the mental model that a <code>&lt;template&gt;</code> which is part of a class body has access to the instance properties on the backing class.</p>
</li>
<li>
<p>When discussing use of values from <code>ENV</code>, instead of providing a getter on a backing class, start by creating a <code>TOKEN</code> constant in module scope, and show that it is available to access in the template. In the following section, which shows args being used in the template, simply use that <code>TOKEN</code> value in the template directly, <code>access_token={{TOKEN}}</code>.</p>
</li>
</ol>
<h5 id="reusable-components"><a class="header" href="#reusable-components">Reusable Components</a></h5>
<p>This section provides us an opportunity to show how useful it can be to introduce local functions. The code samples here currently use a backing class, but they only do so to provide a home for getters which provide an encoded URI for the Mapbox token and derive the <code>src</code> from the arguments.</p>
<p>(I will provide this example in full here in part because it shows powerfully the pedagogical value of this RFC!)</p>
<p>The Mapbox token value is not reactive and therefore the computation has no reason to exist on a backing class <em>at all</em>. It is only there today because <em>without</em> first-class component templates, it requires introducing the heavier notion of helpers off in a separate file. (The more so given that the guides currently assume classic, i.e. pre-<a href="https://github.com/emberjs/rfcs/pull/756">RFC #0756</a> helpers using the <code>helper</code> function and not a standalone function!) With <code>&lt;template&gt;</code>, it can simply become a constant value defined in local scope:</p>
<pre><code class="language-js">import ENV from 'super-rentals/config/environment';

const TOKEN = encodeURIComponent(ENV.MAPBOX_ACCESS_TOKEN)

&lt;template&gt;
  &lt;div class=&quot;map&quot;&gt;
    &lt;img
      alt=&quot;Map image at coordinates {{@lat}},{{@lng}}&quot;
      ...attributes
      src=&quot;https://api.mapbox.com/styles/v1/mapbox/streets-v11/static/{{@lng}},{{@lat}},{{@zoom}}/{{@width}}x{{@height}}@2x?access_token={{TOKEN}}&quot;
      width={{@width}} height={{@height}}
    &gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>Similarly, while <code>src</code> <em>is</em> computed from reactive data, there is once again no reason to compute it <em>in a class</em> if we are not going to use the class to store state. We can just write a local function and use it (and use that to note that we handle named arguments, too):</p>
<pre><code class="language-js">import ENV from 'super-rentals/config/environment';

const TOKEN = encodeURIComponent(ENV.MAPBOX_ACCESS_TOKEN)
const MAPBOX_API = 'https://api.mapbox.com/styles/v1/mapbox/streets-v11/static';

function source({ lng, lat, width, height, zoom }) {
  let coordinates = `${lng},${lat},${zoom}`;
  let dimensions = `${width}x${height}`;
  let accessToken = `access_token=${TOKEN}`;

  return `${MAPBOX_API}/${coordinates}/${dimensions}@2x?${accessToken}`;
}

&lt;template&gt;
  &lt;div class=&quot;map&quot;&gt;
    &lt;img
      alt=&quot;Map image at coordinates {{@lat}},{{@lng}}&quot;
      ...attributes
      src={{source lng=@lng lat=@lat width=@width zoom=@zoom}}
      width={{@width}} height={{@height}}
    &gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>Notice the results of this pedagogically:</p>
<ul>
<li>We have asked people to write <em>less code</em>: fewer imports, and less overall syntax.</li>
<li>The code they <em>do</em> write feels much more HTML-first. The template can stay almost exactly as it was, with no shift to a backing class.</li>
<li>For developers who have experience with other frameworks, this feels familiar, but with an Ember twist.</li>
</ul>
<p>At this point we could <em>additionally</em> show that we could introduce a backing class, and discuss the trade-offs of introducing a class when we don't have any other local state. This also allows us to encourage just using functions unless you <em>do</em> need local state.</p>
<p>The section “Getting JavaScript Values into the Test Context” will also be possible to simplify: we will simply be able to introduce tracked state locally and update it directly, without special testing helpers. That will dramatically reduce the number of bespoke ideas we have to cover here. Much of the related work will be addressed in other RFCs, but being able to use the <em>same</em> primitives to bring values into scope for tests as we do in apps (immediately above!) will be very helpful in reducing what we have to cover in this section.</p>
<h4 id="core-concepts-components"><a class="header" href="#core-concepts-components">Core Concepts: Components</a></h4>
<p>This entire section will also need to be substantially reworked. Once again, I am here summarizing the changes rather than trying to rewrite the guide in place. Each section represents a page to be changed; if a section is not mentioned, it needs no substantive changes—likely only switching over to using the <code>&lt;template&gt;</code> wrapper.</p>
<p>At some point in the course of this discussion, we should call out (e.g. with a “Zoey says” block) that users should treat <code>&lt;template&gt;</code> the same way they treat a costly function which produces a result for the life of the whole app, and should therefore avoiding using <code>&lt;template&gt;</code> in function bodies rather than hoisting them, etc. This cannot be a hard and fast rule about where <code>&lt;template&gt;</code> definitions live, because there are plenty of ways to do it safely, and what’s more we <em>need</em> to do it in test modules. The point is simply to align people’s mental model for <code>&lt;template&gt;</code> with <em>other</em> costly operations, since these concerns are not specific to component creation.</p>
<h5 id="introducing-components"><a class="header" href="#introducing-components">Introducing Components</a></h5>
<p>Unsurprisingly, this is the section which will see the most sweeping changes.</p>
<ul>
<li>
<p>As described in the tutorial, our introduction will depend on the design chosen for route templates. We will either note that we’ve already seen our first component, if the application template <em>was</em> a component, or note the similarities and differences between route templates and components otherwise.</p>
</li>
<li>
<p>We can continue to show breaking the component out into separate files, with a top-level <code>&lt;template&gt;</code> (serving, so far implicitly, as a default export).</p>
</li>
<li>
<p>Then, back in the application file, we can show using <code>import</code> to refer to it.</p>
</li>
<li>
<p>As in the tutorial, the discussion around naming will need to be updated to indicate that we capitalize by <em>convention</em>: it will no longer be a hard requirement. Likewise, the “Zoey says...” will go away because we will no longer be using resolution to get imports.</p>
</li>
<li>
<p>After showing the other extraction-style refactors, we can show how components which don't need to be exported can just be defined locally with a <code>const</code> declaration, and explain that the standalone <code>&lt;template&gt;</code> tag is sugar for a default export. This will also provide the first hook for defining helpers etc. locally in following sections.</p>
</li>
<li>
<p>We will entirely drop the folder namespace syntax (<code>::</code>) discussion, in favor of showing how normal JS imports handle that concern—including showing how the combination of named exports and namespace-style imports handle those. (This will necessitate reworking the example, which currently uses that namespacing as a means of scoping.)</p>
</li>
</ul>
<h5 id="helper-functions"><a class="header" href="#helper-functions">Helper functions</a></h5>
<p>Instead of introducing <code>app/helpers</code> and the resolution-based lookup, we can introduce the helper as a local function in the component which needs it. This will be the first place where this guide explicitly calls out that components have access to values in their surrounding scope, just like normal JavaScript. This will be a good point to call out the power and versatility this affords.</p>
<p>Additionally, instead of the <em>next</em> section being the place where we first identify that JS is needed to make our UI dynamic, we will address that here. The next section can then build on that by showing how classes make certain patterns <em>easier</em>.</p>
<h5 id="component-state-and-actions"><a class="header" href="#component-state-and-actions">Component State and Actions</a></h5>
<p>Here, the content will need to shift in two ways:</p>
<ol>
<li>
<p>The motivation for introducing a backing class shifts slightly: we have the ability to have state at the module level already, including via class-backed helpers. What we need is a way to have state that is for <em>each component instance</em>. A class is JavaScript’s first-class way of doing that, so we have a version of first-class component templates which supports it!</p>
</li>
<li>
<p>Having made the motivation clear, we can show the <code>&lt;template&gt;</code> in the body of the class and explain that it is exactly the same as a standalone template component, except that it now has access to the backing class for local state, &quot;actions&quot;, etc.</p>
</li>
</ol>
<h5 id="template-lifecycle-dom-and-modifiers"><a class="header" href="#template-lifecycle-dom-and-modifiers">Template Lifecycle, DOM, and Modifiers</a></h5>
<p>Once again, many of the changes here will be mechanical: just using the new syntax. However, this also provides another opportunity to discuss (and demonstrate) the value of local-only vs. exported functionality. Both of the main custom modifier examples here currently show highly-reusable examples of modifiers which <em>should</em> be exported and should indeed probably live in their own modules. Accordingly, we might find an example which shows the value of having a locally-scoped modifier—e.g. something which manages the private details of an <code>iframe</code>.</p>
<h3 id="api-docs-7"><a class="header" href="#api-docs-7">API Docs</a></h3>
<p>There is presently no API for <code>&lt;template&gt;</code> itself, as proposed in this RFC, though it leaves room for future RFCs to do so.<sup class="footnote-reference"><a href="#emblem-etc">12</a></sup> Since there is no import location, we should cover it under the <code>@glimmer/component</code> module documentation. This will be a natural home for it, since we will always discuss it in the context of components.</p>
<div class="footnote-definition" id="emblem-etc"><sup class="footnote-definition-label">12</sup>
<p>Historically, for example, many Ember apps used <a href="http://emblemjs.com">Emblem</a> as a templating language—and it is still possible to do so today! In the future, that could be supported with <code>&lt;template lang=&quot;emblem&quot;&gt;</code>. This would also be an easy home for experiments with a Svelte-like syntax with e.g. <code>&lt;template lang=&quot;svelte&quot;&gt;</code> etc.</p>
</div>
<h3 id="existing-ember-users"><a class="header" href="#existing-ember-users">Existing Ember users</a></h3>
<p>The Ember community has long experience with the idea that we can only have <em>one</em> component per file, and that component templates and the backing class must always be in separate files. The name of this feature, <em>first-class component templates</em>, is designed to help explain how it relates to that historical experience. In the past, templates in many ways were second-class citizens of the overall experience of authoring an Ember app—especially for template-only components. Adding even a small amount of functionality to a template came with a lot of friction and other downsides: switching to a class-backed component, or introducing a globally-available helper. Now, adding a local helper utility is no different for a template-only component than it is anywhere else: write a function!</p>
<p>As a result, we can teach this to existing Ember users as taking everything they already know about how templates work, while making it faster, easier, and lighter-weight to solve common problems. The one significant new concept here is the <code>&lt;template&gt;</code> tag. We can describe that to existing features as the one addition which raises templates up to being a first-class tool in your app or addon. For this audience, we can explicitly connect standalone <code>&lt;template&gt;</code> to “template-only components,” a long-standing concept. (I did <em>not</em> use this verbiage in the overall discussion because this design, even more than Octane, helps make template-only components the <em>default</em> kind of component, with class-backed components the exception and thing to treat as a special case.)</p>
<p>A blog post can introduce the feature along these lines when the feature ships, with examples showing how it simplifies existing patterns and enables new capabilities. For simplifying existing patterns, we might pull the same Mapbox example from the guides shown above. For enabling new capabilities, we could show how it enables using native CSS Modules with none of the hacks required by Ember CSS Modules.</p>
<h2 id="drawbacks-172"><a class="header" href="#drawbacks-172">Drawbacks</a></h2>
<ul>
<li>
<p>Since there is no notional import for <code>&lt;template&gt;</code>, there also isn’t a notional home for API documentation for it other than components.</p>
</li>
<li>
<p>We must build a custom tooling integration with Prettier for the file format to <em>parse</em>. (As discussed below, we must build custom tooling to <em>use</em> Prettier for other options, but Prettier can <em>parse</em> them without custom tooling.)</p>
</li>
<li>
<p>Developers may put an unreasonable number of components, helpers, modifiers, etc. in a single file, degrading the maintainability of that module. However, the counterpoint here is that large files are already common in many code bases, with or without this tool. Indeed, that happens in non-UI and UI code bases alike!</p>
<p>Moreover, experience from frameworks which restrict component authoring formats to a single component per file, including Ember’s loose mode templates as well as Vue and Svelte SFCs, is that those components themselves tend to balloon in size. Sometimes that’s because everything in those components is notionally related or because much of it should be treated as &quot;private API&quot; for that component (even if it would be helpful to refactor small local components). Sometimes it is just because of the annoying overhead of needing to create a separate file to break the huge component into smaller pieces, and then import them all (or make them globally available, in Ember loose mode template!).</p>
<p>The analogy here would be if a JavaScript module could only have a single function or class in it, or a CSS file could only have a single declaration in it, regardless of what actually made sense for that particular module.</p>
</li>
<li>
<p>The syntax offered here, <code>&lt;template&gt;</code>, overlaps with <a href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element/template">a platform built-in</a>, and would look very strange if a user <em>did</em>  want to use the built-in form. This may provoke some degree of confusion for users if they are familiar with it. However, there are several reasons to think this drawback is not significant:</p>
<ul>
<li>
<p>In practice <code>&lt;template&gt;</code> is very-little used, and only in the context of progressive enhancement with vanilla JS—not with frameworks.</p>
</li>
<li>
<p>Although it looks a little odd, the platform-native <code>&lt;template&gt;</code> can still be nested <em>within</em> a <code>&lt;template&gt;</code> tag as defined here.</p>
</li>
<li>
<p>Other frameworks (most notably Vue) have used <code>&lt;template&gt;</code> in much the same way we are here with no major confusion on the part of developers.</p>
</li>
<li>
<p>Most importantly, there is no <em>actual</em> conflict with the platform built-in, since <code>&lt;template&gt;</code> is not <em>JavaScript</em> syntax, which is where we are using it.</p>
</li>
</ul>
<p>As a bonus: in a certain sense, the use of <code>&lt;template&gt;</code> here “rhymes” with the version from the platform: it represents the dynamic HTML content associated with some JavaScript functionality.</p>
</li>
<li>
<p>Some developers prefer to keep a hard file-level separation between JavaScript and HTML. This proposal allows that to continue for loose mode components, but not for strict mode components, and strongly suggests a future where it is <em>not</em> possible (if we deprecate loose mode in the future).</p>
</li>
</ul>
<h2 id="alternatives-174"><a class="header" href="#alternatives-174">Alternatives</a></h2>
<p>Within the major strokes of this design proposal, we could tweak the invocation for the template space to clarify that it does <em>not</em> overlap with the built-in <code>&lt;template&gt;</code> tag.</p>
<ul>
<li>Use <code>&lt;Template&gt;</code> or <code>&lt;Glimmer&gt;</code> or similar. This would disambiguate it from the built-in <code>&lt;template&gt;</code>, but would introduce ambiguity with component invocation.</li>
<li>Use a new sigil—much as we use <code>&lt;:main&gt;...&lt;/:main&gt;</code> for named blocks, we could do <code>&lt;[template]&gt;...&lt;/[template]&gt;</code> or something similar. While verbose and not especially pretty, this avoids overloading the platform tag.</li>
</ul>
<p>There are also alternative possibilities for defining the type of a non-class-backed <code>&lt;template&gt;</code>, for the choice of consistency of <code>&lt;template&gt;</code> between class-backed and non-class-backed components, and for the syntax for <em>some</em> sort of strict mode templates.</p>
<h3 id="typescript-signature"><a class="header" href="#typescript-signature">TypeScript signature</a></h3>
<p>Instead of adding the generic position to <code>&lt;template&gt;</code>, we can simply recommend that TypeScript users always create a named <code>&lt;template&gt;</code> with a <code>const</code> binding, and then <code>export default</code> that named export:</p>
<pre><code class="language-js">import type { TC } from '@glimmer/component';

const Greet: TC&lt;{ name: string }&gt; = &lt;template&gt;
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
&lt;/template&gt;

export default Greet;
</code></pre>
<p>(Users may also be tempted use an <code>as</code> cast after the <code>&lt;template&gt;</code>—but this is unsafe: it allows users to unsafely provide a narrower type than the item actually provides, whereas assignment only allows <em>widening</em> of the types.)</p>
<p>This works, and it simplifies the burden of the tooling implementation, but it comes with the significant downside of making a <em>much</em> worse authoring experience for TypeScript users than for JavaScript users.</p>
<h3 id="distinguishing-class-backed-and-template-only-components"><a class="header" href="#distinguishing-class-backed-and-template-only-components">Distinguishing class-backed and template-only components</a></h3>
<p>There is a small pedagogical difficulty, suggested by some of the language above, about the fact that we use <code>&lt;template&gt;</code> here to represent both the entirety of a component, when it is free-standing; and also the template portion of a component, when it is embedded in a class. Similarly, the proposed syntax for a TypeScript type signature must forbid the type parameter in class-backed components, because the correct home for the type parameter is on the backing class itself.</p>
<p>We could instead introduce <code>&lt;component&gt;</code> and <code>&lt;template&gt;</code> as separate constructs, where <code>&lt;template&gt;</code> provides a template definition for the class it is embedded in, and <code>&lt;component&gt;</code> defines a standalone component. In this approach, <code>&lt;component&gt;</code> could <em>not</em> be used within the body of a class, nor <code>&lt;template&gt;</code> in a standalone form.<sup class="footnote-reference"><a href="#route-template">16</a></sup></p>
<p>The major downside here is that the transformation of adding a backing class becomes a bit more involved: not just moving a <code>&lt;template&gt;</code> definition into the new class body, but moving a <code>&lt;component&gt;</code> into the new class body and then changing it from <code>&lt;component&gt;</code> to <code>&lt;template&gt;</code>. Notice, however, that the move for TS users <em>already</em> involves some further transformation, even if we chose not to ship the <code>&lt;template[Signature]&gt;</code> form, because type parameters have to move. The same goes for any documentation attached to a <code>&lt;template&gt;</code> declaration when moved to a backing class: it has to go on the class itself instead.</p>
<p><strong>This is a reasonable alternative and <em>we should strongly consider adopting it</em>.</strong> I did not propose it here because I think just using <code>&lt;template&gt;</code> is more or less comparable to having both <code>&lt;template&gt;</code> and <code>&lt;component&gt;</code> on balance, and having <em>only</em> <code>&lt;template&gt;</code> feels a little nicer. That is, however, a purely subjective judgment and I would be perfectly happy with a solution using both <code>&lt;component&gt;</code> and <code>&lt;template&gt;</code>.</p>
<div class="footnote-definition" id="route-template"><sup class="footnote-definition-label">16</sup>
<p>One other <em>possible</em> upside is that we could then in theory use <code>&lt;template&gt;</code> in the context of routes—but it is not clear that that is preferable to the direction suggested by <a href="https://github.com/emberjs/rfcs/pull/731">RFC #0731</a>. My own judgment is that using <code>&lt;template&gt;</code> that way would be a mistake.</p>
</div>
<h3 id="alternative-syntaxes"><a class="header" href="#alternative-syntaxes">Alternative syntaxes</a></h3>
<p>Additionally, there are three major alternatives which Ember community members have proposed in the design space:</p>
<ul>
<li><strong>imports-only:</strong> a design which uses “front-matter” to add imports, and only imports, to templates, while maintaining everything else in today’s system</li>
<li><strong>single-file components (SFCs)</strong>: a design which follows the example of Svelte and Vue and make HTML the basis of a component, and use a <code>&lt;script&gt;</code> tag to host JavaScript functionality</li>
<li><strong><code>hbs</code> template literals</strong>: a design which mirrors the <code>&lt;template&gt;</code> design quite closely, but uses <code>hbs</code> template literals similar to those we use in tests today</li>
</ul>
<p>I discuss each of these briefly below; for a <em>much</em> longer and more thorough discussion, please see the ~16,000-word series of blog posts I wrote as a deep dive: <a href="https://v5.chriskrycho.com/journal/ember-template-imports/"><strong>Ember Template Imports</strong></a>. Notably, as I alluded to above, <em>all</em> of them require custom parsing implementation for tooling, especially including Prettier and language servers.</p>
<h4 id="imports-only"><a class="header" href="#imports-only">Imports-only</a></h4>
<p>The imports-only design borrows the idea of “front-matter” from many text authoring formats, using something like <code>---</code>-delimiters to introduce a new, non-Handlebars area at the top of a template which allows exactly and only <em>imports</em> to appear. As with all strict-mode designs, all non-built-in values must be imported here. Thus, the <em>template</em> for the final component shown in the motivating example might appear like this:</p>
<details><summary>motivating example shown with imports-only</summary>
<ul>
<li>
<p><code>greet.hbs</code>:</p>
<pre><code class="language-hbs">&lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
</code></pre>
</li>
<li>
<p><code>set-username.js</code>:</p>
<pre><code class="language-js">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

export default class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) =&gt; {
    this.name = value;
  }

  saveName = (submitEvent) =&gt; {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };
}
</code></pre>
</li>
<li>
<p><code>set-username.hbs</code>:</p>
<pre><code class="language-hbs">&lt;form {{on &quot;submit&quot; this.saveName}}&gt;
  &lt;label for='name'&gt;Set username:&lt;/label&gt;
  &lt;input
    id='name'
    value={{this.value}}
    {{on &quot;input&quot; this.updateName}}
  /&gt;
  &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
    Generate
  &lt;/button&gt;
&lt;/form&gt;
</code></pre>
</li>
<li>
<p><code>replace-location.js</code>:</p>
<pre><code class="language-js">export default function replaceLocation(el, { with: newUrl }) {
    el.contentWindow.location.replace(newUrl);
});
</code></pre>
</li>
<li>
<p><code>generate-avatar.js</code>:</p>
<pre><code class="language-js">import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import Greet from './greet.glimmer';
import SetUsername from './set-username.glimmer';

export default class GenerateAvatar extends Component {
  @tracked name = &quot;&quot;;

  get previewUrl() {
    return `http://www.example.com/avatars/${name}`;
  }

  updateName = (newName) =&gt; {
    this.name = newName;
  };
}
</code></pre>
</li>
<li>
<p><code>generate-avatar.hbs</code>:</p>
<pre><code class="language-hbs">---
import Greet from './greet';
import SetUsername from './set-username';
import replaceLocation from '../modifiers/replace-location';
---

&lt;Greet @name={{this.name}} /&gt;
&lt;SetUsername
  @name={{this.name}}
  @onSaveName={{this.updateName}}
/&gt;

{{#if (gt 0 this.name.length)}}
  &lt;iframe
    title='Preview'
    {{replaceLocation with=this.previewUrl}}
  &gt;
{{/if}}
</code></pre>
</li>
</ul>
</details>
<p>The major upside to this is that it is the smallest possible delta over today’s implementation. It also allows users who appreciate the separation between JavaScript and template files to maintain that. However, it has a number of significant downsides which render it much worse than the first-class component templates proposal, and in some cases worse than the <em>status quo</em>.</p>
<p>First, as with today’s <em>status quo</em>, it does not allow locally-scoped JavaScript values (including helpers and modifiers but also ecosystem tooling like GraphQL values, CSS-in-JS tooling, etc.) even when that is a perfectly reasonable design decision.</p>
<p>Second, it substantially complicates the implementation of tooling for language servers, which have to do extra work to detect the presence of a backing class and “stitch together” the backing class and the template if a backing class does exist.</p>
<p>Third, Since there are separate files for a template and its backing class, users may be tempted try to implement JavaScript functionality in the module for the backing class, and import it in the template:</p>
<pre><code class="language-js">import Component from '@glimmer/component';

export function isBirthday() {/*...*/}

export default class MyComponent extends Component { /*...*/ }
</code></pre>
<pre><code class="language-hbs">---
import { isBirthday } from './my-component';
---
{{#if (isBirthday @user.name)}}
  &lt;p&gt;Happy birthday, {{@user.name}}!&lt;/p&gt;
{{/if}}
</code></pre>
<p>While a colocated template (the default since Octane) is part of the same module as the backing class, this does technically work<sup class="footnote-reference"><a href="#recursive-module">17</a></sup> However, it’s the kind of extremely surprising and weird thing we would generally try to avoid pedagogically—it requires us to explain that these two separate files (<code>.js</code> and <code>.hbs</code>) are combined into a single module at build time… and that we have nonetheless kept them separate at authoring time, requiring these kinds of workarounds.<sup class="footnote-reference"><a href="#recursive-import-perf">18</a></sup></p>
<p>Perhaps most critically, this is <strong>much worse than the <em>status quo</em> for tests</strong>.</p>
<p>If we support strict mode for tests, then out of the box we require people’s test authoring format to become <em>massively</em> more verbose and less useful, with imports in every single test <code>hbs</code> string, to support strict mode for tests:</p>
<pre><code class="language-js">import { module, test } from 'qunit';
import { hbs } from 'ember-cli-htmlbars';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';

module('demonstrates the problem', function (hooks) {
  setupRenderingTest(hooks);

  test('by rendering an imported component', async function (assert) {
    await render(hbs`
      ---
      import ComponentToTest from 'my-app/components/component-to-test';
      ---

      &lt;ComponentToTest /&gt;
    `);
  });

  test('then again with an argument', async function (assert) {
    await render(hbs`
      ---
      import ComponentToTest from 'my-app/components/component-to-test';
      ---

      &lt;ComponentToTest @anArg={{123}} /&gt;
    `);
  });
});
</code></pre>
<p>There are two major problems to notice here:</p>
<ol>
<li>
<p>There is no way to import <code>ComponentToTest</code> here just once. This overhead will multiply across the number of items to reference in a given test—every component, every helper, every modifier!—as well as across the number of tests. This is a <em>large</em> increase in the burden of testing compared to today.</p>
</li>
<li>
<p>This also requires us to maintain, <em>and to teach</em>, the <code>hbs</code> handling for tests (or to design some replacement for it), on top of the “regular” template handling for components. This is the same situation as in Ember apps today—but since first-class component templates allow us to <em>improve</em> the consistency between app code and test code, this counts as a negative by comparison!</p>
</li>
</ol>
<p>To get around this, we could continue to support a completely separate design for testing than for app code. In that case, though, if we want to support strict mode templates in tests, we need a separate authoring format for tests from app code. In fact, it basically requires that we fully implement something like the first-class component templates design!</p>
<div class="footnote-definition" id="recursive-module"><sup class="footnote-definition-label">17</sup>
<p>To see this for yourself, follow the instructions in <a href="https://gist.github.com/chriskrycho/dc5adabd80c04d405c7a4894c0ffb99e">this gist</a>. I had to test this out myself, and while it’s actually <em>very good</em> that modules work this way, I was initially surprised by it! If you’re curious: imports and exports are <em>static</em> and so are analyzed before the module is executed.</p>
</div>
<div class="footnote-definition" id="recursive-import-perf"><sup class="footnote-definition-label">18</sup>
<p>Without additional post-processing, this would also introduce extra runtime overhead in terms of the imports!</p>
</div>
<h4 id="sfcs"><a class="header" href="#sfcs">SFCs</a></h4>
<p>Single File Components (hereafter SFCs) start with an HTML baseline and layer on functionality in a <code>&lt;script&gt;</code> tag, modeled on HTML’s own design, but with extra semantics supporting imports and making an <code>export default class extends Component</code> statement provide the <code>this</code> for the template context. It can, however, define modifiers and helpers local to the component. You can think of this as a fairly natural (and HTML-like) extension to the imports-only design.</p>
<details><summary>motivating example shown with SFCs</summary>
<ul>
<li>
<p><code>greet.glimmer</code>:</p>
<pre><code class="language-hbs">&lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
</code></pre>
</li>
<li>
<p><code>set-username.glimmer</code>:</p>
<pre><code class="language-hbs">&lt;script&gt;
  import Component from '@glimmer/component';
  import { tracked } from '@glimmer/tracking';

  export default class SetUsername extends Component {
    @tracked name = '';

    updateName = ({ target: { value } }) =&gt; {
      this.name = value;
    }

    saveName = (submitEvent) =&gt; {
      submitEvent.preventDefault();
      this.args.onSaveName(this.name);
    };
  }
&lt;/script&gt;

&lt;form {{on &quot;submit&quot; this.saveName}}&gt;
  &lt;label for='name'&gt;Set username:&lt;/label&gt;
  &lt;input
    id='name'
    value={{this.value}}
    {{on &quot;input&quot; this.updateName}}
  /&gt;
  &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
    Generate
  &lt;/button&gt;
&lt;/form&gt;
</code></pre>
</li>
<li>
<p><code>generate-avatar.glimmer</code>:</p>
<pre><code class="language-hbs">&lt;script&gt;
  import Component from '@glimmer/component';
  import { tracked } from '@glimmer/tracking';
  import Greet from './greet.glimmer';
  import SetUsername from './set-username.glimmer';

  function replaceLocation(el, { with: newUrl }) {
    el.contentWindow.location.replace(newUrl);
  }

  export default class GenerateAvatar extends Component {
    @tracked name = &quot;&quot;;

    get previewUrl() {
      return `http://www.example.com/avatars/${name}`;
    }

    updateName = (newName) =&gt; {
      this.name = newName;
    };
  }
&lt;/script&gt;

&lt;Greet @name={{this.name}} /&gt;
&lt;SetUsername
  @name={{this.name}}
  @onSaveName={{this.updateName}}
/&gt;

{{#if (gt 0 this.name.length)}}
  &lt;iframe
    title='Preview'
    {{replaceLocation with=this.previewUrl}}
  &gt;
{{/if}}
</code></pre>
</li>
</ul>
</details>
<p>This is very attractive in some ways, but it comes with three downsides:</p>
<p>First, SFCs do not allow multiple components to be defined in a single file. This has been an ongoing sticking point with the Vue and Svelte designs, such that there is even an <a href="https://github.com/sveltejs/rfcs/blob/inline-components/text/0000-inline-components.md">RFC for Svelte for supporting at least a subset of this functionality</a>.</p>
<p>Second, the scope handling for the default export is unusual and requires additional teaching.</p>
<p>Third, and again most critically: as with the imports-only design, <strong>the SFC design requires that we continue to support a completely separate design for testing than for app code or use an incredibly verbose test authoring format.</strong> If we maintain the same authoring format, we end up with the same problems as in the imports-only proposal:</p>
<pre><code class="language-js">import { module, test } from 'qunit';
import { hbs } from 'ember-cli-htmlbars';
import { setupRenderingTest } from 'ember-qunit';
import { render } from '@ember/test-helpers';

module('demonstrates the problem', function (hooks) {
  setupRenderingTest(hooks);

  test('by rendering an imported component', async function (assert) {
    await render(hbs`
      &lt;script&gt;
        import ComponentToTest from 'my-app/components/component-to-test';
      &lt;/script&gt;

      &lt;ComponentToTest /&gt;
    `);
  });

  test('then again with an argument', async function (assert) {
    await render(hbs`
      &lt;script&gt;
        import ComponentToTest from 'my-app/components/component-to-test';
      &lt;/script&gt;

      &lt;ComponentToTest @anArg={{123}} /&gt;
    `);
  });
});
</code></pre>
<p>Besides having all the same problems as the imports-only approach does, notice that this also substantially increases the cost of tooling even at the level of syntax highlighting, because now we need multiple nested layers of syntax highlighting: <code>hbs</code> strings include both HTML and JavaScript! While some syntax highlighters support this, it is a much higher lift for those which do not.</p>
<p>And, once again, avoiding those problems more or less requires that we fully implement first-class component templates to avoid this!</p>
<h4 id="template-literals-hbs"><a class="header" href="#template-literals-hbs">Template literals (<code>hbs</code>)</a></h4>
<p>The “template literals” design takes as its starting point the <code>hbs</code> template strings Ember has used for testing since the 1.x era. It is relatively similar to the <code>&lt;template&gt;</code> design, in that it uses JavaScript/TypeScript files as the basis for its design. Unlike <code>template</code>, it uses an explicit <code>hbs</code> import, presumably from <code>@glimmer/component</code>. For components with a backing class, the template is defined as a static class field.</p>
<details><summary>Motivating example shown with <code>hbs</code></summary>
<pre><code class="language-js">import Component, { hbs } from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

const Greet = hbs`
  &lt;p&gt;Hello, {{@name}}!&lt;/p&gt;
`;

class SetUsername extends Component {
  @tracked name = '';

  updateName = ({ target: { value } }) =&gt; {
    this.name = value;
  }

  saveName = (submitEvent) =&gt; {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  static template = hbs`
    &lt;form {{on &quot;submit&quot; this.saveName}}&gt;
      &lt;label for='name'&gt;Set username:&lt;/label&gt;
      &lt;input
        id='name'
        value={{this.value}}
        {{on &quot;input&quot; this.updateName}}
      /&gt;
      &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
        Generate
      &lt;/button&gt;
    &lt;/form&gt;
  `;
}

function replaceLocation(el, { with: newUrl }) {
  el.contentWindow.location.replace(newUrl);
}

export default class GenerateAvatar extends Component {
  @tracked name = &quot;&quot;;

  get previewUrl() {
    return `http://www.example.com/avatars/${name}`;
  }

  updateName = (newName) =&gt; {
    this.name = newName;
  };

  static template = hbs`
    &lt;Greet @name={{this.name}} /&gt;
    &lt;SetUsername
      @name={{this.name}}
      @onSaveName={{this.updateName}}
    /&gt;

    {{#if (gt 0 this.name.length)}}
      &lt;iframe
        title='Preview'
        {{replaceLocation with=this.previewUrl}}
      &gt;
    {{/if}}
  `;
}
</code></pre>
</details>
<p>This has a few significant advantages!</p>
<p>First, unlike with the <code>&lt;template&gt;</code> proposal, Prettier can <em>parse</em> a file using <code>hbs</code> string with no further changes. (It cannot <em>format</em> them, however: it treats the contents of the string opaquely.) This is a small, but significant, decrease in the cost of supporting the format both up front and over time.</p>
<p>Second, it feels familiar to developers in the Ember ecosystem used to using <code>hbs</code> strings with their tests.</p>
<p>Third, the broader JavaScript ecosystem makes use of a number of template string syntaxes, e.g. with <code>css</code> from <a href="https://emotion.sh/docs/@emotion/css">Emotion</a> or <a href="https://www.apollographql.com/docs/react/data/queries/"><code>graphql</code> from Apollo</a>, so it has familiarity for people coming from <em>outside</em> the Ember ecosystem as well.</p>
<p>Fourth, we do not need to introduce custom syntax for providing types: we can type <code>hbs</code> as a function which accepts the args/signature as a type parameter, and teach people to perform.</p>
<p>Finally, it shares many of the other strongly-positive properties of the <code>&lt;template&gt;</code> design, including that it works exactly the same way for testing and app code.</p>
<p>These advantages are strong enough that this is <em>absolutely</em> the second-best move in the design space for us, and given a choice between maintaining the status quo and using <code>hbs</code> (i.e. if <code>&lt;template&gt;</code> were off the table), <em><strong>we should absolutely choose <code>hbs</code></strong></em>.</p>
<p>Those positives notwithstanding, <strong>it also has some significant disadvantages compared to <code>&lt;template&gt;</code></strong>.</p>
<p>First, the design re-purposes JavaScript syntax and gives it totally different semantics—like <code>&lt;template&gt;</code> does with HTML, but with <em>zero</em> signal from the context that it is doing something special.</p>
<ul>
<li>
<p><code>hbs</code> is <em>not</em> actually a template string literal; it is a compile-time macro. Attempting to use it like a template string literal (e.g. by using <code>${...}</code> string interpolation) is a build-time error. This substantially undercuts the familiarity of the design: <code>css</code> and <code>graphql</code> and similar are <em>actual</em> string templates, not compile-time macros, and accordingly developers can use normal JavaScript semantics with them.</p>
</li>
<li>
<p>The use of <code>static template = ...</code> has the wrong semantics: static class fields do not have access to an instance’s <code>this</code>—but templates quite expressly <em>do</em>. The whole point of a component with a backing class is to provide a normal JavaScript <code>this</code>, so this is a significant mismatch, which has consequences for both teaching and tooling.</p>
</li>
</ul>
<p>Second, the learning path is <em>much</em> less gradual: the simplest possible component requires showing and at least minimally explaining JavaScript import and export semantics and template literals <em>and</em> that it isn’t a normal template literal as described above.</p>
<p>Third, explaining what exactly <code>hbs</code> invocations produce is also strange: they aren’t actually JavaScript expressions, but they <em>appear</em> to be. In a template-only context, “invoking” <code>hbs</code> produces a component; in a class, it produces the <em>template</em> for that component. This is the same as with the <code>&lt;template&gt;</code> proposal, but it has the additional quirk of using JavaScript syntax to do it, rather than shifting languages.</p>
<p>Fourth, while supplying a type definition which allows <code>hbs</code> to receive a type parameter initially appears nicer than the custom syntax for <code>&lt;template&gt;</code>, that form <em>appears</em> like an unsafe type cast in TypeScript, the same as writing <code>as TC&lt;Signature&gt;</code> after the definition. In terms of how we implement the transform, it would actually be safe in practice (the compiled output would be the same as with <code>&lt;template[Signature]&gt;</code>, and therefore would constrain the body of the template in the same way)—but only because the thing passed to <code>hbs</code> is <em>not</em> a template string. People can therefore not rely on any of their intuitions on the TypeScript side, either.</p>
<p>Net, while there are some nice features to the <code>hbs</code> proposal, it comes out significantly worse than <code>&lt;template&gt;</code> in most ways we care about. The decreased tooling costs are real, but they are much smaller than the other downsides of the format.</p>
<h2 id="unresolved-questions-112"><a class="header" href="#unresolved-questions-112">Unresolved questions</a></h2>
<ul>
<li>
<p>Introducing a new file extension also provides an easy opportunity to change the default component manager for class-backed components in, and only in, the new file type—eliminating the need to subclass from Glimmer's <code>Component</code>. From the motivating example:</p>
<pre><code class="language-js">class SetUsername {
  @tracked name = '';

  updateName = ({ target: { value } }) =&gt; {
    this.name = value;
  }

  saveName = (submitEvent) =&gt; {
    submitEvent.preventDefault();
    this.args.onSaveName(this.name);
  };

  &lt;template&gt;
    &lt;form {{on &quot;submit&quot; this.saveName}}&gt;
      &lt;label for='name'&gt;Set username:&lt;/label&gt;
      &lt;input
        id='name'
        value={{this.value}}
        {{on &quot;input&quot; this.updateName}}
      /&gt;
      &lt;button type='submit' disabled={{eq this.value.length 0}}&gt;
        Generate
      &lt;/button&gt;
    &lt;/form&gt;
  &lt;/template&gt;
}
</code></pre>
<p>However, this is, at present, not yet well-motivated: it’s not clear what the actual advantage it provides over an explicit inheritance-driven interface. Additionally, has unresolved complexities around providing the types needed for Glint, which requires a home for the information about the element(s) and yield(s) for the component. Today, Glint uses type-only declarations on Glimmer <code>Component</code>, which cannot be straightforwardly translated to this mode. This is likely tractable, and a future RFC may introduce it (including for defaulting <code>.gjs</code> and <code>.gts</code> into it automatically), but it is large enough that it is probably worth addressing separately.</p>
</li>
<li>
<p>Does the possible confusion with the platform <code>&lt;template&gt;</code> warrant adopting an alternative syntax, whether component-like (<code>&lt;Template&gt;</code>) or using an additional sigil (<code>&lt;[template]&gt;</code>, <code>&lt;% ... %&gt;</code>, <code>&lt;$ ... $&gt;</code> etc.)? If so, what design? Here we must keep in mind that the design should not be ambiguous with “dynamic” behavior (e.g. <code>&lt;{template}&gt;</code> which is suggestive of the Svelte and React expression marker, and which we might find attractive for future iterations of template language ourselves).</p>
</li>
<li>
<p>Are <code>.gjs</code> and <code>.gts</code> the best file extensions?</p>
</li>
<li>
<p>How does this relate to the currently un-merged <a href="https://github.com/emberjs/rfcs/pull/731">RFC #0731: Add <code>setRouteComponent</code> API</a>? That is: can we merge this and proceed with authoring components while there is an unresolved design problem for the related issue of routes, controllers, and their host components? Or should we see this as a helpful part of resolving <em>that</em> design question? (I believe we can move forward in parallel.)</p>
<p>The primary challenge here is that, as things stand, our guides would have some fairly substantial incoherence until we solve the problems which #0731 is addressing: route templates would be totally different from component templates in their semantics and behavior. This points to the ongoing and increasing divergence of the <code>Route</code> and <code>Controller</code> design from the rest of the framework, but it’s directly connected to <em>this</em> RFC pedagogically.</p>
</li>
<li>
<p>Should we include a plan for a staged rollout of deprecating namespace resolution in this RFC, rather than tackling it in a later RFC?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-11-30
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember
RFC PR: https://github.com/emberjs/rfcs/pull/785</h2>
<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->
<h1 id="introduce-new-test-helpers-for-rendering-and-re-rendering-that-obviate-the-need-for-get-and-set"><a class="header" href="#introduce-new-test-helpers-for-rendering-and-re-rendering-that-obviate-the-need-for-get-and-set">Introduce new test helpers for rendering (and re-rendering) that obviate the need for <code>get</code> and <code>set</code></a></h1>
<h2 id="summary-188"><a class="header" href="#summary-188">Summary</a></h2>
<p>Introduce new testing utilities that remove the need for the use of <code>this.get</code>/<code>this.set</code> in test contexts. This will make rendering tests behave more like application code, and also greatly simplify the process of writing rendering tests in TypeScript since it will remove the need to append type information to <code>this</code> as properties are set.</p>
<h2 id="motivation-188"><a class="header" href="#motivation-188">Motivation</a></h2>
<p>Current rendering tests require developers to set values on <code>this</code> in order for them to actually be present in the template that gets rendered as part of the test. For example, if we're testing that a component correctly displays a value that gets passed in as an argument, we'd do something like:</p>
<pre><code class="language-js">this.set('name', 'foo');

await render(hbs`&lt;MyComponent @name={{this.name}} /&gt;`);

assert.dom('[data-test-name]').hasText(this.get('name'));

this.set('name', 'FOO');

assert.dom('[data-test-name]').hasText(this.get('name'));
</code></pre>
<p>This approach has three main issues:</p>
<ol>
<li>It's not consistent with any other programming model in Ember</li>
<li>It synchronously flushes the DOM</li>
<li>It makes writing tests in TypeScript a huge pain</li>
</ol>
<p>On the first point: <code>this.set</code> is essentially irrelevant everywhere else in Ember. In a post-Octane world, we no longer need to <code>get</code> or <code>set</code>, and it is, in fact, frequently discouraged as an unnecessary complication. Additonally, the value of <code>this</code> inside of a test is extremely murky. The fact that <code>this</code> is both the test context <em>and</em> a sort of ersatz scope for the surrounding &quot;template&quot; of the rendering test is not exactly intuitive or easy to teach.</p>
<p>On the second point: <code>this.set</code> is actually <a href="https://github.com/emberjs/ember-test-helpers/blob/master/addon-test-support/@ember/test-helpers/setup-context.ts#L412-L423">run-wrapped when called in tests</a>, which means that every time someone calls <code>this.set</code>, they are actually synchronously flushing the entirety of the DOM and triggering a re-render of the entire test template. This <em>in no way</em> resembles the relationship between data updates and re-renders in application code. In application code, changes to the underlying data in template are coalesced into a single DOM update, which, in turn, re-renders only the parts of the DOM that are affected by the changed data. As a result, rendering tests end up essentially testing a version of rendering that isn't even used in the application being tested.</p>
<p>On the third point: having to set properties on <code>this</code> leads to a whole bunch of papercuts when writing tests in TypeScript. <a href="https://docs.ember-cli-typescript.com/ember/testing#the-testcontext">As discussed in the <code>ember-cli-typescript</code> docs</a>, rendering tests require developers to arbitrarily add (and change) properties on <code>this</code>. Developers thus have to define (and re-define) the interface for <code>this</code> to accommodate <em>all</em> of those properties to prevent TypeScript from complaining that each of the values that were set don't exist on the <code>TestContext</code> type. Beyond simply being annoying, this actually makes it impossible to write safe and useful types spanning multiple tests: properties declared for one test appear to be available in all of the tests in a module (and get autocompleted accordingly), whether or not they actually <em>are</em> available.</p>
<p>The goal of this RFC, then, is to greatly simplify the testing model by removing the need for <code>get</code> and <code>set</code> in rendering tests, thereby reducing the reliance on <code>this</code>.</p>
<h2 id="detailed-design-153"><a class="header" href="#detailed-design-153">Detailed design</a></h2>
<p>We will introduce two new/refactored utilities for use in rendering tests:</p>
<ol>
<li>Update the <code>render</code> helper to accept either a component or a template snippet.</li>
<li>A new <code>rerender</code> function that would be used after the initial <code>render</code> call to wait for DOM updates</li>
</ol>
<p>These additions, used in concert with <a href="https://github.com/emberjs/rfcs/blob/master/text/0779-first-class-component-templates.md">First Class Component Templates</a>, should significantly improve the DX of writing component tests in Ember.</p>
<h3 id="updated-render-helper"><a class="header" href="#updated-render-helper">Updated <code>render</code> helper</a></h3>
<p>Rendering tests currently work by rendering a template that is bound to the <code>this</code> of the surrounding test. This is why developers have to call <code>this.set</code> in the first place, since the value of <code>this</code> in a given test is doing double duty as both the actual test context AND the backing object for the template that eventually gets rendered. Since we want to move away from this very behavior, we need a version of <code>render</code> that can alternatively accept a fully-formed component, since components have their own context and are self-contained.</p>
<p>The updated version of <code>render</code> would be imported from <code>@ember/test-helpers</code> and have the following signature:</p>
<pre><code class="language-ts">function render(template: TemplateFactory | Component, options?: RenderOptions): Promise&lt;void&gt;;
</code></pre>
<p>Since this new version of <code>render</code> will need to differentiate between components and templates, we'll also add an <code>isComponent</code> utility to the <code>@glimmer/runtime</code> package. This addition will significantly reduce the amount of private API that would be required when implementing the new <code>render</code> function.</p>
<p>Additionally, since passing a component to <code>render</code> also precludes the user from being able to access the text context via <code>this</code> (since components will use their own local context rather than the test's), we'll display a warning message if someone passes a component to <code>render</code> while also using <code>this.set</code> in the same test. This will help avoid confusion in the case that they opt in to the new component-based testing model but then copy an example from the guides or an older writeup that uses <code>this.set</code>.</p>
<h3 id="rerender"><a class="header" href="#rerender"><code>rerender</code></a></h3>
<p>Finally, we need to handle cases where you want to update the backing data and assert against the resulting changes in the rendered output. In the current testing paradigm, we'd <em>usually</em> just update the values using <code>this.set</code>, which immediately triggers a rerender. In more complex cases, e.g. where there is some async operation involved, we would wait for the state we want to assert against, likely using either <code>settled</code> or <code>waitFor</code>. This works, but has the downside of either waiting for <em>everything</em> to finish (in the case of <code>settled</code>), or waiting for a single thing to finish (in the case of <code>waitFor</code>).</p>
<p>Instead, we propose adding a new <code>rerender</code> function to <code>@ember/test-helpers</code> that exclusively waits on pending render operations, but ignores all other <a href="https://github.com/emberjs/ember-test-helpers/blob/master/API.md#issettled">settledness metrics</a>:</p>
<pre><code class="language-ts">rerender(): Promise&lt;void&gt;
</code></pre>
<p>In order to implement <code>rerender</code>, we would also expose the work done by @rwjblue on <a href="https://github.com/emberjs/ember.js/blob/703b9ca2653a6b479a762b30dca1a33eaa13d8ab/packages/%40ember/-internals/glimmer/lib/renderer.ts#L219-L240"><code>renderSettled</code></a> as public API in a new <code>@ember/renderer</code> module so that it could then be imported and used by <code>@ember/test-helpers</code> without issuue.</p>
<p>When combined with <a href="https://guides.emberjs.com/release/in-depth-topics/autotracking-in-depth/#toc_autotracking-basics">tracked state</a>, this new <code>rerender</code> function allows developers to make updates to their component state and <code>await</code> the newly rendered version of their component <em>without</em> having to also wait for other pending timers or run loops. In other words, they can still assert against changes in the DOM, but would also be able to assert against things like loading states without having to use <code>waitFor</code> since <code>rerender</code> would not wait for things like async operations to complete.</p>
<p>Continuing the example from above, here's what we'd expect an update and re-render to look like:</p>
<pre><code class="language-js">import { render, rerender } from '@ember/test-helpers';
import { tracked } from '@glimmer/tracking';

// setup elided
test('it works', async function (assert) {
  const somePerson = new class {
    @tracked name = 'Zoey',
    @tracked age = 5,
  };

  const component = &lt;template&gt;
    &lt;ProfileCard @name={{somePerson.name}} @age={{somePerson.age}} /&gt;
  &lt;/template&gt;;

  await render(component);

  assert.dom(this.element).hasText(somePerson.name);

  somePerson.name = 'Zoeyyyyyyyyyyyyy';

  await rerender();

  assert.dom(this.element).hasText(somePerson.name);
});
</code></pre>
<p>It's worth noting that rendering tests without <code>get</code>/<code>set</code> are actually possible today using a combination of the <code>precompileTemplate</code> function from <code>@ember/template-compilation</code>, a scope object containing all of the relevant values referenced in the template, and the <code>settled</code> function from <code>@ember/test-helpers</code>. Accordingly, the implementation of this RFC would largely involve exposing these existing APIs in a way that is both more user-friendly and better-suited to both <a href="https://github.com/emberjs/rfcs/pull/779">First-Class Component Templates</a> and <a href="https://github.com/emberjs/rfcs/pull/724">TypeScript</a>, rather than introducing a significant amount of new internal functionality.</p>
<h2 id="how-we-teach-this-156"><a class="header" href="#how-we-teach-this-156">How we teach this</a></h2>
<p>We'd need to add a new TypeScript-specific section to the <a href="https://guides.emberjs.com/release/testing/testing-components/">testing components</a> section of the official guides to document this new approach for TypeScript users.</p>
<p>We expect there will be a future RFC that introduces a form which also allows passing arguments into the invoking component, in addition to the approach described in this RFC that requires a backing class in order to mark primitives as tracked. As a result, for the time being, we'll only teach this new approach in a TypeScript-specific subsection of the guides on testing components until that followup RFC has been written and merged. We believe that the benefits to the TypeScript community (namely, no longer needing to fight with the type checker over the type of <code>this</code> in each test) still significantly outweigh the costs of the slightly awkward method of passing arguments.</p>
<p>We'd also need to update the <a href="https://github.com/emberjs/ember-test-helpers/blob/master/API.md">API docs for @ember/test-helpers</a> for the new version of <code>render</code> as well as the newly introduced <code>rerender</code> function.</p>
<p>API documentation for the two new functions are included below:</p>
<h3 id="render"><a class="header" href="#render">render</a></h3>
<pre><code class="language-ts">/**
  Renders the provided template or component and appends it to the DOM, overwriting any previously-rendered template or component.
  @public
  @param {CompiledTemplate|Component} template the template or component to render
  @param {RenderOptions} options options hash containing engine owner ({ owner: engineOwner })
  @returns {Promise&lt;void&gt;} resolves when settled
*/
render(template: CompiledTemplate | Component, options?: RenderOptions): Promise&lt;void&gt;;
</code></pre>
<h3 id="rerender-1"><a class="header" href="#rerender-1">rerender</a></h3>
<pre><code class="language-ts">/**
  Returns a promise that resolves when rendering has settled.  Settled in this context is defined as when all of the
  tags in use are &quot;current&quot;. When this is checked at the _end_ of the run loop, this essentially guarantees that all
  rendering is completed.
  @public
  @returns {Promise&lt;void&gt;} resolves when settled
*/
rerender(): Promise&lt;void&gt;
</code></pre>
<p>All things considered, the changes in this RFC should result in a component testing model that is ultimately <em>more</em> intuitive. We could also introduce a configuration option to <code>@ember/test-helpers</code> that would allow users to turn on an assertion that prevents rendering tests from being written using the old method to help codebases migrate.</p>
<h2 id="drawbacks-173"><a class="header" href="#drawbacks-173">Drawbacks</a></h2>
<p>Ember's testing setup is one its most valuable features, and this RFC would introduce changes to a testing model that already works fine. These changes would be introduced alongside the existing rendering test models, so they would not constitute a breaking change, but would introduce additional overhead in terms of &quot;old vs. new&quot;, similar to the overhead of Octane, or the Grand Testing Unification RFCs.</p>
<h2 id="alternatives-175"><a class="header" href="#alternatives-175">Alternatives</a></h2>
<ul>
<li>Leave things as they are.</li>
<li>Encourage people to use <code>precompileTemplate</code> along with the current version of <code>render</code>.</li>
</ul>
<h2 id="unresolved-questions-113"><a class="header" href="#unresolved-questions-113">Unresolved questions</a></h2>
<blockquote>
<p>Optional, but suggested for first drafts. What parts of the design are still
TBD?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2021-01-11
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember Learn
RFC PR: https://github.com/emberjs/rfcs/pull/786</h2>
<!---
Directions for above:

Stage: Leave as is
Start Date: Fill in with today's date, YYYY-MM-DD
Release Date: Leave as is
Release Versions: Leave as is
Relevant Team(s): Fill this in with the [team(s)](README.md#relevant-teams) to which this RFC applies
RFC PR: Fill this in with the URL for the Proposal RFC PR
-->
<h1 id="ember-cookbook-proposal"><a class="header" href="#ember-cookbook-proposal">Ember cookbook proposal</a></h1>
<h2 id="summary-189"><a class="header" href="#summary-189">Summary</a></h2>
<p>Adding a cookbook section to our learning resources will help Ember developers to learn maintainable, accessible patterns for common tasks.</p>
<h2 id="motivation-189"><a class="header" href="#motivation-189">Motivation</a></h2>
<p>Ember docs in its current state are missing <a href="https://documentation.divio.com/how-to-guides/">how-to guides</a> that would provide goal-oriented answers / patterns to common problems Ember developers face on a daily basis. For example, if someone wants to learn how to handle a form submission, they would have to look at blog posts.
Additionally, many Ember users over the years have requested a cookbook-like resource. Early versions of Ember had a <a href="https://guides.emberjs.com/v1.12.0/cookbook/">resource like this</a>, but it was removed in 1.13.</p>
<h2 id="detailed-design-154"><a class="header" href="#detailed-design-154">Detailed design</a></h2>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<p>Ember-cookbook will be a repo under <a href="https://github.com/ember-learn">ember learn</a>. We start by introducing an Ember Cookbook section in the ember docs dropdown. </p>
<p>Currently, there is a lot of material out there in the form of blogs, stackoverflow answers and efforts like Ember Atlas. The challenge is to make sure they are discoverable.<br />
An official Ember cookbook will be a great way to officially endorse patterns, since not all patterns found on all blogs can be trusted. </p>
<p>Sourcing information for the cookbook can be done a few ways:
Officially endorsing existing articles and blogs
Monitoring most asked questions on stackoverflow 
Create entries for <a href="https://discuss.emberjs.com/t/adding-a-delete-row-button-from-a-table/18623">really good explanations</a> from the ember forum. 
Create sections that would make it easier for the developer to navigate through the different guides. Ember-data's adapter/serializer cookbook articles can go under a specific section called &quot;Ember Data&quot; within the cookbook. </p>
<p>For the MVP we can include the following articles and topics, or similar content.
<a href="https://discuss.emberjs.com/t/looking-for-an-example-of-a-grid-and-form/18490">How to create a grid/table with Ember Data and creating a CRUD form with Ember data</a>
<a href="https://discuss.emberjs.com/t/show-or-hiding-content-based-on-current-route/18567">Show or Hiding content based on current Route</a>
<a href="https://discuss.emberjs.com/t/synchronising-query-parameters-with-a-component/18084">Synchronising query parameters with a component</a>
<a href="https://stackoverflow.com/questions/24408892/ember-without-ember-data">Ember without Ember Data</a>
<a href="https://guides.emberjs.com/v1.12.0/cookbook/">Updating entries from previous cookbook</a></p>
<h3 id="contributing--maintaining"><a class="header" href="#contributing--maintaining">Contributing &amp; Maintaining</a></h3>
<p>The Ember learn team will manage this repository and will guide what goes into the cookbook. 
In addition, we could have a set of volunteers sign up to add content to the cookbook regularly. Some of the tasks to maintain the cookbook would include,
Monitoring stack overflow and other forums to come up with most-asked questions
Work closely with the Ember Core team on upgrades to add, modify or delete information from Ember Guides. </p>
<p>A cookbook template will be used to keep all the entries uniform. The template would contain the following sections, </p>
<h4 id="title"><a class="header" href="#title">Title</a></h4>
<p>This is an intro section that lets someone know what they will learn by the time they are done reading.</p>
<h4 id="the-challenge"><a class="header" href="#the-challenge">The challenge</a></h4>
<p>Lay out the example and the problem you are trying to solve</p>
<h4 id="steps"><a class="header" href="#steps">Steps</a></h4>
<p>The steps someone should take to get to the end result.
Use headings to describe steps and not numbers.</p>
<h4 id="results"><a class="header" href="#results">Results</a></h4>
<p>When you are finished, here's how it should work</p>
<h4 id="resources"><a class="header" href="#resources">Resources</a></h4>
<p>Links to Guides and API go here.
Also include ways that someone could build upon this knowledge.</p>
<h4 id="tags"><a class="header" href="#tags">Tags</a></h4>
<p>After reading this recipe you should now know what is a cookbook and what is the templete that Ember recipes follow.</p>
<h4 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h4>
<h3 id="launch-strategy"><a class="header" href="#launch-strategy">Launch strategy</a></h3>
<p>The cookbook articles will be drafted in markdown format. Once there is a critical mass of 5 articles, they can be published. The cookbook will be hosted at cookbook.emberjs.com
The cookbook will use Guidemaker, similar to cli.emberjs.com
We will mention it in the Ember Newsletter.
To Evangelize it further, we can share the links on social media and as answers to stackoverflow questions. </p>
<h3 id="versioning-3"><a class="header" href="#versioning-3">Versioning</a></h3>
<p>We can show a single version of the recipe and have a “last updated at” and a field that shows the range of versions that it is applicable to. This would make it easier to maintain. </p>
<p>What kinds of content belong in the Cookbook?
One challenge for the cookbook is determining where content belongs.</p>
<p>Today, Ember has the following key learning resources:
The Super Rentals Tutorial
The Ember Guides
The CLI Guides
The API docs
Community-maintained learning resources like blogs, videos, and livestreams</p>
<p>We know that something may belong in the cookbook if we answer yes to the following questions:</p>
<ul>
<li>The concept can be explained in an article that would take less than 10 mins to read</li>
<li>The concept is not already shown in the Super Rentals tutorial</li>
<li>The article helps show how to put together multiple Ember features to achieve a goal.</li>
<li>The article is trying to demonstrate a pattern, not teach a concept. For example, if we are showing how to use a model hook to accomplish something, we are not explaining what a model hook is.</li>
<li><a href="https://guides.emberjs.com/v1.12.0/cookbook/contributing/deciding_if_a_recipe_is_a_good_fit/#toc_solution">It is narrowly tailored to solve a single problem</a></li>
<li>It shows how to solve a problem that Ember apps may commonly face. For example, managing a dropdown menu or creating a form are common. Integrating WebRTC is not.</li>
<li>The article goal can be accomplished without installing new addons, with the exception of addons mentioned in the Guides.</li>
</ul>
<p>Removal of recipes
If a topic becomes obsolete for any reason, we could add a warning at the top. An archived section for outdated things would help with this. This way the links stay forever but hidden in a section. This way it will serve as an example of which pattern is deprecated.</p>
<h2 id="drawbacks-174"><a class="header" href="#drawbacks-174">Drawbacks</a></h2>
<p>We will need to maintain the cookbooks as we have major Ember version upgrades. </p>
<h3 id="language-support"><a class="header" href="#language-support">Language support</a></h3>
<p>The Ember documentation serves a global community. The cookbook aims to be a resource that could be translated into multiple languages after the initial content settles. The translations would be found under the same domain, <code>cookbook.emberjs.com</code></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2022-02-12
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): ember-data 
RFC PR: https://github.com/emberjs/rfcs/pull/794</h2>
<h1 id="simplify-schema-definition-service-methods-in-ember-data"><a class="header" href="#simplify-schema-definition-service-methods-in-ember-data">Simplify Schema Definition Service methods in Ember Data</a></h1>
<h2 id="summary-190"><a class="header" href="#summary-190">Summary</a></h2>
<p>This RFC is an amendment to the Custom Model Classes RFC (https://github.com/emberjs/rfcs/pull/487).
Based on implementation feedback, we discovered we could simplify the arguments to
<code>attributesDefinitionFor</code> and <code>relationshipsDefinitionFor</code> to drop the string argument and always
pass in an object.</p>
<h2 id="motivation-190"><a class="header" href="#motivation-190">Motivation</a></h2>
<p>When implementing a schema service, code ends up easier and cleaner if it does not have to deal with
both a raw string and an object.</p>
<h2 id="detailed-design-155"><a class="header" href="#detailed-design-155">Detailed design</a></h2>
<p>The original RFC proposed the following interface:</p>
<pre><code class="language-typescript">interface SchemaDefinitionService {
  // Following the existing RD implementation 
  attributesDefinitionFor(identifier: RecordIdentifier | type: string): AttributesDefinition
  
  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier: RecordIdentifier | type: string): RelationshipsDefinition
  doesTypeExist(type: string): boolean
}
</code></pre>
<p>We can simplify <code>attributesDefinitionFor</code> and <code>relationshipsDefinitionFor</code> methods to always accept an object.</p>
<pre><code class="language-typescript">interface SchemaDefinitionService {
  // Following the existing RD implementation 
  attributesDefinitionFor(identifier: RecordIdentifier | { type: string }): AttributesDefinition
  
  // Following the existing RD implementation
  relationshipsDefinitionFor(identifier: RecordIdentifier | { type: string }): RelationshipsDefinition

  doesTypeExist(type: string): boolean
}
</code></pre>
<h2 id="how-we-teach-this-157"><a class="header" href="#how-we-teach-this-157">How we teach this</a></h2>
<p>It simplifies the types passed in, so should be easier to teach.</p>
<h2 id="drawbacks-175"><a class="header" href="#drawbacks-175">Drawbacks</a></h2>
<h2 id="alternatives-176"><a class="header" href="#alternatives-176">Alternatives</a></h2>
<p>Keeping the existing design per the original RFC.</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2022-02-13
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): ember-data 
RFC PR: https://github.com/emberjs/rfcs/pull/795</h2>
<h1 id="return-a-promise-from-modelsave"><a class="header" href="#return-a-promise-from-modelsave">Return a Promise from Model.save()</a></h1>
<h2 id="summary-191"><a class="header" href="#summary-191">Summary</a></h2>
<p>Model.save() will return a Promise instead of a <a href="https://api.emberjs.com/ember/release/classes/PromiseProxyMixin"><code>PromiseProxyMixin</code></a>, otherwise referred to as a PromiseObject from here on out.</p>
<h2 id="motivation-191"><a class="header" href="#motivation-191">Motivation</a></h2>
<ul>
<li>The API documentation already documents the return value as a Promise.</li>
<li>Remove dependency on promise proxies</li>
<li>Async Consistency - The PromiseObject encourages a usage pattern of sometimes-async, sometimes-sync behavior. We want to <a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">reduce zalgo</a>.</li>
<li>API consistency - While the PromiseObject proxies properties, the PromiseObject does not proxy methods on the underlying model. For instance, if you try to call a method like destroyRecord on the model, you will get a “not a function” error because the method is called on the Proxy and not the underlying model. This encourages users for Ember Data to reach into private implementation details of the promise proxy, such as using proxy.get('content') to call methods.</li>
<li>Enable new functionality in Ember Data while making backwards compatibility with older versions of Ember easier.</li>
<li>The documentation of using PromiseObject APIs have been replaced over time in the guides and API documentation to use more typical JavaScript usage of Promises, such as async/await, instead of PromiseProxies.</li>
</ul>
<h2 id="detailed-design-156"><a class="header" href="#detailed-design-156">Detailed design</a></h2>
<p>Introduce a new feature flag, <code>DS_MODEL_SAVE_PROMISE</code>, Model.save() will return an a Promise that resolves with the model if the save was successful, or rejects with an error if the save fails.  When disabled, a PromiseObject will be returned to keep today's behavior, but accessing properties on the PromiseObject or calling non-Promise functions (.then, .finally, .catch) on the PromiseObject will issue a deprecation warning.</p>
<p>Deprecation Plan:</p>
<p>The deprecations can be implemented by adding deprecations around the existing PromiseObject. However, we can't include the deprecations in the actual PromiseObject class because <a href="https://github.com/emberjs/data/blob/master/addon/-legacy-private/system/promise-proxies.js#L85">it is the base class for the relationship proxies</a>. Instead, we can create and use a new DeprecatedPromiseObject for the DS.Model.save() function. It functions like a PromiseObject but deprecates the following behavior:</p>
<pre><code>* Accessing properties on the PromiseObject returned from DS.Model.save()
    * Use deprecateProperty from Ember to deprecate all the properties that the PromiseProxy Mixin provides. The list of properties can be found here: https://github.com/emberjs/ember.js/blob/master/packages/ember-runtime/lib/mixins/promise_proxy.js
    * Deprecate accessing any unknown properties. For instance, someone might try to grab the value of an attr or computed property from a model, e.g. proxy.get('email').
* Calling functions that are not available on Promises
    * Not Safe (issue deprecation): .get/.set/anything else really
    * Safe (do not issue a deprecation): .then, .catch, .finally
</code></pre>
<p>The implementation follows the standard feature-flagging process in Ember and Ember Data. The final implementation will look something like:</p>
<pre><code>  save(options) {
    const savePromise = this._internalModel.save(options).then(() =&gt; this);
    
    if (DS_MODEL_SAVE_PROMISE) {
      return savePromise;
    } else {
      return DeprecatedPromiseObject.create({
        promise: savePromise
      });
    }
  },
</code></pre>
<h2 id="how-we-teach-this-158"><a class="header" href="#how-we-teach-this-158">How we teach this</a></h2>
<p>We do not believe this requires any update to the Ember curriculum. API documentation does not need to be updated as it is already documented as returning a promise. This behavior of accessing properties through the PromiseProxyMixin specifically for DS.Model.save() is not documented in the guides.</p>
<h2 id="drawbacks-176"><a class="header" href="#drawbacks-176">Drawbacks</a></h2>
<p>For users relying on this behavior, they will have to refactor their code to either use patterns like async/await, ember-concurrency, or ember-promise-helpers. Alternatively, if all they want to access are properties on the model, they can use the model instead.</p>
<h2 id="alternatives-177"><a class="header" href="#alternatives-177">Alternatives</a></h2>
<ul>
<li>The impact of not doing this prevents further changes in Ember Data.</li>
<li>Return a promise but also exposing a template/js helper in a new package that wraps any promise exposing isResolved and isRejected flags. This helps maintain similar behaviour to the existing implementation.</li>
</ul>
<h2 id="unresolved-questions-114"><a class="header" href="#unresolved-questions-114">Unresolved questions</a></h2>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2022-02-20
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): ember-data 
RFC PR: https://github.com/emberjs/rfcs/pull/796</h2>
<h1 id="deprecate-rsvppromise-for-native-promise"><a class="header" href="#deprecate-rsvppromise-for-native-promise">Deprecate <code>RSVP.Promise</code> for native Promise</a></h1>
<h2 id="summary-192"><a class="header" href="#summary-192">Summary</a></h2>
<p>All methods currently returning an <code>RSVP.Promise</code> will return a native Promise. In addition, all documentation will be updated accordingly.</p>
<h2 id="motivation-192"><a class="header" href="#motivation-192">Motivation</a></h2>
<p>With the removal of IE11 from our build infrastructure and browser requirements, we can now safely remove <code>RSVP.Promise</code>. From the <a href="https://github.com/tildeio/rsvp.js/">docs</a>:</p>
<blockquote>
<p>Specifically, it is a tiny implementation of Promises/A+. It works in node and the browser (IE9+, all the popular evergreen ones).</p>
</blockquote>
<p>RSVP was Ember's polyfill since an early v1.0.0 version during a time when native Promises didn't exist in any browser.  In addition, Promises have been supported since Node 0.12.</p>
<p>By removing <code>RSVP.Promise</code> in favor of native Promises, we can drop an unnecessary dependency for both client side and server side fetching of data.</p>
<p>According to <a href="https://bundlephobia.com/package/rsvp@4.8.5">bundlephobia</a>, this would allow us to remove a significant chunk of dependency weight.</p>
<h2 id="detailed-design-157"><a class="header" href="#detailed-design-157">Detailed design</a></h2>
<p>Two steps will be required to fulfill deprecating <code>RSVP.Promise</code>.</p>
<p>First, we will issue a deprecation <code>DEPRECATE_RSVP_PROMISE</code> to async callbacks that might be relying on a convenient feature of <code>RSVP.Promise</code>.  Namely, an <code>RSVP.Promise</code> may still be hanging by the time the underlying model instance or store has been destroyed.  This will help users surface instances where their test suite or code is dealing with dangling promises.  After the removal of this deprecation, this will throw an Error.</p>
<ul>
<li><code>id: ember-data:rsvp-unresolved-async</code></li>
</ul>
<p>Second, we will also utilize the deprecation to replace all instances of <code>RSVP.Promise</code> with native Promises.</p>
<p>The final implementation will look something like:</p>
<pre><code class="language-js">  ajax(options) {
    if (DEPRECATE_RSVP_PROMISE) {
      return new Promise((resolve, reject) =&gt; {
        ...
      });
    } else {
      return new RSVPPromise((resolve, reject) =&gt; {
        ...
      });
    }
  },
</code></pre>
<h2 id="how-we-teach-this-159"><a class="header" href="#how-we-teach-this-159">How we teach this</a></h2>
<p>We do not believe this requires any update to the Ember curriculum. API documentation may be needed to remove traces of <code>RSVP.Promise</code>.</p>
<p>See the informal <a href="https://github.com/emberjs/data/blob/fa18fd148e9881a860343eabf0ba15b6f048c3ea/packages/private-build-infra/addon/current-deprecations.ts">docs</a> on how to configure your compatibility with ember-data deprecations. </p>
<h2 id="drawbacks-177"><a class="header" href="#drawbacks-177">Drawbacks</a></h2>
<p>For users relying on <code>RSVP.onerror</code>, they will have to either refactor their code to set the global Promise to RSVP or configure <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection">onunhandledrejection</a> appropriately.</p>
<p>If users continue to use <code>rsvp</code> after it is dropped from ember-data, users can add <code>rsvp</code> to their package.json explicitly if they were depending on it transitively.</p>
<p>Lastly, RSVP gives meaningful labels so that the promise can be debugged easily. We may need to take this into account with a native Promise wrapper, especially how it interacts with the Ember Inspector.</p>
<h2 id="alternatives-178"><a class="header" href="#alternatives-178">Alternatives</a></h2>
<p>Continue resolving async paths with <code>RSVP.Promise</code> will allowing users a convenient override to use native Promises.</p>
<h2 id="unresolved-questions-115"><a class="header" href="#unresolved-questions-115">Unresolved questions</a></h2>
<ul>
<li>What level of an abstraction should we provide over native Promise. Derived state for <code>isPending</code>, <code>isResolved</code>, and <code>isRejected</code> seem like probable derived state we want to expose to users to avoid significant churn in their codebase.</li>
<li>Consideration of Ember's continued use of RSVP.</li>
<li>After scanning the codebase, the non native equivalent methods we use from RSVP is <code>defer</code> in test files.  This is an implementation detail that doesn't need to be flushed out here.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2022-02-24
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): &quot;Ember.js, Ember Data, Ember CLI, Learning&quot;
RFC PR: https://github.com/emberjs/rfcs/pull/800</h2>
<h1 id="typescript-adoption-plan"><a class="header" href="#typescript-adoption-plan">TypeScript Adoption Plan</a></h1>
<h2 id="summary-193"><a class="header" href="#summary-193">Summary <!-- omit in toc --></a></h2>
<p><a href="https://github.com/emberjs/rfcs/pull/724">RFC #0724</a> commits Ember to officially supporting TypeScript and articulates an overall philosophy for what official support means. This RFC defines a detailed implementation plan for officially supporting TypeScript in Ember, including:</p>
<ul>
<li>the SemVer policies Ember packages should adopt, following <a href="https://github.com/emberjs/rfcs/pull/730">RFC #0730</a>:
<ul>
<li>supported TypeScript versions</li>
<li>the &quot;breaking change&quot; policy</li>
</ul>
</li>
<li>an Edition support policy</li>
<li>how we will migrate users from depending on the <code>@types</code> definitions on DefinitelyTyped to Ember packages</li>
<li>test infrastructure to catch regressions early</li>
<li>updates to Ember CLI to support TypeScript</li>
<li>release &quot;channel&quot; testing analogous to Ember's existing feature flag system for runtime code</li>
<li>a basic communication plan for the rollout</li>
<li>updates to our guides, API docs, and even the version release blog post announcement</li>
</ul>
<p>…and more!</p>
<h3 id="outline-3"><a class="header" href="#outline-3">Outline <!-- omit in toc --></a></h3>
<ul>
<li><a href="0800-ts-adoption-plan.html#motivation">Motivation</a></li>
<li><a href="0800-ts-adoption-plan.html#detailed-design">Detailed design</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#semantic-versioning">Semantic Versioning</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#strictness">Strictness</a></li>
<li><a href="0800-ts-adoption-plan.html#primary-packages">Primary packages</a></li>
<li><a href="0800-ts-adoption-plan.html#secondary-packages">Secondary packages</a></li>
</ul>
</li>
<li><a href="0800-ts-adoption-plan.html#edition-support-policy">Edition support policy</a></li>
<li><a href="0800-ts-adoption-plan.html#rfc-process-updates">RFC process updates</a></li>
<li><a href="0800-ts-adoption-plan.html#migration-from-definitelytyped">Migration from DefinitelyTyped</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#classic-features">Classic features</a></li>
<li><a href="0800-ts-adoption-plan.html#ember-internals">Ember internals</a></li>
<li><a href="0800-ts-adoption-plan.html#type-registries">Type Registries</a></li>
</ul>
</li>
<li><a href="0800-ts-adoption-plan.html#cli-integration">CLI Integration</a></li>
<li><a href="0800-ts-adoption-plan.html#test-infrastructure">Test Infrastructure</a></li>
<li><a href="0800-ts-adoption-plan.html#publishing-types">Publishing types</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#implementation">Implementation</a></li>
<li><a href="0800-ts-adoption-plan.html#release-channels">Release channels</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="0800-ts-adoption-plan.html#how-we-teach-this">How we teach this</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#publicizing">Publicizing</a></li>
<li><a href="0800-ts-adoption-plan.html#documenting-semver">Documenting SemVer</a></li>
<li><a href="0800-ts-adoption-plan.html#embers-documentation">Ember’s documentation</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#guides">Guides</a></li>
<li><a href="0800-ts-adoption-plan.html#api-documentation">API documentation</a></li>
</ul>
</li>
<li><a href="0800-ts-adoption-plan.html#migration-docs">Migration docs</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#general-migration-guide">General migration guide</a></li>
<li><a href="0800-ts-adoption-plan.html#ember-classic-features">Ember Classic features</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="0800-ts-adoption-plan.html#drawbacks">Drawbacks</a></li>
<li><a href="0800-ts-adoption-plan.html#alternatives">Alternatives</a>
<ul>
<li><a href="0800-ts-adoption-plan.html#documentation">Documentation</a></li>
<li><a href="0800-ts-adoption-plan.html#classic-features-1">Classic features</a></li>
<li><a href="0800-ts-adoption-plan.html#semantic-versioning-options">Semantic versioning options</a></li>
<li><a href="0800-ts-adoption-plan.html#documentation-1">Documentation</a></li>
</ul>
</li>
<li><a href="0800-ts-adoption-plan.html#unresolved-questions">Unresolved questions</a></li>
</ul>
<h2 id="motivation-193"><a class="header" href="#motivation-193">Motivation</a></h2>
<p>The overall motivation for this work is the same as that in <a href="https://github.com/emberjs/rfcs/pull/724">RFC #0724</a>:</p>
<blockquote>
<p>In sum, making TypeScript an officially supported language for Ember will benefit all Ember users, JavaScript and TypeScript alike; it will solve many pain points for TypeScript users that cannot otherwise be addressed; and it will close a gap for Ember compared to other frameworks.</p>
</blockquote>
<p>Where that RFC was concerned with <em>whether</em> we should pursue those goals, this RFC is concerned with <em>how</em> we accomplish them. The specific approach described here aims to roll out TypeScript support in a way that:</p>
<ul>
<li>maintains Ember’s strong stability guarantees</li>
<li>allows us to make steady incremental progress</li>
<li>communicates progress clearly to the community</li>
<li>minimizes the migration costs for existing Ember TypeScript users</li>
</ul>
<h2 id="detailed-design-158"><a class="header" href="#detailed-design-158">Detailed design</a></h2>
<p>To fully support TypeScript across the Ember ecosystem, we need:</p>
<ul>
<li>a Semantic Versioning policy which can absorb breaking changes in TypeScript itself <em>without</em> imposing breaking changes on Ember developers</li>
<li>an edition support policy which tells us what our types <em>must</em> support (as distinct from what they <em>may</em> support)</li>
<li>a plan for migrating existing Ember TypeScript users from DefinitelyTyped to using Ember’s own core types</li>
<li>a plan for CLI integration (e.g. <code>ember new --typescript</code>)</li>
<li>test infrastructure for Ember’s types, both to prevent regressions and to catch breaking changes from TypeScript early so they can be mitigated</li>
<li>release infrastructure to allow us to handle pre-release testing, feature flags, and alpha and beta releases</li>
<li>updates to our documentation to include TypeScript as a first-class citizen of the ecosystem</li>
</ul>
<p>While we need full template-aware type checking to complete our support for TypeScript, this RFC intentionally defers that consideration to a dedicated RFC to hammer out the remaining design questions around <a href="https://github.com/typed-ember/glint">Glint</a>.</p>
<h3 id="semantic-versioning"><a class="header" href="#semantic-versioning">Semantic Versioning</a></h3>
<p>Ember packages which publish types will adhere to the <a href="https://github.com/emberjs/rfcs/pull/730">Semantic Versioning for TypeScript Types</a> proposal. See that RFC for details on strategies for mitigating breaking changes from TypeScript, and see <a href="0800-ts-adoption-plan.html#documenting-semver"><strong>How We Teach This: Documenting SemVer</strong></a> below for discussion of how we will document this at the framework level.</p>
<p>The 10,000-foot summary of our treatment of SemVer for TypeScript is:</p>
<blockquote>
<p>Code which type checks at any given point in a major release of Ember packages will continue to type check throughout that Ember major release for consumers who use supported TypeScript versions.</p>
</blockquote>
<p>This is <strong>the “no new red squiggles rule”:</strong> if you use supported TypeScript versions, you will not see new “red squiggles” for type errors in your editor for Ember minor version upgrades.</p>
<p>The only exceptions to the “no new red squiggles” rule are:</p>
<ul>
<li>
<p><em>Bug fixes to the types</em>: where we previously allowed code we should not have and which could produce runtime errors, the introduction of those red squiggles is making your code safer.</p>
</li>
<li>
<p><em>Rare cases involving inferred types</em>: very rarely, we may make a change to the types which is safe for your code at runtime, and which allows TypeScript to detect new unused code paths or similar. These will introduce “red squiggles” in your editor, but in a way which will simply allow you to clean up code you didn’t need.</p>
<details><summary>example of this kind of change</summary>
<p>Assume a library provides a function, <code>idFor</code>, which gives back the <code>id</code> for a given item. Maybe it finds an <code>id</code> field on the object and hands it back if it exists, or generates a UUID otherwise, or similar—the details are unimportant, as we only care about the type signature.</p>
<p>In v1.0 of the library, it specifies that it always returns a <code>string</code> or  a <code>number</code>:</p>
<pre><code class="language-ts">declare function idFor(obj: unknown): string | number;
</code></pre>
<p>In our own code, we need IDs to always be <code>string</code>s, so we do something like this:</p>
<pre><code class="language-ts">const id = idFor({ cool: 'story' });
const usableId = typeof id === 'number' ? id.toString() : id;
</code></pre>
<p>Then let’s say that the authors of <code>idFor</code> recognize that returning <code>string | number</code> is kind of annoying, and they update their API to always return <code>string</code>:</p>
<pre><code class="language-ts">function idFor(obj: unknown): string;
</code></pre>
<p>This is perfectly safe from a runtime perspective. Any code which worked before will work now. However, TypeScript is smart enough to see that the <code>typeof</code> check is dead code:</p>
<pre><code class="language-ts">const id = idFor({ cool: 'story' });
const usableId = typeof id === 'number' ? id.toString() : id;
//                                           ^^^^^^^^❌
</code></pre>
<p>TypeScript will now report <code>&quot;Property 'toString' does not exist on type 'never'.&quot;</code> on the <code>id.toString()</code> call, because it determines that <code>id</code> can never be a <code>number</code>, which makes that entire branch dead code (<a href="https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEBbA9sArhBA1AjPA3gFDwnwgAeADsjAC7wBmaAdmLQJbLPzvABiNABTIARgCsAXPBYBrZsgDuzAJRSAzrRjtmAc3gAfeMzSIRIGAG5S8QgF9ChUJFgIU6TPCwAmAsVIVqOkYWNk5uXgEYYXEpWXklVXgNLV0LOwcmVg4ueAA3HEFlX2swLg0eYHgAXk8cADoIoXx4UuQIKQByDRoATw74W2U0krL6NDUoEUwASUqa2h7KEGQGCuqqmo7jU3N+gH4KutpkAGVNbR1C+CleNPtCTNCc3K8rohHmct5qzy8G-iaLWQbU63RgfQGQz8JFKnzGEymIFmPwWSxWaw2m22Zhg+0OxzOKUuRRuwDuhCAA">playground</a>). The &quot;cleanup&quot; work here is that you can simply <em>get rid of</em> that code, though!</p>
<p>For further examples and a discussion of why we cannot work around this (e.g. with lint rules), see <a href="https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#appendix-c-on-variance-in-typescript"><strong>Appendix C</strong></a> in the Semantic Versioning for TypeScript Types RFC.</p>
</details>
</li>
</ul>
<p>For details on both of these, see <a href="https://github.com/emberjs/rfcs/pull/730">Semantic Versioning for TypeScript Types RFC</a>, which explains these in detail and provides justification for especially the second case.</p>
<h4 id="strictness-1"><a class="header" href="#strictness-1">Strictness</a></h4>
<p>In line with the <a href="https://github.com/emberjs/rfcs/pull/730">Semantic Versioning for TypeScript Types RFC</a>, both Ember projects and the blueprints generated by Ember using the new <code>--typescript</code> flag will set the following compiler options:</p>
<ul>
<li><code>strict: true</code></li>
<li><code>noUncheckedIndexedAccess: true</code></li>
<li><code>esModuleInterop: false</code></li>
<li><code>allowSyntheticDefaultImports: false</code></li>
</ul>
<p>(See discussion below under <a href="0800-ts-adoption-plan.html#cli-integration"><strong>CLI Integration</strong></a> for further details on the new <code>--typescript</code> flag`.)</p>
<p>Beyond this, we <em>may</em> define a set of <em>additional</em> “lint”-type strictness flags over time taking advantage of TypeScript and/or ESLint, an <code>ember-ultra-strict</code> mode, and provide tooling to expose that.</p>
<p>A consequence of adopting <code>strict: true</code> as a behavior is that we will be progressively catching <em>more</em> type safety issues over time. Since these changes are not gated on TypeScript major versions (that is, they may appear in <em>any</em> TypeScript release), they make cause “red squiggles” during any TypeScript upgrade. However, we still believe this is an appropriate default, for the following reasons:</p>
<ol>
<li>
<p>Because of the guidelines under which the TypeScript team admits new strictness settings, errors caught by a new strictness flag will <em>always</em> represent real type safety features. Features do <em>not</em> rise to this bar instead go under a set of “lint”-style rules, which today include checks like <code>noUncheckedIndexedAccess</code>, which we <em>will</em> enable, and also <code>noPropertyAccessFromIndexSignature</code>, which we will by default <em>not</em>.</p>
</li>
<li>
<p>Because of the support policy described throughout, Ember’s <em>own</em> types will always have to check with these settings enabled, including its test suite, including its <em>type</em> test suite (as described under <a href="0800-ts-adoption-plan.html#test-infrastructure"><strong>Test Infrastructure</strong></a>). This means that users will <em>always</em> be able to update to a version of TypeScript supported by the Ember version they are using and be guaranteed that one of the following is true:</p>
<ul>
<li>there <em>are</em> no new errors related to their use of Ember code</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>any errors which <em>do</em> appear represent real possible bugs in your <em>use</em> of Ember code</li>
</ul>
</li>
</ol>
<p>This maximizes the value offered by TypeScript for consumers of Ember’s types (as well as maximizing the benefit to Ember itself internally). Developers who want to  take advantage of the strictest type checking options available to prevent runtime errors will always be able to do so. Accordingly, we do <em>not</em> guarantee that code will type check in looser modes, especially when <code>strictNullChecks</code> is disabled. <em>Most</em> code will still work correctly, but advanced types features used in Ember sometimes rely on the ability to distinguish between <code>null</code> or <code>undefined</code> and other types, and we do not commit to avoiding those—not least because there is otherwise an exponential explosion of possible strictness combinations we would have to test.</p>
<details><summary>On including <code>noUncheckedIndexedAccess</code></summary>
<p>We include the <code>noUncheckedIndexedAccess</code> setting in our recommended settings because it catches one of the most significant holes in the TypeScript type system prior to its introduction: not accounting for the fact that &quot;index&quot;-style access to objects and arrays <em>always</em> allows arbitrary access to any index (numeric or string), whether or not it is defined. For example, consider this type (not recommended for <em>other</em> reasons, but legal):</p>
<pre><code class="language-ts">type Anything {
  [key: string]: string;
}

function describe(anything: Anything) {
  let email = person['email'];
}
</code></pre>
<p>Here, <code>email</code> would be typed as <code>string</code>, and so TypeScript would not complain if you did something like <code>email.length</code>. But you can <em>call</em> this with an object which does <em>not</em> have an <code>email</code> field on it:</p>
<pre><code class="language-ts">describe({ noEmailsHere: 'bwahahaha' });
</code></pre>
<p>This will cause a runtime error instead of a type error. However, TypeScript is (as of recent releases) smart enough to understand that if you <em>check</em> for <code>&quot;email&quot;</code> it can be <em>known</em> to be present:</p>
<pre><code class="language-ts">function describe(anything: Anything) {
  if (anything['email']) {
    let email = anything['email']
    email.length
  }
}
</code></pre>
<p>Accordingly, we include this as part of Ember’s own strictness settings and defaults generated for users.<sup class="footnote-reference"><a href="#should-be-strict">1</a></sup></p>
</details>
<div class="footnote-definition" id="should-be-strict"><sup class="footnote-definition-label">1</sup>
<p>The Typed Ember team thinks TypeScript <em>should</em> have included this under <code>strict: true</code>!</p>
</div>
<h4 id="primary-packages"><a class="header" href="#primary-packages">Primary packages</a></h4>
<p>The primary packages in the ecosystem, <code>ember-source</code>, <code>ember-data</code>, and <code>ember-cli</code>, will adopt the <a href="https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#rolling-support-windows">rolling window</a> policy:</p>
<blockquote>
<p>In <em>rolling window</em>, a package may declare a range of supported versions which moves over time, similar to supporting evergreen browsers.</p>
<p>Packages using the “rolling window” policy should normally support all TypeScript versions released during the current ‘LTS’ of other core packages/runtimes/etc. they support, and drop support for them only when they drop support for that ‘LTS’, to minimize the number of major versions in the ecosystem.</p>
</blockquote>
<p>This aligns the support policy for these packages with the existing policy for Node and browser versions, both of which already operate on exactly this model.</p>
<p>Additionally, primary packages must ensure that the rolling windows <em>always</em> overlap across LTS versions, so that upgrading a primary Ember packages does not require a <em>simultaneous</em> TypeScript upgrade. That is: Ember users should always be able to upgrade to the latest supported TypeScript version for one Ember LTS, then upgrade the Ember LTS <em>without</em> changing their TypeScript version—a “laddering up” strategy.</p>
<p>This “laddering up” strategy means that Ember major releases do not need a special release from the constraints about what TypeScript versions they support. Instead, the requirement that users be able to upgrade across LTS releases without also requiring a simultaneous TypeScript upgrade holds: a user should be able to upgrade from the final Ember 4.x LTS to Ember 5.4 LTS by first upgrading to the latest supported TS version on the 4.x LTS and then upgrading to Ember 5.4 LTS <em>without</em> changing their TS version.</p>
<p>Given the release cadences, this should not be burdensome: at most there is a nine month delay between the release of a TypeScript feature and its being able to be used in Ember.</p>
<p>At each minor release, Ember primary packages should add any newly-released TypeScript versions to their support matrix (just as we aim to do for Node and browsers). If there is a critical bug in TS (affecting correctness or performance) which is not fixed in the time that TS version is current, Ember can choose <em>not</em> to support it.<sup class="footnote-reference"><a href="#precedent">2</a></sup> This is a last resort, for bugs which TS itself later resolves. If a TS minor version introduces a breaking change, Ember will update the types to absorb the breakage.<sup class="footnote-reference"><a href="#mechanisms">3</a></sup> In some cases, this <em>may</em> include bug fix releases to the types for LTS versions of Ember, even if they would not be in the supported range otherwise. (This is not required, but as with runtime bugs, fixes are normally backported where possible.) Bug fixes to TypeScript types for supported versions will be treated exactly as they are for runtime code:</p>
<ul>
<li>Stable releases will receive bug fixes for types for the six weeks they are the current stable release.</li>
<li>LTS releases will receive bug fixes for types for the roughly 6 months (4 releases) they are the current active LTS.</li>
</ul>
<p>LTS releases do <em>not</em> automatically add TypeScript versions released during their support window to their supported versions list (just as they do not for Node versions).</p>
<p>Ember primary packages should display the currently supported TypeScript versions prominently in their READMEs as well as in their documentation.</p>
<p>Finally, as long as the Ember primary packages maintain a lockstep release cadence, they must support the <em>same</em> matrix of supported TypeScript versions.<sup class="footnote-reference"><a href="#lockstep">4</a></sup></p>
<div class="footnote-definition" id="precedent"><sup class="footnote-definition-label">2</sup>
<p>This has happened in the past, though rarely: once late in the TS 2.x series and once early in the 3.x series, there were significant regressions around performance and correctness which meant a given minor release could not be supported by Ember’s types on DefinitelyTyped.</p>
</div>
<div class="footnote-definition" id="mechanisms"><sup class="footnote-definition-label">3</sup>
<p>There are a variety of mechanisms by which this can be supported, ranging from simple changes to the types in most cases to occasional need for the TypeScript <code>typesVersions</code> tooling.</p>
</div>
<div class="footnote-definition" id="lockstep"><sup class="footnote-definition-label">4</sup>
<p>If Ember primary packages ever stop using a lockstep release cadence, they must continue to use the same rolling support strategy, but would need to additionally consider the intersection of their TypeScript version support as well as their support for the other core packages. However, there is no current proposal to make such a change, and it would be the responsibility of the RFC making such a proposal to account for this.</p>
</div>
<h5 id="example-2"><a class="header" href="#example-2">Example</a></h5>
<p>If Ember were to begin publishing types with Ember 4.4, the flow might look something like this, given the following assumptions:</p>
<ul>
<li>Ember starts out supporting TypeScript 4.5 and 4.6</li>
<li>TypeScript 4.6 introduces a feature not in 4.5 which Ember wants to use</li>
<li>TypeScript 4.8 has a significant regression, fixed in TypeScript 4.9, which means TS 4.8 is never supported</li>
<li>TypeScript 4.9 introduces a feature not in 4.6 which Ember wants to use</li>
</ul>
<table><thead><tr><th>Ember version</th><th>Supported TypeScript versions</th></tr></thead><tbody>
<tr><td><strong>4.4 (LTS)</strong></td><td><strong>4.5, 4.6</strong></td></tr>
<tr><td>4.5</td><td>4.5, 4.6</td></tr>
<tr><td>4.6</td><td>4.5, 4.6, 4.7</td></tr>
<tr><td>4.7</td><td>4.5, 4.6, 4.7</td></tr>
<tr><td><strong>4.8 (LTS)</strong></td><td><strong>4.6, 4.7</strong></td></tr>
<tr><td>4.9</td><td>4.6, 4.7</td></tr>
<tr><td>4.10</td><td>4.6, 4.7, 4.9</td></tr>
<tr><td>4.11</td><td>4.6, 4.7, 4.9</td></tr>
<tr><td><strong>4.12 (LTS)</strong></td><td><strong>4.6, 4.7, 4.9, 5.0</strong><sup class="footnote-reference"><a href="#counting">5</a></sup></td></tr>
<tr><td>4.13</td><td>4.6, 4.7, 4.9, 5.0</td></tr>
<tr><td>4.14</td><td>4.6, 4.7, 4.9, 5.0, 5.1</td></tr>
<tr><td>4.15</td><td>4.6, 4.7, 4.9, 5.0, 5.1</td></tr>
<tr><td><strong>4.16 (LTS)</strong></td><td><strong>4.9, 5.0, 5.1, 5.2</strong></td></tr>
</tbody></table>
<p>The key points to notice in this upgrade cycle:</p>
<ul>
<li>
<p>Regular minor versions may add support for new TS versions, if one has been released.</p>
</li>
<li>
<p>Ember may also choose not to support a given TS version if it cannot reasonably do so. </p>
</li>
<li>
<p>LTS versions <em>may</em> drop support for old TS versions, but are not <em>required</em> to. In this example:</p>
<ul>
<li>Ember 4.8 LTS <em>does</em> drop TS 4.5.</li>
<li>Ember 4.12 LTS does <em>not</em> drop TS 4.6.</li>
<li>Ember 4.16 LTS <em>does</em> drop all versions before TS 4.9.</li>
</ul>
</li>
</ul>
<p>In this example, a team upgrading from Ember 4.4 LTS to Ember 4.8 LTS can upgrade to TypeScript 4.6, then upgrade to Ember 4.8 LTS separately. They would not need to upgrade TS at all to upgrade to Ember 4.12. Then they would need to upgrade to at least TS 4.9. Note that the 4.16 LTS release <em>could</em> drop all TS versions up to 5.0. In general, however, we will not drop support for older versions unless there is a reason to do so (e.g. 5.0 itself introduced a desirable feature).</p>
<p>Additionally, we <em>may</em> make best-effort fixes to later (technically unsupported) TypeScript versions for LTS releases. For example, if TypeScript 4.7 introduced a breaking change which could be fixed by types-only changes to Ember 4.4 LTS, we would accept PRs to fix it and otherwise prioritize it in accordance with its severity (just as we do for runtime issues related to browsers, Node, or other ecosystem packages we depend on, e.g. <code>@babel</code> packages).</p>
<div class="footnote-definition" id="counting"><sup class="footnote-definition-label">5</sup>
<p>As part of its rejection of SemVer, TS just rolls over from an <code>x.9</code> release to the next major <code>y.0</code>, e.g. <code>2.9</code> to <code>3.0</code> and <code>3.9</code> to <code>4.0</code>.</p>
</div>
<h5 id="reasoning"><a class="header" href="#reasoning">Reasoning</a></h5>
<p>Like browsers and Node, TypeScript regularly introduces new features which are attractive to use. Unlike browsers or Node, however, it is impossible to “polyfill” those new features for TypeScript. We want to enable primary Ember packages to take advantage of those new features without waiting for a full major release. For example, in the almost 4-year span between the releases of Ember 3.0 (February 2018) and Ember 4.0 (December 2021), TypeScript released the following key features which dramatically changed our ability to represent Ember’s APIs correctly or to use TypeScript effectively (as well as many other smaller enhancements):</p>
<ul>
<li>conditional types (2.8, March 2018)</li>
<li><code>unknown</code>, spread parameter types, improved tuple types with optional and spread elements, and composite projects (3.0)</li>
<li>improved strictness settings (3.2, 4.0, 4.2, 4.4)</li>
<li><code>const</code> assertions and higher-order inference for functions, which was key to enabling Glint (3.4)</li>
<li>assertion functions, allowing more useful typing of <code>assert</code> (3.7)</li>
<li>the <code>declare</code> modifier, allowing safe declaration of injections and CPs (3.7)</li>
<li>spec compatibility for class fields, optional chaining,. and nullish coalescing (3.7)</li>
<li>spec compatibility for top-level <code>await</code> (3.8)</li>
<li>variadic tuple types and labeled tuple elements (4.0, improved in 4.2)</li>
<li>template literal types (4.1)</li>
<li>spec compatibility for <code>#private</code> class fields (4.3)</li>
</ul>
<p>Had we been publishing types and using the <em>simple majors</em>, we would not have been able to adopt <em>any</em> of those features, because doing so would have required downstream consumers to update to versions which supported them. This is basically the same problem we had with IE11 support: any feature which could not be polyfilled, we could not use at any point in the Ember 3 era.<sup class="footnote-reference"><a href="#polyfill">6</a></sup></p>
<p>Using the “rolling window” policy allows us to adopt new features from TypeScript in the same way we do with Node and browsers, and never couples users to do TypeScript and Ember primary package upgrades simultaneously.</p>
<div class="footnote-definition" id="polyfill"><sup class="footnote-definition-label">6</sup>
<p>In fact, we could not even use some features which <em>could</em> be polyfilled in some places, because the polyfill was too expensive!</p>
</div>
<h4 id="secondary-packages"><a class="header" href="#secondary-packages">Secondary packages</a></h4>
<p>All secondary packages (i.e. all officially-published packages which are not listed above) in the ecosystem should use the same <a href="https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#simple-majors">simple majors</a> policy</p>
<blockquote>
<p>In <em>simple majors</em>, dropping support for a previously supported compiler version requires a breaking change.</p>
</blockquote>
<p>As with the primary packages, this aligns secondary packages with their existing support policies, as they already treat Node version support exactly this way.</p>
<p>For example: <code>ember-cli-htmlbars</code> currently publishes types, but there is no documented contract for SemVer. Following this RFC and <a href="https://github.com/emberjs/rfcs/pull/730">the SemVer for TS RFC</a>, it must:</p>
<ul>
<li>link to the SemVer-for-TS spec</li>
<li>include the currently supported TypeScript versions in its README</li>
<li>specify that it uses the <em>simple majors policy</em> in its README</li>
<li>add all supported TS versions to its CI jobs</li>
<li>cut a new major any time it drops a TS version from support (which, for ecosystem stability, should generally be aligned with dropping a Node version when it goes out of LTS)</li>
</ul>
<h3 id="edition-support-policy"><a class="header" href="#edition-support-policy">Edition support policy</a></h3>
<p>Per <a href="https://github.com/emberjs/rfcs/pull/724">RFC #0724: Official TypeScript Support</a> (emphasis added):</p>
<blockquote>
<p>All libraries which are installed as part of the default blueprint must ship accurate and up-to-date type definitions <strong>for the current edition</strong>. These types will uphold a Semantic Versioning commitment which includes a definition of SemVer for TypeScript types as well as a specification of supported compiler versions and settings, so that TypeScript will receive the same stability commitments as the rest of Ember.</p>
</blockquote>
<p>Ember’s types will always provide full support for the APIs of the <em>current</em> edition, and is <em>not</em> required to continue supporting previous editions when crossing a major version change. This does <em>not</em> supercede the Semantic Versioning commitment, however.</p>
<p>What this means in practice is:</p>
<ol>
<li>
<p>If a new edition is introduced during a given major release (e.g. the projected Polaris Edition during 4.x), the types will maintain support for <em>both</em> editions. This is required by the SemVer support policy: dropping support for the previous edition would be a breaking change!</p>
</li>
<li>
<p>When a new major version is released after an edition has been introduced (e.g. v4 after Octane and presumably v5 after Polaris), Ember may drop some or all support for features which are not part of the updated programming model represented by the new edition.</p>
</li>
</ol>
<p>The motivating example here is the custom class system from Ember Classic (as discussed below under <a href="0800-ts-adoption-plan.html#classic-features"><strong>Migration from DefinitelyTyped: Classic Features</strong></a>). While this continues to exist and works, it is extremely difficult to provide types for and the value of the types is very low. Ember users are recommended to use native classes instead. Accordingly, when Ember begins publishing its own types, we will only support a very limited version of the Classic features like <code>.extend()</code>, <code>.reopen()</code>, <code>.reopenClass()</code>, and legacy decorator forms which interoperate with them.</p>
<p>If we did <em>not</em> adopt this option, Ember would have to provide the same extensive support for the Classic features that the DefinitelyTyped version of the types have historically provided, despite the very bad cost-benefit ratio of these types for our maintenance.</p>
<p>In future editions, it is conceivable that we might lean on this escape hatch to drop support for legacy CLI features (after Embroider is standard) or legacy routing features (if Ember adopts a modernized routing system) etc. However, in general we do <em>not</em> expect to need it, because our designs have generally been accounting for TypeScript even before making it an officially supported language for the framework.</p>
<h3 id="rfc-process-updates"><a class="header" href="#rfc-process-updates">RFC process updates</a></h3>
<p>RFCs which introduce new APIs must specify the public types for those APIs. RFCs which deprecate existing APIs must consider the migration path for TypeScript users as well as JavaScript users.</p>
<p>Note that this is not a major new design constraint, because we have largely already been doing this! This simply formalizes the process Ember has been using for the past few years already: we have regularly used TypeScript signatures to represent new APIs, and TypeScript concerns have been included in the discussion of API proposals.</p>
<p>This does introduce two new small considerations:</p>
<ul>
<li>
<p>New APIs will now need to specify import paths for type-only imports. For example, today there is no public import for <code>Transition</code> or <code>RouteInfo</code>, because they are not intended for end users to construct. However, types for them <em>should</em> be publicly exported because end users need to be able to name those types them in their own code. If we were to write <a href="https://emberjs.github.io/rfcs/0095-router-service.html">RFC #0095: Router Service</a> today, we would specify imports for both.</p>
</li>
<li>
<p>New APIs will need to specify whether a given interface or type is intended for user-constructibility. This is part of the Semantic Versioning contract. By way of example:</p>
<ul>
<li>
<p>Both <code>Transition</code> and <code>RouteInfo</code> are <em>non</em>-user-constructible. Although they are classes under the hood, it is illegal for end users to make their own copies: the only legal way to get one is <em>from the framework</em>. We can enforce this for TypeScript users with type machinery under the hood, but it is important that they be documented accordingly as well.</p>
</li>
<li>
<p>Classes like <code>Service</code> and the Glimmer <code>Component</code> are <em>intended</em> to be user-subclassed, but are <em>not</em> intended to be implemented directly.</p>
</li>
<li>
<p>Interfaces like the <code>ComponentManager</code>, <code>ModifierManager</code>, and <code>HelperManager</code> <em>are</em> intended to be user-constructible, and in fact this is the entire reason they exist.</p>
</li>
</ul>
</li>
</ul>
<p>The Detailed Design paragraph of the default RFC template will be updated to include corresponding text:</p>
<pre><code class="language-markdown">&gt; This is the bulk of the RFC.

&gt; Explain the design in enough detail for somebody
familiar with the framework to understand, and for somebody familiar with the
implementation to implement. This should get into specifics and corner-cases,
and include examples of how the feature is used. Any new terminology should be
defined here. New types should be specified as they are intended to be used by
TypeScript consumers, including their import locations and whether they are
intended to be constructed by end users.
</code></pre>
<p>The “Transition path” paragraph of the deprecation RFC template will be updated to include the following:</p>
<pre><code class="language-markdown">&gt; This is the bulk of the RFC. Explain the use-cases that deprecated functionality
covers, and for each use-case, describe the transition path.
Describe it in enough detail for someone who uses the deprecated functionality
to understand, for someone to write the deprecation guide, and for someone
familiar with the implementation to implement. Make sure to include details
specific to TypeScript users, if any.
</code></pre>
<h3 id="migration-from-definitelytyped"><a class="header" href="#migration-from-definitelytyped">Migration from DefinitelyTyped</a></h3>
<p>There are many existing Ember TypeScript users, who use the <code>@types</code> packages maintained by the Typed Ember team on <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">the DefinitelyTyped repository</a> since 2017. We need to support those users migrating off of DefinitelyTyped in a minimally-disruptive way. At the same time, we <em>do</em> have an opportunity to align the types with <a href="0800-ts-adoption-plan.html#edition-support-policy">the edition support policy described above</a>, as well as to fix some early infelicities in design choices.<sup class="footnote-reference"><a href="#infelicities">7</a></sup></p>
<p>Accordingly, we will:</p>
<ul>
<li>simplify our handling of Classic features (see <a href="0800-ts-adoption-plan.html#classic-features"><strong>Migration from DefinitelyTyped: Classic features</strong></a> below)</li>
<li>update our handling of type registries (see <a href="0800-ts-adoption-plan.html#type-registries"><strong>Migration from DefinitelyTyped: Type registries</strong></a> below)</li>
<li>simplify or improve other APIs if and as we see opportunities</li>
</ul>
<div class="footnote-definition" id="infelicities"><sup class="footnote-definition-label">7</sup>
<p>There are a number of reasons for those infelicities: in some cases, it was simply our own ignorance when we wrote the types; in others, TypeScript did not yet support the features we needed to represent Ember; and in yet others Ember’s own design wasn’t great (we have all started designing better JS APIs in the meantime, partly informed by experience with TS!).</p>
</div>
<p>To reiterate, though: in general, the goal will be to <em>minimize</em> disruption to existing users. The majority of the work will be as described in <a href="0800-ts-adoption-plan.html#migration-docs"><strong>How we teach this: Migration docs</strong></a> below.</p>
<p>For the current DefinitelyTyped maintainers (the Typed Ember team and some other contributors), there is one additional step: we will follow the DefinitelyTyped <a href="https://github.com/DefinitelyTyped/DefinitelyTyped#removing-a-package">guide to removing a package</a>, so that users can get support for package versions <em>up to</em> the point where the package was removed from <code>@types</code>, while package versions after that which try to use <code>@types</code> will be notified that they should switch.</p>
<h4 id="classic-features"><a class="header" href="#classic-features">Classic features</a></h4>
<p>Per the edition support policy, we will provide minimal support for Ember Classic features:</p>
<ul>
<li>
<p><strong>Ember's classic class system</strong>: we will provide minimal definitions for the <code>.extend()</code>, <code>.reopen()</code>, <code>.reopenClass()</code>, and <code>.create()</code> methods, which make no attempt to use them to actually update the types of the items they modify.</p>
<p>It is not possible to provide a good experience working with those types (in particular, working with mixins <em>at all</em> requires extensive unsafe casting), and they are no longer recommended for any new code. We will support them only because they are <em>required</em> for migrating some critical ecosystem code which still depends on them (especially around Ember Data).</p>
<details><summary>detailed discussion of classic class system updates</summary>
<p>All of the relevant tweaks to class types can be represented using <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>. Given a class <code>Demo</code>:</p>
<ul>
<li>including a <code>Mixin</code> with <code>.extend()</code> can be represented with a type alias for the mixin <code>type TheMixin = ...</code> and <code>interface Demo extends TheMixin {}</code></li>
<li>reopen can be represented with a type alias for the mixin <code>type TheReopen = ...</code> and <code>interface Demo extends TheReopen {}</code></li>
<li><code>reopenClass</code> can be represented with a namespace for the reopened type, <code>namespace Demo { ... }</code></li>
</ul>
<p>Accordingly, the types for the <code>.extend()</code>, <code>.create()</code>, <code>.reopen()</code>, and <code>.reopenClass()</code> methods can become much “dumber” than in the DefinitelyTyped definitions, providing a minimal layer of type safety but using these other techniques for the transition/fallback period.</p>
<p>For a full working demo, see <a href="https://www.typescriptlang.org/play?#code/PTAEFpNBnAXBDATrUBTAtgI1Y0B7TAK1QGMVYBPAB1WgihACgATUgGyVVBI+joFkAlgA9BAO1ABvRqBgJYgkt0Sp4sVAB4ASgD4AFFUR4q0AFygtASnNbGAX0Yt2nbrzoBhPCoDyRUimlZODVFNGF1MWYNdzCI5g8vVF9iMn0ZWVBYAAtBM1B3ABp02QA6MsNjPIIU2ABtAF1063yAbnT04IUlEhU1TRjUcNRIhJ8-VL1izJy8wqmKk3Nq-ybzdzaO+VCVY2Ho2OH4-MTk-zSM6dy1oouFqvHYG9Bm9ccgraUdmjF3N33BuKjJIPc4ZbJXfJPWR3JYPJ4vNoOJw8FwAMwArmIyII8BIAOaoWAaAAqBVAAGkDiNQABrVAUPCo0DE-QIRAE2DmUm0+nmcnNYm1cn1NqsFEqUAYrEKXGgDl6Nkc8yYmliPAAdzEZLpFHMcEQ4jxzRVas1oucEql2Nl0EJJLJlIBhzoOsZzNZSCVzO1vIpZIAbvA2OjUFyhfUBeHzeKuFaZRJbUSAGoe9mE5ViVUarU83VyA1iPEBoMh8xJ5pJjYovigACiWBwpzIVKOnjGNSkSJA9HAaEiaAbuGWzcoNDokF7TEY3YnoHQInEjBIuLgoAAIhg8EJRBIALygbfiEo9VTqPSBOeErJ4ZgAMSM6EPYj0nvMYnRg+a-rwgmYUimiYKjMZIAOTzjuAAKRhUCBZKepYbSyHYTzgeIUHGOYAAMRR2AhjijlwG7oFuC57pk1CoG6REkTuGwzlA6LQIac6kYw4jqIgqLwCQhGbi2dDUU+nZLm4658U61L1tgiBNrAJQScweiCaRlj-rIYghP6qDoVQeqwAWeKgAAPqA75sGwoD7mZbCIo49G9oxzFfMMS4rigWiUd81GWWpl7ZDe954OgHm7M+4J5NRzTvoOvmyCosDoog+KEkBuSgahYg6SBeFIfY+EURYnnDN5+4EW6IVeZujjsTgXE8WJxH8YVoXeZIDjUSUznPhVxWbnh05gLOjmFqAXW-PAfCuWIq49T8bglb5qIPrNqDMONfDmPpIb2BsYocBKGnoLQVDcbxjUXoMVBeCgy7TSgS1BSta1uOYmB4HgbCqGItkDfQoCsMRU2rkoVmoOqDV4HoeEkCUGkKFpOk+QARFkqDmXgZLql4bDMAAhEjbQw0d-l3g+T56AAjAATAAzHhghMnoROkYjuO7vuRNXgFy1Fc+liqReDOgEpm4lA9wW86t63QALUy3dAH2oCUbB4HiehI4APBuAJH7SM5aADgOEAA">this playground</a>.</p>
</details>
</li>
<li>
<p><strong>Ember’s <code>get</code> and <code>set</code> helpers:</strong> we will not provide types to make <code>get</code> and <code>set</code> type-safe beyond simple property lookups on objects—i.e. no support for nested path lookups.</p>
<p>While it would be possible to do so using advanced type system features, doing so would have a high maintenance cost and provides very little value in the Ember v4 era, where use of native property access is possible for all features which historically required <code>get</code> and <code>set</code> and their <code>-Properties</code> variants.<sup class="footnote-reference"><a href="#get-set">8</a></sup></p>
</li>
<li>
<p><strong>Classic computed property handling:</strong> we will not provide “safe” types for the classic form of computed properties.</p>
<details><summary>detailed discussion of classic computed property updates</summary>
<p>Since they integrate with the clsasic class system and mixins, it is impossible to provide a correct experience of them in terms of the keys they accept or the <code>this</code> type within them: the types become circular. The supplied types for them will simply accept a dumb list of strings as dependent keys and a simple callback. All access to <code>this</code> will require unsafe casts.</p>
<p>We will also continue to provide public types for the decorator forms, <code>@computed</code> as well as the computed property macros like <code>@alias</code>. However, decorators currently cannot affect the type of the decorated item (a TypeScript restriction), and so the public type definitions supplied will continue to simply specify them as <code>PropertyDecorator</code>s.</p>
<p>Additionally, this means that we will eliminate the <code>UnwrapComputedPropertyGetter</code>, <code>UnwrapComputedPropertySetter</code>, and related types entirely. The return type will become the normal value return tyeps.</p>
<p>The result will be similar to the definitions on DefinitelyTyped, but with much less “type machinery”.</p>
</details>
</li>
</ul>
<p>See below for a discussion of how we should approach TypeScript with Classic features in the documentation.</p>
<h4 id="ember-internals"><a class="header" href="#ember-internals">Ember internals</a></h4>
<p>Ember's internals will regularly include APIs which are <em>not</em> intended to be public, and should be excluded from public builds. In most cases, we can solve this by making sure our type publishing tooling understands the <code>@internal</code> annotation in comments and excludes items marked with it from publishing to the public API. In conjunction with the workflow described in <a href="0800-ts-adoption-plan.html#implementation"><strong>Publishing types: Implementation</strong></a>, below, this can also allow us to publish internal-only builds for collaborators who need access to those APIs. For example, Ember’s test infrastructure lives in separate packages, but has sometimes needed access to private APIs to work.</p>
<p>A particularly vexing version of this problem is that Ember’s own internals still make extensive use of Ember Classic features—features we are explicitly choosing not to support by publishing rich types for them. This is well-motivated: in many cases we <em>must</em> continue to use those types internally to prevent consumers who are still using those features from being broken in surprising and hard-to-debug ways.<sup class="footnote-reference"><a href="#zebra">9</a></sup> Accordingly, there are <em>more</em> robust types for <code>.extend()</code>, <code>.reopen()</code>, etc. in Ember’s internals than we want to support publicly. This is also tractable, though: we can provide those internal-only extensions via <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a> in imports which are <em>not</em> part of the published build, and which therefore do not impact the public APIs.</p>
<p>The main risk here is that we need to make sure to run type tests against what is <em>published</em>, rather than from within the framework itself.</p>
<div class="footnote-definition" id="get-set"><sup class="footnote-definition-label">8</sup>
<p>This has been true for <em>many</em> things since Ember 3.1, which unlocked it for getters in the Ember Classic world; and for nearly everything since Ember Octane’s release in 3.15, which unlocked it for setters for all <code>@tracked</code> properties. With changes to Ember Data in 3.28, it also works (using native proxies) even for async relationships. Finally, its handling of possibly-<code>undefined</code> intermediate properties has been superceded by a language feature: <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional-chaining</a>.</p>
</div>
<div class="footnote-definition" id="zebra"><sup class="footnote-definition-label">9</sup>
<p>The primary example here is the “zebra-striping” problem with native classes and classic classes. When you set instance properties on a native class and then extend from it using a classic class, the values set in the subclass using <code>.extend()</code> will be superceded by the class properties on the parent native class. There are a number of other related issues around native and classic class interop; see <a href="https://ember-twiddle.com/fdf70756b8d551b3364fd3278f66c8a9">this Ember Twiddle</a> for a demo of two of them. This “makes sense”: the fields set via <code>.extend()</code> go on the prototype while class fields are per-instance, and so override the prototype values—but it is extremely confusing in practice. Until we <em>remove</em> the ability to use <code>.extend()</code>, our internals likely need to be implemented as classic classes, or they need to use annoying hacks which amount to doing the same!</p>
</div>
<h4 id="type-registries"><a class="header" href="#type-registries">Type Registries</a></h4>
<p>The existing type definitions on <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> make heavy use of “type registries”, which use some advanced type system features introduced early in TypeScript 2.x to map string keys to specific types. This allowed us to support string-based lookups for many Ember Classic APIs, particularly in the dependency injection (DI) system and Ember Data lookups.</p>
<p>For the classic DI system, we no longer require (or benefit from) string key-based lookups to resolve the type of an injected item. In Ember Classic, we could use those key-based lookups to infer the type:</p>
<ul>
<li>
<p><code>app/services/session.ts</code></p>
<pre><code class="language-ts">import Service from '@ember/service';

export default class SessionService extends Service {
  login(username: string, password: string) {
    // ...
  }

  logout() {
    // ...
  }
}

declare module '@ember/service' {
  interface Registry {
    session: SessionService;
  }
}
</code></pre>
</li>
<li>
<p><code>app/components/some-component.ts</code> (note the odd mixed declaration form!):</p>
<pre><code class="language-ts">import Component from '@ember/component';
import { service } from '@ember/service';
import { action } from '@ember/object';

export default Component.extend({
  // session here has the type SessionService...
  session: service('session'),
}) {
  @action login(username: string, password: string) {
    // ...so this call is type safe
    this.session.login(username, string);
  }
}
</code></pre>
</li>
</ul>
<p>With the introduction of full support for native classes and decorators in Octane, there is no need for this (and it was rather janky to begin with!). Accordingly, we will simply remove support for these two type registries entirely:</p>
<ul>
<li>The service <code>Registry</code> in <code>@ember/service</code></li>
<li>The controller <code>Registry</code> in <code>@ember/controller</code></li>
</ul>
<p>The decorators will continue to accept a string key, but will not validate that against a registry, since decorators cannot change the types of the items they decorator in TypeScript.<sup class="footnote-reference"><a href="#reintroduce">10</a></sup></p>
<p>For Ember Data, there is considerably more ongoing need for registry-style APIs. <code>Store.findRecord</code> isn’t going anywhere any time soon, for example, and it <em>requires</em> some kind of registry to make <code>this.store.findRecord('user', 1)</code> correctly return a <code>User</code> model. Many other APIs within Ember Data similarly require registries for type safety. Thus, Ember Data will need its own dedicated design for handling those, and this RFC leaves those for the Ember Data team to address in a dedicated RFC.</p>
<div class="footnote-definition" id="reintroduce"><sup class="footnote-definition-label">10</sup>
<p>We could conceivably reintroduce a registry of this form in the future if that limitation on decorators in TypeScript changes, so that <code>@service('session') declare session;</code> would have the right type without needing an explicit type annotation, but that would need to be well-motivated on the merits, and there are actually advantages to having explicit type imports for the static analyzability of the code. The combination of Embroider and other future design moves we might make for the design system, for example <a href="https://github.com/pzuraq/ember-totally-not-module-based-services">this experiment by pzuraq</a>, may make other directions more appealing than the registry approach.</p>
</div>
<h3 id="cli-integration"><a class="header" href="#cli-integration">CLI Integration</a></h3>
<p>We will introduce a new <code>--typescript</code> (<code>-ts</code>) flag for the <code>ember new</code> and <code>ember addon</code> commands, allowing users to opt into TypeScript when generating a new project. Using this flag will:</p>
<ul>
<li>Install Ember TypeScript integration tooling, today consisting simply of <code>ember-cli-typescript</code> and its generators.</li>
<li>Set the <code>isTypeScriptProject</code> option for <code>.ember-cli</code> (introduced in <a href="https://emberjs.github.io/rfcs/0776-typescript-blueprints.html">RFC #0776</a>) to <code>true</code>, so that blueprints are generated with TypeScript by default in the project.</li>
<li>Configure linting:
<ul>
<li>In the<code>.eslintrc.js</code> blueprint:
<ul>
<li>use <code>@typescript-eslint/parser</code> instead of the Babel ESLint parser</li>
<li>include <code>@typescript-eslint</code> in the <code>plugins</code> key</li>
<li>include <code>plugin:@typescript-eslint/recommended</code> in the <code>extends</code> key</li>
</ul>
</li>
<li>Install the <code>@typescript-eslint</code> dependencies instead of of the Babel ESLint dependencies in <code>package.json</code></li>
</ul>
</li>
</ul>
<p>We will also update the Glimmer Component blueprint in the Ember.js repo to include <a href="https://github.com/emberjs/rfcs/pull/748">the component’s signature</a>, so that it can be used by TypeScript.</p>
<p>We will <em>not</em> be eliminating <code>ember-cli-typescript</code> as part of this process, because it remains a useful home for some of the tooling, and may remain a useful configuration point in the future, for example when we incorporate <a href="https://github.com/typed-ember/glint">Glint</a> into official Ember tooling. In this design, only the pieces which are <em>necessarily</em> shared will be hoisted into <code>ember-cli</code> itself, with the other pieces remaining in <code>ember-cli-typescript</code>. For example, the blueprint for generating <code>tsconfig.json</code> files should remain in <code>ember-cli-typescript</code>.</p>
<p>We will also deprecate the <code>ember-cli-typescript-blueprints</code> repository, since it will become defunct, with the blueprints moving to the host repository (<code>ember-source</code>, <code>ember-data</code>, and <code>ember-cli</code>) and being authored in TypeScript directly, with types stripped for JS consumers, so they remain in sync permanently. (See again <a href="https://emberjs.github.io/rfcs/0776-typescript-blueprints.html">RFC #0776</a> for details.)</p>
<h3 id="test-infrastructure"><a class="header" href="#test-infrastructure">Test Infrastructure</a></h3>
<p>To meet the Semantic Versioning and stability guarantees described above, we need strong testing infrastructure in place. We need to avoid introducing breaking changes in our types (the same as in our runtime code). We also need to catch breaking changes introduced by TypeScript, so that we can mitigate them.</p>
<p>To this end, we will extend our existing test infrastructure in the following ways:</p>
<ol>
<li>We will convert our test suite to use TypeScript, so that all existing tests can be used for catching type errors.</li>
<li>We will add dedicated “type tests” using tooling like <a href="https://github.com/mmkal/ts/tree/master/packages/expect-type">expect-type</a> to guarantee we are upholding <em>exactly</em> the contract we intend for our published types.</li>
<li>We will add CI jobs which type check the code against all supported TypeScript versions.</li>
<li>We will incorporate checking against the <code>typescript@next</code> nightly builds so that we can identify breaking changes early.</li>
</ol>
<p>Point (4) will make sure that we have early warning about any inbound breakage from TypeScript itself, generally giving us on the order of 2–3 Ember minor release cycles to prepare for those changes and prevent them from breaking Ember users.</p>
<h3 id="publishing-types"><a class="header" href="#publishing-types">Publishing types</a></h3>
<p>When Ember official packages begin publishing types, they will need to account for TypeScript's default of using Node module resolution to look up type definitions. Specifically, a number of Ember packages which have multiple “entry points”—that is, multiple modules in a package from which it is valid to import, like <code>@ember/object</code> and <code>@ember/object/computed</code>. The only way to make this work “automatically” today is to publish types in the root of the package, just as that was the only way to make non-root modules resolve correctly in a Node package historically. A publish step which copies the types to the root is possible, and that is how <code>ember-cli-typescript</code> has made types for addons work correctly. That is <em>not</em> desirable for Ember core packages, however, because it makes it impossible to provide things like preview access to types before stabilization, types for different editions, etc. (each discussed below).</p>
<p>In the future, we will be able to publish types in a much more “natural” way for Ember’s package design, by taking advantage of <a href="https://nodejs.org/api/packages.html#package-entry-points">Node package entry points</a>. However, TypeScript support for that feature is still experimental and available only in TS nightly builds, so our design does not depend on it.</p>
<h4 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h4>
<p>As long as we are not publishing actual packages for the <code>@ember/*</code> and <code>@ember-data/*</code> packages, we will also need to include one additional file in our output which makes the published types visible to the consumer: a “root” entry point module for the package, published either in the root as <code>index.d.ts</code> or in some other location specified by the <code>types</code> key in <code>package.json</code>. Using <code>ember-source</code> as an example, we might publish the following to <code>dist/index.d.ts</code>, with <code>&quot;types&quot;: &quot;./dist/index.d.ts&quot;</code> set in <code>package.json</code>:</p>
<pre><code class="language-ts">import './types/ember-application.d.ts';
import './types/ember-object/index.d.ts';
import './types/ember-object/computed.d.ts';
// ...etc.
</code></pre>
<p>The referenced files in turn will have <code>declare module</code> statements in them, generated by whatever tooling we use to create public API rollups (see discussion below). The <code>index.d.ts</code> acts as a type-level “side-effect” module. It makes the <code>@ember/*</code> types <em>visible</em> to any app or addon which does <code>import 'ember-source';</code>. This will make compilation work correctly <em>without</em> configuring <code>compilerOptions.paths</code> in <code>tsconfig.json</code>.</p>
<p>We will accordingly incorporate that <code>import</code> statement in our blueprints (with a long comment explaining why it exists) and document it.</p>
<h4 id="release-channels"><a class="header" href="#release-channels">Release channels</a></h4>
<p>These moves also allow us to support another constraint: As with runtime code, TypeScript types need to be provided via Ember's release channel mechanism.</p>
<ol>
<li>Types for a given runtime feature should be available with the version the runtime feature appears with.</li>
<li>Types for unreleased features should be available only on <code>master</code> and in canary builds.</li>
</ol>
<p>We can solve both (1) and (2) by using the <code>@alpha</code> and <code>@beta</code> tags in conjunction with tooling which understands how to use those to strip non-public types from the generated types.<sup class="footnote-reference"><a href="#extractor-tool">11</a></sup> When generating a canary build, items marked with <code>@alpha</code> will be included; but for beta and canary builds, they will be excluded. The same holds for beta vs. stable builds and the <code>@beta</code> flag.</p>
<p>As part of the rollout, we may also provide one <em>additional</em> level of publishing: publishing to a beta location, allowing early adopters to help prove out and find bugs with the types while not losing any <em>runtime</em> guarantees. For example: an app which tracks LTS releases for stability might nonetheless want to use the official TypeScript types, even if they are not yet published on Ember 4.4 LTS.</p>
<p>In that case, we will not yet be publishing a root <code>index.d.ts</code> for <code>ember-source</code> etc. in a location TypeScript will resolve automatically—not in the root, and with no corresponding <code>&quot;types&quot;</code> field in <code>package.json</code>. Instead, we might publish it to something like <code>types/experimental.d.t.s</code>. Early adopters could then do <code>import 'ember-source/types/experimental';</code>. This will prevent anyone from <em>accidentally</em> opting into those types, while still allowing feedback from early adopters.</p>
<p>This design works well with future possibilities in the design space as well:</p>
<ul>
<li>
<p>When TypeScript begins supporting Node’s <a href="https://nodejs.org/api/packages.html#package-entry-points">entry points</a>, we will be able to leave this in place while <em>also</em> using <code>exports</code> to make it unnecessary, allowing a smooth upgrade path. Once we <em>require</em> that version of TypeScript as the minimum supported version, we will be able to deprecate the import, and then we can drop it at the next Ember major.</p>
</li>
<li>
<p>When delivering a new Edition, we <em>could</em> publish edition-specific types which allow users to opt into <em>only</em> using the new Edition, and they might do <code>import 'ember-source/types/polaris.d.ts</code>. This would be akin to how we set new defaults for linting, blueprints, etc. once the <code>&quot;edition&quot;</code> flag is updated for an app or addon, though stronger.</p>
</li>
</ul>
<div class="footnote-definition" id="extractor-tool"><sup class="footnote-definition-label">11</sup>
<p>This RFC intentionally leaves the tool unspecified, because it is an implementation detail. Presently, it looks like our best bet will be combining multiple existing tools, for example combining <a href="https://github.com/Swatinem/rollup-plugin-dts">rollup-plugin-dts</a> with <a href="https://api-extractor.com">API Extractor</a>. That could change over time, though!</p>
</div>
<h2 id="how-we-teach-this-160"><a class="header" href="#how-we-teach-this-160">How we teach this</a></h2>
<p>There are four major components to teaching the Ember community about this new capability:</p>
<ul>
<li>Publicizing it, including what it does and does not entail.</li>
<li>Documenting the SemVer commitments</li>
<li>Incorporating support for TypeScript into Ember’s documentation.</li>
<li>Documenting the migration path for existing Ember TypeScript users from DefinitelyTyped to using Ember directly.</li>
</ul>
<p>Note that this is in addition to the process-related updates described above in <a href="0800-ts-adoption-plan.html#rfc-process-updates"><strong>Detailed design: RFC process updates</strong></a>.</p>
<h3 id="publicizing"><a class="header" href="#publicizing">Publicizing</a></h3>
<p>First, we should announce official support when it lands across Ember’s various media channels (blog, Twitter, etc.): official support for TypeScript is a big deal. If possible, we should also take the opportunity to engage with high-profile podcasts to talk about our approach and the benefits we hope it brings for both our users and for the rest of the TypeScript ecosystem.</p>
<p>In particular, we should emphasize:</p>
<ul>
<li>
<p>that our official support for TypeScript is about making it a full peer to JavaScript—<em>not</em> replacing JavaScript, and never <em>requiring</em> TypeScript, but rather supporting TypeScript users as equal peers to JavaScript users, and improving the JavaScript authoring experience using TypeScript “under the hood”</p>
</li>
<li>
<p>what is new about Ember’s having official support, as compared to the community support we have had for the past few years, including:</p>
<ul>
<li>the integration of TypeScript into the design process</li>
<li>the benefits of publishing types directly from Ember’s source, and thereby solving the problem of keeping Ember and its types in sync over time</li>
<li>the stability guarantees that come with a clear definition of and commitment to Semantic Versioning for TypeScript</li>
</ul>
</li>
</ul>
<p>Second, we should incorporate messaging about TypeScript support in all of our discussions of the planned Polaris edition. Along with Embroider and First-Class Component Templates (if accepted), it will represent a significant shift in the experience of authoring Ember apps.</p>
<h3 id="documenting-semver"><a class="header" href="#documenting-semver">Documenting SemVer</a></h3>
<p>Besides the per-package documentation, we will also include a discussion of how Ember handles <em>TypeScript</em> in its SemVer commitments under the <strong>How Ember uses SemVer</strong> section on the <a href="https://emberjs.com/releases/">Releases</a> page. There, we will link to the published SemVer for Types spec as well as summarizing how end users should think about it—just as we already do for runtime. This should likely be a new subsection which extends the existing discussion, e.g. <strong>Notes for TypeScript users</strong> just after the existing <strong>What SemVer means for your app</strong> section.</p>
<p>Additionally, when each new version of Ember is released, any updates to supported versions should be included in the blog post associated with that version in a dedicated section at the same level as the <strong>Ember</strong>, <strong>Ember Data</strong>, and <strong>Ember CLI</strong> sections today. For example, in an Ember 4.6 release which added support for TypeScript 4.7, the section might look like this, immediately following the Ember CLI section:</p>
<blockquote>
<h3 id="typescript-support"><a class="header" href="#typescript-support">TypeScript support</a></h3>
<p>Using Ember does not require using TypeScript, but Ember provides first-class TypeScript integration for users who wish to use TypeScript, with strong backwards-compatibility guarantees.</p>
<p>You can always update TypeScript to a supported version independently of updating your Ember, Ember Data, and Ember CLI versions.</p>
<p>Ember.js, Ember Data, and Ember CLI 4.6 all <strong>added support for TypeScript 4.7</strong>. Supported TypeScript versions now include 4.5, 4.6, and 4.7.</p>
</blockquote>
<p>In an Ember 4.8 LTS release which <em>dropped</em> support for TypeScript 4.5 (as described in <a href="0800-ts-adoption-plan.html#example">the example above</a>), we would emphasize this in the text:</p>
<blockquote>
<h3 id="typescript-support-1"><a class="header" href="#typescript-support-1">TypeScript support</a></h3>
<p>Using Ember does not require using TypeScript, but Ember provides first-class TypeScript integration for users who wish to use TypeScript, with strong backwards-compatibility guarantees.</p>
<p>You can always update TypeScript to a supported version independently of updating your Ember, Ember Data, and Ember CLI versions.</p>
<p>Ember.js, Ember Data, and Ember CLI 4.6 all <strong>added support for TypeScript 4.7</strong> and <strong>dropped support for TypeScript version 4.5</strong>. Supported TypeScript versions now include 4.6, and 4.7. To upgrade to Ember 4.8, you should first upgrade to at least TypeScript 4.6.</p>
</blockquote>
<h3 id="embers-documentation"><a class="header" href="#embers-documentation">Ember’s documentation</a></h3>
<p>Ember’s documentation needs to treat TypeScript as a first-class citizen. <strong>We take it as a fundamental consideration that types and documentation <em>must</em> stay in sync.</strong> In its most ambitious form, this could lead us to massively revamp Ember’s docs, so that every example can toggle between JS and TS. For prior art, see how Microsoft’s API docs support all of C#, F#, C++, and Visual Basic; or how Apple’s API docs support both Objective-C and Swift. However valuable and worthwhile such an investment would be, doing it would be a massive amount of work. Instead, this RFC recommends a more measured approach—while still encouraging further consideration of that very valuable work! It leaves the guides mostly as-is, with light additions of new content; and requires the updates <em>only</em> to API documentation, where it is a hard necessity.</p>
<h4 id="guides-3"><a class="header" href="#guides-3">Guides</a></h4>
<p>We will add a new TypeScript-focused section to Ember’s guides, built on the lessons learned (and in some cases possibly using content directly from) the docs written for ember-cli-typescript. As with the existing guides at &lt;docs.ember-cli-typescript.com&gt;, the goal here will be to provide an explanation of the <em>additional</em> features and mechanics users need to know if working with TypeScript. Some key topics might include:</p>
<ul>
<li>the setup process, including running <code>--typescript</code> at the start of a project or manually configuring it later</li>
<li>how we compile apps and addons (i.e. using Babel rather than tsc), and why</li>
<li>how the <code>paths</code> mappings work and why they are necessary</li>
<li>working with Ember Classic features</li>
</ul>
<p>We should also introduce some of the material from the Typed Ember docs in dedicated TypeScript sections to each of the Core Concepts guides. For example:</p>
<ul>
<li>in the Components guide, we could add a section describing how to write the signature for a Glimmer Component</li>
<li>in the Services guide, we could add a section show how to safely write a well-typed service injection</li>
<li>etc.</li>
</ul>
<h4 id="api-documentation-1"><a class="header" href="#api-documentation-1">API documentation</a></h4>
<p>API documentation <em>must</em> be updated to show TypeScript type signatures. This will make it possible for TypeScript users to see in the docs exactly the same thing they see in their editor, thereby avoiding any potential confusion from documentation being out of sync with the types provided. In support of this, we will need to update our tooling to support deriving the API documentation information from the types, so that there is a single source of truth.</p>
<p>There are also two other new concerns for documenting types which are meant to be consumed <em>only</em> as types: where/how to import and document them, and whether they are user-constructible. I will use the <code>RouteInfo</code> type from Ember’s routing system as a motivating example here.</p>
<p><strong>Import locations:</strong> historically, type-only imports have been documented but without <em>having</em> to pin down a fixed location. For example, as of the time of writing, <code>RouteInfo</code> is documented as belonging only to the <code>ember</code> module. This has been “fine” because users expect to <em>receive</em> <code>RouteInfo</code> instances, not construct them directly, but when needing to name the type, the type must have a definite import location (presumably <code>@ember/routing</code>).</p>
<p><strong>User-constructibility:</strong> as <a href="https://github.com/chriskrycho/ember-rfcs/blob/semver-for-ts/text/0730-semver-for-ts.md#definitions">described in the SemVer for TS types RFC</a>, whether a given type is intended to be constructed by users impacts its public API contract. See the discussion on that RFC for details. For this RFC, it is sufficient to note that every published <code>interface</code> or <code>type</code> alias must explicitly specify whether it is legal for users to construct it. <em>Implicitly</em>, <code>RouteInfo</code>s are only ever provided by the framework, but only implicitly. The docs should explicitly specify that the type can be imported and named, but not implemented by users.</p>
<div class="footnote-definition" id="transition-on-DT"><sup class="footnote-definition-label">12</sup>
<p>Historically, users on DefinitelyTyped have had to import <code>Transition</code> and <code>RouteInfo</code> from private locations <em>or</em> use type hacks to get them from the return types of other functions. This is because Typed Ember has consistently maintained a rule that we only publish types corresponding to the documented public API of Ember itself, and there was no possible public API for these types as <em>type-only</em> exports, since Ember was not publishing types.</p>
</div>
<h3 id="migration-docs"><a class="header" href="#migration-docs">Migration docs</a></h3>
<p>As discussed briefly above, existing Ember TypeScript users have used the <code>@types</code> packages from <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>. We must document a migration path for users, to be published as part of the blog post announcing officially-published types for any given package. This will include both a general migration path, common to all of these, and then specific details dealing with migration of specific Ember Classic patterns.</p>
<h4 id="general-migration-guide"><a class="header" href="#general-migration-guide">General migration guide</a></h4>
<p>The outline of that migration path, regardless of the specific package, is:</p>
<ol>
<li>Upgrade to a version of the package (e.g. <code>ember-source</code>) which officially publishes types.</li>
<li>Remove the corresponding <code>@types</code> package(s) from your dependencies.</li>
<li>Check that your program compiles. Here, we will provide a guide of expected changes, if any.</li>
<li>Invite bug reports, directing them to the package in question!</li>
</ol>
<p>We will <em>need</em> to publish one of these guides/posts for each package or group of packages which begins officially publishing types, at the time they begin doing so (as well as in the release notes for the package in question, of course). Users who have types from both the package itself and a <code>@types</code> package may end up confused or experiencing odd issues in their editor, so we need to make this messaging very clear!</p>
<p>As described above in <a href="0800-ts-adoption-plan.html#rollout"><strong>Detailed design: Rollout</strong></a>, we can and should start shipping types incrementally as packages are ready, rather than gating the ecosystem on <em>everything</em> being ready. Accordingly, we will probably need a fair number of these posts!</p>
<p>For example, <code>@ember/test-helpers</code>, <code>ember-qunit</code>, and <code>ember-mocha</code> could begin publishing types more or less immediately after this RFC is accepted, while for <code>ember-source</code>, the publication of types would happen in line with the normal release train, as described in <a href="0800-ts-adoption-plan.html#publishing-types-and-release-channels"><strong>Publishing types and release channels</strong></a> above. Thus, we could do publish a blog post for the release of official types in the infrastructure, which would guide people to the correct version to update to, and tell them to remove the <code>@types/ember__test-helpers</code> and <code>@types/ember-qunit</code> or <code>@types/ember-mocha</code> packages from their dependencies. In that specific example, we would not expect there to be any changes between the types as published on DefinitelyTyped and those published from the packages directly.</p>
<p>Similarly, when a minor version of <code>ember-source</code> is published with types, we should publish a dedicated migration post, to be published at the same time as, and linked from, the announcement blog post. That post <em>will</em> include the expected changes consumers can make. However, since we <em>know</em> the expected sets of changes there (as discussed under <a href="0800-ts-adoption-plan.html#ember-classic-features"><strong>Ember Classic Features</strong></a> below), we can also guide Ember developers to start making those changes <em>sooner</em>, by publishing a post outlining the details as soon as we begin publishing the types on our canary channel. Then the announcement blog post can reiterate those as well as modifications made in response to pre-release testing.</p>
<h4 id="ember-classic-features"><a class="header" href="#ember-classic-features">Ember Classic features</a></h4>
<p>Besides the general migration guide, we will also provide tips for code which uses Classic features:</p>
<ul>
<li>
<p>for <code>get</code> and <code>set</code>, guidance about switching to Octane idioms</p>
</li>
<li>
<p>for <code>.extend()</code>, <code>.create()</code>, <code>.reopen()</code>, and <code>reopenClass()</code>, examples of using <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a> to correctly represent the runtime result of those types</p>
</li>
</ul>
<h2 id="drawbacks-178"><a class="header" href="#drawbacks-178">Drawbacks</a></h2>
<p>The major drawbacks here are the same as those in <a href="https://github.com/emberjs/rfcs/pull/724">RFC #0724</a>:</p>
<blockquote>
<p>Adding TypeScript support imposes an additional maintenance burden on all contributors to Ember:</p>
<ul>
<li>documentation must be kept up to date in both JavaScript and TypeScript</li>
<li>changes to APIs must be kept in sync with published types (when the types are not generated from the implementation)</li>
<li>managing support for TypeScript versions will require additional effort and versioning coordination</li>
<li>presumably, API designs will be constrained in new ways (though this may also be an upside!)</li>
</ul>
</blockquote>
<p>There are also a few drawbacks to the specific recommendations around the rollout design here:</p>
<ul>
<li>Providing a more minimal support path for Classic features could make adoption more difficult for some users who have not yet fully migrated to Octane.</li>
<li>Using a “rolling majors” support policy <em>does</em> impose additional upgrade cost on our TypeScript users.</li>
</ul>
<h2 id="alternatives-179"><a class="header" href="#alternatives-179">Alternatives</a></h2>
<p>The major alternative here is the same as that in <a href="https://github.com/emberjs/rfcs/pull/724">RFC #0724</a>:</p>
<blockquote>
<p>TypeScript support has historically been managed by the community. We could continue with this approach, including e.g. investigating other alternatives to DefinitelyTyped for supplying types in a more robust way. This has worked reasonably well to date, though it has added friction for adopters, especially when the Typed Ember maintainers could not keep up with changes to Ember itself.</p>
</blockquote>
<p>In terms of the details of the rollout specifically, however, there are a few specific alternative approaches available to us.</p>
<h3 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h3>
<ul>
<li>
<p>We could leave the TypeScript docs in a separate location entirely, as they are today. This would require many of the same costs we pay today in terms of maintenance, and would also leave TypeScript something of a second-class citizen.</p>
</li>
<li>
<p>We could build an entirely separate tooling stack to support TypeScript vs. JavaScript in our documentation. This would create major maintenance overhead, and again would mirror the situation we find ourselves in today with the ember-cli-typescript docs representing a totally separate “source of truth” for that part of the ecosystem.</p>
</li>
<li>
<p>We could use this as an opportunity to investigate rebuilding our documentation tooling entirely. While attractive in some ways, these projects are time-consuming and this would introduce considerable risk and likely major timeline delay. Instead, using the things we learn from building support for TypeScript can and should inform future efforts.</p>
</li>
</ul>
<h3 id="classic-features-1"><a class="header" href="#classic-features-1">Classic features</a></h3>
<p>Per the edition support policy, we could choose <em>not</em> provide direct support for Ember Classic features in the core types. Since those types are still in use throughout the ecosystem, including in key ways for Ember Data, we would need to support them <em>somehow</em>, but we could do so by instead providing a <em>bridge</em> for working with them, analogous to the legacy support packages provided at major version changes.</p>
<p>In that design, we would ship a package like <code>@ember-types/classic</code>, which took advantage of <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation">module augmentation</a> to provide enhanced versions of those types. This would allow us to keep the supported public API published <em>by Ember</em> much smaller and simpler, while also providing an escape hatch for parts of the ecosystem which are still transitioning to Octane idioms (including especially Ember Data).</p>
<p>This would be a reasonable approach—and was in fact what the other Typed Ember folks and I originally thought we would do!—but we decided against it because of the problems with making the classic types work well <em>at all</em>. The approach we are <em>actually</em> proposing is minimal and easy to support, minimizes impact to the ecosystem as it stands, and actually provides <em>better</em> feedback during the transition period.</p>
<h3 id="semantic-versioning-options"><a class="header" href="#semantic-versioning-options">Semantic versioning options</a></h3>
<ul>
<li>
<p>Instead of adopting the “rolling window” TypeScript version policy, we could lock each Ember major version to the minimum supported version of TypeScript at the time the Ember major was released. For example, if TypeScript 5.0 were the minimum supported version for Ember 5.0, it would <em>remain</em> the supported version throughout the Ember 5.x life-cycle. The major downside here is that it prevents Ember itself from taking advantage of any new type system features for the entirety of the Ember major release.</p>
<p>For context, if we had adopted the “simple majors” policy for TypeScript with the Ember 3.x era, we would have been stuck with TypeScript 2.6 or 2.7 until Ember 4.0’s release in November 2021. In that time frame, there were over 20 TypeScript releases, some of which included features which allowed for major improvements to the experience of authoring Ember apps and addons and caught many more bugs.</p>
</li>
<li>
<p>Instead of allowing Ember’s published types to support only the current edition at a major, we could require that all public API be supported as long as it exists. The downside to this approach is primarily for the Ember 4.x era, where robustly supporting Ember Classic idioms with TypeScript is difficult at best and in some cases impossible. Presumably, by the time of Ember 5.0, it will be possible to publish types directly from Ember’s source (with no use of ambient types), so supporting pre-Polaris idioms may be <em>lower</em> effort than not.</p>
<p>However, we fundamentally <em>need</em> that flexibility for official TypeScript support in the Ember 4.x era while we finish removing Classic APIs. Moreover, it will not hurt us to have the flexibility available for future releases: having the option on the table does not require us to use it.</p>
</li>
<li>
<p>Instead of using <code>strict: true</code>, we could adopt a specific set of flags to support for the life of an Ember major series—presumably, the set of flags corresponding to <code>strict: true</code> at the time of a major version. However, this would mean we would not be providing benefits to users who <em>are</em> using <code>strict: true</code>, and might put us in the position of having to tell users <em>not</em> to use <code>strict: true</code> because our types don’t support it. <strong>This is not merely hypothetical:</strong> it was the case for 3–4 years for Ember’s types on DefinitelyTyped! The result is maintenance churn and needlessly lower strictness than available from TypeScript.</p>
</li>
</ul>
<h3 id="documentation-2"><a class="header" href="#documentation-2">Documentation</a></h3>
<ul>
<li>
<p>The guides for migrating from DefinitelyTyped could be hosted as dedicated documentation rather than blog posts. This would have the upside of being long-lived documentation for apps which make this change at later points (since it requires updating to the specific Ember version before it becomes possible). However, it has the downside of being dedicated documentation we must maintain which is <em>only</em> valuable for that one specific transition, and it is really part of the &quot;upgrade&quot; process for apps using TypeScript.</p>
</li>
<li>
<p>This RFC could specify details for documenting the disctinction between “primary” and “seconadry” packages (with implications for their SemVer commitments) in a future where the packages <em>do</em> actually exist and can be installed independently of each other. However, since it is not clear when that will happen, or what the versioning design for those packages will be, it seems more appropriate to defer any such discussion to an RFC which designs those features as a coherent whole.</p>
</li>
</ul>
<h2 id="unresolved-questions-116"><a class="header" href="#unresolved-questions-116">Unresolved questions</a></h2>
<ul>
<li>
<p>How should we support opting into TypeScript support after starting a project? Today, users do this by running <code>ember install ember-cli-typescript</code> and getting its updates to blueprints etc.—but that will not be as obvious in this design, and even if we continue to use that as the mechanism, we need to document it and decide which parts <code>ember-cli-typescript</code> is responsible for and which it is not.</p>
</li>
<li>
<p>Which, if any, blueprints need to be updated besides the Glimmer Component blueprint, in the absence of type registries for Service and Controller classes?</p>
</li>
<li>
<p>Did we miss any Classic features for which we need to specify what we will and will not provide?</p>
</li>
<li>
<p>Should we ship an <code>ember-ultra-strict</code> mode initially, and if so what additional flags should it include?</p>
</li>
<li>
<p>Is specifying Ember Data’s registries a blocker for adopting this RFC?</p>
</li>
<li>
<p>Do we need an appendix to this RFC specifying user-constructibility and import location for existing interfaces like <code>Transition</code> and <code>RouteInfo</code>?</p>
</li>
<li>
<p>Should we do the work to introduce a “simplified” presentation of the types for JavaScript users in our API docs, which (for example) removes generics and replaces <code>unknown</code> with <code>any</code> or similar, to avoid requiring JavaScript users to understand those TypeScript details?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>Stage: Accepted
Start Date: 2022-02-25
Release Date: Unreleased
Release Versions:
ember-source: vX.Y.Z
ember-data: vX.Y.Z
Relevant Team(s): Ember CLI
RFC PR: https://github.com/emberjs/rfcs/pull/801</h2>
<h1 id="deprecate-blacklist-and-whitelist-build-options"><a class="header" href="#deprecate-blacklist-and-whitelist-build-options">Deprecate <code>blacklist</code> and <code>whitelist</code> build options</a></h1>
<h2 id="summary-194"><a class="header" href="#summary-194">Summary</a></h2>
<p>This RFC proposes to deprecate the <code>blacklist</code> and <code>whitelist</code> build options, in
favour of the <code>exclude</code> and <code>include</code> build options.</p>
<h2 id="motivation-194"><a class="header" href="#motivation-194">Motivation</a></h2>
<p>In <a href="https://emberjs.github.io/rfcs/0639-replace-blacklist-whitelist.html">RFC 639</a>,
the <code>exclude</code> and <code>include</code> build options were introduced. These options provide
exactly the same functionality as the <code>blacklist</code> and <code>whitelist</code> build options,
but these new terms are more neutral.</p>
<p>RFC 639 was implemented and released in <a href="https://github.com/ember-cli/ember-cli/blob/master/CHANGELOG.md#v400">Ember CLI v4</a>,
which means we should be able to deprecate the old terms in favour of the new
ones somewhere in the near future.</p>
<h2 id="transition-path-36"><a class="header" href="#transition-path-36">Transition Path</a></h2>
<p>When either the <code>blacklist</code> or the <code>whitelist</code> build option is used, the
following deprecation message will be triggered:</p>
<pre><code>Using the `addons.blacklist` or the `addons.whitelist` build option is deprecated.
Please use `addons.exclude` or `addons.include` respectively instead.
</code></pre>
<p><strong>Deprecation details:</strong></p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td><code>for</code></td><td><code>'ember-cli'</code></td></tr>
<tr><td><code>id</code></td><td><code>'ember-cli.blacklist-whitelist-build-options'</code></td></tr>
<tr><td><code>since</code></td><td><code>{ available: '4.X.X', enabled: '4.X.X' }</code></td></tr>
<tr><td><code>until</code></td><td><code>'5.0.0'</code></td></tr>
</tbody></table>
<h2 id="deprecation-guide-11"><a class="header" href="#deprecation-guide-11">Deprecation Guide</a></h2>
<p>The <code>addons.blacklist</code> and the <code>addons.whitelist</code> build options are deprecated.
Please use <code>addons.exclude</code> or <code>addons.include</code> respectively instead.</p>
<h3 id="before-1"><a class="header" href="#before-1">Before</a></h3>
<pre><code class="language-js">// ember-cli-build.js

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    addons: {
      blacklist: ['ember-freestyle'],
    },
  });

  return app.toTree();
};
</code></pre>
<h3 id="after-1"><a class="header" href="#after-1">After</a></h3>
<pre><code class="language-js">// ember-cli-build.js

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    addons: {
      exclude: ['ember-freestyle'],
    },
  });

  return app.toTree();
};
</code></pre>
<h2 id="how-we-teach-this-161"><a class="header" href="#how-we-teach-this-161">How We Teach This</a></h2>
<p>At the moment, these options are not mentioned in the Ember CLI guides.
This means, no documentation updates are required.</p>
<h2 id="drawbacks-179"><a class="header" href="#drawbacks-179">Drawbacks</a></h2>
<ul>
<li>I cannot see any real drawbacks at the moment, the only user action that is
required to resolve the deprecation is to rename one or two configuration keys</li>
</ul>
<h2 id="alternatives-180"><a class="header" href="#alternatives-180">Alternatives</a></h2>
<ul>
<li>I cannot think of any alternatives worth mentioning, keeping both sets of keys
doesn't seem like a good idea, because they provide exactly the same functionality</li>
</ul>
<h2 id="unresolved-questions-117"><a class="header" href="#unresolved-questions-117">Unresolved questions</a></h2>
<ul>
<li>None at the moment</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
